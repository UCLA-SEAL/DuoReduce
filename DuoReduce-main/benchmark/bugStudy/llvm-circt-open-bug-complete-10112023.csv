number,title,created_at,state,labels,body,code_snippet_01,code_snippet_02,code_snippet_03,code_snippet_04,code_snippet_05,code_snippet_06,code_snippet_07,code_snippet_08,code_snippet_09,code_snippet_10
6275,[ExportVerilog] Aggregate constant produces invalid assignment pattern,2023-10-10T18:38:20Z,open,"bug, ExportVerilog","The following snippet of MLIR creates an aggregate constant of a struct nested in an array nested in a struct:
```mlir
hw.module @Foo() {
    %bar = sv.reg : !hw.inout<struct<mem: !hw.array<1xstruct<sink: i1>>>>
    %0 = hw.aggregate_constant [[[false]]] : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>
    sv.assign %bar, %0 : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>
}
```
Running this through `circt-opt --export-verilog` produces the following invalid Verilog:
```verilog
module Foo();
  struct packed {struct packed {logic sink; }[0:0] mem; } bar;
  assign bar = '{mem: {'{sink: 1'h0}}};
endmodule
```
The problematic part is `'{mem: {'{sink: 1'h0}}}`, which contains an assignment pattern `'{sink: 1'h0}` inside a concatenation `{...}` (without the `'`). The assignment pattern `'{...}` (with the `'`) requires an assignment-like context, which the concatenation is not.

Maybe we can emit the array also as an assignment pattern `'{...}`. Or add explicit types to the assignment patterns somehow, like `struct {...} '{...}`?","hw.module @Foo() {
    %bar = sv.reg : !hw.inout<struct<mem: !hw.array<1xstruct<sink: i1>>>>
    %0 = hw.aggregate_constant [[[false]]] : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>
    sv.assign %bar, %0 : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>
}","module Foo();
  struct packed {struct packed {logic sink; }[0:0] mem; } bar;
  assign bar = '{mem: {'{sink: 1'h0}}};
endmodule",,,,,,,,
6272,[LowerToHW] Error in firtool-1.54.0 Memory Lowering w/ Clock Type,2023-10-09T18:21:57Z,open,"bug, FIRRTL, HW","I ran into a bug with `firtool`'s lowering of FIRRTL memories. If you have a memory that includes a `Clock` type, then `LowerToHW` creates a wire of type `(i1) -> !seq.clock` which the verifier is unhappy about.

Example:

```
circuit Foo:
  module Foo:
    input r: {addr: UInt<3>, en: UInt<1> clk: Clock, flip data: {a: Clock}}
    input w: {addr: UInt<3>, en: UInt<1> clk: Clock, data: {a: Clock}, mask: {a: UInt<1>}}

    mem memory:
      data-type => {a: Clock}
      depth => 16
      reader => r
      writer => w
      read-latency => 1
      write-latency => 1
      read-under-write => undefined

    memory.r <= r
    memory.w <= w
```

Compiling with `firtool-1.54.0 Memory.fir`:
```
Memory.fir:6:5: error: 'hw.wire' op requires the same type for all operands and results
    mem memory:
    ^
Memory.fir:6:5: note: see current operation: %2 = ""hw.wire""(%5) {name = ""memory_r_data_a""} : (i1) -> !seq.clock
```

The failing MLIR is:
```mlir
#loc = loc(""Memory.fir"":3:11)
#loc1 = loc(""Memory.fir"":4:11)
""builtin.module""() ({
  ""hw.module""() ({
  ^bb0(%arg0: i3, %arg1: i1, %arg2: !seq.clock, %arg3: i3, %arg4: i1, %arg5: !seq.clock, %arg6: !seq.clock, %arg7: i1):
    %0 = ""hw.constant""() {value = false} : () -> i1
    %1 = ""hw.wire""(%7) {name = ""memory_r_addr""} : (i4) -> i4
    %2 = ""hw.wire""(%5) {name = ""memory_r_data_a""} : (i1) -> !seq.clock
    %3 = ""hw.wire""(%8) {name = ""memory_w_addr""} : (i4) -> i4
    %4 = ""seq.firmem""() <{name = ""memory_a"", prefix = """", readLatency = 1 : i32, ruw = 0 : i32, writeLatency = 1 : i32, wuw = 1 : i32}> : () -> !seq.firmem<16 x 1>
    %5 = ""seq.firmem.read_port""(%4, %1, %arg2, %arg1) : (!seq.firmem<16 x 1>, i4, !seq.clock, i1) -> i1
    %6 = ""comb.and""(%arg4, %arg7) <{twoState}> : (i1, i1) -> i1
    ""seq.firmem.write_port""(%4, %3, %arg5, %6, %arg6) <{operandSegmentSizes = array<i32: 1, 1, 1, 1, 1, 0>}> : (!seq.firmem<16 x 1>, i4, !seq.clock, i1, !seq.clock) -> ()
    %7 = ""comb.concat""(%0, %arg0) : (i1, i3) -> i4
    %8 = ""comb.concat""(%0, %arg3) : (i1, i3) -> i4
    ""hw.output""(%2) : (!seq.clock) -> ()
  }) {argLocs = [#loc, #loc, #loc, #loc1, #loc1, #loc1, #loc1, #loc1], argNames = [""r_addr"", ""r_en"", ""r_clk"", ""w_addr"", ""w_en"", ""w_clk"", ""w_data_a"", ""w_mask_a""], arg_attrs = [{}, {}, {}, {}, {}, {}, {}, {}], comment = """", function_type = (i3, i1, !seq.clock, i3, i1, !seq.clock, !seq.clock, i1) -> !seq.clock, parameters = [], res_attrs = [{}], resultLocs = [#loc], resultNames = [""r_data_a""], sym_name = ""Foo""} : () -> ()
}) : () -> ()
```

If I compile with `firtool-1.53.0 Memory.fir -disable-all-randomization`, I get the following Verilog:
```verilog
// Generated by CIRCT firtool-1.53.0
// VCS coverage exclude_file
module memory_a_16x1(
  input  [3:0] R0_addr,
  input        R0_en,
               R0_clk,
  input  [3:0] W0_addr,
  input        W0_en,
               W0_clk,
               W0_data,
  output       R0_data
);

  reg       Memory[0:15];
  reg       _R0_en_d0;
  reg [3:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 1'bx;
endmodule

module Foo(
  input  [2:0] r_addr,
  input        r_en,
               r_clk,
  input  [2:0] w_addr,
  input        w_en,
               w_clk,
               w_data_a,
               w_mask_a,
  output       r_data_a
);

  memory_a_16x1 memory_a_ext (
    .R0_addr ({1'h0, r_addr}),
    .R0_en   (r_en),
    .R0_clk  (r_clk),
    .W0_addr ({1'h0, w_addr}),
    .W0_en   (w_en & w_mask_a),
    .W0_clk  (w_clk),
    .W0_data (w_data_a),
    .R0_data (r_data_a)
  );
endmodule
```","circuit Foo:
  module Foo:
    input r: {addr: UInt<3>, en: UInt<1> clk: Clock, flip data: {a: Clock}}
    input w: {addr: UInt<3>, en: UInt<1> clk: Clock, data: {a: Clock}, mask: {a: UInt<1>}}

    mem memory:
      data-type => {a: Clock}
      depth => 16
      reader => r
      writer => w
      read-latency => 1
      write-latency => 1
      read-under-write => undefined

    memory.r <= r
    memory.w <= w","Memory.fir:6:5: error: 'hw.wire' op requires the same type for all operands and results
    mem memory:
    ^
Memory.fir:6:5: note: see current operation: %2 = ""hw.wire""(%5) {name = ""memory_r_data_a""} : (i1) -> !seq.clock","#loc = loc(""Memory.fir"":3:11)
#loc1 = loc(""Memory.fir"":4:11)
""builtin.module""() ({
  ""hw.module""() ({
  ^bb0(%arg0: i3, %arg1: i1, %arg2: !seq.clock, %arg3: i3, %arg4: i1, %arg5: !seq.clock, %arg6: !seq.clock, %arg7: i1):
    %0 = ""hw.constant""() {value = false} : () -> i1
    %1 = ""hw.wire""(%7) {name = ""memory_r_addr""} : (i4) -> i4
    %2 = ""hw.wire""(%5) {name = ""memory_r_data_a""} : (i1) -> !seq.clock
    %3 = ""hw.wire""(%8) {name = ""memory_w_addr""} : (i4) -> i4
    %4 = ""seq.firmem""() <{name = ""memory_a"", prefix = """", readLatency = 1 : i32, ruw = 0 : i32, writeLatency = 1 : i32, wuw = 1 : i32}> : () -> !seq.firmem<16 x 1>
    %5 = ""seq.firmem.read_port""(%4, %1, %arg2, %arg1) : (!seq.firmem<16 x 1>, i4, !seq.clock, i1) -> i1
    %6 = ""comb.and""(%arg4, %arg7) <{twoState}> : (i1, i1) -> i1
    ""seq.firmem.write_port""(%4, %3, %arg5, %6, %arg6) <{operandSegmentSizes = array<i32: 1, 1, 1, 1, 1, 0>}> : (!seq.firmem<16 x 1>, i4, !seq.clock, i1, !seq.clock) -> ()
    %7 = ""comb.concat""(%0, %arg0) : (i1, i3) -> i4
    %8 = ""comb.concat""(%0, %arg3) : (i1, i3) -> i4
    ""hw.output""(%2) : (!seq.clock) -> ()
  }) {argLocs = [#loc, #loc, #loc, #loc1, #loc1, #loc1, #loc1, #loc1], argNames = [""r_addr"", ""r_en"", ""r_clk"", ""w_addr"", ""w_en"", ""w_clk"", ""w_data_a"", ""w_mask_a""], arg_attrs = [{}, {}, {}, {}, {}, {}, {}, {}], comment = """", function_type = (i3, i1, !seq.clock, i3, i1, !seq.clock, !seq.clock, i1) -> !seq.clock, parameters = [], res_attrs = [{}], resultLocs = [#loc], resultNames = [""r_data_a""], sym_name = ""Foo""} : () -> ()
}) : () -> ()","// Generated by CIRCT firtool-1.53.0
// VCS coverage exclude_file
module memory_a_16x1(
  input  [3:0] R0_addr,
  input        R0_en,
               R0_clk,
  input  [3:0] W0_addr,
  input        W0_en,
               W0_clk,
               W0_data,
  output       R0_data
);

  reg       Memory[0:15];
  reg       _R0_en_d0;
  reg [3:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 1'bx;
endmodule

module Foo(
  input  [2:0] r_addr,
  input        r_en,
               r_clk,
  input  [2:0] w_addr,
  input        w_en,
               w_clk,
               w_data_a,
               w_mask_a,
  output       r_data_a
);

  memory_a_16x1 memory_a_ext (
    .R0_addr ({1'h0, r_addr}),
    .R0_en   (r_en),
    .R0_clk  (r_clk),
    .W0_addr ({1'h0, w_addr}),
    .W0_en   (w_en & w_mask_a),
    .W0_clk  (w_clk),
    .W0_data (w_data_a),
    .R0_data (r_data_a)
  );
endmodule",,,,,,
6226,Mixed ssaName and true name fails to parse correctly,2023-09-29T21:51:37Z,open,bug,"See Bar3 below.
circt-opt foo.mlir --mlir-print-op-generic

```
hw.module @Bar0(in %0: i1) {
}

hw.module @Bar1(in %a: i1) {
}

hw.module @Bar2(in %0 ""space here"" : i1) {
}

hw.module @Bar3(in %b ""space here"" : i1) {
}
```","hw.module @Bar0(in %0: i1) {
}

hw.module @Bar1(in %a: i1) {
}

hw.module @Bar2(in %0 ""space here"" : i1) {
}

hw.module @Bar3(in %b ""space here"" : i1) {
}",,,,,,,,,
6193,[FIRRTL][firtool] Unknown Windows Release Build Test Failures,2023-09-23T04:21:45Z,open,"bug, FIRRTL","There have been a number of odd test failures that have been observed on Windows release builds.

## Failures

### First Failure

A commit, https://github.com/llvm/circt/commit/3668f6760f9c7ca814035292435f930e30320fea, enabling properties as attributes in the Seq dialect resulted in similar failures in one test. See: https://github.com/llvm/circt/actions/runs/6043611927/job/16400911216 This corrected itself on the subsequent commit, https://github.com/llvm/circt/commit/c88186e18a74fe74e2d2bdb7de2610a0334eaa7d, passed.

The failing test was:
  - `Dialect/FIRRTL/SFCTests/width-spec-errors.fir`

The exit code was: 3221225477

### Second Failure

A commit adding two folders, https://github.com/llvm/circt/commit/68b79fc35fcc2d68abc8a0b830c0f5a303af3f04, failed intermittently. See: https://github.com/llvm/circt/actions/runs/6083208189/job/16502633046. This then passed on retry: https://github.com/llvm/circt/actions/runs/6083208189.

The failing test was:
  - `Dialect/FIRRTL/SFCTests/data-taps-flip.fir`

The exit code was: 3221225477

There was no stack trace.

### Third Failure

Commit https://github.com/llvm/circt/commit/3b6f737c360fa19e3f16f9ea4856128f36ce9296 made a change that disabled deduplication. This caused four tests to fail repeatedly. One such run is: https://github.com/llvm/circt/actions/runs/6278904029/job/17056030822

The failing tests were:
  - `Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/Wire.fir`
  - `Dialect/FIRRTL/SFCTests/data-taps.fir`
  - `firtool/prefixMemory.fir`
  - `firtool/refs-in-aggs.fir`

Only `firtool/prefixMemory.fir` was a test that was sensitive to deduplication and required modifications, in the commit, to fix.

This was ""fixed"" by adding a `-no-dedup` option to `firtool` and using it for those four tests. It is unclear if this actually ""fixed"" anything, i.e., if the issue was that not running deduplication fixed it or if this just permuted the sources enough to get `cl` to produce something that didn't crash.

The exit code was: 0xc0000005

There was a stack trace. (This isn't particularly useful as it is a release build...) Example:

```
 #0 0x00007ff7b9dca204 (d:\a\circt\circt\build\bin\firtool.exe+0x1fa204)
 #1 0x00007ff7b9dd00a1 (d:\a\circt\circt\build\bin\firtool.exe+0x2000a1)
 #2 0x00007ff7ba5f0107 (d:\a\circt\circt\build\bin\firtool.exe+0xa20107)
 #3 0x00007ff7ba5f5a27 (d:\a\circt\circt\build\bin\firtool.exe+0xa25a27)
 #4 0x00007ff7ba5f7529 (d:\a\circt\circt\build\bin\firtool.exe+0xa27529)
 #5 0x00007ff7ba5f0616 (d:\a\circt\circt\build\bin\firtool.exe+0xa20616)
 #6 0x00007ff7ba5f6ee2 (d:\a\circt\circt\build\bin\firtool.exe+0xa26ee2)
 #7 0x00007ff7ba5f00f2 (d:\a\circt\circt\build\bin\firtool.exe+0xa200f2)
 #8 0x00007ff7ba5f5a27 (d:\a\circt\circt\build\bin\firtool.exe+0xa25a27)
 #9 0x00007ff7ba5f61fd (d:\a\circt\circt\build\bin\firtool.exe+0xa261fd)
#10 0x00007ff7b9be0544 (d:\a\circt\circt\build\bin\firtool.exe+0x10544)
#11 0x00007ff7b9be09ff (d:\a\circt\circt\build\bin\firtool.exe+0x109ff)
#12 0x00007ff7b9bdee3b (d:\a\circt\circt\build\bin\firtool.exe+0xee3b)
#13 0x00007ff7b9be26df (d:\a\circt\circt\build\bin\firtool.exe+0x126df)
#14 0x00007ff7ba60d560 (d:\a\circt\circt\build\bin\firtool.exe+0xa3d560)
#15 0x00007ffe8a4c7ac4 (C:\Windows\System32\KERNEL32.DLL+0x17ac4)
#16 0x00007ffe8bfda351 (C:\Windows\SYSTEM32\ntdll.dll+0x5a351)
```

Just before the third test, the windows build failed on the previous commit twice. This appeared to be due to issues running PowerShell's `Install-Package`. The two failures were:

```
WARNING: Unable to resolve package source 'https://www.powershellgallery.com/api/v2'.
Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all
available registered module repositories.

Error: Process completed with exit code 1.
```

```
Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all
available registered module repositories.

Error: Process completed with exit code 1.
```

This appears unrelated, though it has high temporal locality to the third failure.

For the third failure, I tried a clean rebuild by deleting all `sccache` caches. This again failed in the same way after a 3 hour complete rebuild.

## Analysis

1. All tests involved `firtool` end-to-end tests. 
2. All tests were some kind of hard crash with exit codes 3221225477 or 0xc0000005. (This is the same number, but the latter seems to produce a stack trace and the former does not.)
3. The third test would repeatedly fail. The second test was intermittent. It is unknown if the first test was intermittent or repeatable.

## Ideas to try

1. The Unified Build/Test/Install GitHub Action does support running a Windows build in debug mode or relwithdebinfo. This won't have caching and will be about 3 hours to run.
2. More UBSan or other sanitizers. Is there a way to run these on Windows?","#0 0x00007ff7b9dca204 (d:\a\circt\circt\build\bin\firtool.exe+0x1fa204)
 #1 0x00007ff7b9dd00a1 (d:\a\circt\circt\build\bin\firtool.exe+0x2000a1)
 #2 0x00007ff7ba5f0107 (d:\a\circt\circt\build\bin\firtool.exe+0xa20107)
 #3 0x00007ff7ba5f5a27 (d:\a\circt\circt\build\bin\firtool.exe+0xa25a27)
 #4 0x00007ff7ba5f7529 (d:\a\circt\circt\build\bin\firtool.exe+0xa27529)
 #5 0x00007ff7ba5f0616 (d:\a\circt\circt\build\bin\firtool.exe+0xa20616)
 #6 0x00007ff7ba5f6ee2 (d:\a\circt\circt\build\bin\firtool.exe+0xa26ee2)
 #7 0x00007ff7ba5f00f2 (d:\a\circt\circt\build\bin\firtool.exe+0xa200f2)
 #8 0x00007ff7ba5f5a27 (d:\a\circt\circt\build\bin\firtool.exe+0xa25a27)
 #9 0x00007ff7ba5f61fd (d:\a\circt\circt\build\bin\firtool.exe+0xa261fd)
#10 0x00007ff7b9be0544 (d:\a\circt\circt\build\bin\firtool.exe+0x10544)
#11 0x00007ff7b9be09ff (d:\a\circt\circt\build\bin\firtool.exe+0x109ff)
#12 0x00007ff7b9bdee3b (d:\a\circt\circt\build\bin\firtool.exe+0xee3b)
#13 0x00007ff7b9be26df (d:\a\circt\circt\build\bin\firtool.exe+0x126df)
#14 0x00007ff7ba60d560 (d:\a\circt\circt\build\bin\firtool.exe+0xa3d560)
#15 0x00007ffe8a4c7ac4 (C:\Windows\System32\KERNEL32.DLL+0x17ac4)
#16 0x00007ffe8bfda351 (C:\Windows\SYSTEM32\ntdll.dll+0x5a351)","WARNING: Unable to resolve package source 'https://www.powershellgallery.com/api/v2'.
Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all
available registered module repositories.

Error: Process completed with exit code 1.","Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all
available registered module repositories.

Error: Process completed with exit code 1.",,,,,,,
6074,[FIRRTL] Add missing dialect dependencies,2023-09-07T21:54:58Z,open,"bug, FIRRTL","LowerXMR and LowerToHW, at least, may lower/introduce operations from HW, SV, and Seq dialects.

Fix the dependentDialects to ensure this works properly (such as when invoking via `circt-opt`).

Current failing example to demonstrate:

```mlir
firrtl.circuit ""ClockProbe"" {
  firrtl.module @ClockProbe(in %in: !firrtl.clock, out %out: !firrtl.clock) attributes {convention = #firrtl<convention scalarized>} {
    %0 = firrtl.ref.send %in : !firrtl.clock
    %1 = firrtl.ref.resolve %0 : !firrtl.probe<clock>
    firrtl.strictconnect %out, %1 : !firrtl.clock
  }
}
```

Which presently errors out when running `circt-opt --firrtl-lower-xmr`:
```
LLVM ERROR: can't create type 'circt::seq::ClockType' because storage uniquer isn't initialized: the dialect was likely not loaded, or the type wasn't added with addTypes<...>() in the Dialect::initialize() method.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/circt-opt --firrtl-lower-xmr ./clock-probe.mlir
```","firrtl.circuit ""ClockProbe"" {
  firrtl.module @ClockProbe(in %in: !firrtl.clock, out %out: !firrtl.clock) attributes {convention = #firrtl<convention scalarized>} {
    %0 = firrtl.ref.send %in : !firrtl.clock
    %1 = firrtl.ref.resolve %0 : !firrtl.probe<clock>
    firrtl.strictconnect %out, %1 : !firrtl.clock
  }
}","LLVM ERROR: can't create type 'circt::seq::ClockType' because storage uniquer isn't initialized: the dialect was likely not loaded, or the type wasn't added with addTypes<...>() in the Dialect::initialize() method.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/circt-opt --firrtl-lower-xmr ./clock-probe.mlir",,,,,,,,
6059,[FIRRTL][IMDCE] Annotations on ports are not preserved when moving to wires,2023-09-06T16:02:17Z,open,"bug, FIRRTL","Input:
```mlir
// -----
// Test that annotations keep ports alive.
// CHECK-LABEL: ""AnnoAlivePort""
firrtl.circuit ""AnnoAlivePort"" {
  // CHECK: module private @AnnoPort
  firrtl.module private @AnnoPort(out %dead : !firrtl.uint<5> [{class = ""circt.test""}]) {}
  firrtl.module @AnnoAlivePort() {
    // CHECK: firrtl.instance
    %inst_dead = firrtl.instance inst @AnnoPort(out dead : !firrtl.uint<5>)
  }
}
```

The port is dead at instantiation sites but alive within the module, so port is dropped and wire is created for it (maybe it's written/read locally, so on).

Looks like annotations are not moved to the wire, however, here's the current output pointing IMDCE at the above:
```mlir
firrtl.circuit ""AnnoAlivePort"" {
  firrtl.module private @AnnoPort() {
    %0 = firrtl.wire : !firrtl.uint<5>
  }
  firrtl.module @AnnoAlivePort() {
    firrtl.instance inst @AnnoPort()
  }
}
```

cc #6046 for more discussion on annotations and IMDCE, but not directly related.","// -----
// Test that annotations keep ports alive.
// CHECK-LABEL: ""AnnoAlivePort""
firrtl.circuit ""AnnoAlivePort"" {
  // CHECK: module private @AnnoPort
  firrtl.module private @AnnoPort(out %dead : !firrtl.uint<5> [{class = ""circt.test""}]) {}
  firrtl.module @AnnoAlivePort() {
    // CHECK: firrtl.instance
    %inst_dead = firrtl.instance inst @AnnoPort(out dead : !firrtl.uint<5>)
  }
}","firrtl.circuit ""AnnoAlivePort"" {
  firrtl.module private @AnnoPort() {
    %0 = firrtl.wire : !firrtl.uint<5>
  }
  firrtl.module @AnnoAlivePort() {
    firrtl.instance inst @AnnoPort()
  }
}",,,,,,,,
6013,[FIRRTL] Need to handle Macro Collision,2023-08-31T17:46:47Z,open,"bug, FIRRTL","If a FIRRTL name collides with a macro, the compiler currently crashes. `LowerToHW` and others need to disconnect the symbol creation from the name of the symbol. `sv.macro.decl` already has support for this. It is not used yet.

Consider:

```
FIRRTL version 4.0.0
circuit RANDOM:
  module RANDOM:
    input clock: Clock
    input d: UInt<1>
    output q: UInt<1>

    reg r: UInt<1>, clock

    connect r, d
    connect q, r
```

This errors during `LowerToHW` with:

```
<unknown>:0: error: Referenced macro doesn't exist ""ENABLE_INITIAL_MEM_""
<unknown>:0: note: see current operation: ""sv.macro.def""() {format_string = """", macroName = @ENABLE_INITIAL_MEM_, symbols = []} : () -> ()
```","FIRRTL version 4.0.0
circuit RANDOM:
  module RANDOM:
    input clock: Clock
    input d: UInt<1>
    output q: UInt<1>

    reg r: UInt<1>, clock

    connect r, d
    connect q, r","<unknown>:0: error: Referenced macro doesn't exist ""ENABLE_INITIAL_MEM_""
<unknown>:0: note: see current operation: ""sv.macro.def""() {format_string = """", macroName = @ENABLE_INITIAL_MEM_, symbols = []} : () -> ()",,,,,,,,
5886,[FIRRTL] Enum with uninferred reset,2023-08-18T16:04:53Z,open,"bug, FIRRTL, Arc","Input:
```
circuit ResetEnum:
  module ResetEnum:
    input in : {| Some: UInt<1> |}
    output out: {| Some: Reset |}
    out <= in
```

Crashes during parsing, related: #5322 .","circuit ResetEnum:
  module ResetEnum:
    input in : {| Some: UInt<1> |}
    output out: {| Some: Reset |}
    out <= in",,,,,,,,,
5884,[FIRRTL] Can't parse const enum (and therefore can't parse enum w/const elements),2023-08-18T16:00:26Z,open,"bug, FIRRTL","Enum's must be const if their elements are const, but the way we parse constructs a non-const enum (with the parsed element types) before converting it to const.

Consider:

```
circuit EnumConst:
  module EnumConst:
    input e : {| Some : const UInt<8>, None |}
```
Which is invalid and should diagnose the invalid enum type.

or this legal enum:

```
circuit ConstEnumConst:
  module ConstEnumConst:
    input e : const {| Some : const UInt<8>, None |}
```","circuit EnumConst:
  module EnumConst:
    input e : {| Some : const UInt<8>, None |}","circuit ConstEnumConst:
  module ConstEnumConst:
    input e : const {| Some : const UInt<8>, None |}",,,,,,,,
5772,[Comb] comb.concat doesn't work with type alias,2023-08-03T13:32:25Z,open,"bug, Comb","```
hw.type_scope @__hw_typedecls {
  hw.typedecl @foo : i1
}

hw.module @Top(%arg0: !hw.typealias<@__hw_typedecls::@foo,i1>) {
  %0 = comb.concat %arg0 : !hw.typealias<@__hw_typedecls::@foo,i1>
}
```

```
circt-opt: /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `isa<To>(Val) && ""cast<Ty>() argument of incompatible type!""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.      Program arguments: ./build/bin/circt-opt foo.mlir
1.      MLIR Parser: custom op parser 'hw.module'
2.      MLIR Parser: custom op parser 'comb.concat'
 #0 0x0000000000447057 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x00000000004451e0 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x000000000044796f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007fe418fd6cf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)
 #4 0x00007fe417e61aff raise (/lib64/libc.so.6+0x4eaff)
 #5 0x00007fe417e34ea5 abort (/lib64/libc.so.6+0x21ea5)
 #6 0x00007fe417e34d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)
 #7 0x00007fe417e5a456 (/lib64/libc.so.6+0x47456)
 #8 0x0000000000609c3b (./build/bin/circt-opt+0x609c3b)
 #9 0x000000000060c749 circt::comb::ConcatOp::inferReturnTypes(mlir::MLIRContext*, std::optional<mlir::Location>, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::RegionRange, llvm::SmallVectorImpl<mlir::Type>&) /scratch/hidetou/circt/lib/Dialect/Comb/CombOps.cpp:270:21
#10 0x000000000060c749 circt::comb::ConcatOp::parse(mlir::OpAsmParser&, mlir::OperationState&) /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/Comb/Comb.cpp.inc:948:22
#11 0x00000000014d521f mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#12 0x00000000014d521f mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43
#13 0x00000000014d521f (anonymous namespace)::CustomOpAsmParser::parseOperation(mlir::OperationState&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1491:9
#14 0x00000000014d521f (anonymous namespace)::OperationParser::parseCustomOperation(llvm::ArrayRef<std::tuple<llvm::StringRef, unsigned int, llvm::SMLoc>>) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1987:19
#15 0x00000000014d521f (anonymous namespace)::OperationParser::parseOperation() /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1146:10
#16 0x00000000014e0ac0 mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#17 0x00000000014e0ac0 mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43
#18 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlockBody(mlir::Block*) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2263:9
#19 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2193:12
```","hw.type_scope @__hw_typedecls {
  hw.typedecl @foo : i1
}

hw.module @Top(%arg0: !hw.typealias<@__hw_typedecls::@foo,i1>) {
  %0 = comb.concat %arg0 : !hw.typealias<@__hw_typedecls::@foo,i1>
}","circt-opt: /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `isa<To>(Val) && ""cast<Ty>() argument of incompatible type!""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.      Program arguments: ./build/bin/circt-opt foo.mlir
1.      MLIR Parser: custom op parser 'hw.module'
2.      MLIR Parser: custom op parser 'comb.concat'
 #0 0x0000000000447057 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x00000000004451e0 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x000000000044796f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007fe418fd6cf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)
 #4 0x00007fe417e61aff raise (/lib64/libc.so.6+0x4eaff)
 #5 0x00007fe417e34ea5 abort (/lib64/libc.so.6+0x21ea5)
 #6 0x00007fe417e34d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)
 #7 0x00007fe417e5a456 (/lib64/libc.so.6+0x47456)
 #8 0x0000000000609c3b (./build/bin/circt-opt+0x609c3b)
 #9 0x000000000060c749 circt::comb::ConcatOp::inferReturnTypes(mlir::MLIRContext*, std::optional<mlir::Location>, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::RegionRange, llvm::SmallVectorImpl<mlir::Type>&) /scratch/hidetou/circt/lib/Dialect/Comb/CombOps.cpp:270:21
#10 0x000000000060c749 circt::comb::ConcatOp::parse(mlir::OpAsmParser&, mlir::OperationState&) /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/Comb/Comb.cpp.inc:948:22
#11 0x00000000014d521f mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#12 0x00000000014d521f mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43
#13 0x00000000014d521f (anonymous namespace)::CustomOpAsmParser::parseOperation(mlir::OperationState&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1491:9
#14 0x00000000014d521f (anonymous namespace)::OperationParser::parseCustomOperation(llvm::ArrayRef<std::tuple<llvm::StringRef, unsigned int, llvm::SMLoc>>) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1987:19
#15 0x00000000014d521f (anonymous namespace)::OperationParser::parseOperation() /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1146:10
#16 0x00000000014e0ac0 mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#17 0x00000000014e0ac0 mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43
#18 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlockBody(mlir::Block*) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2263:9
#19 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2193:12",,,,,,,,
5727,[FIRRTL] Lower XMR assumes unique port names,2023-07-28T21:07:23Z,open,"bug, FIRRTL","FIRRTL's `LoweXMR` pass will currently produce invalid IR if it is given a module which has duplicate port names.

```mlir
firrtl.circuit ""Foo"" {
  firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [""a"", ""a""]} {
    %b = firrtl.wire interesting_name : !firrtl.uint<1>
    %0 = firrtl.ref.send %b : !firrtl.uint<1>
    firrtl.ref.define %a, %0 : !firrtl.probe<uint<1>>
    %1 = firrtl.ref.send %b : !firrtl.uint<1>
    firrtl.ref.define %a0, %1 : !firrtl.probe<uint<1>>
  }
}
```

This produces:

```
# circt-opt Foo.mlir -firrtl-lower-xmr                                   
firrtl-snippets/issues/x.mlir:3:5: error: redefinition of symbol named 'ref_Foo_Foo_a'
    firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [""a"", ""a""]} {
    ^
firrtl-snippets/issues/x.mlir:3:5: note: see current operation: ""sv.macro.decl""() {sym_name = ""ref_Foo_Foo_a""} : () -> ()
firrtl-snippets/issues/x.mlir:3:5: note: see existing symbol definition here
```","firrtl.circuit ""Foo"" {
  firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [""a"", ""a""]} {
    %b = firrtl.wire interesting_name : !firrtl.uint<1>
    %0 = firrtl.ref.send %b : !firrtl.uint<1>
    firrtl.ref.define %a, %0 : !firrtl.probe<uint<1>>
    %1 = firrtl.ref.send %b : !firrtl.uint<1>
    firrtl.ref.define %a0, %1 : !firrtl.probe<uint<1>>
  }
}","# circt-opt Foo.mlir -firrtl-lower-xmr                                   
firrtl-snippets/issues/x.mlir:3:5: error: redefinition of symbol named 'ref_Foo_Foo_a'
    firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [""a"", ""a""]} {
    ^
firrtl-snippets/issues/x.mlir:3:5: note: see current operation: ""sv.macro.decl""() {sym_name = ""ref_Foo_Foo_a""} : () -> ()
firrtl-snippets/issues/x.mlir:3:5: note: see existing symbol definition here",,,,,,,,
5721,[FIRRTL] FIRRTL Exporter needs to unique names,2023-07-28T17:58:04Z,open,"bug, good first issue","Currently, the FIRRTL exporter will not properly unique names during emission (like what `ExportVerilog` does). Consider the following:

```mlir
firrtl.circuit ""Foo"" {
  firrtl.module @Foo() {
    %0 = firrtl.wire {name = ""a""} : !firrtl.uint<1>
    %1 = firrtl.wire {name = ""a""} : !firrtl.uint<1>
  }
}
```

This produces the following illegal FIRRTL (`circt-translate -export-firrtl Foo.mlir`):
```
FIRRTL version 3.1.0
circuit Foo :
  module Foo : 
    wire a : UInt<1> 
    wire a : UInt<1> 
```

`wire a` is defined twice.","firrtl.circuit ""Foo"" {
  firrtl.module @Foo() {
    %0 = firrtl.wire {name = ""a""} : !firrtl.uint<1>
    %1 = firrtl.wire {name = ""a""} : !firrtl.uint<1>
  }
}","FIRRTL version 3.1.0
circuit Foo :
  module Foo : 
    wire a : UInt<1> 
    wire a : UInt<1>",,,,,,,,
5590,"[FIRRTL][LowerToHW] Zero-width signals with inner symbol are silently deleted, breaking users",2023-07-14T17:16:38Z,open,"bug, FIRRTL","Consider this MLIR example:

```
module {
  firrtl.circuit ""OMIRField"" {
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0>, out %y_b: !firrtl.uint<0>) {
      %n_b = firrtl.node sym @omir_sym %x_b : !firrtl.uint<0>
      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>
    }
  }
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
}
```

Feeding through LowerToHW: `circt-opt --lower-firrtl-to-hw` produces:

```
module {
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
  hw.module @OMIRField() {
    hw.output
  }
}
```

And if run through `firtool` directly, produces:
```
omir_zw_field_issue.mlir:8:3: error: cannot get name for symbol #hw.innerNameRef<@OMIRField::@omir_sym>
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
  ^
omir_zw_field_issue.mlir:8:3: note: see current operation: ""sv.verbatim""() {format_string = ""Testing {{0}}"", symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]} : () -> ()
// Generated by CIRCT 1.46.0g20230714_98d0bf5
Testing <INVALID>	// omir_zw_field_issue.mlir:8:3
module OMIRField();	// omir_zw_field_issue.mlir:3:5
endmodule
```

The non-failing error isn't great and should be fixed (cc #4770 for similar in adjacent code).
Also, this should be caught by the verifier in HW but that support isn't in place yet (cc #3526).

---

Moving the symbol to a port produces an error, modified input:

```
module {
  firrtl.circuit ""OMIRField"" {
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {
      %n_b = firrtl.node %x_b : !firrtl.uint<0>
      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>
    }
  }
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
}
```

Error:
```
omir_zw_field_issue.mlir:3:33: error: zero width port ""x_b"" is referenced by name [#hw<innerSym@omir_sym>] (e.g. in an XMR) but must be removed
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {
                                ^
```","module {
  firrtl.circuit ""OMIRField"" {
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0>, out %y_b: !firrtl.uint<0>) {
      %n_b = firrtl.node sym @omir_sym %x_b : !firrtl.uint<0>
      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>
    }
  }
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
}","module {
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
  hw.module @OMIRField() {
    hw.output
  }
}","omir_zw_field_issue.mlir:8:3: error: cannot get name for symbol #hw.innerNameRef<@OMIRField::@omir_sym>
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
  ^
omir_zw_field_issue.mlir:8:3: note: see current operation: ""sv.verbatim""() {format_string = ""Testing {{0}}"", symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]} : () -> ()
// Generated by CIRCT 1.46.0g20230714_98d0bf5
Testing <INVALID>	// omir_zw_field_issue.mlir:8:3
module OMIRField();	// omir_zw_field_issue.mlir:3:5
endmodule","module {
  firrtl.circuit ""OMIRField"" {
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {
      %n_b = firrtl.node %x_b : !firrtl.uint<0>
      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>
    }
  }
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
}","omir_zw_field_issue.mlir:3:33: error: zero width port ""x_b"" is referenced by name [#hw<innerSym@omir_sym>] (e.g. in an XMR) but must be removed
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {
                                ^",,,,,
5566,[SV] Crash in `P/BPAssignOp` verifiers for `hw.inout` ports,2023-07-12T07:32:39Z,open,"bug, good first issue, Verilog/SystemVerilog","[In the SV `P/BPAssignOp` verifiers](https://github.com/llvm/circt/blob/main/lib/Dialect/SV/SVOps.cpp#L1142-L1156) it is assumed that the target argument is defined by an op (`isa` used on `getDefiningOp`). Hence, in the case of a `hw.inout` input port, the verifier crashes.

i.e.:
```mlir
hw.module @unsupported(%a: !hw.inout<i42>) {
  %clock = hw.constant 1 : i1
  %c42 = hw.constant 42 : i42
  sv.alwaysff(posedge %clock) {
    sv.passign %a, %c42 : i42
  }
}
```

","hw.module @unsupported(%a: !hw.inout<i42>) {
  %clock = hw.constant 1 : i1
  %c42 = hw.constant 42 : i42
  sv.alwaysff(posedge %clock) {
    sv.passign %a, %c42 : i42
  }
}",,,,,,,,,
5562,[FIRRTL][LowerToHW] An uninstantiated module can crash LowerToHW,2023-07-10T23:17:06Z,open,"bug, FIRRTL","I came across the following failure. The problem occurs if a module which is not under the main module in the instance graph includes reference type ports:

```mlir
firrtl.circuit ""Foo"" {
  firrtl.module @Foo() {}
  firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.probe<uint<1>>) {
    %0 = firrtl.ref.send %a : !firrtl.uint<1>
    firrtl.ref.define %b, %0 : !firrtl.probe<uint<1>>
  }
}
```

The failure trips an assert in `LowerToHW` [here](https://github.com/llvm/circt/blob/main/lib/Conversion/FIRRTLToHW/LowerToHW.cpp#L2337):

```
Assertion failed: ((!result || !isa<FIRRTLType>(result.getType())) && ""Lowering didn't turn a FIRRTL value into a non-FIRRTL value""), function setLowering, file LowerToHW.cpp, line 2338.
```","firrtl.circuit ""Foo"" {
  firrtl.module @Foo() {}
  firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.probe<uint<1>>) {
    %0 = firrtl.ref.send %a : !firrtl.uint<1>
    firrtl.ref.define %b, %0 : !firrtl.probe<uint<1>>
  }
}","Assertion failed: ((!result || !isa<FIRRTLType>(result.getType())) && ""Lowering didn't turn a FIRRTL value into a non-FIRRTL value""), function setLowering, file LowerToHW.cpp, line 2338.",,,,,,,,
5483,[ExportVerilog] Missing `hw.struct_explode` support?,2023-06-26T22:23:43Z,open,"bug, HW","Running `circt-opt <file.mlir> --export-verilog` with `file.mlir` having the following content:
```mlir
module {
  hw.module @EXPLODE(%0: i64, %1: i64) -> (arg1: i64, arg2: i64) {
    %2 = hw.struct_create (%0, %1) : !hw.struct<arg1: i64, arg2: i64>
    %arg1, %arg2 = hw.struct_explode %2 : !hw.struct<arg1: i64, arg2: i64>

    hw.output %arg1, %arg2 : i64, i64
  }
}
```
triggers the following assertion:
```
circt-opt: circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:3295:
void (anonymous namespace)::NameCollector::collectNames(mlir::Block &): 
Assertion `(!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options))
 && ""If 'op' is a verilog expression, the expression must be inlinable. "" 
 ""Otherwise, it is a bug of PrepareForEmission""' failed.
```

This seems to be strongly related to the `hw.struct_explode` operation, because replacing it with `hw.struct_extract` ops works just fine.

(Yes, I know that in this case, the canonicalizer would optimize `hw.struct_create` and `hw.struct_explode` away. But this is the smallest example that I could come up with to reproduce the bug.)","module {
  hw.module @EXPLODE(%0: i64, %1: i64) -> (arg1: i64, arg2: i64) {
    %2 = hw.struct_create (%0, %1) : !hw.struct<arg1: i64, arg2: i64>
    %arg1, %arg2 = hw.struct_explode %2 : !hw.struct<arg1: i64, arg2: i64>

    hw.output %arg1, %arg2 : i64, i64
  }
}","circt-opt: circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:3295:
void (anonymous namespace)::NameCollector::collectNames(mlir::Block &): 
Assertion `(!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options))
 && ""If 'op' is a verilog expression, the expression must be inlinable. "" 
 ""Otherwise, it is a bug of PrepareForEmission""' failed.",,,,,,,,
5462,"[FIRRTL][CheckCombCycles] Missed cycles, sensitive to presence of node?",2023-06-22T23:52:10Z,open,"bug, FIRRTL","Input, `--preserve-aggregate=all`:

```firrtl
circuit Loop:
  module Loop:
    wire w : {a: UInt<8>}
    node n = w
    w <= n
```

For some reason the node is needed for this to be missed (?).

This was reduced from slightly more complicated interprocedural inputs like:

```firrtl
circuit Loop:
  module Child:
    input bundle : { a : UInt<1>, b : UInt<1> }
    output p : {a : UInt<1>, b : UInt<1> }

    node n = bundle

    p <= n
  module Loop:
    input x : UInt<1>

    inst c of Child
    c.bundle.a <= x
    c.bundle.b <= c.p.b
```

----

Does not appear to be limited to cycles entirely unreachable/disconnected from the rest of the design/ports, FWIW, consider:

```firrtl
circuit Loop:
  module Loop:
    input in : {a: UInt<8>}
    output out : {a: UInt<8>}
    input c : UInt<1>

    wire w : {a: UInt<8>}
    node n = w
    w <= mux(c, n, in)

    out <= w
```","circuit Loop:
  module Loop:
    wire w : {a: UInt<8>}
    node n = w
    w <= n","circuit Loop:
  module Child:
    input bundle : { a : UInt<1>, b : UInt<1> }
    output p : {a : UInt<1>, b : UInt<1> }

    node n = bundle

    p <= n
  module Loop:
    input x : UInt<1>

    inst c of Child
    c.bundle.a <= x
    c.bundle.b <= c.p.b","circuit Loop:
  module Loop:
    input in : {a: UInt<8>}
    output out : {a: UInt<8>}
    input c : UInt<1>

    wire w : {a: UInt<8>}
    node n = w
    w <= mux(c, n, in)

    out <= w",,,,,,,
5447,[FIRRTL][InferWidths] Make checkCycles Iterative,2023-06-21T15:58:20Z,open,"bug, FIRRTL","The method `InferWidths::checkCycles` is currently recursive. If `firtool` is spawned in a thread which has an abnormally low stack size (i.e., on MacOS running Chisel tests using Scalatest), this can result in stack overflows. Fix this method to make it recursive. This is similar to https://github.com/llvm/circt/pull/5305.",,,,,,,,,,
5355,[HWLegalizeModules] Legalize array concat op,2023-06-10T10:18:04Z,open,"bug, HW","Support hw.array_concat in HWLegalizeModules
```mlir
$ ./build/bin/firtool perf/regress/chipyard.TestHarness.RocketSmall1Medium1Big1_BoomMedium1Large1Mega1.top.v.hi.fir -o foo.sv --lowering-options=disallowLocalVariables,disallowPackedArrays
Arbiters.scala:42:16: error: unsupported packed array expression
Arbiters.scala:42:16: note: see current operation: %57 = ""hw.array_concat""(%3, %56) : (!hw.array<3xi1>, !hw.array<5xi1>) -> !hw.array<8xi1>
```
","$ ./build/bin/firtool perf/regress/chipyard.TestHarness.RocketSmall1Medium1Big1_BoomMedium1Large1Mega1.top.v.hi.fir -o foo.sv --lowering-options=disallowLocalVariables,disallowPackedArrays
Arbiters.scala:42:16: error: unsupported packed array expression
Arbiters.scala:42:16: note: see current operation: %57 = ""hw.array_concat""(%3, %56) : (!hw.array<3xi1>, !hw.array<5xi1>) -> !hw.array<8xi1>",,,,,,,,,
5205,"[FIRRTL] Exporter prints invalid probe of constant (, inline expressions?)",2023-05-16T15:34:54Z,open,"bug, FIRRTL","Cannot probe inline expressions, probe target must be a static reference to a declaration (in current spec anyway).

Consider:

```mlir
firrtl.circuit ""ProbeConstant"" {
  firrtl.module @ProbeConstant(out %bore: !firrtl.probe<uint<1>>) {
    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1> {name = ""internalWire""}
    %0 = firrtl.ref.send %c0_ui1 : !firrtl.uint<1>
    firrtl.ref.define %bore, %0 : !firrtl.probe<uint<1>>
  }
}
```

Which becomes:

```firrtl
circuit ProbeConstant :
  module ProbeConstant :
    output bore : Probe<UInt<1>>

    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]
```

Which is invalid and does not parse:

```
<stdin>:5:25: error: use of unknown declaration 'UInt'
    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]
```

Not sure what approach works best with Exporter, but strategies such as giving expression a name with a node (or wire if non-passive) would give something to probe.","firrtl.circuit ""ProbeConstant"" {
  firrtl.module @ProbeConstant(out %bore: !firrtl.probe<uint<1>>) {
    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1> {name = ""internalWire""}
    %0 = firrtl.ref.send %c0_ui1 : !firrtl.uint<1>
    firrtl.ref.define %bore, %0 : !firrtl.probe<uint<1>>
  }
}","circuit ProbeConstant :
  module ProbeConstant :
    output bore : Probe<UInt<1>>

    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]","<stdin>:5:25: error: use of unknown declaration 'UInt'
    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]",,,,,,,
5204,[FIRRTL] Register with Self Connection Crashes Exporter,2023-05-16T02:21:20Z,open,"bug, FIRRTL","Consider the following FIRRTL Dialect:

```mlir
firrtl.circuit ""Foo"" {
  firrtl.module @Foo(in %clock: !firrtl.clock, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>
    %0 = firrtl.wire : !firrtl.uint<1>
    %r = firrtl.regreset interesting_name %clock, %c1_ui1, %0 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.strictconnect %0, %r : !firrtl.uint<1>
  }
}
```

This produces a nice crash in the exporter (`circt-translate -export-firrtl Bar.mlir`):

```
Assertion failed: (!s->text().empty() && ""empty string token""), function operator(), file PrettyPrinter.cpp, line 91.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.      Program arguments: circt-translate -export-firrtl Bar.mlir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  circt-translate          0x00000001079167ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  circt-translate          0x0000000107916d5b PrintStackTraceSignalHandler(void*) + 27
2  circt-translate          0x0000000107914896 llvm::sys::RunSignalHandlers() + 134
3  circt-translate          0x0000000107918b8f SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff81820c5ed _sigtramp + 29
5  libsystem_platform.dylib 0x00007ff7b877dd20 _sigtramp + 18446744072104646480
6  libsystem_c.dylib        0x00007ff818105b45 abort + 123
7  libsystem_c.dylib        0x00007ff818104e5e err + 0
8  circt-translate          0x0000000108746000 circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1::operator()(circt::pretty::StringToken*) const + 176
9  circt-translate          0x0000000108745ee8 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::TypeSwitch<circt::pretty::Token*, void>::Case<circt::pretty::StringToken, circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 88
10 circt-translate          0x0000000108744af5 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<circt::pretty::Token*, void>, circt::pretty::Token*>::Case<circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 53
11 circt-translate          0x0000000108744a03 circt::pretty::PrettyPrinter::add(circt::pretty::Token) + 99
12 circt-translate          0x000000010819d235 std::__1::enable_if<std::is_base_of_v<circt::pretty::Token, circt::pretty::StringToken>, void>::type circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::add<circt::pretty::StringToken, llvm::StringRef&>(llvm::StringRef&) + 101
13 circt-translate          0x000000010819d1c1 circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::literal(llvm::StringRef) + 33
14 circt-translate          0x000000010819c118 circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::operator<<(circt::pretty::PPExtString const&) + 56
15 circt-translate          0x00000001081c2fa8 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5::operator()() const + 104
16 circt-translate          0x00000001081c2f35 decltype(static_cast<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(fp)()) std::__1::__invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 21
17 circt-translate          0x00000001081c2e5d std::__1::invoke_result<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>::type std::__1::invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 29
18 circt-translate          0x00000001081c2d96 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(circt::pretty::PP&&, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&, circt::pretty::Token) + 102
19 circt-translate          0x00000001081c2d13 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp) + 179
20 circt-translate          0x00000001081c2808 auto (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16::operator()<circt::firrtl::WireOp>(circt::firrtl::WireOp) const + 40
21 circt-translate          0x00000001081c278b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::WireOp, (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&>((anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&) + 107
22 circt-translate          0x000000010819ea0d (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&) + 365
23 circt-translate          0x000000010819e669 (anonymous namespace)::Emitter::emitModule(circt::firrtl::FModuleOp)::$_1::operator()() const + 217
```","firrtl.circuit ""Foo"" {
  firrtl.module @Foo(in %clock: !firrtl.clock, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>
    %0 = firrtl.wire : !firrtl.uint<1>
    %r = firrtl.regreset interesting_name %clock, %c1_ui1, %0 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.strictconnect %0, %r : !firrtl.uint<1>
  }
}","Assertion failed: (!s->text().empty() && ""empty string token""), function operator(), file PrettyPrinter.cpp, line 91.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.      Program arguments: circt-translate -export-firrtl Bar.mlir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  circt-translate          0x00000001079167ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  circt-translate          0x0000000107916d5b PrintStackTraceSignalHandler(void*) + 27
2  circt-translate          0x0000000107914896 llvm::sys::RunSignalHandlers() + 134
3  circt-translate          0x0000000107918b8f SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff81820c5ed _sigtramp + 29
5  libsystem_platform.dylib 0x00007ff7b877dd20 _sigtramp + 18446744072104646480
6  libsystem_c.dylib        0x00007ff818105b45 abort + 123
7  libsystem_c.dylib        0x00007ff818104e5e err + 0
8  circt-translate          0x0000000108746000 circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1::operator()(circt::pretty::StringToken*) const + 176
9  circt-translate          0x0000000108745ee8 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::TypeSwitch<circt::pretty::Token*, void>::Case<circt::pretty::StringToken, circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 88
10 circt-translate          0x0000000108744af5 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<circt::pretty::Token*, void>, circt::pretty::Token*>::Case<circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 53
11 circt-translate          0x0000000108744a03 circt::pretty::PrettyPrinter::add(circt::pretty::Token) + 99
12 circt-translate          0x000000010819d235 std::__1::enable_if<std::is_base_of_v<circt::pretty::Token, circt::pretty::StringToken>, void>::type circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::add<circt::pretty::StringToken, llvm::StringRef&>(llvm::StringRef&) + 101
13 circt-translate          0x000000010819d1c1 circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::literal(llvm::StringRef) + 33
14 circt-translate          0x000000010819c118 circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::operator<<(circt::pretty::PPExtString const&) + 56
15 circt-translate          0x00000001081c2fa8 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5::operator()() const + 104
16 circt-translate          0x00000001081c2f35 decltype(static_cast<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(fp)()) std::__1::__invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 21
17 circt-translate          0x00000001081c2e5d std::__1::invoke_result<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>::type std::__1::invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 29
18 circt-translate          0x00000001081c2d96 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(circt::pretty::PP&&, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&, circt::pretty::Token) + 102
19 circt-translate          0x00000001081c2d13 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp) + 179
20 circt-translate          0x00000001081c2808 auto (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16::operator()<circt::firrtl::WireOp>(circt::firrtl::WireOp) const + 40
21 circt-translate          0x00000001081c278b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::WireOp, (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&>((anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&) + 107
22 circt-translate          0x000000010819ea0d (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&) + 365
23 circt-translate          0x000000010819e669 (anonymous namespace)::Emitter::emitModule(circt::firrtl::FModuleOp)::$_1::operator()() const + 217",,,,,,,,
5202,[FIRRTL] Incorrect Register Parsing,2023-05-15T21:22:04Z,open,"bug, FIRRTL","The FIRRTL parser uses the reset initial value being the reset as a shorthand for ""this is a reset-less register"". However, it only narrowly means that if the reset signal is `UInt<1>(0)`. Consider the following:

```
circuit Foo :
  module Foo :
    input clock: Clock
    input a: UInt<1>
    output b: UInt<1>

    reg r: UInt<1>, clock with: (reset => (UInt<1>(1), r))

    r <= a
    b <= r
```

This register never exits an indeterminate state and can be optimized to some constant. CIRCT currently thinks this is a reset-less register:

```verilog
module Foo(
  input  clock,
         a,
  output b
);

  reg r;
  always @(posedge clock)
    r <= a;
  assign b = r;
endmodule
```

SFC will produce:
```verilog
module Foo(
  input   clock,
  input   a,
  output  b
);
  assign b = 1'h0;
endmodule
```

Note: this code is impossible to emit from Chisel due to limitations of how it works.","circuit Foo :
  module Foo :
    input clock: Clock
    input a: UInt<1>
    output b: UInt<1>

    reg r: UInt<1>, clock with: (reset => (UInt<1>(1), r))

    r <= a
    b <= r","module Foo(
  input  clock,
         a,
  output b
);

  reg r;
  always @(posedge clock)
    r <= a;
  assign b = r;
endmodule","module Foo(
  input   clock,
  input   a,
  output  b
);
  assign b = 1'h0;
endmodule",,,,,,,
5031,[scf-to-calyx] Mark `cf` operations illegal,2023-04-13T16:30:52Z,open,"bug, Calyx","Hi! I just posted on the #circt channel on discord about a model I had that I tried to pass to CIRCT to lower to Calyx via `-lower-scf-to-calyx`. It seems like it takes a few hours at least, and sometime just crashes my machine - which is very strange, since the model is pretty simple with mostly arithmetic operations and 163 if statements that are represented with conditional branches (they were `scf.if` statements, but converted to `cf` with [convert-scf-to-cf](https://mlir.llvm.org/docs/Passes/#-convert-scf-to-cf-convert-scf-dialect-to-controlflow-dialect-replacing-structured-control-flow-with-a-cfg). 

This is the model: https://gist.github.com/asraa/93f10e86abcc3fe386eec172cb918e5c

I'll be poking around the conversion code near the conditional branch handling, just in case, and if I see something suspicious I'll update this thread. https://github.com/llvm/circt/blob/4a2ae91b421c71841c69153f81fc4277fe5409ef/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp#L1016

Thank you!

@mikeurbach for CC, thank you for responding in the chat!
",,,,,,,,,,
4921,"[FIRRTL][Inliner] UNREACHABLE ""the default constructor for MutableNLA should never be used""",2023-04-03T14:08:13Z,open,"bug, FIRRTL","Variant of inliner crash test case in #4920 .  This crashes on 1.35.0 and 1.37.0:

```firrtl
module {
  firrtl.circuit ""Unreachable"" {
    hw.hierpath private @nla_5560 [@Unreachable::@w, @Bar2]
    hw.hierpath private @nla_5561 [@Bar1::@w, @Bar3]
    firrtl.module private @Bar2() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      %x = firrtl.wire sym @x {annotations = [{circt.nonlocal = @nla_5560, class = ""test0""}]} : !firrtl.uint<8>
      firrtl.instance no sym @no @Bar1()
    }
    firrtl.module private @Bar1() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      firrtl.instance bar3 sym @w @Bar3()
    }
    firrtl.module private @Bar3() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @nla_5561, class = ""test0""}]} : !firrtl.uint<8>
    }
    firrtl.module @Unreachable() {
      firrtl.instance no sym @no @Bar1()
      firrtl.instance bar2 sym @w @Bar2()
    }
  }
}
```

Error:

```
the default constructor for MutableNLA should never be used
UNREACHABLE executed at /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:130!
```

Backtrace:

```
* thread #1, name = 'circt-opt', stop reason = signal SIGABRT
  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295
    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22
    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215
    frame #3: 0x00005555561857bf circt-opt`llvm::llvm_unreachable_internal(msg=<unavailable>, file=<unavailable>, line=<unavailable>) at ErrorHandling.cpp:212:3
    frame #4: 0x0000555556788dba circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] (anonymous namespace)::MutableNLA::MutableNLA(this=<unavailable>) at ModuleInliner.cpp:129:5
    frame #5: 0x0000555556788d2e circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>* llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (this=<unavailable>, TheBucket=<unavailable>, Key=0x00007fffffff3db8)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::InsertIntoBucket<mlir::Attribute const&>(llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>*, mlir::Attribute const&) at DenseMap.h:563:37
    frame #6: 0x0000555556788d20 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::FindAndConstruct(this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:339:13
    frame #7: 0x0000555556788ce2 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:343:12
    frame #8: 0x0000555556789f68 circt-opt`(anonymous namespace)::Inliner::setActiveHierPaths(this=0x00007fffffff4588, moduleName=StringAttr @ rbx, instInnerSym=StringAttr @ scalar) at ModuleInliner.cpp:596:11
    frame #9: 0x000055555678e194 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=(Data = ""bar2_"", Length = 5), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, beb=0x00007fffffff41a0, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3f18, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1094:5
    frame #10: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7
    frame #11: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7
    frame #12: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13
    frame #13: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17
    frame #14: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #15: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #16: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000330afe0, irUnits=ArrayRef<mlir::IRUnit> @ 0x000000000331dee0, args=0x0000555557bfe4f0)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #17: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfe4f0, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #18: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be0d10, op=0x0000555557bfd560, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16
    frame #19: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557c00380)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36
    frame #20: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18
    frame #21: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10
    frame #22: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14
    frame #23: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5
    frame #24: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20
    frame #25: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #26: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #27: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003435460, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000038b4fc0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #28: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #29: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16
    frame #30: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfd5c0, am=AnalysisManager @ scalar) at Pass.cpp:857:10
    frame #31: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfd5c0) at Pass.cpp:837:60
    frame #32: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc9000, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17
    frame #33: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12
    frame #34: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12
    frame #35: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12
    frame #36: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12
    frame #37: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12
    frame #38: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10
    frame #39: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14
    frame #40: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23
    frame #41: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126
    frame #42: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137
    frame #43: 0x0000555556160415 circt-opt`_start + 37
```","module {
  firrtl.circuit ""Unreachable"" {
    hw.hierpath private @nla_5560 [@Unreachable::@w, @Bar2]
    hw.hierpath private @nla_5561 [@Bar1::@w, @Bar3]
    firrtl.module private @Bar2() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      %x = firrtl.wire sym @x {annotations = [{circt.nonlocal = @nla_5560, class = ""test0""}]} : !firrtl.uint<8>
      firrtl.instance no sym @no @Bar1()
    }
    firrtl.module private @Bar1() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      firrtl.instance bar3 sym @w @Bar3()
    }
    firrtl.module private @Bar3() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @nla_5561, class = ""test0""}]} : !firrtl.uint<8>
    }
    firrtl.module @Unreachable() {
      firrtl.instance no sym @no @Bar1()
      firrtl.instance bar2 sym @w @Bar2()
    }
  }
}","the default constructor for MutableNLA should never be used
UNREACHABLE executed at /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:130!","* thread #1, name = 'circt-opt', stop reason = signal SIGABRT
  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295
    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22
    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215
    frame #3: 0x00005555561857bf circt-opt`llvm::llvm_unreachable_internal(msg=<unavailable>, file=<unavailable>, line=<unavailable>) at ErrorHandling.cpp:212:3
    frame #4: 0x0000555556788dba circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] (anonymous namespace)::MutableNLA::MutableNLA(this=<unavailable>) at ModuleInliner.cpp:129:5
    frame #5: 0x0000555556788d2e circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>* llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (this=<unavailable>, TheBucket=<unavailable>, Key=0x00007fffffff3db8)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::InsertIntoBucket<mlir::Attribute const&>(llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>*, mlir::Attribute const&) at DenseMap.h:563:37
    frame #6: 0x0000555556788d20 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::FindAndConstruct(this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:339:13
    frame #7: 0x0000555556788ce2 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:343:12
    frame #8: 0x0000555556789f68 circt-opt`(anonymous namespace)::Inliner::setActiveHierPaths(this=0x00007fffffff4588, moduleName=StringAttr @ rbx, instInnerSym=StringAttr @ scalar) at ModuleInliner.cpp:596:11
    frame #9: 0x000055555678e194 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=(Data = ""bar2_"", Length = 5), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, beb=0x00007fffffff41a0, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3f18, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1094:5
    frame #10: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7
    frame #11: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7
    frame #12: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13
    frame #13: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17
    frame #14: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #15: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #16: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000330afe0, irUnits=ArrayRef<mlir::IRUnit> @ 0x000000000331dee0, args=0x0000555557bfe4f0)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #17: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfe4f0, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #18: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be0d10, op=0x0000555557bfd560, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16
    frame #19: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557c00380)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36
    frame #20: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18
    frame #21: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10
    frame #22: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14
    frame #23: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5
    frame #24: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20
    frame #25: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #26: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #27: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003435460, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000038b4fc0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #28: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #29: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16
    frame #30: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfd5c0, am=AnalysisManager @ scalar) at Pass.cpp:857:10
    frame #31: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfd5c0) at Pass.cpp:837:60
    frame #32: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc9000, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17
    frame #33: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12
    frame #34: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12
    frame #35: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12
    frame #36: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12
    frame #37: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12
    frame #38: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10
    frame #39: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14
    frame #40: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23
    frame #41: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126
    frame #42: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137
    frame #43: 0x0000555556160415 circt-opt`_start + 37",,,,,,,
4896,[FIRRTL] Verify annotation symbol uses!,2023-03-28T00:07:06Z,open,"bug, good first issue, FIRRTL","Currently there is no verification that the symbols used by annotations exist at all, nevermind any sense of being appropriate/correct.  This should be fixed.  Example:

```firrtl
module {
  firrtl.circuit ""Oops"" {
    firrtl.module private @Child() attributes {annotations = [{circt.nonlocal = @nla, class = ""circt.test""}]} {
    }
    firrtl.module @Oops() {
      firrtl.instance child @Child()
    }
  }
}
```

Presently, `circt-opt` round-trips this, and `firtool` makes it all the way to `PrefixModules` before something notices.

There may be support for Attribute symbol-use verification, so look for such as that would be ideal.  Otherwise we may need to find a way to expose the uses to the symbol verifier, there are interfaces for exposing subelement's that may be appropriate here.  A final but offhand seemingly less-than-ideal approach to consider would be SymbolUserOpInterface's `verifySymbolUses` (I suppose on all our operations that take annotations).","module {
  firrtl.circuit ""Oops"" {
    firrtl.module private @Child() attributes {annotations = [{circt.nonlocal = @nla, class = ""circt.test""}]} {
    }
    firrtl.module @Oops() {
      firrtl.instance child @Child()
    }
  }
}",,,,,,,,,
4886,[FIRRTL] InferResets Not Duplicating Modules When Necessary,2023-03-24T22:32:02Z,open,"bug, FIRRTL","In the following FIRRTL, we have a module instantiated twice, once in a FullAsyncReset domain, and once not in any domain.

```
circuit Top : %[[
  {
    ""class"":""sifive.enterprise.firrtl.FullAsyncResetAnnotation"",
    ""target"":""~Top|FullAsyncWrapper>rf_reset""
  }
]]
  module Child :
    input clock : Clock
    input foo : UInt<8>
    output bar : UInt<8>

    reg r : UInt<8>, clock
    r <= foo
    bar <= r

  module FullAsyncWrapper :
    input clock : Clock
    input rf_reset : AsyncReset
    input foo : UInt<8>
    output bar : UInt<8>

    inst c of Child
    c.clock <= clock
    c.foo <= foo
    bar <= c.bar

  module Top :
    input clock : Clock
    input rf_reset : AsyncReset
    input foo : UInt<8>
    output bar : UInt<8>

    inst wrap of FullAsyncWrapper
    wrap.clock <= clock
    wrap.rf_reset <= rf_reset
    wrap.foo <= foo

    inst child of Child
    child.clock <= clock
    child.foo <= foo

    bar <= and(wrap.bar, child.bar)
```

Run this with firtool 1.36.0 and you will get
```
test.fir:7:10: error: module 'Child' instantiated in different reset domains
  module Child :
         ^
test.fir:7:10: note: see current operation: 
""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<8>, %arg2: !firrtl.uint<8>):
  %0 = ""firrtl.reg""(%arg0) {annotations = [], name = ""r"", nameKind = #firrtl<name_kind droppable_name>} : (!firrtl.clock) -> !firrtl.uint<8>
  ""firrtl.strictconnect""(%0, %arg1) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()
  ""firrtl.strictconnect""(%arg2, %0) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()
}) {annotations = [], portAnnotations = [], portDirections = -4 : i3, portLocations = [loc(""test.fir"":8:11), loc(""test.fir"":9:11), loc(""test.fir"":10:12)], portNames = [""clock"", ""foo"", ""bar""], portSyms = [], portTypes = [!firrtl.clock, !firrtl.uint<8>, !firrtl.uint<8>], sym_name = ""Child"", sym_visibility = ""private""} : () -> ()
test.fir:22:5: note: instance 'wrap/c' is in reset domain rooted at 'rf_reset' of module 'FullAsyncWrapper'
    inst c of Child
    ^
test.fir:18:11: note: reset domain 'rf_reset' of module 'FullAsyncWrapper' declared here:
    input rf_reset : AsyncReset
          ^
test.fir:38:5: note: instance 'child' is in no reset domain
    inst child of Child
    ^
```

This is a very similar issue to https://github.com/llvm/circt/issues/4586","circuit Top : %[[
  {
    ""class"":""sifive.enterprise.firrtl.FullAsyncResetAnnotation"",
    ""target"":""~Top|FullAsyncWrapper>rf_reset""
  }
]]
  module Child :
    input clock : Clock
    input foo : UInt<8>
    output bar : UInt<8>

    reg r : UInt<8>, clock
    r <= foo
    bar <= r

  module FullAsyncWrapper :
    input clock : Clock
    input rf_reset : AsyncReset
    input foo : UInt<8>
    output bar : UInt<8>

    inst c of Child
    c.clock <= clock
    c.foo <= foo
    bar <= c.bar

  module Top :
    input clock : Clock
    input rf_reset : AsyncReset
    input foo : UInt<8>
    output bar : UInt<8>

    inst wrap of FullAsyncWrapper
    wrap.clock <= clock
    wrap.rf_reset <= rf_reset
    wrap.foo <= foo

    inst child of Child
    child.clock <= clock
    child.foo <= foo

    bar <= and(wrap.bar, child.bar)","test.fir:7:10: error: module 'Child' instantiated in different reset domains
  module Child :
         ^
test.fir:7:10: note: see current operation: 
""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<8>, %arg2: !firrtl.uint<8>):
  %0 = ""firrtl.reg""(%arg0) {annotations = [], name = ""r"", nameKind = #firrtl<name_kind droppable_name>} : (!firrtl.clock) -> !firrtl.uint<8>
  ""firrtl.strictconnect""(%0, %arg1) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()
  ""firrtl.strictconnect""(%arg2, %0) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()
}) {annotations = [], portAnnotations = [], portDirections = -4 : i3, portLocations = [loc(""test.fir"":8:11), loc(""test.fir"":9:11), loc(""test.fir"":10:12)], portNames = [""clock"", ""foo"", ""bar""], portSyms = [], portTypes = [!firrtl.clock, !firrtl.uint<8>, !firrtl.uint<8>], sym_name = ""Child"", sym_visibility = ""private""} : () -> ()
test.fir:22:5: note: instance 'wrap/c' is in reset domain rooted at 'rf_reset' of module 'FullAsyncWrapper'
    inst c of Child
    ^
test.fir:18:11: note: reset domain 'rf_reset' of module 'FullAsyncWrapper' declared here:
    input rf_reset : AsyncReset
          ^
test.fir:38:5: note: instance 'child' is in no reset domain
    inst child of Child
    ^",,,,,,,,
4849,[ExportVerilog][SV] sv.interface instance name not Verilog-keyword mangled,2023-03-17T21:27:52Z,open,"bug, ExportVerilog","The instance name of an SV interface op is not mangled if it collides with a Verilog keyword when it should be.

Consider:

```mlir
module {
  sv.interface @wire {}
  hw.module private @Foo() {
    %module = sv.interface.instance : !sv.interface<@wire>
    hw.output
  }
}
```

This is being output as the following when using `circt-opt -export-verilog Foo.mlir`:

```verilog
// Generated by CIRCT unknown git version
interface module_0;
endinterface

module Foo();	// Foo.mlir:3:3
  wire_0 module();	// Foo.mlir:4:15
endmodule
```","module {
  sv.interface @wire {}
  hw.module private @Foo() {
    %module = sv.interface.instance : !sv.interface<@wire>
    hw.output
  }
}","// Generated by CIRCT unknown git version
interface module_0;
endinterface

module Foo();	// Foo.mlir:3:3
  wire_0 module();	// Foo.mlir:4:15
endmodule",,,,,,,,
4842,[Lower Calyx to FSM] Pass can fail if not canonicalized before running,2023-03-16T16:28:01Z,open,"bug, Calyx, need triage","This works:
```bash
$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --canonicalize --lower-calyx-to-fsm
```

But the following (without the `--canonicalize`) triggers an assertion:
```bash
$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm
circt-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed
```

`simple_arith.mlir` can be found [here](https://github.com/llvm/circt/blob/main/integration_test/Dialect/Calyx/simple_arith.mlir).

Backtrace:
```
circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm   
circt-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ../../circt/build/bin/circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm
 #0 0x000055d161ee52d4 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:22
 #1 0x000055d161ee56a6 PrintStackTraceSignalHandler(void*) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:676:1
 #2 0x000055d161ee2d57 llvm::sys::RunSignalHandlers() /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Signals.cpp:104:20
 #3 0x000055d161ee4c32 SignalHandler(int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #4 0x00007f117de51f50 (/usr/lib/libc.so.6+0x38f50)
 #5 0x00007f117dea08ec (/usr/lib/libc.so.6+0x878ec)
 #6 0x00007f117de51ea8 raise (/usr/lib/libc.so.6+0x38ea8)
 #7 0x00007f117de3b53d abort (/usr/lib/libc.so.6+0x2253d)
 #8 0x00007f117de3b45c (/usr/lib/libc.so.6+0x2245c)
 #9 0x00007f117de4a9f6 (/usr/lib/libc.so.6+0x319f6)
#10 0x000055d1621313f5 llvm::SmallVectorTemplateCommon<std::pair<mlir::Operation*, circt::fsm::StateOp>, void>::front() /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:304:17
#11 0x000055d16212bf8b (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:196:26
#12 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#13 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#14 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#15 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#16 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#17 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#18 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#19 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#20 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#21 0x000055d16212b958 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp)::'lambda'(mlir::Value, llvm::StringRef, bool, mlir::Operation*)::operator()(mlir::Value, llvm::StringRef, bool, mlir::Operation*) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:147:15
#22 0x000055d16212bb0e (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:153:13
#23 0x000055d16212dbe3 auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::IfOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#24 0x000055d16212dc60 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::IfOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#25 0x000055d16212b320 Case<circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#26 0x000055d16212b320 Case<circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42
#27 0x000055d16212b320 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42
#28 0x000055d16212b320 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#29 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#30 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#31 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#32 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#33 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#34 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#35 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#36 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#37 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#38 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#39 0x000055d16212cada (anonymous namespace)::CalyxToFSMPass::runOnOperation() /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:307:13
#40 0x000055d164764cc4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:471:27
#41 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15
#42 0x000055d1647660e8 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:754:47
#43 0x000055d164768e17 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:46:17
#44 0x000055d1647681df mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:94:1
#45 0x000055d164766627 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:764:13
#46 0x000055d164765ab9 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:658:1
#47 0x000055d164764ca5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:468:28
#48 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15
#49 0x000055d164766e06 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:843:40
#50 0x000055d164766c66 mlir::PassManager::run(mlir::Operation*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:823:69
#51 0x000055d16397c887 performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:175:13
#52 0x000055d16397ccf5 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPool*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:221:26
#53 0x000055d16397ce21 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:262:25
#54 0x000055d16397dcd2 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:52
#55 0x000055d1639bae6b llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
#56 0x000055d1639ba6ff mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:28:30
#57 0x000055d16397cfd2 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:265:31
#58 0x000055d16397d8cf mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:354:13
#59 0x000055d161ddc13e main /home/xerpi/Desktop/Research/circt/tools/circt-opt/circt-opt.cpp:70:22
#60 0x00007f117de3c790 (/usr/lib/libc.so.6+0x23790)
#61 0x00007f117de3c84a __libc_start_main (/usr/lib/libc.so.6+0x2384a)
#62 0x000055d161ddbec5 _start (../../circt/build/bin/circt-opt+0x119ec5)
Aborted (core dumped)
```",$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --canonicalize --lower-calyx-to-fsm,"$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm
circt-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed","circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm   
circt-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ../../circt/build/bin/circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm
 #0 0x000055d161ee52d4 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:22
 #1 0x000055d161ee56a6 PrintStackTraceSignalHandler(void*) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:676:1
 #2 0x000055d161ee2d57 llvm::sys::RunSignalHandlers() /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Signals.cpp:104:20
 #3 0x000055d161ee4c32 SignalHandler(int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #4 0x00007f117de51f50 (/usr/lib/libc.so.6+0x38f50)
 #5 0x00007f117dea08ec (/usr/lib/libc.so.6+0x878ec)
 #6 0x00007f117de51ea8 raise (/usr/lib/libc.so.6+0x38ea8)
 #7 0x00007f117de3b53d abort (/usr/lib/libc.so.6+0x2253d)
 #8 0x00007f117de3b45c (/usr/lib/libc.so.6+0x2245c)
 #9 0x00007f117de4a9f6 (/usr/lib/libc.so.6+0x319f6)
#10 0x000055d1621313f5 llvm::SmallVectorTemplateCommon<std::pair<mlir::Operation*, circt::fsm::StateOp>, void>::front() /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:304:17
#11 0x000055d16212bf8b (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:196:26
#12 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#13 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#14 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#15 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#16 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#17 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#18 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#19 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#20 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#21 0x000055d16212b958 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp)::'lambda'(mlir::Value, llvm::StringRef, bool, mlir::Operation*)::operator()(mlir::Value, llvm::StringRef, bool, mlir::Operation*) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:147:15
#22 0x000055d16212bb0e (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:153:13
#23 0x000055d16212dbe3 auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::IfOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#24 0x000055d16212dc60 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::IfOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#25 0x000055d16212b320 Case<circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#26 0x000055d16212b320 Case<circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42
#27 0x000055d16212b320 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42
#28 0x000055d16212b320 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#29 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#30 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#31 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#32 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#33 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#34 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#35 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#36 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#37 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#38 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#39 0x000055d16212cada (anonymous namespace)::CalyxToFSMPass::runOnOperation() /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:307:13
#40 0x000055d164764cc4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:471:27
#41 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15
#42 0x000055d1647660e8 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:754:47
#43 0x000055d164768e17 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:46:17
#44 0x000055d1647681df mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:94:1
#45 0x000055d164766627 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:764:13
#46 0x000055d164765ab9 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:658:1
#47 0x000055d164764ca5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:468:28
#48 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15
#49 0x000055d164766e06 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:843:40
#50 0x000055d164766c66 mlir::PassManager::run(mlir::Operation*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:823:69
#51 0x000055d16397c887 performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:175:13
#52 0x000055d16397ccf5 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPool*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:221:26
#53 0x000055d16397ce21 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:262:25
#54 0x000055d16397dcd2 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:52
#55 0x000055d1639bae6b llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
#56 0x000055d1639ba6ff mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:28:30
#57 0x000055d16397cfd2 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:265:31
#58 0x000055d16397d8cf mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:354:13
#59 0x000055d161ddc13e main /home/xerpi/Desktop/Research/circt/tools/circt-opt/circt-opt.cpp:70:22
#60 0x00007f117de3c790 (/usr/lib/libc.so.6+0x23790)
#61 0x00007f117de3c84a __libc_start_main (/usr/lib/libc.so.6+0x2384a)
#62 0x000055d161ddbec5 _start (../../circt/build/bin/circt-opt+0x119ec5)
Aborted (core dumped)",,,,,,,
4834,[FIRRTL] Inline + MarkDUT + MemTap crasher,2023-03-15T17:12:30Z,open,"bug, FIRRTL","Inline+MarkDUTAnnotation already don't seem compatible, but FWIW we crash in LowerToHW on this input.

Input:
```firrtl
circuit Top : %[[
  {
    ""class"": ""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""~Top|DUTModule""
  },
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top>memTap""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.MemTapAnnotation"",
    ""source"":""~Top|DUTModule>rf"",
    ""sink"":[
      ""~Top|Top>memTap[0]"",
      ""~Top|Top>memTap[1]"",
      ""~Top|Top>memTap[2]"",
      ""~Top|Top>memTap[3]"",
      ""~Top|Top>memTap[4]"",
      ""~Top|Top>memTap[5]"",
      ""~Top|Top>memTap[6]"",
      ""~Top|Top>memTap[7]""
    ]
  },
  {
    ""class"": ""firrtl.passes.InlineAnnotation"",
    ""target"": ""~Top|DUTModule""
  }
]]
  module DUTModule :
    input clock : Clock
    input reset : Reset
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    cmem rf : UInt<8> [8]
    infer mport read = rf[io.addr], clock
    io.dataOut <= read
    when io.wen :
      infer mport write = rf[io.addr], clock
      write <= io.dataIn

  module Top :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    inst dut of DUTModule
    dut.clock <= clock
    dut.reset <= reset
    wire memTap : UInt<8>[8]
    memTap is invalid
    io.dataOut <= dut.io.dataOut
    dut.io.wen <= io.wen
    dut.io.dataIn <= io.dataIn
    dut.io.addr <= io.addr
```

This is basically our `mem-taps.fir` lit test with the Inline annotation added.

With threading disabled, see the following error: `invalid element for hw.inout type '!firrtl.ref<uint<8>>'`, FWIW.","circuit Top : %[[
  {
    ""class"": ""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""~Top|DUTModule""
  },
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top>memTap""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.MemTapAnnotation"",
    ""source"":""~Top|DUTModule>rf"",
    ""sink"":[
      ""~Top|Top>memTap[0]"",
      ""~Top|Top>memTap[1]"",
      ""~Top|Top>memTap[2]"",
      ""~Top|Top>memTap[3]"",
      ""~Top|Top>memTap[4]"",
      ""~Top|Top>memTap[5]"",
      ""~Top|Top>memTap[6]"",
      ""~Top|Top>memTap[7]""
    ]
  },
  {
    ""class"": ""firrtl.passes.InlineAnnotation"",
    ""target"": ""~Top|DUTModule""
  }
]]
  module DUTModule :
    input clock : Clock
    input reset : Reset
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    cmem rf : UInt<8> [8]
    infer mport read = rf[io.addr], clock
    io.dataOut <= read
    when io.wen :
      infer mport write = rf[io.addr], clock
      write <= io.dataIn

  module Top :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    inst dut of DUTModule
    dut.clock <= clock
    dut.reset <= reset
    wire memTap : UInt<8>[8]
    memTap is invalid
    io.dataOut <= dut.io.dataOut
    dut.io.wen <= io.wen
    dut.io.dataIn <= io.dataIn
    dut.io.addr <= io.addr",,,,,,,,,
4816,Late pipeline passes should not be doing type coercion.,2023-03-13T23:26:33Z,open,bug,"              Please do not do this.  The goal is to remove this logic entirely and stop duplicating it in every pass.  We should never get to this point in the pass with the register reset value being the wrong type for the register.  That should be fixed in parsing.

_Originally posted by @darthscsi in https://github.com/llvm/circt/pull/4788#pullrequestreview-1338110528_
            ",,,,,,,,,,
4780,"[FIRRTL] Missed comb cycle, crash in canonicalizer",2023-03-08T02:24:27Z,open,"bug, FIRRTL","Input:

```firrtl
circuit wut :
   module wut :
     output rwDataOut : UInt<8>

     rwDataOut <= rwDataOut
```

<details>
<summary>Crashes after making it to HW dialect:</summary>

```
firtool: /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:190: void mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith(ValueT &&) [OperandType = mlir::OpOperand, ValueT = mlir::Value &]: Assertion `(!newValue || this != OperandType::getUseList(newValue)) && ""cannot RAUW a value with itself""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool wut.fir
 #0 0x00000000006c71bb llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x00000000006c5450 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x00000000006c786d SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007f882063dbf0 __restore_rt (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3dbf0)
 #4 0x00007f882068abc7 __pthread_kill_implementation (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x8abc7)
 #5 0x00007f882063db46 gsignal (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3db46)
 #6 0x00007f88206284b5 abort (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x284b5)
 #7 0x00007f88206283d9 _nl_load_domain.cold.0 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x283d9)
 #8 0x00007f88206367b6 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x367b6)
 #9 0x0000000000a5476c std::enable_if<!(std::is_convertible<mlir::ValueRange&, mlir::Operation*>::value), void>::type mlir::ResultRange::replaceAllUsesWith<mlir::ValueRange&>(mlir::ValueRange&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/ValueRange.h:271:5
#10 0x0000000000a52ec3 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:275:61
#11 0x0000000000c31cb7 circt::sv::WireOp::canonicalize(circt::sv::WireOp, mlir::PatternRewriter&) /home/will/src/sifive/circt/lib/Dialect/SV/SVOps.cpp:1460:18
#12 0x0000000000e0ccb7 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25
#13 0x0000000000dd93ed (anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:229:19
#14 0x0000000000dd702d (anonymous namespace)::RegionPatternRewriteDriver::simplify() && /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:458:15
#15 0x0000000000dd702d mlir::applyPatternsAndFoldGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:487:47
#16 0x0000000000a66148 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#17 0x0000000000a66148 mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:115:70
#18 0x0000000000a66148 (anonymous namespace)::Canonicalizer::runOnOperation() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:61:9
#19 0x0000000000ee9829 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11
#20 0x0000000000ee9e61 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#21 0x0000000000ee9e61 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#22 0x0000000000ee9e61 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#23 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::size() const /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:919:66
#24 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1045:2
#25 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5
#26 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18
#27 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#28 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14
#29 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5
#30 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14
#31 0x0000000000eec3a3 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#32 0x0000000000eec3a3 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#33 0x0000000000eec3a3 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#34 0x0000000000eec3a3 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:843:10
#35 0x0000000000eec3a3 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:823:60
#36 0x000000000061a57b mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#37 0x000000000061a57b mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#38 0x000000000061a57b processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:856:7
#39 0x00000000006182bf processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:12
#40 0x0000000000617f42 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:968:12
#41 0x0000000000617f42 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1058:14
#42 0x00000000006179f6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#43 0x00000000006179f6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#44 0x00000000006179f6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1122:8
#45 0x00007f882062924e __libc_start_call_main (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x2924e)
#46 0x00007f8820629309 __libc_start_main@GLIBC_2.2.5 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x29309)
#47 0x0000000000617825 _start (./build/bin/firtool+0x617825)
zsh: IOT instruction (core dumped)  ./build/bin/firtool wut.fir
```

</details>

Dumping the IR shows this before the crash:

```
// -----// IR Dump Before Canonicalizer (canonicalize) //----- //
hw.module @wut() -> (rwDataOut: i8) {
  %.rwDataOut.output = sv.wire : !hw.inout<i8>
  %0 = sv.read_inout %.rwDataOut.output : !hw.inout<i8>
  sv.assign %.rwDataOut.output, %0 : i8
  hw.output %0 : i8
}
```","circuit wut :
   module wut :
     output rwDataOut : UInt<8>

     rwDataOut <= rwDataOut","firtool: /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:190: void mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith(ValueT &&) [OperandType = mlir::OpOperand, ValueT = mlir::Value &]: Assertion `(!newValue || this != OperandType::getUseList(newValue)) && ""cannot RAUW a value with itself""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool wut.fir
 #0 0x00000000006c71bb llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x00000000006c5450 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x00000000006c786d SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007f882063dbf0 __restore_rt (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3dbf0)
 #4 0x00007f882068abc7 __pthread_kill_implementation (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x8abc7)
 #5 0x00007f882063db46 gsignal (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3db46)
 #6 0x00007f88206284b5 abort (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x284b5)
 #7 0x00007f88206283d9 _nl_load_domain.cold.0 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x283d9)
 #8 0x00007f88206367b6 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x367b6)
 #9 0x0000000000a5476c std::enable_if<!(std::is_convertible<mlir::ValueRange&, mlir::Operation*>::value), void>::type mlir::ResultRange::replaceAllUsesWith<mlir::ValueRange&>(mlir::ValueRange&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/ValueRange.h:271:5
#10 0x0000000000a52ec3 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:275:61
#11 0x0000000000c31cb7 circt::sv::WireOp::canonicalize(circt::sv::WireOp, mlir::PatternRewriter&) /home/will/src/sifive/circt/lib/Dialect/SV/SVOps.cpp:1460:18
#12 0x0000000000e0ccb7 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25
#13 0x0000000000dd93ed (anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:229:19
#14 0x0000000000dd702d (anonymous namespace)::RegionPatternRewriteDriver::simplify() && /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:458:15
#15 0x0000000000dd702d mlir::applyPatternsAndFoldGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:487:47
#16 0x0000000000a66148 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#17 0x0000000000a66148 mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:115:70
#18 0x0000000000a66148 (anonymous namespace)::Canonicalizer::runOnOperation() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:61:9
#19 0x0000000000ee9829 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11
#20 0x0000000000ee9e61 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#21 0x0000000000ee9e61 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#22 0x0000000000ee9e61 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#23 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::size() const /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:919:66
#24 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1045:2
#25 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5
#26 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18
#27 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#28 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14
#29 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5
#30 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14
#31 0x0000000000eec3a3 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#32 0x0000000000eec3a3 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#33 0x0000000000eec3a3 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#34 0x0000000000eec3a3 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:843:10
#35 0x0000000000eec3a3 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:823:60
#36 0x000000000061a57b mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#37 0x000000000061a57b mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#38 0x000000000061a57b processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:856:7
#39 0x00000000006182bf processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:12
#40 0x0000000000617f42 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:968:12
#41 0x0000000000617f42 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1058:14
#42 0x00000000006179f6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#43 0x00000000006179f6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#44 0x00000000006179f6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1122:8
#45 0x00007f882062924e __libc_start_call_main (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x2924e)
#46 0x00007f8820629309 __libc_start_main@GLIBC_2.2.5 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x29309)
#47 0x0000000000617825 _start (./build/bin/firtool+0x617825)
zsh: IOT instruction (core dumped)  ./build/bin/firtool wut.fir","// -----// IR Dump Before Canonicalizer (canonicalize) //----- //
hw.module @wut() -> (rwDataOut: i8) {
  %.rwDataOut.output = sv.wire : !hw.inout<i8>
  %0 = sv.read_inout %.rwDataOut.output : !hw.inout<i8>
  sv.assign %.rwDataOut.output, %0 : i8
  hw.output %0 : i8
}",,,,,,,
4771,[FIRRTL] attach of analog under when (+ subaccess)?,2023-03-06T14:58:23Z,open,"bug, FIRRTL","Generally, this may be more of a FIRRTL-spec consideration, but the following is accepted and only is rejected late in the pipeline:

```firrtl
circuit Foo :
  module Foo :
    output d : { a: UInt<2>, b: Analog<1>}
    input c : UInt<1>
    d is invalid
    when c :
      inst b of Bar
      attach(d.b, b.b.b[c])
    else :
      inst b2 of Bar
      attach(d.b, b2.b.b[c])

  extmodule Bar :
    output b : { a : UInt<2>, b : Analog<1>[2]}
 ```
 
 Output:
 
 ```
analog.fir:11:11: error: operand isn't an inout type
      d.b <- b2.b.b[c]
          ^
analog.fir:11:11: note: see current operation: ""firrtl.attach""(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()
analog.fir:11:11: error: 'firrtl.attach' op LowerToHW couldn't handle this operation
      d.b <- b2.b.b[c]
          ^
analog.fir:11:11: note: see current operation: ""firrtl.attach""(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> () 
 ```
 
*Does conditional attach make sense?* (is it unconditional even under `when`?)
","circuit Foo :
  module Foo :
    output d : { a: UInt<2>, b: Analog<1>}
    input c : UInt<1>
    d is invalid
    when c :
      inst b of Bar
      attach(d.b, b.b.b[c])
    else :
      inst b2 of Bar
      attach(d.b, b2.b.b[c])

  extmodule Bar :
    output b : { a : UInt<2>, b : Analog<1>[2]}","analog.fir:11:11: error: operand isn't an inout type
      d.b <- b2.b.b[c]
          ^
analog.fir:11:11: note: see current operation: ""firrtl.attach""(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()
analog.fir:11:11: error: 'firrtl.attach' op LowerToHW couldn't handle this operation
      d.b <- b2.b.b[c]
          ^
analog.fir:11:11: note: see current operation: ""firrtl.attach""(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()",,,,,,,,
4770,"[ExportVerilog] ""$name is not allowed in Verilog output"" error does not fail pass",2023-03-06T14:37:28Z,open,"bug, ExportVerilog","Encountered crafting test over here: https://github.com/llvm/circt/pull/4589#discussion_r1126488967 .

Is currently reachable + executed as part of the `verilog-errors.mlir` test case:

```mlir
hw.module.extern @parameter ()
```

=>

```
verilog-error.mlir:4:1: error: name ""parameter"" is not allowed in Verilog output
hw.module.extern @parameter ()
^
verilog-error.mlir:4:1: note: see current operation: 
""hw.module.extern""() ({
}) {argLocs = [], argNames = [], comment = """", function_type = () -> (), parameters = [], resultLocs = [], resultNames = [], sym_name = ""parameter""} : () -> ()
// Generated by CIRCT 1.34.0g20230304_3ddf879
// external module parameter
```

As an aside, getting our error tests to check that pass/execution is not successful would be great, cc #4553 .",hw.module.extern @parameter (),"verilog-error.mlir:4:1: error: name ""parameter"" is not allowed in Verilog output
hw.module.extern @parameter ()
^
verilog-error.mlir:4:1: note: see current operation: 
""hw.module.extern""() ({
}) {argLocs = [], argNames = [], comment = """", function_type = () -> (), parameters = [], resultLocs = [], resultNames = [], sym_name = ""parameter""} : () -> ()
// Generated by CIRCT 1.34.0g20230304_3ddf879
// external module parameter",,,,,,,,
4753,[FIRRTL] Crash with out-of-bounds Index,2023-03-02T16:55:07Z,open,"bug, FIRRTL","I noticed that the following is crashing:

```
circuit Foo:
  module Foo:
    input a: UInt<8>[3]
    output b: UInt<8>

    b <= a[UInt<99>(300)]
```

This throws an error (doesn't exit) and then crashes (`firtool Foo.fir`):

```
Foo.fir:6:12: error: out of range index '300' in vector type '!firrtl.vector<uint<8>, 3>'
    b <= a[UInt<99>(300)]
           ^
LLVM ERROR: Failed to infer result type(s).
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: firtool Foo.fir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x00000001039cf21d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x00000001039cf79b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x00000001039cd566 llvm::sys::RunSignalHandlers() + 134
3  firtool                  0x00000001039d14cf SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff80f497dfd _sigtramp + 29
5  firtool                  0x00000001037856e5 std::__1::__libcpp_deallocate(void*, unsigned long, unsigned long) + 85
6  libsystem_c.dylib        0x00007ff80f3cdd24 abort + 123
7  firtool                  0x000000010389f2d4 llvm::report_fatal_error(llvm::Twine const&, bool) + 388
8  firtool                  0x000000010389f145 llvm::report_fatal_error(char const*, bool) + 53
9  firtool                  0x000000010479c065 circt::firrtl::SubindexOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Value, unsigned int) + 533
10 firtool                  0x0000000103ed526c circt::firrtl::SubindexOp mlir::OpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::Location, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 220
11 firtool                  0x0000000103ed4fd1 circt::firrtl::SubindexOp mlir::ImplicitLocOpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 81
```","circuit Foo:
  module Foo:
    input a: UInt<8>[3]
    output b: UInt<8>

    b <= a[UInt<99>(300)]","Foo.fir:6:12: error: out of range index '300' in vector type '!firrtl.vector<uint<8>, 3>'
    b <= a[UInt<99>(300)]
           ^
LLVM ERROR: Failed to infer result type(s).
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: firtool Foo.fir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x00000001039cf21d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x00000001039cf79b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x00000001039cd566 llvm::sys::RunSignalHandlers() + 134
3  firtool                  0x00000001039d14cf SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff80f497dfd _sigtramp + 29
5  firtool                  0x00000001037856e5 std::__1::__libcpp_deallocate(void*, unsigned long, unsigned long) + 85
6  libsystem_c.dylib        0x00007ff80f3cdd24 abort + 123
7  firtool                  0x000000010389f2d4 llvm::report_fatal_error(llvm::Twine const&, bool) + 388
8  firtool                  0x000000010389f145 llvm::report_fatal_error(char const*, bool) + 53
9  firtool                  0x000000010479c065 circt::firrtl::SubindexOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Value, unsigned int) + 533
10 firtool                  0x0000000103ed526c circt::firrtl::SubindexOp mlir::OpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::Location, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 220
11 firtool                  0x0000000103ed4fd1 circt::firrtl::SubindexOp mlir::ImplicitLocOpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 81",,,,,,,,
4586,[FIRRTL] PrefixModules Not Duplicating Modules When Necessary,2023-01-25T01:29:48Z,open,"bug, FIRRTL","I hit a situation where `PrefixModules` should be duplicating modules, but it is not.

Consider the following:

```
circuit Top : %[[
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""target"":""~Top|Foo"",
    ""prefix"":""A_"",
    ""inclusive"":true
  },
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""target"":""~Top|Foo_1"",
    ""prefix"":""B_"",
    ""inclusive"":true
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|Foo>in""
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|Foo_1>in""
  }
]]
  module Foo :
    input in : UInt<8>

  module Foo_1 :
    input in : UInt<8>

  module Top :
    input in : UInt<8>

    inst f1 of Foo
    inst f2 of Foo_1
    f1.in <= in
    f2.in <= in
```

If I run this with `firtool -dedup`, I get the following Verilog:

```verilog
module A_Foo(
  input [7:0] in);

endmodule

module Top(
  input [7:0] in);

  A_Foo f1 (
    .in (in)
  );
  A_Foo f2 (
    .in (in)
  );
endmodule
```

If I run without dedup, I get two modules (expectedly):

```verilog
module A_Foo(
  input [7:0] in);

endmodule

module B_Foo_1(
  input [7:0] in);

endmodule

module Top(
  input [7:0] in);

  A_Foo f1 (
    .in (in)
  );
  B_Foo_1 f2 (
    .in (in)
  );
endmodule
```

Basically, I'm expecting to see both an `A_` and `B_` prefix in the output and I only get an `A_` prefix.","circuit Top : %[[
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""target"":""~Top|Foo"",
    ""prefix"":""A_"",
    ""inclusive"":true
  },
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""target"":""~Top|Foo_1"",
    ""prefix"":""B_"",
    ""inclusive"":true
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|Foo>in""
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|Foo_1>in""
  }
]]
  module Foo :
    input in : UInt<8>

  module Foo_1 :
    input in : UInt<8>

  module Top :
    input in : UInt<8>

    inst f1 of Foo
    inst f2 of Foo_1
    f1.in <= in
    f2.in <= in","module A_Foo(
  input [7:0] in);

endmodule

module Top(
  input [7:0] in);

  A_Foo f1 (
    .in (in)
  );
  A_Foo f2 (
    .in (in)
  );
endmodule","module A_Foo(
  input [7:0] in);

endmodule

module B_Foo_1(
  input [7:0] in);

endmodule

module Top(
  input [7:0] in);

  A_Foo f1 (
    .in (in)
  );
  B_Foo_1 f2 (
    .in (in)
  );
endmodule",,,,,,,
4354,[LowerToHW] An Error Should Be Generated if ForceNameAnnotation Would Not Be Unique,2022-11-23T03:08:03Z,open,"bug, good first issue, FIRRTL","Currently, two `ForceNameAnnotation`s can set an instance within the same module to the same name. The later one will eventually lose when it is uniqued by `PrepareForEmission`/`ExporVerilog`. This should instead be an error:

Consider the following which is trying to set all instances inside `ForceNameTop` to be called `Foo`:

```mlir
firrtl.circuit ""ForceNameTop"" {
  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]
  firrtl.hierpath private @nla_2 [@ForceNameTop::@sym_bar, @ForceNameSubmodule]
  firrtl.module private @ForceNameSubmodule() attributes {annotations = [
    {circt.nonlocal = @nla_1,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Foo""},
    {circt.nonlocal = @nla_2,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Foo""}
  ]} {}
  firrtl.module @ForceNameTop() {
    firrtl.instance Foo @ForceNameSubmodule()
    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()
    firrtl.instance bar sym @sym_bar @ForceNameSubmodule()
  }
}
```

After `LowerToHW` this has two instances with the same `verilogName`:

```mlir
module {
  hw.module private @ForceNameSubmodule() {
    hw.output
  }
  hw.module @ForceNameTop() {
    hw.instance ""Foo"" @ForceNameSubmodule() -> ()
    hw.instance ""foo"" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = ""Foo""}
    hw.instance ""bar"" sym @sym_bar @ForceNameSubmodule() -> () {hw.verilogName = ""Foo""}
    hw.output
  }
}
```

This is fine and will generate sane Verilog below. However, this may be surprising to a user. Verilog is:

```verilog
// Generated by CIRCT unknown git version
module ForceNameSubmodule();
endmodule

module ForceNameTop();
  ForceNameSubmodule Foo_0 ();
  ForceNameSubmodule Foo ();
  ForceNameSubmodule Foo_1 ();
endmodule
```","firrtl.circuit ""ForceNameTop"" {
  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]
  firrtl.hierpath private @nla_2 [@ForceNameTop::@sym_bar, @ForceNameSubmodule]
  firrtl.module private @ForceNameSubmodule() attributes {annotations = [
    {circt.nonlocal = @nla_1,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Foo""},
    {circt.nonlocal = @nla_2,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Foo""}
  ]} {}
  firrtl.module @ForceNameTop() {
    firrtl.instance Foo @ForceNameSubmodule()
    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()
    firrtl.instance bar sym @sym_bar @ForceNameSubmodule()
  }
}","module {
  hw.module private @ForceNameSubmodule() {
    hw.output
  }
  hw.module @ForceNameTop() {
    hw.instance ""Foo"" @ForceNameSubmodule() -> ()
    hw.instance ""foo"" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = ""Foo""}
    hw.instance ""bar"" sym @sym_bar @ForceNameSubmodule() -> () {hw.verilogName = ""Foo""}
    hw.output
  }
}","// Generated by CIRCT unknown git version
module ForceNameSubmodule();
endmodule

module ForceNameTop();
  ForceNameSubmodule Foo_0 ();
  ForceNameSubmodule Foo ();
  ForceNameSubmodule Foo_1 ();
endmodule",,,,,,,
4097,[FIRRTL][SV] Grand Central w/ Extract Test Code Can Create Bind-under-bind,2022-10-13T21:36:28Z,open,"bug, FIRRTL","Nested binds are pedantically illegal SystemVerilog even though some tools support them. I have a situation where the combination of instantiating a module inside a Grand Central View that has assertions can result in extraction which produces a bind-under-bind.

Consider the following FIRRTL text and annotation file:

```
circuit Top :
  extmodule DataTap_2 :
    output _2 : UInt<1>
    output _1 : UInt<1>
    output _0 : Clock
    defname = DataTap_2

  module Wrapper :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>

    node _T = asUInt(reset)
    node _T_1 = eq(_T, UInt<1>(""h0""))
    when _T_1 :
      node _T_2 = eq(in, UInt<1>(""h0""))
      when _T_2 :
        printf(clock, UInt<1>(""h1""), ""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"") : printf
      assert(clock, in, UInt<1>(""h1""), """") : assert


  module MyView_companion :

    wire _WIRE : UInt<1>
    _WIRE <= UInt<1>(""h0"")
    wire clk : Clock
    wire rst : UInt<1>
    wire cond : UInt<1>
    inst DataTap_2 of DataTap_2
    DataTap_2._0 is invalid
    DataTap_2._1 is invalid
    DataTap_2._2 is invalid
    clk <= DataTap_2._0
    rst <= DataTap_2._1
    cond <= DataTap_2._2
    inst wrapper of Wrapper
    wrapper.clock <= clk
    wrapper.reset <= rst
    wrapper.in <= cond

  module DUT :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>

    wire w : UInt<1>
    w <= in
    inst MyView_companion of MyView_companion

  module Top :
    input clock : Clock
    input reset : UInt<1>
    input in : UInt<1>

    inst dut of DUT
    dut.clock <= clock
    dut.reset <= reset
    dut.in <= in
```

```json
[
  {
    ""class"":""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"":""~Top|DataTap_2"",
    ""keys"":[
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>clock"",
        ""portName"":""~Top|DataTap_2>_0""
      },
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>reset"",
        ""portName"":""~Top|DataTap_2>_1""
      },
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>w"",
        ""portName"":""~Top|DataTap_2>_2""
      }
    ]
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"":""MyView"",
    ""companion"":""~Top|MyView_companion"",
    ""parent"":""~Top|DUT"",
    ""view"":""{\""class\"":\""sifive.enterprise.grandcentral.AugmentedBundleType\"",\""defName\"":\""MyInterface\"",\""elements\"":[{\""name\"":\""ground\"",\""description\"":\""a ground type port\"",\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.AugmentedGroundType\"",\""ref\"":{\""circuit\"":\""Top\"",\""module\"":\""Top\"",\""path\"":[{\""_1\"":{\""class\"":\""firrtl.annotations.TargetToken$Instance\"",\""value\"":\""dut\""},\""_2\"":{\""class\"":\""firrtl.annotations.TargetToken$OfModule\"",\""value\"":\""DUT\""}}],\""ref\"":\""w\"",\""component\"":[]},\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\""}}}]}""
  },
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""Top.DUT""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""gct"",
    ""filename"":""bindings.sv""
  }
]
```

Compiling this with `firtool Top.fir -annotation-file Top.anno.json -extract-test-code` produces the illegal:

```
// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

// VCS coverage exclude_file
module Wrapper_assert(
  input in,
        reset,
        clock);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & ~in) begin
        if (`ASSERT_VERBOSE_COND_)
          $error(""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule

module DUT(
  input clock,
        reset,
        in);

  wire w = in;
  /* This instance is elsewhere emitted as a bind statement.
    MyView_companion MyView_companion ();
  */
endmodule

module Top(
  input clock,
        reset,
        in);

  DUT dut (
    .clock (clock),
    .reset (reset),
    .in    (in)
  );
endmodule


// ----- 8< ----- FILE ""gct/DataTap_2_impl_0.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// VCS coverage exclude_file
module DataTap_2_impl_0(
  output _2,
         _1,
         _0);

  assign _2 = DUT.w;
  assign _1 = DUT.reset;
  assign _0 = DUT.clock;
endmodule


// ----- 8< ----- FILE ""gct/MyView_companion.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

// VCS coverage exclude_file
module MyView_companion();
  wire _DataTap_2__2;
  wire _DataTap_2__1;
  wire _DataTap_2__0;
  MyInterface MyView();
  `ifndef SYNTHESIS
    always @(posedge _DataTap_2__0) begin
      if (~_DataTap_2__1 & ~_DataTap_2__2) begin
        if (`ASSERT_VERBOSE_COND_)
          $error(""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
  assign MyView.ground = DUT.w;
  DataTap_2_impl_0 DataTap_2 (
    ._2 (_DataTap_2__2),
    ._1 (_DataTap_2__1),
    ._0 (_DataTap_2__0)
  );
  /* This instance is elsewhere emitted as a bind statement.
    Wrapper_assert Wrapper_assert (
      .in    (_DataTap_2__2),
      .reset (_DataTap_2__1),
      .clock (_DataTap_2__0)
    );
  */
endmodule


// ----- 8< ----- FILE ""bindings.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
bind DUT MyView_companion MyView_companion ();

// ----- 8< ----- FILE ""gct/MyInterface.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// VCS coverage exclude_file
interface MyInterface;
  // a ground type port
  logic ground;
endinterface


// ----- 8< ----- FILE ""bindfile"" ----- 8< -----

// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

bind MyView_companion Wrapper_assert Wrapper_assert (
  .in    (_DataTap_2__2),
  .reset (_DataTap_2__1),
  .clock (_DataTap_2__0)
);
```

Notice that `MyView_companion` is bound into `DUT` and `Wrapper_assert` is bound into `MyView_companion`. Verilator happily accepts this, so I don't have a nice script to lint that this doesn't happen.","circuit Top :
  extmodule DataTap_2 :
    output _2 : UInt<1>
    output _1 : UInt<1>
    output _0 : Clock
    defname = DataTap_2

  module Wrapper :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>

    node _T = asUInt(reset)
    node _T_1 = eq(_T, UInt<1>(""h0""))
    when _T_1 :
      node _T_2 = eq(in, UInt<1>(""h0""))
      when _T_2 :
        printf(clock, UInt<1>(""h1""), ""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"") : printf
      assert(clock, in, UInt<1>(""h1""), """") : assert


  module MyView_companion :

    wire _WIRE : UInt<1>
    _WIRE <= UInt<1>(""h0"")
    wire clk : Clock
    wire rst : UInt<1>
    wire cond : UInt<1>
    inst DataTap_2 of DataTap_2
    DataTap_2._0 is invalid
    DataTap_2._1 is invalid
    DataTap_2._2 is invalid
    clk <= DataTap_2._0
    rst <= DataTap_2._1
    cond <= DataTap_2._2
    inst wrapper of Wrapper
    wrapper.clock <= clk
    wrapper.reset <= rst
    wrapper.in <= cond

  module DUT :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>

    wire w : UInt<1>
    w <= in
    inst MyView_companion of MyView_companion

  module Top :
    input clock : Clock
    input reset : UInt<1>
    input in : UInt<1>

    inst dut of DUT
    dut.clock <= clock
    dut.reset <= reset
    dut.in <= in","[
  {
    ""class"":""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"":""~Top|DataTap_2"",
    ""keys"":[
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>clock"",
        ""portName"":""~Top|DataTap_2>_0""
      },
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>reset"",
        ""portName"":""~Top|DataTap_2>_1""
      },
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>w"",
        ""portName"":""~Top|DataTap_2>_2""
      }
    ]
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"":""MyView"",
    ""companion"":""~Top|MyView_companion"",
    ""parent"":""~Top|DUT"",
    ""view"":""{\""class\"":\""sifive.enterprise.grandcentral.AugmentedBundleType\"",\""defName\"":\""MyInterface\"",\""elements\"":[{\""name\"":\""ground\"",\""description\"":\""a ground type port\"",\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.AugmentedGroundType\"",\""ref\"":{\""circuit\"":\""Top\"",\""module\"":\""Top\"",\""path\"":[{\""_1\"":{\""class\"":\""firrtl.annotations.TargetToken$Instance\"",\""value\"":\""dut\""},\""_2\"":{\""class\"":\""firrtl.annotations.TargetToken$OfModule\"",\""value\"":\""DUT\""}}],\""ref\"":\""w\"",\""component\"":[]},\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\""}}}]}""
  },
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""Top.DUT""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""gct"",
    ""filename"":""bindings.sv""
  }
]","// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

// VCS coverage exclude_file
module Wrapper_assert(
  input in,
        reset,
        clock);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & ~in) begin
        if (`ASSERT_VERBOSE_COND_)
          $error(""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule

module DUT(
  input clock,
        reset,
        in);

  wire w = in;
  /* This instance is elsewhere emitted as a bind statement.
    MyView_companion MyView_companion ();
  */
endmodule

module Top(
  input clock,
        reset,
        in);

  DUT dut (
    .clock (clock),
    .reset (reset),
    .in    (in)
  );
endmodule


// ----- 8< ----- FILE ""gct/DataTap_2_impl_0.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// VCS coverage exclude_file
module DataTap_2_impl_0(
  output _2,
         _1,
         _0);

  assign _2 = DUT.w;
  assign _1 = DUT.reset;
  assign _0 = DUT.clock;
endmodule


// ----- 8< ----- FILE ""gct/MyView_companion.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

// VCS coverage exclude_file
module MyView_companion();
  wire _DataTap_2__2;
  wire _DataTap_2__1;
  wire _DataTap_2__0;
  MyInterface MyView();
  `ifndef SYNTHESIS
    always @(posedge _DataTap_2__0) begin
      if (~_DataTap_2__1 & ~_DataTap_2__2) begin
        if (`ASSERT_VERBOSE_COND_)
          $error(""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
  assign MyView.ground = DUT.w;
  DataTap_2_impl_0 DataTap_2 (
    ._2 (_DataTap_2__2),
    ._1 (_DataTap_2__1),
    ._0 (_DataTap_2__0)
  );
  /* This instance is elsewhere emitted as a bind statement.
    Wrapper_assert Wrapper_assert (
      .in    (_DataTap_2__2),
      .reset (_DataTap_2__1),
      .clock (_DataTap_2__0)
    );
  */
endmodule


// ----- 8< ----- FILE ""bindings.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
bind DUT MyView_companion MyView_companion ();

// ----- 8< ----- FILE ""gct/MyInterface.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// VCS coverage exclude_file
interface MyInterface;
  // a ground type port
  logic ground;
endinterface


// ----- 8< ----- FILE ""bindfile"" ----- 8< -----

// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

bind MyView_companion Wrapper_assert Wrapper_assert (
  .in    (_DataTap_2__2),
  .reset (_DataTap_2__1),
  .clock (_DataTap_2__0)
);",,,,,,,
3810,[SystemC] SCModuleOp::getPortsOfDirection(direction) only returns first occurence,2022-09-02T14:36:30Z,open,"bug, SystemC","Above mentioned member function seems to only return the first port of the given direction for some reason.
There is no regression test with more than one output port, thus at least one should be added.
Observed in the `hw.output` lowering in HWToSystemC at 9384dccab8692086c21a4166c5e5181623695d91",,,,,,,,,,
3768,[HW] Enum aliasing in SV output,2022-08-24T09:25:15Z,open,"bug, HW","Currently, different enums with identical field names:
```mlir
  hw.type_scope @fsm_enum_typedecls {
    hw.typedecl @M2_state_t : !hw.enum<A, B>
    hw.typedecl @M1_state_t : !hw.enum<A, B>
  }
```

Will export as:
```sv
typedef enum {A, B} M2_state_t;
typedef enum {A, B} M1_state_t;
```
wherein enum values alias.

Enum values should be emitted with additional pre/suffixing of the enum type name to avoid this, e.g.:
```sv
typedef enum {M2_state_A, M2_state_B} M2_state_t;
typedef enum {M1_state_A, M1_state_B} M1_state_t;
```","hw.type_scope @fsm_enum_typedecls {
    hw.typedecl @M2_state_t : !hw.enum<A, B>
    hw.typedecl @M1_state_t : !hw.enum<A, B>
  }","typedef enum {A, B} M2_state_t;
typedef enum {A, B} M1_state_t;","typedef enum {M2_state_A, M2_state_B} M2_state_t;
typedef enum {M1_state_A, M1_state_B} M1_state_t;",,,,,,,
3494,[FIRRTL] GCT Views and Dedup,2022-07-08T23:19:29Z,open,"bug, FIRRTL","Grand Central (GCT) Views do not currently work when combined with FIRRTL's deduplication pass. Consider the following circuit and annotation file. `Top` instantiates `Foo` and `Foo_1`. Each of those, respectively, instantiate `Bar` and `Bar_1`. Each `Foo*` has a view of something inside each `Bar*`:

```scala
circuit Top :
  module Bar :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  module MyView_companion :

    skip

  module Foo :
    input clock : Clock
    input reset : Reset

    inst bar of Bar
    bar.clock <= clock
    bar.reset <= reset
    inst MyView_companion of MyView_companion

  module Bar_1 :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  module MyView_companion_0 :

    skip

  module Foo_1 :
    input clock : Clock
    input reset : Reset

    inst bar of Bar_1
    bar.clock <= clock
    bar.reset <= reset
    inst MyView_companion_0 of MyView_companion_0

  module Top :
    input clock : Clock
    input reset : UInt<1>

    inst foo1 of Foo
    foo1.clock <= clock
    foo1.reset <= reset
    inst foo2 of Foo_1
    foo2.clock <= clock
    foo2.reset <= reset
```

```json
[
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~Top|MyView_companion"",
    ""parent"": ""~Top|Foo"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""w"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""Top"",
              ""module"": ""Top"",
              ""path"": [
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""foo1""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Foo""
                  }
                },
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""bar""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Bar""
                  }
                }
              ],
              ""ref"": ""w"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~Top|MyView_companion_0"",
    ""parent"": ""~Top|Foo_1"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""w"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""Top"",
              ""module"": ""Top"",
              ""path"": [
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""foo2""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Foo_1""
                  }
                },
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""bar""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Bar_1""
                  }
                }
              ],
              ""ref"": ""w"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  }
]
```

If you run this with `firtool Foo.fir -annotation-file Foo.anno.json -dedup -firrtl-grand-central` you get an expected error. The GCT Views pass is asserting that the `NoDedupAnnotation` behavior exists:

```
firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once
  module Foo :
         ^
firrtl/Top.fir:13:10: note: see current operation: ""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):
  %0:2 = ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@bar"">, moduleName = @Bar, name = ""bar"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""]} : () -> (!firrtl.clock, !firrtl.uint<1>)
  ""firrtl.strictconnect""(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()
  ""firrtl.strictconnect""(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@MyView_companion"">, moduleName = @MyView_companion, name = ""MyView_companion"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()
}) {annotations = [{circt.nonlocal = @nla_3, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 2 : i64, name = ""MyView"", type = ""parent""}, {circt.nonlocal = @nla_4, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 0 : i64, name = ""MyView"", type = ""parent""}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""], portSyms = ["""", """"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = ""Foo"", sym_visibility = ""private""} : () -> ()
firrtl/Top.fir:49:5: note: parent is instantiated here
    inst foo2 of Foo_1
    ^
firrtl/Top.fir:46:5: note: parent is instantiated here
    inst foo1 of Foo
    ^
firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once
  module Foo :
         ^
firrtl/Top.fir:13:10: note: see current operation: ""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):
  %0:2 = ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@bar"">, moduleName = @Bar, name = ""bar"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""]} : () -> (!firrtl.clock, !firrtl.uint<1>)
  ""firrtl.strictconnect""(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()
  ""firrtl.strictconnect""(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@MyView_companion"">, moduleName = @MyView_companion, name = ""MyView_companion"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()
}) {annotations = [{circt.nonlocal = @nla_3, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 2 : i64, name = ""MyView"", type = ""parent""}, {circt.nonlocal = @nla_4, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 0 : i64, name = ""MyView"", type = ""parent""}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""], portSyms = ["""", """"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = ""Foo"", sym_visibility = ""private""} : () -> ()
firrtl/Top.fir:49:5: note: parent is instantiated here
    inst foo2 of Foo_1
    ^
firrtl/Top.fir:46:5: note: parent is instantiated here
    inst foo1 of Foo
    ^
firrtl/Top.fir:1:1: error: 'firrtl.circuit' op contains a 'companion' with id '2', but does not contain a GrandCentral 'parent' with the same id
circuit Top :
^
```

If you run this without dedup (or with a `NoDedupAnnotation`) everything expectedly works. The fundamental problem is that GCT Views are encoding an XMR using annotations. After Dedup runs, it rightly keeps both of these annotations around. However, now you have a multiply instantiated parent module that is supposed to describe _two_ XMRs. However, these XMRs ""deduplicate"" to a single XMR.

There are multiple approaches to fix this:

1. Modify the GCT Views pass to recognize this pattern and generate a ""minimal"" XMR that combines all the deduplicated XMRs.
2. Special case certain annotations in dedup to also deduplicate.
3. Change `LowerAnnotations` to represent XMRs as ""fake ports"" in the design rooted at the lowest-common ancestor necessary to make the connection. Then dedup works correctly.

(1) is janky, but expedient. (2) is extremely janky. (3) is the only reasonable solution here.","circuit Top :
  module Bar :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  module MyView_companion :

    skip

  module Foo :
    input clock : Clock
    input reset : Reset

    inst bar of Bar
    bar.clock <= clock
    bar.reset <= reset
    inst MyView_companion of MyView_companion

  module Bar_1 :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  module MyView_companion_0 :

    skip

  module Foo_1 :
    input clock : Clock
    input reset : Reset

    inst bar of Bar_1
    bar.clock <= clock
    bar.reset <= reset
    inst MyView_companion_0 of MyView_companion_0

  module Top :
    input clock : Clock
    input reset : UInt<1>

    inst foo1 of Foo
    foo1.clock <= clock
    foo1.reset <= reset
    inst foo2 of Foo_1
    foo2.clock <= clock
    foo2.reset <= reset","[
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~Top|MyView_companion"",
    ""parent"": ""~Top|Foo"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""w"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""Top"",
              ""module"": ""Top"",
              ""path"": [
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""foo1""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Foo""
                  }
                },
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""bar""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Bar""
                  }
                }
              ],
              ""ref"": ""w"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~Top|MyView_companion_0"",
    ""parent"": ""~Top|Foo_1"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""w"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""Top"",
              ""module"": ""Top"",
              ""path"": [
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""foo2""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Foo_1""
                  }
                },
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""bar""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Bar_1""
                  }
                }
              ],
              ""ref"": ""w"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  }
]","firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once
  module Foo :
         ^
firrtl/Top.fir:13:10: note: see current operation: ""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):
  %0:2 = ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@bar"">, moduleName = @Bar, name = ""bar"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""]} : () -> (!firrtl.clock, !firrtl.uint<1>)
  ""firrtl.strictconnect""(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()
  ""firrtl.strictconnect""(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@MyView_companion"">, moduleName = @MyView_companion, name = ""MyView_companion"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()
}) {annotations = [{circt.nonlocal = @nla_3, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 2 : i64, name = ""MyView"", type = ""parent""}, {circt.nonlocal = @nla_4, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 0 : i64, name = ""MyView"", type = ""parent""}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""], portSyms = ["""", """"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = ""Foo"", sym_visibility = ""private""} : () -> ()
firrtl/Top.fir:49:5: note: parent is instantiated here
    inst foo2 of Foo_1
    ^
firrtl/Top.fir:46:5: note: parent is instantiated here
    inst foo1 of Foo
    ^
firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once
  module Foo :
         ^
firrtl/Top.fir:13:10: note: see current operation: ""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):
  %0:2 = ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@bar"">, moduleName = @Bar, name = ""bar"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""]} : () -> (!firrtl.clock, !firrtl.uint<1>)
  ""firrtl.strictconnect""(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()
  ""firrtl.strictconnect""(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@MyView_companion"">, moduleName = @MyView_companion, name = ""MyView_companion"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()
}) {annotations = [{circt.nonlocal = @nla_3, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 2 : i64, name = ""MyView"", type = ""parent""}, {circt.nonlocal = @nla_4, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 0 : i64, name = ""MyView"", type = ""parent""}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""], portSyms = ["""", """"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = ""Foo"", sym_visibility = ""private""} : () -> ()
firrtl/Top.fir:49:5: note: parent is instantiated here
    inst foo2 of Foo_1
    ^
firrtl/Top.fir:46:5: note: parent is instantiated here
    inst foo1 of Foo
    ^
firrtl/Top.fir:1:1: error: 'firrtl.circuit' op contains a 'companion' with id '2', but does not contain a GrandCentral 'parent' with the same id
circuit Top :
^",,,,,,,
3454,[ExportVerilog] Initial statement needs begin/end for single declaration,2022-06-30T11:00:07Z,open,"bug, ExportVerilog","Input:
```mlir
hw.module private @Foo() -> (){
    sv.initial {
      %param_x = sv.localparam : i42 { value = 11: i42 }
    }
}
```
`$ circt-opt -export-verilog` produces:
```verilog
module Foo();
  initial     
    localparam [41:0] param_x = 42'd11; 

endmodule
```

At least Verilator and Yosys produce a syntax error. When I added ""begin"" and ""end"" around initial statement, it parses.  
```verilog
  initial begin 
    localparam [41:0] param_x = 42'd11;
  end
```","hw.module private @Foo() -> (){
    sv.initial {
      %param_x = sv.localparam : i42 { value = 11: i42 }
    }
}","module Foo();
  initial     
    localparam [41:0] param_x = 42'd11; 

endmodule","initial begin 
    localparam [41:0] param_x = 42'd11;
  end",,,,,,,
3268,[StandardToHandshake] Passing `memref` to a function will still use `memref.alloc` ,2022-06-03T11:12:50Z,open,"bug, Handshake","Passing the following code to `--lower-std-to-handshake` produces a weird output.

```mlir
func.func @external_mem(%mem : memref<4xi32>) {
  return
}

func.func @normal_mem() {
  %mem = memref.alloc() : memref<4xi32>
  func.call @external_mem(%mem) : (memref<4xi32>) -> ()
  return
}
```

Output:

```mlir
handshake.func @external_mem(%arg0: memref<4xi32>, %arg1: none, ...) -> none attributes {argNames = [""in0"", ""inCtrl""], resNames = [""outCtrl""]} {
  extmemory[ld = 0, st = 0] (%arg0 : memref<4xi32>) () {id = 0 : i32} : () -> ()
  return %arg1 : none
 }
handshake.func @normal_mem(%arg0: none, ...) -> none attributes {argNames = [""inCtrl""], resNames = [""outCtrl""]} {
  %0:2 = fork [2] %arg0 : none
  %1 = memref.alloc() : memref<4xi32>
  %2 = instance @external_mem(%1, %0#0) : (memref<4xi32>, none) -> none
  sink %2 : none
  return %0#1 : none
}
```

As you can see, a `memref.alloc()` remains, which is not expected and thus breaks further transformations. 

I would expect that a correct lowering would construct a `MemoryOp` in the `@normal_mem` function. How this exactly interacts with the external memory op is not clear to me, as this will cause cross function dependencies depending on the amount of memory operations in `@external_mem`.","func.func @external_mem(%mem : memref<4xi32>) {
  return
}

func.func @normal_mem() {
  %mem = memref.alloc() : memref<4xi32>
  func.call @external_mem(%mem) : (memref<4xi32>) -> ()
  return
}","handshake.func @external_mem(%arg0: memref<4xi32>, %arg1: none, ...) -> none attributes {argNames = [""in0"", ""inCtrl""], resNames = [""outCtrl""]} {
  extmemory[ld = 0, st = 0] (%arg0 : memref<4xi32>) () {id = 0 : i32} : () -> ()
  return %arg1 : none
 }
handshake.func @normal_mem(%arg0: none, ...) -> none attributes {argNames = [""inCtrl""], resNames = [""outCtrl""]} {
  %0:2 = fork [2] %arg0 : none
  %1 = memref.alloc() : memref<4xi32>
  %2 = instance @external_mem(%1, %0#0) : (memref<4xi32>, none) -> none
  sink %2 : none
  return %0#1 : none
}",,,,,,,,
3240,[FIRRTL] Grand Central Views/Taps Should Not Block Deduplication,2022-05-29T05:27:10Z,open,"bug, FIRRTL","The dead wire taps added to GCT Views and Data Taps are causing problems with deduplication. Specifically, the dead wire taps can block deduplication because they are IR operations. A GCT view or tap should not block deduplication.

## Example

Consider the following circuit.  In this, there are two submodules and _only one_ is tapped via a Grand Central View on wire `_w`:

```scala
circuit Top :
  module Submodule :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>
    output out : UInt<1>

    wire _w : UInt<1> 
    _w <= in 
    out <= _w 

  module Submodule_1 :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>
    output out : UInt<1>

    wire _w : UInt<1> 
    _w <= in 
    out <= _w 

  module MyView_companion :

    wire _WIRE : UInt<1>
    _WIRE <= UInt<1>(""h0"")

  module Top :
    input clock : Clock
    input reset : UInt<1>
    input in : UInt<1>
    output out : UInt<1>

    inst sub1 of Submodule 
    sub1.clock <= clock
    sub1.reset <= reset
    inst sub2 of Submodule_1 
    sub2.clock <= clock
    sub2.reset <= reset
    sub1.in <= in 
    sub2.in <= in 
    node _out_T = xor(sub1.out, sub2.out) 
    out <= _out_T 
    inst MyView_companion of MyView_companion 
```

The corresponding annotation file is:
```json
[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|MyView_companion>_WIRE""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"":""MyView"",
    ""companion"":""~Top|MyView_companion"",
    ""parent"":""~Top|Top"",
    ""view"":""{\""class\"":\""sifive.enterprise.grandcentral.AugmentedBundleType\"",\""defName\"":\""MyInterface\"",\""elements\"":[{\""name\"":\""tap1\"",\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.AugmentedGroundType\"",\""ref\"":{\""circuit\"":\""Top\"",\""module\"":\""Top\"",\""path\"":[{\""_1\"":{\""class\"":\""firrtl.annotations.TargetToken$Instance\"",\""value\"":\""sub1\""},\""_2\"":{\""class\"":\""firrtl.annotations.TargetToken$OfModule\"",\""value\"":\""Submodule\""}}],\""ref\"":\""_w\"",\""component\"":[]},\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\""}}}]}""
  },
  {
    ""class"":""firrtl.transforms.NoDedupAnnotation"",
    ""target"":""~Top|MyView_companion""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""builds/gct-tests/DedupOneTap/firrtl/gct"",
    ""filename"":""builds/gct-tests/DedupOneTap/firrtl/bindings.sv""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation"",
    ""filename"":""builds/gct-tests/DedupOneTap/firrtl/gct/gct.yaml""
  },
  {
    ""class"":""firrtl.stage.RunFirrtlTransformAnnotation"",
    ""transform"":""sifive.enterprise.grandcentral.GrandCentralTransform""
  },
  {
    ""class"":""firrtl.stage.RunFirrtlTransformAnnotation"",
    ""transform"":""sifive.enterprise.firrtl.ExtractTestCodeTransform""
  }
]
```

When compiled, this currently produces two copies of the submodule due to the `_gctTap` which causes them to differ.

The output Verilog currently is:

```verilog
module Submodule(
  input  in,
  output out);

  wire _gctTap;

  assign _gctTap = in;
  assign out = in;
endmodule

module Submodule_1(
  input  in,
  output out);

  assign out = in;
endmodule

module Top(
  input  clock,
         reset,
         in,
  output out);

  wire _sub2_out;
  wire _sub1_out;

  // This interface is elsewhere emitted as a bind statement.
  // MyInterface MyView();
  Submodule sub1 (
    .in  (in),
    .out (_sub1_out)
  );
  Submodule_1 sub2 (
    .in  (in),
    .out (_sub2_out)
  );
  /* This instance is elsewhere emitted as a bind statement.
    MyView_companion MyView_companion ();
  */
  assign out = _sub1_out ^ _sub2_out;
endmodule
```","circuit Top :
  module Submodule :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>
    output out : UInt<1>

    wire _w : UInt<1> 
    _w <= in 
    out <= _w 

  module Submodule_1 :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>
    output out : UInt<1>

    wire _w : UInt<1> 
    _w <= in 
    out <= _w 

  module MyView_companion :

    wire _WIRE : UInt<1>
    _WIRE <= UInt<1>(""h0"")

  module Top :
    input clock : Clock
    input reset : UInt<1>
    input in : UInt<1>
    output out : UInt<1>

    inst sub1 of Submodule 
    sub1.clock <= clock
    sub1.reset <= reset
    inst sub2 of Submodule_1 
    sub2.clock <= clock
    sub2.reset <= reset
    sub1.in <= in 
    sub2.in <= in 
    node _out_T = xor(sub1.out, sub2.out) 
    out <= _out_T 
    inst MyView_companion of MyView_companion","[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|MyView_companion>_WIRE""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"":""MyView"",
    ""companion"":""~Top|MyView_companion"",
    ""parent"":""~Top|Top"",
    ""view"":""{\""class\"":\""sifive.enterprise.grandcentral.AugmentedBundleType\"",\""defName\"":\""MyInterface\"",\""elements\"":[{\""name\"":\""tap1\"",\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.AugmentedGroundType\"",\""ref\"":{\""circuit\"":\""Top\"",\""module\"":\""Top\"",\""path\"":[{\""_1\"":{\""class\"":\""firrtl.annotations.TargetToken$Instance\"",\""value\"":\""sub1\""},\""_2\"":{\""class\"":\""firrtl.annotations.TargetToken$OfModule\"",\""value\"":\""Submodule\""}}],\""ref\"":\""_w\"",\""component\"":[]},\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\""}}}]}""
  },
  {
    ""class"":""firrtl.transforms.NoDedupAnnotation"",
    ""target"":""~Top|MyView_companion""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""builds/gct-tests/DedupOneTap/firrtl/gct"",
    ""filename"":""builds/gct-tests/DedupOneTap/firrtl/bindings.sv""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation"",
    ""filename"":""builds/gct-tests/DedupOneTap/firrtl/gct/gct.yaml""
  },
  {
    ""class"":""firrtl.stage.RunFirrtlTransformAnnotation"",
    ""transform"":""sifive.enterprise.grandcentral.GrandCentralTransform""
  },
  {
    ""class"":""firrtl.stage.RunFirrtlTransformAnnotation"",
    ""transform"":""sifive.enterprise.firrtl.ExtractTestCodeTransform""
  }
]","module Submodule(
  input  in,
  output out);

  wire _gctTap;

  assign _gctTap = in;
  assign out = in;
endmodule

module Submodule_1(
  input  in,
  output out);

  assign out = in;
endmodule

module Top(
  input  clock,
         reset,
         in,
  output out);

  wire _sub2_out;
  wire _sub1_out;

  // This interface is elsewhere emitted as a bind statement.
  // MyInterface MyView();
  Submodule sub1 (
    .in  (in),
    .out (_sub1_out)
  );
  Submodule_1 sub2 (
    .in  (in),
    .out (_sub2_out)
  );
  /* This instance is elsewhere emitted as a bind statement.
    MyView_companion MyView_companion ();
  */
  assign out = _sub1_out ^ _sub2_out;
endmodule",,,,,,,
3105,[FIRRTL] ExtractInstances wrapper module name is not prefixed,2022-05-11T14:49:40Z,open,"bug, FIRRTL","The optional wrapper modules that `ExtractInstances` can generate (e.g. through the `group` field in `ExtractSeqMemsFileAnnotation`) do not get prefixed by `PrefixModules`. See `test/Dialect/FIRRTL/SFCTests/ExtractSeqMems/Compose.fir` for an example.

Doing the prefixing is not that simple, since ideally we would want prefixing to run before extraction. But extraction creates `sv.verbatim` ops with symbol references to modules which prefixing will invalidate. Alternatively one could go the route of GrandCentral views which also runs after prefixing, but where prefixing updates the annotations relevant for GCT views to contain the prefix. This is challenging for extraction though, since instances to be extracted are not all explicitly annotated, and whether or not a prefix has to be added to the wrapper module also depends on whether the location of the wrapper module is inside the area of effect of a prefix annotation.

Ideally we would make `PrefixInstances` update symbols appropriately (#3104) and make `sv.verbatim` robust under hierarchy modification. That would disentangle the ordering requirements of the passes and we could run extraction before prefixing.",,,,,,,,,,
3104,[FIRRTL] PrefixModules does not update symbols in sv.verbatim ops,2022-05-11T14:42:23Z,open,"bug, FIRRTL","The `PrefixModules` pass does not update uses of the old module symbol names to the renamed version. Occurs if a pass runs before prefixing that already generates verbatim nodes refering to modules through symbol placeholders (as we commonly do in metadata emission).

Getting this right might actually be harder than it looks at first glance, especially if modules have to be duplicated to account for instance-specific prefixing.",,,,,,,,,,
3090,[FIRRTL] ExtractInstances duplicates NLAs without assigning new names,2022-05-10T14:52:23Z,open,"bug, FIRRTL","The following caveat is a problem: https://github.com/llvm/circt/blob/a9bdc67cf5bd9493b402c1ee18dca1f6c9766e28/lib/Dialect/FIRRTL/Transforms/ExtractInstances.cpp#L601-L620

In a nutshell: There are cases where `ExtractInstances` has to create multiple copies of an NLA during extraction, and currently it does not pick new names for those NLAs. Doing so is a bit cumbersome since the pass has to visit all instances along the NLA path and insert trackers for the newly-created NLAs there as well.

The case where this happens requires:
- An instance to be extracted that is nested somewhere within a multiply-instantiated module
- An NLA on that instance that is rooted at the multiply-instantiated module",,,,,,,,,,
3033,[FIRRTL] Dedup Should Work in Circuit Order,2022-05-03T22:37:08Z,open,"bug, FIRRTL","CIRCT deviates from the SFC because it is doing deduplication based on the instantiation order).  Instead, deduplication should use circuit order (declaration order).

Consider the following:

```scala
circuit Bar:
  module X:
    input a: UInt<1>
    output b: UInt<1>

    b <= not(a)
  module Y:
    input a: UInt<1>
    output b: UInt<1>

    b <= not(a)
  module Bar:
    input a: UInt<1>
    output b: UInt<1>

    inst y of Y
    inst x of X

    x.a <= a
    y.a <= a
    b <= xor(x.b, y.b)
```

This circuit, `Bar`, instantiates two modules that will deduplicate, `X` and `Y`. Module `Y` is instantiated before module `X`. However, `Y` should deduplicate into `X` because `X` is declared first.

Currently CIRCT produces (`firtool Bar.fir -dedup -strip-debug-info`):

```verilog
module Y(
  input  a,
  output b);

  assign b = ~a;
endmodule

module Bar(
  input  a,
  output b);

  wire _x_b;
  wire _y_b;

  Y y (
    .a (a),
    .b (_y_b)
  );
  Y x (
    .a (a),
    .b (_x_b)
  );
  assign b = _x_b ^ _y_b;
endmodule
```

SFC produces (`firrtl -i Bar.fir`):

```verilog
module X(
  input   a,
  output  b
);
  assign b = ~a;
endmodule
module Bar(
  input   a,
  output  b
);
  wire  y_a;
  wire  y_b;
  wire  x_a;
  wire  x_b;
  X y (
    .a(y_a),
    .b(y_b)
  );
  X x (
    .a(x_a),
    .b(x_b)
  );
  assign b = x_b ^ y_b;
  assign y_a = a;
  assign x_a = a;
endmodule
```","circuit Bar:
  module X:
    input a: UInt<1>
    output b: UInt<1>

    b <= not(a)
  module Y:
    input a: UInt<1>
    output b: UInt<1>

    b <= not(a)
  module Bar:
    input a: UInt<1>
    output b: UInt<1>

    inst y of Y
    inst x of X

    x.a <= a
    y.a <= a
    b <= xor(x.b, y.b)","module Y(
  input  a,
  output b);

  assign b = ~a;
endmodule

module Bar(
  input  a,
  output b);

  wire _x_b;
  wire _y_b;

  Y y (
    .a (a),
    .b (_y_b)
  );
  Y x (
    .a (a),
    .b (_x_b)
  );
  assign b = _x_b ^ _y_b;
endmodule","module X(
  input   a,
  output  b
);
  assign b = ~a;
endmodule
module Bar(
  input   a,
  output  b
);
  wire  y_a;
  wire  y_b;
  wire  x_a;
  wire  x_b;
  X y (
    .a(y_a),
    .b(y_b)
  );
  X x (
    .a(x_a),
    .b(x_b)
  );
  assign b = x_b ^ y_b;
  assign y_a = a;
  assign x_a = a;
endmodule",,,,,,,
2888,[FIRRTL] Don't Dedup Modules with Different NestedPrefixModulesAnnotation,2022-04-13T04:49:07Z,open,bug,"`NestedPrefixModulesAnnotation` with different prefixes should not deduplicate. This can be interpreted one of two ways, either of which should have the same effect:

1. `NestedPrefixModulesAnnotation` should block deduplication.
2. The `PrefixModules` pass should duplicate modules which have different prefixes.

SiFive's extensions to the SFC are implementing this using strategy (2).

An end-to-end test case that should work is the following:

```scala
circuit Foo: %[[
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""prefix"":""prefix1_"",
    ""inclusive"":true,
    ""target"":""~Foo|Bar""
  },
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""prefix"":""prefix2_"",
    ""inclusive"":true,
    ""target"":""~Foo|Baz""
  }
]]
  module Bar:
  module Baz:
  module Foo:
    inst bar of Bar
    inst baz of Baz
```

Currently, this produces (`firtool -dedup -strip-debug-info`):

```verilog
module prefix2_Bar();
endmodule

module Foo();
  prefix2_Bar bar ();
  prefix2_Bar baz ();
endmodule
```

This should produce:
```verilog
module prefix1_Bar();
endmodule

module prefix2_Baz();
endmodule

module Foo();
  prefix1_Bar bar ();
  prefix2_Baz baz ();
endmodule
```

There may also be an interaction here with memories where memories should not deduplicate if they have different prefixes.  This may be a little funky because it has interactions with the memory generator schema which may not respect prefixing.","circuit Foo: %[[
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""prefix"":""prefix1_"",
    ""inclusive"":true,
    ""target"":""~Foo|Bar""
  },
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""prefix"":""prefix2_"",
    ""inclusive"":true,
    ""target"":""~Foo|Baz""
  }
]]
  module Bar:
  module Baz:
  module Foo:
    inst bar of Bar
    inst baz of Baz","module prefix2_Bar();
endmodule

module Foo();
  prefix2_Bar bar ();
  prefix2_Bar baz ();
endmodule","module prefix1_Bar();
endmodule

module prefix2_Baz();
endmodule

module Foo();
  prefix1_Bar bar ();
  prefix2_Baz baz ();
endmodule",,,,,,,
2531,[FIRRTL] DontTouchAnnotation as Symbol and Deduplication,2022-01-27T21:03:37Z,open,"bug, FIRRTL","The modeling of `DontTouchAnnotation` as a symbol destroys some information that may be necessary for an SFC-exact implementation of deduplication.

Consider the following circuit. Modules `A` and `A_` are structurally equivalent and should deduplicate. `A` has a `DontTouchAnnotation` on a wire inside it. This is not supposed to block deduplication.

```scala
circuit Top : %[[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""Top.A.b""
  }
]]
  module Top :
    inst a1 of A
    inst a2 of A_
  module A :
    output x: UInt<1>
    wire b: UInt<1>
    b is invalid
    x <= b
  module A_ :
    output x: UInt<1>
    wire b: UInt<1>
    b is invalid
    x <= b
```

When we parse this in, this specific annotations becomes a symbol `@b`:

```mlir
module  {
  firrtl.circuit ""Top""   {
    firrtl.module @Top() {
      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
      %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)
    }
    firrtl.module @A(out %x: !firrtl.uint<1>) {
      %b = firrtl.wire sym @b  : !firrtl.uint<1>
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>
    }
    firrtl.module @A_(out %x: !firrtl.uint<1>) {
      %b = firrtl.wire  : !firrtl.uint<1>
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}
```

After deduplication, the circuit looks like with `@b` applied to the deduplicated wire. The effect of the annotation now applies to both wires:
```mlir
module  {
  firrtl.circuit ""Top""   {
    firrtl.module @Top() {
      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
      %a2_x = firrtl.instance a2  @A(out x: !firrtl.uint<1>)
    }
    firrtl.module @A(out %x: !firrtl.uint<1>) {
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      %b = firrtl.wire sym @b  : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}
```

In contrast, the SFC produces a non-local annotation targeting the original instance's wire:
```scala
circuit Top :
  module A :
    output x : UInt<1>

    wire b : UInt<1> @[dont-touch.scala 33:15]
    b is invalid @[dont-touch.scala 34:5]
    x <= b @[dont-touch.scala 36:5]

  module Top :

    inst a1 of A @[dont-touch.scala 47:18]
    inst a2 of A @[dont-touch.scala 48:18]
```
```json
[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top/a1:A>b""
  }
]
```

I don't have an opinion or evidence that this is problematic, yet. This is just reporting an SFC deviation.","circuit Top : %[[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""Top.A.b""
  }
]]
  module Top :
    inst a1 of A
    inst a2 of A_
  module A :
    output x: UInt<1>
    wire b: UInt<1>
    b is invalid
    x <= b
  module A_ :
    output x: UInt<1>
    wire b: UInt<1>
    b is invalid
    x <= b","module  {
  firrtl.circuit ""Top""   {
    firrtl.module @Top() {
      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
      %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)
    }
    firrtl.module @A(out %x: !firrtl.uint<1>) {
      %b = firrtl.wire sym @b  : !firrtl.uint<1>
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>
    }
    firrtl.module @A_(out %x: !firrtl.uint<1>) {
      %b = firrtl.wire  : !firrtl.uint<1>
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}","module  {
  firrtl.circuit ""Top""   {
    firrtl.module @Top() {
      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
      %a2_x = firrtl.instance a2  @A(out x: !firrtl.uint<1>)
    }
    firrtl.module @A(out %x: !firrtl.uint<1>) {
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      %b = firrtl.wire sym @b  : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}","circuit Top :
  module A :
    output x : UInt<1>

    wire b : UInt<1> @[dont-touch.scala 33:15]
    b is invalid @[dont-touch.scala 34:5]
    x <= b @[dont-touch.scala 36:5]

  module Top :

    inst a1 of A @[dont-touch.scala 47:18]
    inst a2 of A @[dont-touch.scala 48:18]","[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top/a1:A>b""
  }
]",,,,,
2516,[FIRRTL] (mem) mismatch,2022-01-25T05:27:32Z,open,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 6243
circuit top_mod :
  module top_mod :
    input clock0: Clock
    input raddr: UInt<10>
    input waddr: UInt<10>
    input wdata: UInt<20>
    output tmp54: UInt<20>
    mem tmp53:
      data-type => UInt<20>
      depth => 10
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp53.r0.clk <= clock0
    tmp53.r0.en <= UInt(0)
    tmp53.r0.addr <= waddr
    tmp53.w0.clk <= clock0
    tmp53.w0.en <= UInt(1)
    tmp53.w0.addr <= raddr
    tmp53.w0.data <= wdata
    tmp53.w0.mask <= UInt(1)
    tmp54 <= tmp53.r0.data
```

Compiled with firtool --lower-to-hw --infer-widths --imconstprop --lowering-options=disallowPackedArrays,emittedLineLength=8192 --mlir-timing --verilog -o=$VFILE2 produces this Verilog:

```verilog
module tmp53_ext(	// a_top_mod.fir:9:5
  input  [3:0]  R0_addr,
  input         R0_en, R0_clk,
  input  [3:0]  W0_addr,
  input         W0_en, W0_clk,
  input  [19:0] W0_data,
  input         W0_mask,
  output [19:0] R0_data);

  reg [19:0] Memory[0:9];

  wire _T = W0_en & W0_mask;
  always @(posedge W0_clk) begin
    if (_T)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 20'bx;	// a_top_mod.fir:9:5
endmodule

module top_mod(	// a_top_mod.fir:3:10
  input         clock0,
  input  [9:0]  raddr, waddr,
  input  [19:0] wdata,
  output [19:0] tmp54);

  tmp53_ext tmp53 (	// a_top_mod.fir:9:5
    .R0_addr (waddr[3:0]),	// a_top_mod.fir:19:19
    .R0_en   (1'h0),	// a_top_mod.fir:18:20
    .R0_clk  (clock0),
    .W0_addr (raddr[3:0]),	// a_top_mod.fir:22:19
    .W0_en   (1'h1),	// a_top_mod.fir:21:20
    .W0_clk  (clock0),
    .W0_data (wdata),
    .W0_mask (1'h1),	// a_top_mod.fir:21:20
    .R0_data (tmp54)
  );
endmodule
```

Compiled with firrtl-1.5-SNAPSHOT produces this Verilog:

```verilog
module top_mod(
  input         clock0,
  input  [9:0]  raddr,
  input  [9:0]  waddr,
  input  [19:0] wdata,
  output [19:0] tmp54
);
`ifdef RANDOMIZE_GARBAGE_ASSIGN
  reg [31:0] _RAND_1;
`endif // RANDOMIZE_GARBAGE_ASSIGN
`ifdef RANDOMIZE_MEM_INIT
  reg [31:0] _RAND_0;
`endif // RANDOMIZE_MEM_INIT
  reg [19:0] tmp53 [0:9];
  wire  tmp53_r0_en;
  wire [3:0] tmp53_r0_addr;
  wire [19:0] tmp53_r0_data;
  wire [19:0] tmp53_w0_data;
  wire [3:0] tmp53_w0_addr;
  wire  tmp53_w0_mask;
  wire  tmp53_w0_en;
  assign tmp53_r0_en = 1'h0;
  assign tmp53_r0_addr = waddr[3:0];
  `ifndef RANDOMIZE_GARBAGE_ASSIGN
  assign tmp53_r0_data = tmp53[tmp53_r0_addr];
  `else
  assign tmp53_r0_data = tmp53_r0_addr >= 4'ha ? _RAND_1[19:0] : tmp53[tmp53_r0_addr];
  `endif // RANDOMIZE_GARBAGE_ASSIGN
  assign tmp53_w0_data = wdata;
  assign tmp53_w0_addr = raddr[3:0];
  assign tmp53_w0_mask = 1'h1;
  assign tmp53_w0_en = 1'h1;
  assign tmp54 = tmp53_r0_data;
  always @(posedge clock0) begin
    if (tmp53_w0_en & tmp53_w0_mask) begin
      tmp53[tmp53_w0_addr] <= tmp53_w0_data;
    end
  end
// Register and memory initialization
`ifdef RANDOMIZE_GARBAGE_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_INVALID_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_REG_INIT
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_MEM_INIT
`define RANDOMIZE
`endif
`ifndef RANDOM
`define RANDOM $random
`endif
`ifdef RANDOMIZE_MEM_INIT
  integer initvar;
`endif
`ifndef SYNTHESIS
`ifdef FIRRTL_BEFORE_INITIAL
`FIRRTL_BEFORE_INITIAL
`endif
initial begin
  `ifdef RANDOMIZE
    `ifdef INIT_RANDOM
      `INIT_RANDOM
    `endif
    `ifndef VERILATOR
      `ifdef RANDOMIZE_DELAY
        #`RANDOMIZE_DELAY begin end
      `else
        #0.002 begin end
      `endif
    `endif
`ifdef RANDOMIZE_GARBAGE_ASSIGN
  _RAND_1 = {1{`RANDOM}};
`endif // RANDOMIZE_GARBAGE_ASSIGN
`ifdef RANDOMIZE_MEM_INIT
  _RAND_0 = {1{`RANDOM}};
  for (initvar = 0; initvar < 10; initvar = initvar+1)
    tmp53[initvar] = _RAND_0[19:0];
`endif // RANDOMIZE_MEM_INIT
  `endif // RANDOMIZE
end // initial
`ifdef FIRRTL_AFTER_INITIAL
`FIRRTL_AFTER_INITIAL
`endif
`endif // SYNTHESIS
endmodule
```
`Yosys 0.13+15 (git sha1 bc027b2ca, clang 13.0.0 -fPIC -Os)` reports formal mismatch:

```
ERROR: Found 20 unproven $equiv cells in 'equiv_status -assert'.
```
","; seed: 6243
circuit top_mod :
  module top_mod :
    input clock0: Clock
    input raddr: UInt<10>
    input waddr: UInt<10>
    input wdata: UInt<20>
    output tmp54: UInt<20>
    mem tmp53:
      data-type => UInt<20>
      depth => 10
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp53.r0.clk <= clock0
    tmp53.r0.en <= UInt(0)
    tmp53.r0.addr <= waddr
    tmp53.w0.clk <= clock0
    tmp53.w0.en <= UInt(1)
    tmp53.w0.addr <= raddr
    tmp53.w0.data <= wdata
    tmp53.w0.mask <= UInt(1)
    tmp54 <= tmp53.r0.data","module tmp53_ext(	// a_top_mod.fir:9:5
  input  [3:0]  R0_addr,
  input         R0_en, R0_clk,
  input  [3:0]  W0_addr,
  input         W0_en, W0_clk,
  input  [19:0] W0_data,
  input         W0_mask,
  output [19:0] R0_data);

  reg [19:0] Memory[0:9];

  wire _T = W0_en & W0_mask;
  always @(posedge W0_clk) begin
    if (_T)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 20'bx;	// a_top_mod.fir:9:5
endmodule

module top_mod(	// a_top_mod.fir:3:10
  input         clock0,
  input  [9:0]  raddr, waddr,
  input  [19:0] wdata,
  output [19:0] tmp54);

  tmp53_ext tmp53 (	// a_top_mod.fir:9:5
    .R0_addr (waddr[3:0]),	// a_top_mod.fir:19:19
    .R0_en   (1'h0),	// a_top_mod.fir:18:20
    .R0_clk  (clock0),
    .W0_addr (raddr[3:0]),	// a_top_mod.fir:22:19
    .W0_en   (1'h1),	// a_top_mod.fir:21:20
    .W0_clk  (clock0),
    .W0_data (wdata),
    .W0_mask (1'h1),	// a_top_mod.fir:21:20
    .R0_data (tmp54)
  );
endmodule","module top_mod(
  input         clock0,
  input  [9:0]  raddr,
  input  [9:0]  waddr,
  input  [19:0] wdata,
  output [19:0] tmp54
);
`ifdef RANDOMIZE_GARBAGE_ASSIGN
  reg [31:0] _RAND_1;
`endif // RANDOMIZE_GARBAGE_ASSIGN
`ifdef RANDOMIZE_MEM_INIT
  reg [31:0] _RAND_0;
`endif // RANDOMIZE_MEM_INIT
  reg [19:0] tmp53 [0:9];
  wire  tmp53_r0_en;
  wire [3:0] tmp53_r0_addr;
  wire [19:0] tmp53_r0_data;
  wire [19:0] tmp53_w0_data;
  wire [3:0] tmp53_w0_addr;
  wire  tmp53_w0_mask;
  wire  tmp53_w0_en;
  assign tmp53_r0_en = 1'h0;
  assign tmp53_r0_addr = waddr[3:0];
  `ifndef RANDOMIZE_GARBAGE_ASSIGN
  assign tmp53_r0_data = tmp53[tmp53_r0_addr];
  `else
  assign tmp53_r0_data = tmp53_r0_addr >= 4'ha ? _RAND_1[19:0] : tmp53[tmp53_r0_addr];
  `endif // RANDOMIZE_GARBAGE_ASSIGN
  assign tmp53_w0_data = wdata;
  assign tmp53_w0_addr = raddr[3:0];
  assign tmp53_w0_mask = 1'h1;
  assign tmp53_w0_en = 1'h1;
  assign tmp54 = tmp53_r0_data;
  always @(posedge clock0) begin
    if (tmp53_w0_en & tmp53_w0_mask) begin
      tmp53[tmp53_w0_addr] <= tmp53_w0_data;
    end
  end
// Register and memory initialization
`ifdef RANDOMIZE_GARBAGE_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_INVALID_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_REG_INIT
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_MEM_INIT
`define RANDOMIZE
`endif
`ifndef RANDOM
`define RANDOM $random
`endif
`ifdef RANDOMIZE_MEM_INIT
  integer initvar;
`endif
`ifndef SYNTHESIS
`ifdef FIRRTL_BEFORE_INITIAL
`FIRRTL_BEFORE_INITIAL
`endif
initial begin
  `ifdef RANDOMIZE
    `ifdef INIT_RANDOM
      `INIT_RANDOM
    `endif
    `ifndef VERILATOR
      `ifdef RANDOMIZE_DELAY
        #`RANDOMIZE_DELAY begin end
      `else
        #0.002 begin end
      `endif
    `endif
`ifdef RANDOMIZE_GARBAGE_ASSIGN
  _RAND_1 = {1{`RANDOM}};
`endif // RANDOMIZE_GARBAGE_ASSIGN
`ifdef RANDOMIZE_MEM_INIT
  _RAND_0 = {1{`RANDOM}};
  for (initvar = 0; initvar < 10; initvar = initvar+1)
    tmp53[initvar] = _RAND_0[19:0];
`endif // RANDOMIZE_MEM_INIT
  `endif // RANDOMIZE
end // initial
`ifdef FIRRTL_AFTER_INITIAL
`FIRRTL_AFTER_INITIAL
`endif
`endif // SYNTHESIS
endmodule",ERROR: Found 20 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
2504,[ExportVerilog] Incorrect verilog output for bitcast + zero width aggregate types,2022-01-23T22:10:34Z,open,"bug, ExportVerilog","We are emitting zero bit width array/struct as one bit element. This is problem when we use bitcast for them.

```mlir
hw.module @top(%source: i1) -> (b: !hw.struct<zero: !hw.array<1xi0>, c: i1>) {
    %cast = hw.bitcast %source: (i1) -> !hw.struct<zero: !hw.array<1xi0>, c: i1>
    hw.output %cast : !hw.struct<zero: !hw.array<1xi0>, c: i1>
 }
```

```sv
module top(	// out.mlir:2:3
  input                                                            source,
  output struct packed {logic [0:0]/*Zero Width*/ zero; logic c; } b);
 
  assign b = source;	// out.mlir:3:12, :4:5
endmodule
```
","hw.module @top(%source: i1) -> (b: !hw.struct<zero: !hw.array<1xi0>, c: i1>) {
    %cast = hw.bitcast %source: (i1) -> !hw.struct<zero: !hw.array<1xi0>, c: i1>
    hw.output %cast : !hw.struct<zero: !hw.array<1xi0>, c: i1>
 }","module top(	// out.mlir:2:3
  input                                                            source,
  output struct packed {logic [0:0]/*Zero Width*/ zero; logic c; } b);
 
  assign b = source;	// out.mlir:3:12, :4:5
endmodule",,,,,,,,
2298,[LowerToHW] Define Behavior for Multiple Circuits,2021-12-06T19:11:08Z,open,"bug, FIRRTL, HW","Currently, if you compile multiple FIRRTL circuits, only one of them gets lowered. We need to define a behavior here for how this should work and what the resulting HW representation is. Consider the following:

```mlir
module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
  firrtl.circuit ""Bar""   {
    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}
```

This produces, after `LowerToHW`:
```mlir
module  {
  firrtl.circuit ""Bar""   {
    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
  hw.module @Foo(%a: i1) -> (b: i1) {
    hw.output %a : i1
  }
}
```

If allowed to continue after this, eventually `ExportVerilog` will print an error because it doesn't know how to handle a `firrtl.circuit`.

I can think of two behaviors here:

1. This should produce a flat list of modules.
2. (Likely what we need) This should lower each to two lists of modules in a `hw.namespace`-guarded region.","module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
  firrtl.circuit ""Bar""   {
    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}","module  {
  firrtl.circuit ""Bar""   {
    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
  hw.module @Foo(%a: i1) -> (b: i1) {
    hw.output %a : i1
  }
}",,,,,,,,
2029,[FIRRTL] RemoveCHIRRTL Should Lower Unused Memories (or at least repsect DontTouch),2021-10-22T17:54:24Z,open,"bug, FIRRTL","If you have an unused behavior memory in FIRRTL, the SFC will lower this to a memory that has no ports. This is a candidate for later DCE, but won't be DCE'd if there is a don't touch annotation. 

In CIRCT, we are deleting behavioral memories which have no users, i.e., DCE'ing unused memories during RemoveCHIRRTL,  and not respecting a dont touch annotation that may exist.

I expect that this has no effect on ""sane"" designs and is consequently a low priority bug. For more info, I hit this when writing some test cases for Grand Central where I didn't want to hook up my memories. 😅 ",,,,,,,,,,
2026,[FIRRTL] BlackBoxMemory Pass Needs to Handle All Annotations,2021-10-22T04:43:51Z,open,"bug, FIRRTL","The `BlackBoxMemory` pass was updated to copy annotations from memories onto the blackboxed instance in f239be4cd23bb21a1a19854f5bdc325ddf953ec1. However, port annotations are currently being dropped.

Update this pass to copy over port annotations with the following strategy:
- An annotation on a memory port should be applied to all flattened ports associated with the original port
- An annotation on a specific field of a memory port should be copied to its respective flattened new port

Additionally, it may make more sense to copy annotations onto the external module as opposed to onto the instance (which is how f239be4cd23bb21a1a19854f5bdc325ddf953ec1) does it. One or the other should be entirely equivalent (from the perspective of preserving the information, though copying onto the module may be better).",,,,,,,,,,
1988,[Simulator] UB when using llhd.shr on signal,2021-10-13T10:26:15Z,open,"bug, LLHD, Simulator","The following code leads to UB in the output trace, although, the semantics are clearly defined. This is because of a bug in the `ShrOpConversion` pattern in the `LLHDToLLVM` pass, where there is a slice extract performed only on the `%basesig` value instead of a concatenation of hidden and base.

```mlir
llhd.entity @root () -> () {
  %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>

  %hidden = hw.constant 0xff : i8
  %base = hw.constant 0 : i8
  %amnt = hw.constant 4 : i3

  %resultsig = llhd.sig ""result"" %base : i8
  %basesig = llhd.sig ""base"" %base : i8
  %hiddensig = llhd.sig ""hidden"" %hidden : i8
  %shr = llhd.shr %basesig, %hiddensig, %amnt : (!llhd.sig<i8>, !llhd.sig<i8>, i3) -> !llhd.sig<i8>
  %prbshr = llhd.prb %shr : !llhd.sig<i8>
  llhd.drv %resultsig, %prbshr after %time : !llhd.sig<i8>
}
```

Expected output:
```
0ps 0d 0e  root/base  0x00
0ps 0d 0e  root/hidden  0xff
0ps 0d 0e  root/result  0x00
1000ps 0d 0e  root/result  0xf0         // UB here (also seen 0x70, 0x10, etc.)
Finished at 2000ps 0d 0e (3 cycles)
```","llhd.entity @root () -> () {
  %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>

  %hidden = hw.constant 0xff : i8
  %base = hw.constant 0 : i8
  %amnt = hw.constant 4 : i3

  %resultsig = llhd.sig ""result"" %base : i8
  %basesig = llhd.sig ""base"" %base : i8
  %hiddensig = llhd.sig ""hidden"" %hidden : i8
  %shr = llhd.shr %basesig, %hiddensig, %amnt : (!llhd.sig<i8>, !llhd.sig<i8>, i3) -> !llhd.sig<i8>
  %prbshr = llhd.prb %shr : !llhd.sig<i8>
  llhd.drv %resultsig, %prbshr after %time : !llhd.sig<i8>
}","0ps 0d 0e  root/base  0x00
0ps 0d 0e  root/hidden  0xff
0ps 0d 0e  root/result  0x00
1000ps 0d 0e  root/result  0xf0         // UB here (also seen 0x70, 0x10, etc.)
Finished at 2000ps 0d 0e (3 cycles)",,,,,,,,
1795,[Simulator] Crash when initializing `llhd.sig` with non-constant value,2021-09-15T12:19:24Z,open,"bug, LLHD","When trying to simulate a module such as the following, the simulator crashes without a meaningful error message or assertion (just telling you that a value not defined in this region is used or the reconcile conversion cast pass complaining that some op was already replaced). This is because in `LLHDToLLVM.cpp` the operations creating `%get` are recursively cloned into a init function created indirectly by the simulation engine, but it only considers `hw.array_create`, `hw.struct_create`, and operations without operands (stop condition of recursion).

It would be ideal to support any operation not just these three, or at least throw a meaningful error message for the user in `recursiveCloneInit`.
Also, wouldn't it be better to clone these operations in a separate function and let the LLVM inliner decide whether to inline it or not (because the operation chain might be a lot bigger than just a constant op, leading to a lot of duplicated code)?

```mlir
llhd.entity @root () -> () {
    %0 = hw.constant 0 : i8
    %index = hw.constant 1 : i1

    %array = hw.array_create %0, %0 : i8
    %get = hw.array_get %array[%index] : !hw.array<2xi8>

    %getsig = llhd.sig ""get"" %get : i8  // Using %0 instead of %get works just fine; %get leads to a crash

    %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>
    llhd.drv %getsig, %get after %time : !llhd.sig<i8>
}
```","llhd.entity @root () -> () {
    %0 = hw.constant 0 : i8
    %index = hw.constant 1 : i1

    %array = hw.array_create %0, %0 : i8
    %get = hw.array_get %array[%index] : !hw.array<2xi8>

    %getsig = llhd.sig ""get"" %get : i8  // Using %0 instead of %get works just fine; %get leads to a crash

    %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>
    llhd.drv %getsig, %get after %time : !llhd.sig<i8>
}",,,,,,,,,
1771,[FIRRTL] Lexing Issues With Deeply Nested Expressions?,2021-09-10T23:09:58Z,open,"bug, FIRRTL","Circuits with long lines and/or deeply nested expressions seem to crash the lexer.

Here's a failing circuit (this is a 1024-deep concatenation):

```scala
circuit Bar :
  module Bar :
    input a: UInt<1>
    output b: UInt<1024>

    b <= cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
```

This is erroring out with an `EXC_BAD_ACCESS` occurring in the lexer:

```
# lldb firtool -- Bar.fir
(lldb) target create ""firtool""
Current executable set to 'firtool' (x86_64).
(lldb) settings set -- target.run-args  ""Bar.fir""
(lldb) run
Process 10399 launched: '/Users/schuylere/usr/bin/firtool' (x86_64)
Process 10399 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=2, address=0x7ffeef3fffff)
    frame #0: 0x00000001005857e4 firtool`llvm::isAlpha(C=<unavailable>) at StringExtras.h:95
   92  	inline bool isHexDigit(char C) { return hexDigitValue(C) != ~0U; }
   93  	
   94  	/// Checks if character \p C is a valid letter as classified by ""C"" locale.
-> 95  	inline bool isAlpha(char C) {
   96  	  return ('a' <= C && C <= 'z') || ('A' <= C && C <= 'Z');
   97  	}
   98  	
Target 0: (firtool) stopped.
(lldb) frame select 1
frame #1: 0x000000010024a592 firtool`circt::firrtl::FIRLexer::lexIdentifierOrKeyword(this=0x00007ffeefbfdbe8, tokStart=""cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))""...) at FIRLexer.cpp:386:10
   383 	///
   384 	FIRToken FIRLexer::lexIdentifierOrKeyword(const char *tokStart) {
   385 	  // Match the rest of the identifier regex: [0-9a-zA-Z_$-]*
-> 386 	  while (llvm::isAlpha(*curPtr) || llvm::isDigit(*curPtr) || *curPtr == '_' ||
   387 	         *curPtr == '$' || *curPtr == '-')
   388 	    ++curPtr;
   389
```","circuit Bar :
  module Bar :
    input a: UInt<1>
    output b: UInt<1024>

    b <= cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))","# lldb firtool -- Bar.fir
(lldb) target create ""firtool""
Current executable set to 'firtool' (x86_64).
(lldb) settings set -- target.run-args  ""Bar.fir""
(lldb) run
Process 10399 launched: '/Users/schuylere/usr/bin/firtool' (x86_64)
Process 10399 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=2, address=0x7ffeef3fffff)
    frame #0: 0x00000001005857e4 firtool`llvm::isAlpha(C=<unavailable>) at StringExtras.h:95
   92  	inline bool isHexDigit(char C) { return hexDigitValue(C) != ~0U; }
   93  	
   94  	/// Checks if character \p C is a valid letter as classified by ""C"" locale.
-> 95  	inline bool isAlpha(char C) {
   96  	  return ('a' <= C && C <= 'z') || ('A' <= C && C <= 'Z');
   97  	}
   98  	
Target 0: (firtool) stopped.
(lldb) frame select 1
frame #1: 0x000000010024a592 firtool`circt::firrtl::FIRLexer::lexIdentifierOrKeyword(this=0x00007ffeefbfdbe8, tokStart=""cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))""...) at FIRLexer.cpp:386:10
   383 	///
   384 	FIRToken FIRLexer::lexIdentifierOrKeyword(const char *tokStart) {
   385 	  // Match the rest of the identifier regex: [0-9a-zA-Z_$-]*
-> 386 	  while (llvm::isAlpha(*curPtr) || llvm::isDigit(*curPtr) || *curPtr == '_' ||
   387 	         *curPtr == '$' || *curPtr == '-')
   388 	    ++curPtr;
   389",,,,,,,,
1734,[FIRRTL] Add non-local annotation support to GCT Data Taps,2021-09-06T15:13:33Z,open,"bug, FIRRTL","The Grand Central Data/Mem Taps pass currently only works with annotations that refer to entire modules. With the non-local annotations having been merged recently, it should now be expanded to also properly support those. We've seen a few cases internally where this is necessary.",,,,,,,,,,
1289,"[FIRRTL] (dshl, tail, mul) width inference mismatch",2021-06-16T16:43:39Z,open,"bug, FIRRTL","The following FIRRTL program

Produces different width for the output port `_tmp40`

```python
; seed: 1144
circuit top_mod :
  module top_mod :
    output _tmp40: UInt
    wire tmp19: UInt
    tmp19 <= mul(UInt(""o20575""), UInt<1>(0))
    _tmp40 <= dshl(UInt(""b10011010000001011101""), tail(tmp19, 15))
```

Compiled with `firtool` produces this Verilog:

```verilog
module top_mod(
  output [19:0] _tmp40);

  assign _tmp40 = 20'h9A05D;	// a_top_mod.fir:3:3, :7:20
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:

```verilog
module top_mod(
  output [18:0] _tmp40
);
  assign _tmp40 = 19'h1a05d;
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
ERROR: Can't match gold port `_tmp40_gold' to a gate port.
```","; seed: 1144
circuit top_mod :
  module top_mod :
    output _tmp40: UInt
    wire tmp19: UInt
    tmp19 <= mul(UInt(""o20575""), UInt<1>(0))
    _tmp40 <= dshl(UInt(""b10011010000001011101""), tail(tmp19, 15))","module top_mod(
  output [19:0] _tmp40);

  assign _tmp40 = 20'h9A05D;	// a_top_mod.fir:3:3, :7:20
endmodule","module top_mod(
  output [18:0] _tmp40
);
  assign _tmp40 = 19'h1a05d;
endmodule",ERROR: Can't match gold port `_tmp40_gold' to a gate port.,,,,,,
1065,[CI] Most tests fail on Ubuntu 18.04,2021-05-17T17:43:44Z,open,bug,"I have a Docker-based repro: https://github.com/llvm/circt/blob/crashes-1804/utils/run-docker-1804.sh. Just run `./utils/run-docker-1804.sh`. This is running the LLVM build in the release config w/ asserts enabled and CIRCT in debug. I've attached a log of the crashes: [test_fails.log](https://github.com/llvm/circt/files/6495753/test_fails.log).


```
Failed Tests (210):
  CIRCT :: CAPI/ir.c
  CIRCT :: Conversion/FIRRTLToHW/errors.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-errors.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-module.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw.mlir
  CIRCT :: Conversion/FIRRTLToHW/zero-width.mlir
  CIRCT :: Conversion/FIRRTLToLLHD/connect.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_inouts.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_ins.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_none.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_outs.fir
  CIRCT :: Conversion/HWToLLHD/errors.mlir
  CIRCT :: Conversion/HWToLLHD/structure.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/simple_addi.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_branch.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_buffer.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_cmerge.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_conditional_branch.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_constant.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_fork.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_join.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_lazy_fork.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_load.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_memory.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_merge.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_mux.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_sink.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_store.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_arithmetic.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_bitwise.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_entity.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_extract.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_insert.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_memory.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_process_persistence.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_signals.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_simple.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_value_creation.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_wait.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/errors.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-for.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-load-store.mlir
  CIRCT :: Conversion/StandardToHandshake/test1.mlir
  CIRCT :: Conversion/StandardToHandshake/test10.mlir
  CIRCT :: Conversion/StandardToHandshake/test11.mlir
  CIRCT :: Conversion/StandardToHandshake/test12.mlir
  CIRCT :: Conversion/StandardToHandshake/test13.mlir
  CIRCT :: Conversion/StandardToHandshake/test14.mlir
  CIRCT :: Conversion/StandardToHandshake/test15.mlir
  CIRCT :: Conversion/StandardToHandshake/test16.mlir
  CIRCT :: Conversion/StandardToHandshake/test17.mlir
  CIRCT :: Conversion/StandardToHandshake/test18.mlir
  CIRCT :: Conversion/StandardToHandshake/test19.mlir
  CIRCT :: Conversion/StandardToHandshake/test2.mlir
  CIRCT :: Conversion/StandardToHandshake/test20.mlir
  CIRCT :: Conversion/StandardToHandshake/test21.mlir
  CIRCT :: Conversion/StandardToHandshake/test22.mlir
  CIRCT :: Conversion/StandardToHandshake/test23.mlir
  CIRCT :: Conversion/StandardToHandshake/test24.mlir
  CIRCT :: Conversion/StandardToHandshake/test25.mlir
  CIRCT :: Conversion/StandardToHandshake/test26.mlir
  CIRCT :: Conversion/StandardToHandshake/test27.mlir
  CIRCT :: Conversion/StandardToHandshake/test28.mlir
  CIRCT :: Conversion/StandardToHandshake/test29.mlir
  CIRCT :: Conversion/StandardToHandshake/test3.mlir
  CIRCT :: Conversion/StandardToHandshake/test30.mlir
  CIRCT :: Conversion/StandardToHandshake/test31.mlir
  CIRCT :: Conversion/StandardToHandshake/test32.mlir
  CIRCT :: Conversion/StandardToHandshake/test33.mlir
  CIRCT :: Conversion/StandardToHandshake/test34.mlir
  CIRCT :: Conversion/StandardToHandshake/test35.mlir
  CIRCT :: Conversion/StandardToHandshake/test4.mlir
  CIRCT :: Conversion/StandardToHandshake/test5.mlir
  CIRCT :: Conversion/StandardToHandshake/test6.mlir
  CIRCT :: Conversion/StandardToHandshake/test7.mlir
  CIRCT :: Conversion/StandardToHandshake/test8.mlir
  CIRCT :: Conversion/StandardToHandshake/test9.mlir
  CIRCT :: Conversion/StandardToHandshake/test_canonicalize.mlir
  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer.mlir
  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer_errors.mlir
  CIRCT :: Conversion/StandardToStaticLogic/test_pipeline.mlir
  CIRCT :: Dialect/ESI/connectivity.mlir
  CIRCT :: Dialect/ESI/errors.mlir
  CIRCT :: Dialect/ESI/lowering.mlir
  CIRCT :: Dialect/ESI/modwrap.mlir
  CIRCT :: Dialect/ESI/wrapif-lowering.mlir
  CIRCT :: Dialect/FIRRTL/annotations.fir
  CIRCT :: Dialect/FIRRTL/blackbox-memory.mlir
  CIRCT :: Dialect/FIRRTL/canonicalization.mlir
  CIRCT :: Dialect/FIRRTL/check-widths-errors.mlir
  CIRCT :: Dialect/FIRRTL/connect-errors.mlir
  CIRCT :: Dialect/FIRRTL/connect.mlir
  CIRCT :: Dialect/FIRRTL/const-prop-single-module.mlir
  CIRCT :: Dialect/FIRRTL/cse.mlir
  CIRCT :: Dialect/FIRRTL/errors.mlir
  CIRCT :: Dialect/FIRRTL/expand-whens-errors.mlir
  CIRCT :: Dialect/FIRRTL/expand-whens.mlir
  CIRCT :: Dialect/FIRRTL/imconstprop.mlir
  CIRCT :: Dialect/FIRRTL/infer-widths-errors.mlir
  CIRCT :: Dialect/FIRRTL/infer-widths.mlir
  CIRCT :: Dialect/FIRRTL/inliner.mlir
  CIRCT :: Dialect/FIRRTL/lower-types-errors.mlir
  CIRCT :: Dialect/FIRRTL/lower-types.mlir
  CIRCT :: Dialect/FIRRTL/parse-basic.fir
  CIRCT :: Dialect/FIRRTL/parse-errors.fir
  CIRCT :: Dialect/FIRRTL/parse-locations.fir
  CIRCT :: Dialect/FIRRTL/test.mlir
  CIRCT :: Dialect/HW/basic.mlir
  CIRCT :: Dialect/HW/bitwise.mlir
  CIRCT :: Dialect/HW/canonicalization.mlir
  CIRCT :: Dialect/HW/errors.mlir
  CIRCT :: Dialect/HW/greybox.mlir
  CIRCT :: Dialect/HW/modules.mlir
  CIRCT :: Dialect/HW/svEmitErrors.mlir
  CIRCT :: Dialect/HW/typedecls.mlir
  CIRCT :: Dialect/HW/types.mlir
  CIRCT :: Dialect/Handshake/errors.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/arithmetic.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/bitwise.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/constant.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/extract.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/memory.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/probeCSE.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/signalOps.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_arithmetic.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_bitwise.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_entity.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_relations.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_sig.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_sig_errors.mlir
  CIRCT :: Dialect/LLHD/IR/arithmetic.mlir
  CIRCT :: Dialect/LLHD/IR/array.mlir
  CIRCT :: Dialect/LLHD/IR/bitwise.mlir
  CIRCT :: Dialect/LLHD/IR/connect-errors.mlir
  CIRCT :: Dialect/LLHD/IR/connect.mlir
  CIRCT :: Dialect/LLHD/IR/const.mlir
  CIRCT :: Dialect/LLHD/IR/entity.mlir
  CIRCT :: Dialect/LLHD/IR/extract-errors.mlir
  CIRCT :: Dialect/LLHD/IR/extract.mlir
  CIRCT :: Dialect/LLHD/IR/insert-errors.mlir
  CIRCT :: Dialect/LLHD/IR/insert.mlir
  CIRCT :: Dialect/LLHD/IR/inst-errors.mlir
  CIRCT :: Dialect/LLHD/IR/inst.mlir
  CIRCT :: Dialect/LLHD/IR/memory.mlir
  CIRCT :: Dialect/LLHD/IR/proc.mlir
  CIRCT :: Dialect/LLHD/IR/reg.mlir
  CIRCT :: Dialect/LLHD/IR/signal-errors.mlir
  CIRCT :: Dialect/LLHD/IR/signal.mlir
  CIRCT :: Dialect/LLHD/IR/time.mlir
  CIRCT :: Dialect/LLHD/IR/tuple.mlir
  CIRCT :: Dialect/LLHD/IR/wait.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_arbitrary_signal_size.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_array_boundary_check.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_bit_precision_drives.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_process.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_reg.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_shifts.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_simple.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_wait.mlir
  CIRCT :: Dialect/LLHD/Transforms/earlyCodeMotion.mlir
  CIRCT :: Dialect/LLHD/Transforms/memoryToBlockArgument.mlir
  CIRCT :: Dialect/LLHD/Transforms/processLowering.mlir
  CIRCT :: Dialect/LLHD/Transforms/processLoweringErrors.mlir
  CIRCT :: Dialect/LLHD/Transforms/totalFunctionInlining.mlir
  CIRCT :: Dialect/MSFT/location.mlir
  CIRCT :: Dialect/MSFT/opt-errors.mlir
  CIRCT :: Dialect/MSFT/translate-errors.mlir
  CIRCT :: Dialect/SV/basic.mlir
  CIRCT :: Dialect/SV/canonicalization.mlir
  CIRCT :: Dialect/SV/errors.mlir
  CIRCT :: Dialect/SV/hw-cleanup.mlir
  CIRCT :: Dialect/SV/hw-generator-callout.mlir
  CIRCT :: Dialect/SV/hw-legalize-names-errors.mlir
  CIRCT :: Dialect/SV/hw-legalize-names.mlir
  CIRCT :: Dialect/SV/hw-memsim.mlir
  CIRCT :: Dialect/SV/interfaces.mlir
  CIRCT :: Dialect/SV/prettify-verilog.mlir
  CIRCT :: Dialect/Seq/basic.mlir
  CIRCT :: ExportVerilog/hw-dialect.mlir
  CIRCT :: ExportVerilog/hw-typedecls.mlir
  CIRCT :: ExportVerilog/line-length.mlir
  CIRCT :: ExportVerilog/load-dialect.mlir
  CIRCT :: ExportVerilog/sv-alwaysff.mlir
  CIRCT :: ExportVerilog/sv-dialect.mlir
  CIRCT :: ExportVerilog/sv-interfaces.mlir
  CIRCT :: ExportVerilog/verilog-basic.mlir
  CIRCT :: ExportVerilog/verilog-errors.mlir
  CIRCT :: circt-opt/trivial.mlir
  CIRCT :: circt-translate/parse_int64.fir
  CIRCT :: firtool/firtool.fir
  CIRCT :: firtool/firtool.mlir
  CIRCT :: firtool/optimizations.fir
  CIRCT :: firtool/phase-ordering.fir
  CIRCT :: firtool/split-verilog.mlir
  CIRCT :: firtool/style.fir
  CIRCT :: handshake-runner/call_bb.mlir
  CIRCT :: handshake-runner/cdiv-old-std.mlir
  CIRCT :: handshake-runner/cdiv-std.mlir
  CIRCT :: handshake-runner/complex_bb.mlir
  CIRCT :: handshake-runner/floydwarshall-std.mlir
  CIRCT :: handshake-runner/histogram-std.mlir
  CIRCT :: handshake-runner/loadstore.mlir
  CIRCT :: handshake-runner/loop-check-1-std.mlir
  CIRCT :: handshake-runner/loop-check-2-std.mlir
  CIRCT :: handshake-runner/matmul-check-std.mlir
  CIRCT :: handshake-runner/matmul-std.mlir
  CIRCT :: handshake-runner/memory_simple_2_std.mlir
  CIRCT :: handshake-runner/memory_simple_std.mlir
  CIRCT :: handshake-runner/simple_loop.mlir


Testing Time: 1.34s
  Unsupported:   4
  Passed     :   6
  Failed     : 210
```","Failed Tests (210):
  CIRCT :: CAPI/ir.c
  CIRCT :: Conversion/FIRRTLToHW/errors.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-errors.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-module.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw.mlir
  CIRCT :: Conversion/FIRRTLToHW/zero-width.mlir
  CIRCT :: Conversion/FIRRTLToLLHD/connect.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_inouts.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_ins.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_none.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_outs.fir
  CIRCT :: Conversion/HWToLLHD/errors.mlir
  CIRCT :: Conversion/HWToLLHD/structure.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/simple_addi.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_branch.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_buffer.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_cmerge.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_conditional_branch.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_constant.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_fork.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_join.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_lazy_fork.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_load.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_memory.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_merge.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_mux.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_sink.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_store.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_arithmetic.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_bitwise.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_entity.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_extract.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_insert.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_memory.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_process_persistence.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_signals.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_simple.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_value_creation.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_wait.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/errors.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-for.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-load-store.mlir
  CIRCT :: Conversion/StandardToHandshake/test1.mlir
  CIRCT :: Conversion/StandardToHandshake/test10.mlir
  CIRCT :: Conversion/StandardToHandshake/test11.mlir
  CIRCT :: Conversion/StandardToHandshake/test12.mlir
  CIRCT :: Conversion/StandardToHandshake/test13.mlir
  CIRCT :: Conversion/StandardToHandshake/test14.mlir
  CIRCT :: Conversion/StandardToHandshake/test15.mlir
  CIRCT :: Conversion/StandardToHandshake/test16.mlir
  CIRCT :: Conversion/StandardToHandshake/test17.mlir
  CIRCT :: Conversion/StandardToHandshake/test18.mlir
  CIRCT :: Conversion/StandardToHandshake/test19.mlir
  CIRCT :: Conversion/StandardToHandshake/test2.mlir
  CIRCT :: Conversion/StandardToHandshake/test20.mlir
  CIRCT :: Conversion/StandardToHandshake/test21.mlir
  CIRCT :: Conversion/StandardToHandshake/test22.mlir
  CIRCT :: Conversion/StandardToHandshake/test23.mlir
  CIRCT :: Conversion/StandardToHandshake/test24.mlir
  CIRCT :: Conversion/StandardToHandshake/test25.mlir
  CIRCT :: Conversion/StandardToHandshake/test26.mlir
  CIRCT :: Conversion/StandardToHandshake/test27.mlir
  CIRCT :: Conversion/StandardToHandshake/test28.mlir
  CIRCT :: Conversion/StandardToHandshake/test29.mlir
  CIRCT :: Conversion/StandardToHandshake/test3.mlir
  CIRCT :: Conversion/StandardToHandshake/test30.mlir
  CIRCT :: Conversion/StandardToHandshake/test31.mlir
  CIRCT :: Conversion/StandardToHandshake/test32.mlir
  CIRCT :: Conversion/StandardToHandshake/test33.mlir
  CIRCT :: Conversion/StandardToHandshake/test34.mlir
  CIRCT :: Conversion/StandardToHandshake/test35.mlir
  CIRCT :: Conversion/StandardToHandshake/test4.mlir
  CIRCT :: Conversion/StandardToHandshake/test5.mlir
  CIRCT :: Conversion/StandardToHandshake/test6.mlir
  CIRCT :: Conversion/StandardToHandshake/test7.mlir
  CIRCT :: Conversion/StandardToHandshake/test8.mlir
  CIRCT :: Conversion/StandardToHandshake/test9.mlir
  CIRCT :: Conversion/StandardToHandshake/test_canonicalize.mlir
  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer.mlir
  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer_errors.mlir
  CIRCT :: Conversion/StandardToStaticLogic/test_pipeline.mlir
  CIRCT :: Dialect/ESI/connectivity.mlir
  CIRCT :: Dialect/ESI/errors.mlir
  CIRCT :: Dialect/ESI/lowering.mlir
  CIRCT :: Dialect/ESI/modwrap.mlir
  CIRCT :: Dialect/ESI/wrapif-lowering.mlir
  CIRCT :: Dialect/FIRRTL/annotations.fir
  CIRCT :: Dialect/FIRRTL/blackbox-memory.mlir
  CIRCT :: Dialect/FIRRTL/canonicalization.mlir
  CIRCT :: Dialect/FIRRTL/check-widths-errors.mlir
  CIRCT :: Dialect/FIRRTL/connect-errors.mlir
  CIRCT :: Dialect/FIRRTL/connect.mlir
  CIRCT :: Dialect/FIRRTL/const-prop-single-module.mlir
  CIRCT :: Dialect/FIRRTL/cse.mlir
  CIRCT :: Dialect/FIRRTL/errors.mlir
  CIRCT :: Dialect/FIRRTL/expand-whens-errors.mlir
  CIRCT :: Dialect/FIRRTL/expand-whens.mlir
  CIRCT :: Dialect/FIRRTL/imconstprop.mlir
  CIRCT :: Dialect/FIRRTL/infer-widths-errors.mlir
  CIRCT :: Dialect/FIRRTL/infer-widths.mlir
  CIRCT :: Dialect/FIRRTL/inliner.mlir
  CIRCT :: Dialect/FIRRTL/lower-types-errors.mlir
  CIRCT :: Dialect/FIRRTL/lower-types.mlir
  CIRCT :: Dialect/FIRRTL/parse-basic.fir
  CIRCT :: Dialect/FIRRTL/parse-errors.fir
  CIRCT :: Dialect/FIRRTL/parse-locations.fir
  CIRCT :: Dialect/FIRRTL/test.mlir
  CIRCT :: Dialect/HW/basic.mlir
  CIRCT :: Dialect/HW/bitwise.mlir
  CIRCT :: Dialect/HW/canonicalization.mlir
  CIRCT :: Dialect/HW/errors.mlir
  CIRCT :: Dialect/HW/greybox.mlir
  CIRCT :: Dialect/HW/modules.mlir
  CIRCT :: Dialect/HW/svEmitErrors.mlir
  CIRCT :: Dialect/HW/typedecls.mlir
  CIRCT :: Dialect/HW/types.mlir
  CIRCT :: Dialect/Handshake/errors.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/arithmetic.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/bitwise.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/constant.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/extract.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/memory.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/probeCSE.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/signalOps.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_arithmetic.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_bitwise.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_entity.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_relations.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_sig.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_sig_errors.mlir
  CIRCT :: Dialect/LLHD/IR/arithmetic.mlir
  CIRCT :: Dialect/LLHD/IR/array.mlir
  CIRCT :: Dialect/LLHD/IR/bitwise.mlir
  CIRCT :: Dialect/LLHD/IR/connect-errors.mlir
  CIRCT :: Dialect/LLHD/IR/connect.mlir
  CIRCT :: Dialect/LLHD/IR/const.mlir
  CIRCT :: Dialect/LLHD/IR/entity.mlir
  CIRCT :: Dialect/LLHD/IR/extract-errors.mlir
  CIRCT :: Dialect/LLHD/IR/extract.mlir
  CIRCT :: Dialect/LLHD/IR/insert-errors.mlir
  CIRCT :: Dialect/LLHD/IR/insert.mlir
  CIRCT :: Dialect/LLHD/IR/inst-errors.mlir
  CIRCT :: Dialect/LLHD/IR/inst.mlir
  CIRCT :: Dialect/LLHD/IR/memory.mlir
  CIRCT :: Dialect/LLHD/IR/proc.mlir
  CIRCT :: Dialect/LLHD/IR/reg.mlir
  CIRCT :: Dialect/LLHD/IR/signal-errors.mlir
  CIRCT :: Dialect/LLHD/IR/signal.mlir
  CIRCT :: Dialect/LLHD/IR/time.mlir
  CIRCT :: Dialect/LLHD/IR/tuple.mlir
  CIRCT :: Dialect/LLHD/IR/wait.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_arbitrary_signal_size.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_array_boundary_check.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_bit_precision_drives.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_process.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_reg.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_shifts.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_simple.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_wait.mlir
  CIRCT :: Dialect/LLHD/Transforms/earlyCodeMotion.mlir
  CIRCT :: Dialect/LLHD/Transforms/memoryToBlockArgument.mlir
  CIRCT :: Dialect/LLHD/Transforms/processLowering.mlir
  CIRCT :: Dialect/LLHD/Transforms/processLoweringErrors.mlir
  CIRCT :: Dialect/LLHD/Transforms/totalFunctionInlining.mlir
  CIRCT :: Dialect/MSFT/location.mlir
  CIRCT :: Dialect/MSFT/opt-errors.mlir
  CIRCT :: Dialect/MSFT/translate-errors.mlir
  CIRCT :: Dialect/SV/basic.mlir
  CIRCT :: Dialect/SV/canonicalization.mlir
  CIRCT :: Dialect/SV/errors.mlir
  CIRCT :: Dialect/SV/hw-cleanup.mlir
  CIRCT :: Dialect/SV/hw-generator-callout.mlir
  CIRCT :: Dialect/SV/hw-legalize-names-errors.mlir
  CIRCT :: Dialect/SV/hw-legalize-names.mlir
  CIRCT :: Dialect/SV/hw-memsim.mlir
  CIRCT :: Dialect/SV/interfaces.mlir
  CIRCT :: Dialect/SV/prettify-verilog.mlir
  CIRCT :: Dialect/Seq/basic.mlir
  CIRCT :: ExportVerilog/hw-dialect.mlir
  CIRCT :: ExportVerilog/hw-typedecls.mlir
  CIRCT :: ExportVerilog/line-length.mlir
  CIRCT :: ExportVerilog/load-dialect.mlir
  CIRCT :: ExportVerilog/sv-alwaysff.mlir
  CIRCT :: ExportVerilog/sv-dialect.mlir
  CIRCT :: ExportVerilog/sv-interfaces.mlir
  CIRCT :: ExportVerilog/verilog-basic.mlir
  CIRCT :: ExportVerilog/verilog-errors.mlir
  CIRCT :: circt-opt/trivial.mlir
  CIRCT :: circt-translate/parse_int64.fir
  CIRCT :: firtool/firtool.fir
  CIRCT :: firtool/firtool.mlir
  CIRCT :: firtool/optimizations.fir
  CIRCT :: firtool/phase-ordering.fir
  CIRCT :: firtool/split-verilog.mlir
  CIRCT :: firtool/style.fir
  CIRCT :: handshake-runner/call_bb.mlir
  CIRCT :: handshake-runner/cdiv-old-std.mlir
  CIRCT :: handshake-runner/cdiv-std.mlir
  CIRCT :: handshake-runner/complex_bb.mlir
  CIRCT :: handshake-runner/floydwarshall-std.mlir
  CIRCT :: handshake-runner/histogram-std.mlir
  CIRCT :: handshake-runner/loadstore.mlir
  CIRCT :: handshake-runner/loop-check-1-std.mlir
  CIRCT :: handshake-runner/loop-check-2-std.mlir
  CIRCT :: handshake-runner/matmul-check-std.mlir
  CIRCT :: handshake-runner/matmul-std.mlir
  CIRCT :: handshake-runner/memory_simple_2_std.mlir
  CIRCT :: handshake-runner/memory_simple_std.mlir
  CIRCT :: handshake-runner/simple_loop.mlir


Testing Time: 1.34s
  Unsupported:   4
  Passed     :   6
  Failed     : 210",,,,,,,,,
907,Parsing Instance Connects Broken,2021-04-09T15:45:51Z,open,"bug, FIRRTL","Connections involving instances fail to parse, but work in the Scala FIRRTL Compiler.

The following currently fails:
```scala
circuit Instance:
  module Sub:
    output a: UInt<1>
    a <= UInt<1>(0)

  module Instance:
    output a: {a: UInt<1>}

    inst sub of Sub
    a <= sub
    a <- sub
```

The error is: 

```
# circt-translate --import-firrtl new/Instance.fir
new/Instance.fir:11:5: error: expected '.' in field reference
    a <- sub
    ^
```

Glancing at the parser, it looks like it expects `sub` to be in the value table, but it isn't. [There is special logic to handle `sub is invalid`](https://github.com/llvm/circt/blob/main/lib/Dialect/FIRRTL/Import/FIRParser.cpp#L1187), but that needs to be extended to handle connections to submodules. If this isn't a `sub is invalid` situation, then the parser expects to see a subfield.","circuit Instance:
  module Sub:
    output a: UInt<1>
    a <= UInt<1>(0)

  module Instance:
    output a: {a: UInt<1>}

    inst sub of Sub
    a <= sub
    a <- sub","# circt-translate --import-firrtl new/Instance.fir
new/Instance.fir:11:5: error: expected '.' in field reference
    a <- sub
    ^",,,,,,,,
806,[LLHD] llhd-sim unable to simulate generated llhd dialect ,2021-03-22T22:30:35Z,open,"bug, LLHD","To simulate below llhd:

```
llhd.entity @adder(%clk: !llhd.sig, %res: !llhd.sig) → (%i5_output: !llhd.sig ) {
%0 = llhd.const #llhd.time<0s, 0d, 1e> : !llhd.time
%1 = llhd.const 16 : i32
llhd.drv %i5_output, %1 after %0 : !llhd.sig
}
```

shows this error:

```
Assertion failed: (idx < size()), function operator[], file …/llvm/llvm/include/llvm/ADT/SmallVector.h, line 277.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0. Program arguments: …/build/bin/llhd-sim addersvllhd.mlir -n 10 -r adder
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var LLVM_SYMBOLIZER_PATH to point to it):
0 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca593d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca5eeb PrintStackTraceSignalHandler(void*) + 27
2 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca3a6b llvm::sys::RunSignalHandlers() + 123
3 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca83f8 SignalHandler(int) + 232
4 libsystem_platform.dylib 0x00007fff6af445fd _sigtramp + 29
5 libdyld.dylib 0x00007fff6ad4a78f dyldGlobalLockRelease() + 0
6 libsystem_c.dylib 0x00007fff6ae1a808 abort + 120
7 libsystem_c.dylib 0x00007fff6ae19ac6 err + 0
8 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4fa48 llvm::SmallVectorTemplateCommon<circt::llhd::sim::Signal, void>::operator[](unsigned long) + 104
9 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4f912 driveSignal + 178
10 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011e1240f1 driveSignal + 6113425
11 llhd-sim 0x000000010acda78e main + 1518
12 libdyld.dylib 0x00007fff6ad4bcc9 start + 1
```

My command to llhd-sim is -n 10 -r adder and I think the expect behaviour should be a constant signal at the output (signal i5_output being constantly at value 16). I was able to trace the code till line 235 of engine.cpp 

(ps: this is not the full code for my sv; I have reduced it to the simplest form to see if I can get an output. Originally my code just aborted when the reaches the adder.adder entity in state.)","llhd.entity @adder(%clk: !llhd.sig, %res: !llhd.sig) → (%i5_output: !llhd.sig ) {
%0 = llhd.const #llhd.time<0s, 0d, 1e> : !llhd.time
%1 = llhd.const 16 : i32
llhd.drv %i5_output, %1 after %0 : !llhd.sig
}","Assertion failed: (idx < size()), function operator[], file …/llvm/llvm/include/llvm/ADT/SmallVector.h, line 277.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0. Program arguments: …/build/bin/llhd-sim addersvllhd.mlir -n 10 -r adder
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var LLVM_SYMBOLIZER_PATH to point to it):
0 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca593d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca5eeb PrintStackTraceSignalHandler(void*) + 27
2 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca3a6b llvm::sys::RunSignalHandlers() + 123
3 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca83f8 SignalHandler(int) + 232
4 libsystem_platform.dylib 0x00007fff6af445fd _sigtramp + 29
5 libdyld.dylib 0x00007fff6ad4a78f dyldGlobalLockRelease() + 0
6 libsystem_c.dylib 0x00007fff6ae1a808 abort + 120
7 libsystem_c.dylib 0x00007fff6ae19ac6 err + 0
8 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4fa48 llvm::SmallVectorTemplateCommon<circt::llhd::sim::Signal, void>::operator[](unsigned long) + 104
9 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4f912 driveSignal + 178
10 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011e1240f1 driveSignal + 6113425
11 llhd-sim 0x000000010acda78e main + 1518
12 libdyld.dylib 0x00007fff6ad4bcc9 start + 1",,,,,,,,
787,[FIRRTL] FIRRTL to RTL Memory Lowering Needs to Handle All Read Under Write Behaviors,2021-03-18T22:30:18Z,open,"bug, FIRRTL","Add support for the ""old"" read-under-write FIRRTL memory behavior. Currently, this is incorrectly emitted as ""new"".

The FIRRTL spec defines three read-under-write behaviors for memories. A read-under-write behavior is what happens if you try to read and write the same address on the same cycle These three behaviors are:

1. New (return the value in the memory when the read was made)
2. Old (return the value when the read was requested)
3. Undefined (technically anything, but the Scala FIRRTL Compiler treats this as ""compiler's choice"" and chooses ""New"")

Note that this only matters for read latencies > 0. These can be treated as equivalent if the ~read latency == 1~ read latency == 0.",,,,,,,,,,
