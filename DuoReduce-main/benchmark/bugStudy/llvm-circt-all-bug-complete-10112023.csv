number,title,created_at,state,labels,body,code_snippet_01,code_snippet_02,code_snippet_03,code_snippet_04,code_snippet_05,code_snippet_06,code_snippet_07,code_snippet_08,code_snippet_09,code_snippet_10
6275,[ExportVerilog] Aggregate constant produces invalid assignment pattern,2023-10-10T18:38:20Z,open,"bug, ExportVerilog","The following snippet of MLIR creates an aggregate constant of a struct nested in an array nested in a struct:
```mlir
hw.module @Foo() {
    %bar = sv.reg : !hw.inout<struct<mem: !hw.array<1xstruct<sink: i1>>>>
    %0 = hw.aggregate_constant [[[false]]] : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>
    sv.assign %bar, %0 : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>
}
```
Running this through `circt-opt --export-verilog` produces the following invalid Verilog:
```verilog
module Foo();
  struct packed {struct packed {logic sink; }[0:0] mem; } bar;
  assign bar = '{mem: {'{sink: 1'h0}}};
endmodule
```
The problematic part is `'{mem: {'{sink: 1'h0}}}`, which contains an assignment pattern `'{sink: 1'h0}` inside a concatenation `{...}` (without the `'`). The assignment pattern `'{...}` (with the `'`) requires an assignment-like context, which the concatenation is not.

Maybe we can emit the array also as an assignment pattern `'{...}`. Or add explicit types to the assignment patterns somehow, like `struct {...} '{...}`?","hw.module @Foo() {
    %bar = sv.reg : !hw.inout<struct<mem: !hw.array<1xstruct<sink: i1>>>>
    %0 = hw.aggregate_constant [[[false]]] : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>
    sv.assign %bar, %0 : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>
}","module Foo();
  struct packed {struct packed {logic sink; }[0:0] mem; } bar;
  assign bar = '{mem: {'{sink: 1'h0}}};
endmodule",,,,,,,,
6273,[HW] Crash in `seq.firreg` canonicalizer,2023-10-09T19:02:20Z,closed,"bug, HW","When playing with some read-only memories in FIRRTL, I came across the following MLIR which causes a crash because the utility `hw::getBitWidth` only knows about HW types, but is being used on a `seq.clock`. This returns the `-1` ""unknown"" value and then blows up:

```mlir
hw.module @Foo(in %clock : !seq.clock, out r_data : !seq.clock) {
  %0 = seq.const_clock  low
  %1 = seq.firreg %1 clock %0 : !seq.clock
  hw.output %1 : !seq.clock
}
```

```
# circt-opt -canonicalize Foo.mlir
<unknown>:0: error: integer bitwidth is limited to 16777215 bits
Assertion failed: (succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))), function get, file StorageUniquerSupport.h, line 181.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: firtool firrtl-snippets/circt/xxx.mlir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x0000000104c17be0 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 88
1  firtool                  0x0000000104c181fc PrintStackTraceSignalHandler(void*) + 28
2  firtool                  0x0000000104c15d90 llvm::sys::RunSignalHandlers() + 152
3  firtool                  0x0000000104c194d4 SignalHandler(int) + 276
4  libsystem_platform.dylib 0x00000001a866aa24 _sigtramp + 56
5  libsystem_pthread.dylib  0x00000001a863bc28 pthread_kill + 288
6  libsystem_c.dylib        0x00000001a8549ae8 abort + 180
7  libsystem_c.dylib        0x00000001a8548e44 err + 0
8  firtool                  0x000000010556f174 mlir::IntegerType mlir::detail::StorageUserBase<mlir::IntegerType, mlir::Type, mlir::detail::IntegerTypeStorage, mlir::detail::TypeUniquer>::get<unsigned int, mlir::IntegerType::SignednessSemantics>(mlir::MLIRContext*, unsigned int, mlir::IntegerType::SignednessSemantics) + 152
9  firtool                  0x000000010556ef74 mlir::IntegerType::get(mlir::MLIRContext*, unsigned int, mlir::IntegerType::SignednessSemantics) + 84
10 firtool                  0x000000010604427c circt::hw::ConstantOp::build(mlir::OpBuilder&, mlir::OperationState&, llvm::APInt const&) + 60
11 firtool                  0x0000000105ccaf6c circt::hw::ConstantOp mlir::OpBuilder::create<circt::hw::ConstantOp, llvm::APInt>(mlir::Location, llvm::APInt&&) + 132
12 firtool                  0x000000010515ea7c circt::seq::FirRegOp::canonicalize(circt::seq::FirRegOp, mlir::PatternRewriter&) + 588
```","hw.module @Foo(in %clock : !seq.clock, out r_data : !seq.clock) {
  %0 = seq.const_clock  low
  %1 = seq.firreg %1 clock %0 : !seq.clock
  hw.output %1 : !seq.clock
}","# circt-opt -canonicalize Foo.mlir
<unknown>:0: error: integer bitwidth is limited to 16777215 bits
Assertion failed: (succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))), function get, file StorageUniquerSupport.h, line 181.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: firtool firrtl-snippets/circt/xxx.mlir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x0000000104c17be0 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 88
1  firtool                  0x0000000104c181fc PrintStackTraceSignalHandler(void*) + 28
2  firtool                  0x0000000104c15d90 llvm::sys::RunSignalHandlers() + 152
3  firtool                  0x0000000104c194d4 SignalHandler(int) + 276
4  libsystem_platform.dylib 0x00000001a866aa24 _sigtramp + 56
5  libsystem_pthread.dylib  0x00000001a863bc28 pthread_kill + 288
6  libsystem_c.dylib        0x00000001a8549ae8 abort + 180
7  libsystem_c.dylib        0x00000001a8548e44 err + 0
8  firtool                  0x000000010556f174 mlir::IntegerType mlir::detail::StorageUserBase<mlir::IntegerType, mlir::Type, mlir::detail::IntegerTypeStorage, mlir::detail::TypeUniquer>::get<unsigned int, mlir::IntegerType::SignednessSemantics>(mlir::MLIRContext*, unsigned int, mlir::IntegerType::SignednessSemantics) + 152
9  firtool                  0x000000010556ef74 mlir::IntegerType::get(mlir::MLIRContext*, unsigned int, mlir::IntegerType::SignednessSemantics) + 84
10 firtool                  0x000000010604427c circt::hw::ConstantOp::build(mlir::OpBuilder&, mlir::OperationState&, llvm::APInt const&) + 60
11 firtool                  0x0000000105ccaf6c circt::hw::ConstantOp mlir::OpBuilder::create<circt::hw::ConstantOp, llvm::APInt>(mlir::Location, llvm::APInt&&) + 132
12 firtool                  0x000000010515ea7c circt::seq::FirRegOp::canonicalize(circt::seq::FirRegOp, mlir::PatternRewriter&) + 588",,,,,,,,
6272,[LowerToHW] Error in firtool-1.54.0 Memory Lowering w/ Clock Type,2023-10-09T18:21:57Z,open,"bug, FIRRTL, HW","I ran into a bug with `firtool`'s lowering of FIRRTL memories. If you have a memory that includes a `Clock` type, then `LowerToHW` creates a wire of type `(i1) -> !seq.clock` which the verifier is unhappy about.

Example:

```
circuit Foo:
  module Foo:
    input r: {addr: UInt<3>, en: UInt<1> clk: Clock, flip data: {a: Clock}}
    input w: {addr: UInt<3>, en: UInt<1> clk: Clock, data: {a: Clock}, mask: {a: UInt<1>}}

    mem memory:
      data-type => {a: Clock}
      depth => 16
      reader => r
      writer => w
      read-latency => 1
      write-latency => 1
      read-under-write => undefined

    memory.r <= r
    memory.w <= w
```

Compiling with `firtool-1.54.0 Memory.fir`:
```
Memory.fir:6:5: error: 'hw.wire' op requires the same type for all operands and results
    mem memory:
    ^
Memory.fir:6:5: note: see current operation: %2 = ""hw.wire""(%5) {name = ""memory_r_data_a""} : (i1) -> !seq.clock
```

The failing MLIR is:
```mlir
#loc = loc(""Memory.fir"":3:11)
#loc1 = loc(""Memory.fir"":4:11)
""builtin.module""() ({
  ""hw.module""() ({
  ^bb0(%arg0: i3, %arg1: i1, %arg2: !seq.clock, %arg3: i3, %arg4: i1, %arg5: !seq.clock, %arg6: !seq.clock, %arg7: i1):
    %0 = ""hw.constant""() {value = false} : () -> i1
    %1 = ""hw.wire""(%7) {name = ""memory_r_addr""} : (i4) -> i4
    %2 = ""hw.wire""(%5) {name = ""memory_r_data_a""} : (i1) -> !seq.clock
    %3 = ""hw.wire""(%8) {name = ""memory_w_addr""} : (i4) -> i4
    %4 = ""seq.firmem""() <{name = ""memory_a"", prefix = """", readLatency = 1 : i32, ruw = 0 : i32, writeLatency = 1 : i32, wuw = 1 : i32}> : () -> !seq.firmem<16 x 1>
    %5 = ""seq.firmem.read_port""(%4, %1, %arg2, %arg1) : (!seq.firmem<16 x 1>, i4, !seq.clock, i1) -> i1
    %6 = ""comb.and""(%arg4, %arg7) <{twoState}> : (i1, i1) -> i1
    ""seq.firmem.write_port""(%4, %3, %arg5, %6, %arg6) <{operandSegmentSizes = array<i32: 1, 1, 1, 1, 1, 0>}> : (!seq.firmem<16 x 1>, i4, !seq.clock, i1, !seq.clock) -> ()
    %7 = ""comb.concat""(%0, %arg0) : (i1, i3) -> i4
    %8 = ""comb.concat""(%0, %arg3) : (i1, i3) -> i4
    ""hw.output""(%2) : (!seq.clock) -> ()
  }) {argLocs = [#loc, #loc, #loc, #loc1, #loc1, #loc1, #loc1, #loc1], argNames = [""r_addr"", ""r_en"", ""r_clk"", ""w_addr"", ""w_en"", ""w_clk"", ""w_data_a"", ""w_mask_a""], arg_attrs = [{}, {}, {}, {}, {}, {}, {}, {}], comment = """", function_type = (i3, i1, !seq.clock, i3, i1, !seq.clock, !seq.clock, i1) -> !seq.clock, parameters = [], res_attrs = [{}], resultLocs = [#loc], resultNames = [""r_data_a""], sym_name = ""Foo""} : () -> ()
}) : () -> ()
```

If I compile with `firtool-1.53.0 Memory.fir -disable-all-randomization`, I get the following Verilog:
```verilog
// Generated by CIRCT firtool-1.53.0
// VCS coverage exclude_file
module memory_a_16x1(
  input  [3:0] R0_addr,
  input        R0_en,
               R0_clk,
  input  [3:0] W0_addr,
  input        W0_en,
               W0_clk,
               W0_data,
  output       R0_data
);

  reg       Memory[0:15];
  reg       _R0_en_d0;
  reg [3:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 1'bx;
endmodule

module Foo(
  input  [2:0] r_addr,
  input        r_en,
               r_clk,
  input  [2:0] w_addr,
  input        w_en,
               w_clk,
               w_data_a,
               w_mask_a,
  output       r_data_a
);

  memory_a_16x1 memory_a_ext (
    .R0_addr ({1'h0, r_addr}),
    .R0_en   (r_en),
    .R0_clk  (r_clk),
    .W0_addr ({1'h0, w_addr}),
    .W0_en   (w_en & w_mask_a),
    .W0_clk  (w_clk),
    .W0_data (w_data_a),
    .R0_data (r_data_a)
  );
endmodule
```","circuit Foo:
  module Foo:
    input r: {addr: UInt<3>, en: UInt<1> clk: Clock, flip data: {a: Clock}}
    input w: {addr: UInt<3>, en: UInt<1> clk: Clock, data: {a: Clock}, mask: {a: UInt<1>}}

    mem memory:
      data-type => {a: Clock}
      depth => 16
      reader => r
      writer => w
      read-latency => 1
      write-latency => 1
      read-under-write => undefined

    memory.r <= r
    memory.w <= w","Memory.fir:6:5: error: 'hw.wire' op requires the same type for all operands and results
    mem memory:
    ^
Memory.fir:6:5: note: see current operation: %2 = ""hw.wire""(%5) {name = ""memory_r_data_a""} : (i1) -> !seq.clock","#loc = loc(""Memory.fir"":3:11)
#loc1 = loc(""Memory.fir"":4:11)
""builtin.module""() ({
  ""hw.module""() ({
  ^bb0(%arg0: i3, %arg1: i1, %arg2: !seq.clock, %arg3: i3, %arg4: i1, %arg5: !seq.clock, %arg6: !seq.clock, %arg7: i1):
    %0 = ""hw.constant""() {value = false} : () -> i1
    %1 = ""hw.wire""(%7) {name = ""memory_r_addr""} : (i4) -> i4
    %2 = ""hw.wire""(%5) {name = ""memory_r_data_a""} : (i1) -> !seq.clock
    %3 = ""hw.wire""(%8) {name = ""memory_w_addr""} : (i4) -> i4
    %4 = ""seq.firmem""() <{name = ""memory_a"", prefix = """", readLatency = 1 : i32, ruw = 0 : i32, writeLatency = 1 : i32, wuw = 1 : i32}> : () -> !seq.firmem<16 x 1>
    %5 = ""seq.firmem.read_port""(%4, %1, %arg2, %arg1) : (!seq.firmem<16 x 1>, i4, !seq.clock, i1) -> i1
    %6 = ""comb.and""(%arg4, %arg7) <{twoState}> : (i1, i1) -> i1
    ""seq.firmem.write_port""(%4, %3, %arg5, %6, %arg6) <{operandSegmentSizes = array<i32: 1, 1, 1, 1, 1, 0>}> : (!seq.firmem<16 x 1>, i4, !seq.clock, i1, !seq.clock) -> ()
    %7 = ""comb.concat""(%0, %arg0) : (i1, i3) -> i4
    %8 = ""comb.concat""(%0, %arg3) : (i1, i3) -> i4
    ""hw.output""(%2) : (!seq.clock) -> ()
  }) {argLocs = [#loc, #loc, #loc, #loc1, #loc1, #loc1, #loc1, #loc1], argNames = [""r_addr"", ""r_en"", ""r_clk"", ""w_addr"", ""w_en"", ""w_clk"", ""w_data_a"", ""w_mask_a""], arg_attrs = [{}, {}, {}, {}, {}, {}, {}, {}], comment = """", function_type = (i3, i1, !seq.clock, i3, i1, !seq.clock, !seq.clock, i1) -> !seq.clock, parameters = [], res_attrs = [{}], resultLocs = [#loc], resultNames = [""r_data_a""], sym_name = ""Foo""} : () -> ()
}) : () -> ()","// Generated by CIRCT firtool-1.53.0
// VCS coverage exclude_file
module memory_a_16x1(
  input  [3:0] R0_addr,
  input        R0_en,
               R0_clk,
  input  [3:0] W0_addr,
  input        W0_en,
               W0_clk,
               W0_data,
  output       R0_data
);

  reg       Memory[0:15];
  reg       _R0_en_d0;
  reg [3:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 1'bx;
endmodule

module Foo(
  input  [2:0] r_addr,
  input        r_en,
               r_clk,
  input  [2:0] w_addr,
  input        w_en,
               w_clk,
               w_data_a,
               w_mask_a,
  output       r_data_a
);

  memory_a_16x1 memory_a_ext (
    .R0_addr ({1'h0, r_addr}),
    .R0_en   (r_en),
    .R0_clk  (r_clk),
    .W0_addr ({1'h0, w_addr}),
    .W0_en   (w_en & w_mask_a),
    .W0_clk  (w_clk),
    .W0_data (w_data_a),
    .R0_data (r_data_a)
  );
endmodule",,,,,,
6259,[FIRRTL] MergeConnections Invalid IR for RWProbes,2023-10-05T21:09:00Z,closed,"bug, FIRRTL","I hit the following issue involving a RWProbe for the following FIRRTL:

```
FIRRTL version 3.1.0
circuit Foo : %[[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Foo|Foo>w""
  }
]]
  module Foo :
    output a : RWProbe<UInt<1>>

    wire w : { a : UInt<1>, flip b : UInt<2> }
    invalidate w.a
    invalidate w.b
    define a = rwprobe(w.a)
```

This errors out with invalid IR after `MergeConnections`:

```
6259.fir:12:5: error: 'firrtl.aggregateconstant' op Cannot have constant bundle type with flip
    invalidate w.a
    ^
6259.fir:12:5: note: see current operation: %1 = ""firrtl.aggregateconstant""() {fields = [0 : ui1, 0 : ui2]} : () -> !firrtl.bundle<a: uint<1>, b flip: uint<2>>
6259.fir:13:5: note: additional location here
    invalidate w.b
    ^
```

```mlir
""firrtl.module""() ({
^bb0(%arg0: !firrtl.rwprobe<uint<1>>):
  %0:2 = ""firrtl.wire""() {annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}], forceable, name = ""w"", nameKind = #firrtl<name_kind droppable_name>} : () -> (!firrtl.bundle<a: uint<1>, b flip: uint<2>>, !firrtl.rwprobe<bundle<a: uint<1>, b: uint<2>>>)
  %1 = ""firrtl.aggregateconstant""() {fields = [0 : ui1, 0 : ui2]} : () -> !firrtl.bundle<a: uint<1>, b flip: uint<2>>
  ""firrtl.connect""(%0#0, %1) : (!firrtl.bundle<a: uint<1>, b flip: uint<2>>, !firrtl.bundle<a: uint<1>, b flip: uint<2>>) -> ()
  %2 = ""firrtl.ref.sub""(%0#1) {index = 0 : i32} : (!firrtl.rwprobe<bundle<a: uint<1>, b: uint<2>>>) -> !firrtl.rwprobe<uint<1>>
  ""firrtl.ref.define""(%arg0, %2) : (!firrtl.rwprobe<uint<1>>, !firrtl.rwprobe<uint<1>>) -> ()
}) {annotations = [], convention = #firrtl<convention scalarized>, portAnnotations = [[]], portDirections = true, portLocations = [loc(""6259.fir"":9:12)], portNames = [""a""], portSyms = [], portTypes = [!firrtl.rwprobe<uint<1>>], sym_name = ""Foo""} : () -> ()
```

This is trying to build an aggregate constant with flips. 😕 ","FIRRTL version 3.1.0
circuit Foo : %[[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Foo|Foo>w""
  }
]]
  module Foo :
    output a : RWProbe<UInt<1>>

    wire w : { a : UInt<1>, flip b : UInt<2> }
    invalidate w.a
    invalidate w.b
    define a = rwprobe(w.a)","6259.fir:12:5: error: 'firrtl.aggregateconstant' op Cannot have constant bundle type with flip
    invalidate w.a
    ^
6259.fir:12:5: note: see current operation: %1 = ""firrtl.aggregateconstant""() {fields = [0 : ui1, 0 : ui2]} : () -> !firrtl.bundle<a: uint<1>, b flip: uint<2>>
6259.fir:13:5: note: additional location here
    invalidate w.b
    ^","""firrtl.module""() ({
^bb0(%arg0: !firrtl.rwprobe<uint<1>>):
  %0:2 = ""firrtl.wire""() {annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}], forceable, name = ""w"", nameKind = #firrtl<name_kind droppable_name>} : () -> (!firrtl.bundle<a: uint<1>, b flip: uint<2>>, !firrtl.rwprobe<bundle<a: uint<1>, b: uint<2>>>)
  %1 = ""firrtl.aggregateconstant""() {fields = [0 : ui1, 0 : ui2]} : () -> !firrtl.bundle<a: uint<1>, b flip: uint<2>>
  ""firrtl.connect""(%0#0, %1) : (!firrtl.bundle<a: uint<1>, b flip: uint<2>>, !firrtl.bundle<a: uint<1>, b flip: uint<2>>) -> ()
  %2 = ""firrtl.ref.sub""(%0#1) {index = 0 : i32} : (!firrtl.rwprobe<bundle<a: uint<1>, b: uint<2>>>) -> !firrtl.rwprobe<uint<1>>
  ""firrtl.ref.define""(%arg0, %2) : (!firrtl.rwprobe<uint<1>>, !firrtl.rwprobe<uint<1>>) -> ()
}) {annotations = [], convention = #firrtl<convention scalarized>, portAnnotations = [[]], portDirections = true, portLocations = [loc(""6259.fir"":9:12)], portNames = [""a""], portSyms = [], portTypes = [!firrtl.rwprobe<uint<1>>], sym_name = ""Foo""} : () -> ()",,,,,,,
6226,Mixed ssaName and true name fails to parse correctly,2023-09-29T21:51:37Z,open,bug,"See Bar3 below.
circt-opt foo.mlir --mlir-print-op-generic

```
hw.module @Bar0(in %0: i1) {
}

hw.module @Bar1(in %a: i1) {
}

hw.module @Bar2(in %0 ""space here"" : i1) {
}

hw.module @Bar3(in %b ""space here"" : i1) {
}
```","hw.module @Bar0(in %0: i1) {
}

hw.module @Bar1(in %a: i1) {
}

hw.module @Bar2(in %0 ""space here"" : i1) {
}

hw.module @Bar3(in %b ""space here"" : i1) {
}",,,,,,,,,
6193,[FIRRTL][firtool] Unknown Windows Release Build Test Failures,2023-09-23T04:21:45Z,open,"bug, FIRRTL","There have been a number of odd test failures that have been observed on Windows release builds.

## Failures

### First Failure

A commit, https://github.com/llvm/circt/commit/3668f6760f9c7ca814035292435f930e30320fea, enabling properties as attributes in the Seq dialect resulted in similar failures in one test. See: https://github.com/llvm/circt/actions/runs/6043611927/job/16400911216 This corrected itself on the subsequent commit, https://github.com/llvm/circt/commit/c88186e18a74fe74e2d2bdb7de2610a0334eaa7d, passed.

The failing test was:
  - `Dialect/FIRRTL/SFCTests/width-spec-errors.fir`

The exit code was: 3221225477

### Second Failure

A commit adding two folders, https://github.com/llvm/circt/commit/68b79fc35fcc2d68abc8a0b830c0f5a303af3f04, failed intermittently. See: https://github.com/llvm/circt/actions/runs/6083208189/job/16502633046. This then passed on retry: https://github.com/llvm/circt/actions/runs/6083208189.

The failing test was:
  - `Dialect/FIRRTL/SFCTests/data-taps-flip.fir`

The exit code was: 3221225477

There was no stack trace.

### Third Failure

Commit https://github.com/llvm/circt/commit/3b6f737c360fa19e3f16f9ea4856128f36ce9296 made a change that disabled deduplication. This caused four tests to fail repeatedly. One such run is: https://github.com/llvm/circt/actions/runs/6278904029/job/17056030822

The failing tests were:
  - `Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/Wire.fir`
  - `Dialect/FIRRTL/SFCTests/data-taps.fir`
  - `firtool/prefixMemory.fir`
  - `firtool/refs-in-aggs.fir`

Only `firtool/prefixMemory.fir` was a test that was sensitive to deduplication and required modifications, in the commit, to fix.

This was ""fixed"" by adding a `-no-dedup` option to `firtool` and using it for those four tests. It is unclear if this actually ""fixed"" anything, i.e., if the issue was that not running deduplication fixed it or if this just permuted the sources enough to get `cl` to produce something that didn't crash.

The exit code was: 0xc0000005

There was a stack trace. (This isn't particularly useful as it is a release build...) Example:

```
 #0 0x00007ff7b9dca204 (d:\a\circt\circt\build\bin\firtool.exe+0x1fa204)
 #1 0x00007ff7b9dd00a1 (d:\a\circt\circt\build\bin\firtool.exe+0x2000a1)
 #2 0x00007ff7ba5f0107 (d:\a\circt\circt\build\bin\firtool.exe+0xa20107)
 #3 0x00007ff7ba5f5a27 (d:\a\circt\circt\build\bin\firtool.exe+0xa25a27)
 #4 0x00007ff7ba5f7529 (d:\a\circt\circt\build\bin\firtool.exe+0xa27529)
 #5 0x00007ff7ba5f0616 (d:\a\circt\circt\build\bin\firtool.exe+0xa20616)
 #6 0x00007ff7ba5f6ee2 (d:\a\circt\circt\build\bin\firtool.exe+0xa26ee2)
 #7 0x00007ff7ba5f00f2 (d:\a\circt\circt\build\bin\firtool.exe+0xa200f2)
 #8 0x00007ff7ba5f5a27 (d:\a\circt\circt\build\bin\firtool.exe+0xa25a27)
 #9 0x00007ff7ba5f61fd (d:\a\circt\circt\build\bin\firtool.exe+0xa261fd)
#10 0x00007ff7b9be0544 (d:\a\circt\circt\build\bin\firtool.exe+0x10544)
#11 0x00007ff7b9be09ff (d:\a\circt\circt\build\bin\firtool.exe+0x109ff)
#12 0x00007ff7b9bdee3b (d:\a\circt\circt\build\bin\firtool.exe+0xee3b)
#13 0x00007ff7b9be26df (d:\a\circt\circt\build\bin\firtool.exe+0x126df)
#14 0x00007ff7ba60d560 (d:\a\circt\circt\build\bin\firtool.exe+0xa3d560)
#15 0x00007ffe8a4c7ac4 (C:\Windows\System32\KERNEL32.DLL+0x17ac4)
#16 0x00007ffe8bfda351 (C:\Windows\SYSTEM32\ntdll.dll+0x5a351)
```

Just before the third test, the windows build failed on the previous commit twice. This appeared to be due to issues running PowerShell's `Install-Package`. The two failures were:

```
WARNING: Unable to resolve package source 'https://www.powershellgallery.com/api/v2'.
Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all
available registered module repositories.

Error: Process completed with exit code 1.
```

```
Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all
available registered module repositories.

Error: Process completed with exit code 1.
```

This appears unrelated, though it has high temporal locality to the third failure.

For the third failure, I tried a clean rebuild by deleting all `sccache` caches. This again failed in the same way after a 3 hour complete rebuild.

## Analysis

1. All tests involved `firtool` end-to-end tests. 
2. All tests were some kind of hard crash with exit codes 3221225477 or 0xc0000005. (This is the same number, but the latter seems to produce a stack trace and the former does not.)
3. The third test would repeatedly fail. The second test was intermittent. It is unknown if the first test was intermittent or repeatable.

## Ideas to try

1. The Unified Build/Test/Install GitHub Action does support running a Windows build in debug mode or relwithdebinfo. This won't have caching and will be about 3 hours to run.
2. More UBSan or other sanitizers. Is there a way to run these on Windows?","#0 0x00007ff7b9dca204 (d:\a\circt\circt\build\bin\firtool.exe+0x1fa204)
 #1 0x00007ff7b9dd00a1 (d:\a\circt\circt\build\bin\firtool.exe+0x2000a1)
 #2 0x00007ff7ba5f0107 (d:\a\circt\circt\build\bin\firtool.exe+0xa20107)
 #3 0x00007ff7ba5f5a27 (d:\a\circt\circt\build\bin\firtool.exe+0xa25a27)
 #4 0x00007ff7ba5f7529 (d:\a\circt\circt\build\bin\firtool.exe+0xa27529)
 #5 0x00007ff7ba5f0616 (d:\a\circt\circt\build\bin\firtool.exe+0xa20616)
 #6 0x00007ff7ba5f6ee2 (d:\a\circt\circt\build\bin\firtool.exe+0xa26ee2)
 #7 0x00007ff7ba5f00f2 (d:\a\circt\circt\build\bin\firtool.exe+0xa200f2)
 #8 0x00007ff7ba5f5a27 (d:\a\circt\circt\build\bin\firtool.exe+0xa25a27)
 #9 0x00007ff7ba5f61fd (d:\a\circt\circt\build\bin\firtool.exe+0xa261fd)
#10 0x00007ff7b9be0544 (d:\a\circt\circt\build\bin\firtool.exe+0x10544)
#11 0x00007ff7b9be09ff (d:\a\circt\circt\build\bin\firtool.exe+0x109ff)
#12 0x00007ff7b9bdee3b (d:\a\circt\circt\build\bin\firtool.exe+0xee3b)
#13 0x00007ff7b9be26df (d:\a\circt\circt\build\bin\firtool.exe+0x126df)
#14 0x00007ff7ba60d560 (d:\a\circt\circt\build\bin\firtool.exe+0xa3d560)
#15 0x00007ffe8a4c7ac4 (C:\Windows\System32\KERNEL32.DLL+0x17ac4)
#16 0x00007ffe8bfda351 (C:\Windows\SYSTEM32\ntdll.dll+0x5a351)","WARNING: Unable to resolve package source 'https://www.powershellgallery.com/api/v2'.
Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all
available registered module repositories.

Error: Process completed with exit code 1.","Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all
available registered module repositories.

Error: Process completed with exit code 1.",,,,,,,
6103,"[FIRRTL] Uninitialized input port error for Integer input, IMDCE bug",2023-09-11T17:02:48Z,closed,"bug, FIRRTL","Simple class with input driven by an integer:

```firrtl
FIRRTL version 3.2.0
circuit InputProp:
  class Test :
    input in : Integer

  module InputProp:
    object o of Test
    propassign o.in, Integer(5)
```

MLIR before lower-classes:
```mlir
module {
  firrtl.circuit ""InputProp"" {
    firrtl.class private @Test(in %in: !firrtl.integer) {
    }
    firrtl.module @InputProp() attributes {convention = #firrtl<convention scalarized>} {
      %o = firrtl.object @Test(in in: !firrtl.integer)
      %0 = firrtl.object.subfield %o[in] : !firrtl.class<@Test(in in: !firrtl.integer)>
      %1 = firrtl.integer 5
      firrtl.propassign %0, %1 : !firrtl.integer
    }
  }
}
```","FIRRTL version 3.2.0
circuit InputProp:
  class Test :
    input in : Integer

  module InputProp:
    object o of Test
    propassign o.in, Integer(5)","module {
  firrtl.circuit ""InputProp"" {
    firrtl.class private @Test(in %in: !firrtl.integer) {
    }
    firrtl.module @InputProp() attributes {convention = #firrtl<convention scalarized>} {
      %o = firrtl.object @Test(in in: !firrtl.integer)
      %0 = firrtl.object.subfield %o[in] : !firrtl.class<@Test(in in: !firrtl.integer)>
      %1 = firrtl.integer 5
      firrtl.propassign %0, %1 : !firrtl.integer
    }
  }
}",,,,,,,,
6076,[FIRRTL][IMCP] Fix deleting part of probe data-flow through wires,2023-09-07T22:44:22Z,closed,"bug, FIRRTL","Input:
```mlir
firrtl.circuit ""WireProbe"" {
  firrtl.module @WireProbe(out %p : !firrtl.probe<uint<5>>) {
    %x = firrtl.constant 0: !firrtl.uint<5>
    %0 = firrtl.ref.send %x : !firrtl.uint<5>
    %w = firrtl.wire : !firrtl.probe<uint<5>>
    firrtl.ref.define %w, %0: !firrtl.probe<uint<5>>
    firrtl.ref.define %p, %w : !firrtl.probe<uint<5>>
  }
}
```

Sending through `circt-opt --firrtl-imconstprop` produces the following, deleting what feeds the wire but leaving it there.

```mlir
module {
  firrtl.circuit ""WireProbe"" {
    firrtl.module @WireProbe(out %p: !firrtl.probe<uint<5>>) {
      %w = firrtl.wire : !firrtl.probe<uint<5>>
      firrtl.ref.define %p, %w : !firrtl.probe<uint<5>>
    }
  }
}
```","firrtl.circuit ""WireProbe"" {
  firrtl.module @WireProbe(out %p : !firrtl.probe<uint<5>>) {
    %x = firrtl.constant 0: !firrtl.uint<5>
    %0 = firrtl.ref.send %x : !firrtl.uint<5>
    %w = firrtl.wire : !firrtl.probe<uint<5>>
    firrtl.ref.define %w, %0: !firrtl.probe<uint<5>>
    firrtl.ref.define %p, %w : !firrtl.probe<uint<5>>
  }
}","module {
  firrtl.circuit ""WireProbe"" {
    firrtl.module @WireProbe(out %p: !firrtl.probe<uint<5>>) {
      %w = firrtl.wire : !firrtl.probe<uint<5>>
      firrtl.ref.define %p, %w : !firrtl.probe<uint<5>>
    }
  }
}",,,,,,,,
6074,[FIRRTL] Add missing dialect dependencies,2023-09-07T21:54:58Z,open,"bug, FIRRTL","LowerXMR and LowerToHW, at least, may lower/introduce operations from HW, SV, and Seq dialects.

Fix the dependentDialects to ensure this works properly (such as when invoking via `circt-opt`).

Current failing example to demonstrate:

```mlir
firrtl.circuit ""ClockProbe"" {
  firrtl.module @ClockProbe(in %in: !firrtl.clock, out %out: !firrtl.clock) attributes {convention = #firrtl<convention scalarized>} {
    %0 = firrtl.ref.send %in : !firrtl.clock
    %1 = firrtl.ref.resolve %0 : !firrtl.probe<clock>
    firrtl.strictconnect %out, %1 : !firrtl.clock
  }
}
```

Which presently errors out when running `circt-opt --firrtl-lower-xmr`:
```
LLVM ERROR: can't create type 'circt::seq::ClockType' because storage uniquer isn't initialized: the dialect was likely not loaded, or the type wasn't added with addTypes<...>() in the Dialect::initialize() method.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/circt-opt --firrtl-lower-xmr ./clock-probe.mlir
```","firrtl.circuit ""ClockProbe"" {
  firrtl.module @ClockProbe(in %in: !firrtl.clock, out %out: !firrtl.clock) attributes {convention = #firrtl<convention scalarized>} {
    %0 = firrtl.ref.send %in : !firrtl.clock
    %1 = firrtl.ref.resolve %0 : !firrtl.probe<clock>
    firrtl.strictconnect %out, %1 : !firrtl.clock
  }
}","LLVM ERROR: can't create type 'circt::seq::ClockType' because storage uniquer isn't initialized: the dialect was likely not loaded, or the type wasn't added with addTypes<...>() in the Dialect::initialize() method.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/circt-opt --firrtl-lower-xmr ./clock-probe.mlir",,,,,,,,
6072,[ExtractTestCode?] Port Order Flipped for Extracted Covers,2023-09-07T20:07:41Z,closed,"bug, ExportVerilog","I noticed the following change between firrtl 1.53.0 and top-of-tree:

```
FIRRTL version 3.1.0
FIRRTL version 3.1.0
circuit TestHarness :
  module DUTTop :
    input clock : Clock
    input in: UInt<1>

    when in :
      printf(clock, UInt<1>(0h1), ""cover:hello:world\n"")

  module TestHarness :
    input clock : Clock
    input in: UInt<1>

    inst dut of DUTTop
    connect dut.clock, clock
    connect dut.in, in
```

If I compile this with firtool-1.53.0 (`firtool-1.53.0 -extract-test-code CoverOrder.fir -disable-all-randomization -split-verilog -o CoverOrder && cat CoverOrder/DUTTop_cover.sv`), I get:

```verilog
// Generated by CIRCT firtool-1.53.0
// VCS coverage exclude_file
module DUTTop_cover(
  input clock,
        in
);

  cover__hello: cover property (@(posedge clock) in);
endmodule
```

If I compile with top-of-tree (`firtool -extract-test-code CoverOrder.fir -disable-all-randomization -split-verilog -o CoverOrder && cat CoverOrder/DUTTop_cover.sv`), I get:

```verilog
// Generated by CIRCT firtool-1.53.0-56-g5bccfd8b3
// VCS coverage exclude_file
module DUTTop_cover(
  input in,
        clock
);

  cover__hello: cover property (@(posedge clock) in);
endmodule
```

The port order flipped. 😕","FIRRTL version 3.1.0
FIRRTL version 3.1.0
circuit TestHarness :
  module DUTTop :
    input clock : Clock
    input in: UInt<1>

    when in :
      printf(clock, UInt<1>(0h1), ""cover:hello:world\n"")

  module TestHarness :
    input clock : Clock
    input in: UInt<1>

    inst dut of DUTTop
    connect dut.clock, clock
    connect dut.in, in","// Generated by CIRCT firtool-1.53.0
// VCS coverage exclude_file
module DUTTop_cover(
  input clock,
        in
);

  cover__hello: cover property (@(posedge clock) in);
endmodule","// Generated by CIRCT firtool-1.53.0-56-g5bccfd8b3
// VCS coverage exclude_file
module DUTTop_cover(
  input in,
        clock
);

  cover__hello: cover property (@(posedge clock) in);
endmodule",,,,,,,
6061,[FIRRTL][Dedup] Don't crash on classes,2023-09-06T16:52:26Z,closed,"bug, FIRRTL","Input:
```firrtl
FIRRTL version 3.2.0
circuit ClassSpec_Anon :
  class Test :
    input in : Integer @[src/test/scala/chiselTests/properties/ClassSpec.scala 114:20]
    output out : Integer @[src/test/scala/chiselTests/properties/ClassSpec.scala 115:21]

    propassign out, in @[src/test/scala/chiselTests/properties/ClassSpec.scala 116:13]

  module ClassSpec_Anon :

    object obj1 of Test @[src/test/scala/chiselTests/properties/ClassSpec.scala 119:46]
    object obj2 of Test @[src/test/scala/chiselTests/properties/ClassSpec.scala 120:46]
```

Running `firtool -dedup` on this crashes with:
```
firtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = circt::firrtl::InstanceOp, From = circt::igraph::InstanceOpInterface]: Assertion `isa<To>(Val) && ""cast<Ty>() argument of incompatible type!""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool class-crash.fir -dedup
 #0 0x000055d94ec24c96 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13
 #1 0x000055d94ec22d20 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18
 #2 0x000055d94ec2532b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007f86e642bd30 __restore_rt (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38d30)
 #4 0x00007f86e647aa8c __pthread_kill_implementation (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x87a8c)
 #5 0x00007f86e642bc86 gsignal (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38c86)
 #6 0x00007f86e64158ba abort (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x228ba)
 #7 0x00007f86e64157d9 _nl_load_domain.cold (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x227d9)
 #8 0x00007f86e64249c6 (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x319c6)
 #9 0x000055d94eceb505 llvm::ilist_iterator<llvm::ilist_detail::node_options<circt::igraph::InstanceGraphNode, true, false, void>, false, false>::operator*() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist_iterator.h:138:5
#10 0x000055d94eceb505 llvm::mapped_iterator<llvm::ilist_iterator<llvm::ilist_detail::node_options<circt::igraph::InstanceGraphNode, true, false, void>, false, false>, circt::igraph::InstanceGraphNode* (*)(circt::igraph::InstanceGraphNode&), circt::igraph::InstanceGraphNode*>::operator*() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:364:44
#11 0x000055d94eceb505 fixupAllModules(circt::firrtl::InstanceGraph&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/Dedup.cpp:1386:19
#12 0x000055d94eced206 (anonymous namespace)::DedupPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/Dedup.cpp:0:5
#13 0x000055d94f6a0c5f mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:17
#14 0x000055d94f6a0c5f void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
#15 0x000055d94f6a0c5f llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
#16 0x000055d94f6a0c5f void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7
#17 0x000055d94f6a0c5f mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:497:21
#18 0x000055d94f6a14a2 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#19 0x000055d94f6a14a2 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#20 0x000055d94f6a14a2 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:569:9
#21 0x000055d94f6a4716 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:794:5
#22 0x000055d94f6a27bb mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#23 0x000055d94f6a27bb mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#24 0x000055d94f6a27bb mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:11
#25 0x000055d94f6a27bb mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#26 0x000055d94f6a27bb mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:799:14
#27 0x000055d94f6a0e18 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5
#28 0x000055d94f6a0e18 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:501:20
#29 0x000055d94f6a0e18 void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
#30 0x000055d94f6a0e18 llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
#31 0x000055d94f6a0e18 void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7
#32 0x000055d94f6a0e18 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:497:21
#33 0x000055d94f6a35a5 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#34 0x000055d94f6a35a5 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#35 0x000055d94f6a35a5 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:569:9
#36 0x000055d94f6a35a5 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:880:10
#37 0x000055d94f6a35a5 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:860:60
#38 0x000055d94eb763ab mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#39 0x000055d94eb763ab mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#40 0x000055d94eb763ab processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:412:7
#41 0x000055d94eb752b8 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:484:12
#42 0x000055d94eb74e25 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:500:12
#43 0x000055d94eb74e25 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:585:14
#44 0x000055d94eb74a0f mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#45 0x000055d94eb74a0f mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#46 0x000055d94eb74a0f main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:656:8
#47 0x00007f86e6416ace __libc_start_call_main (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x23ace)
#48 0x00007f86e6416b89 __libc_start_main@GLIBC_2.2.5 (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x23b89)
#49 0x000055d94eb74825 _start (./build/bin/firtool+0x584825)
```

May be an InstanceGraph thing, not dedup, not sure.

```
$ firtool --version
LLVM (http://llvm.org/):
  LLVM version 18.0.0git
  Optimized build with assertions.
CIRCT firtool-1.53.0-40-gbcaeecf2d
```","FIRRTL version 3.2.0
circuit ClassSpec_Anon :
  class Test :
    input in : Integer @[src/test/scala/chiselTests/properties/ClassSpec.scala 114:20]
    output out : Integer @[src/test/scala/chiselTests/properties/ClassSpec.scala 115:21]

    propassign out, in @[src/test/scala/chiselTests/properties/ClassSpec.scala 116:13]

  module ClassSpec_Anon :

    object obj1 of Test @[src/test/scala/chiselTests/properties/ClassSpec.scala 119:46]
    object obj2 of Test @[src/test/scala/chiselTests/properties/ClassSpec.scala 120:46]","firtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = circt::firrtl::InstanceOp, From = circt::igraph::InstanceOpInterface]: Assertion `isa<To>(Val) && ""cast<Ty>() argument of incompatible type!""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool class-crash.fir -dedup
 #0 0x000055d94ec24c96 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13
 #1 0x000055d94ec22d20 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18
 #2 0x000055d94ec2532b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007f86e642bd30 __restore_rt (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38d30)
 #4 0x00007f86e647aa8c __pthread_kill_implementation (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x87a8c)
 #5 0x00007f86e642bc86 gsignal (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38c86)
 #6 0x00007f86e64158ba abort (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x228ba)
 #7 0x00007f86e64157d9 _nl_load_domain.cold (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x227d9)
 #8 0x00007f86e64249c6 (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x319c6)
 #9 0x000055d94eceb505 llvm::ilist_iterator<llvm::ilist_detail::node_options<circt::igraph::InstanceGraphNode, true, false, void>, false, false>::operator*() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist_iterator.h:138:5
#10 0x000055d94eceb505 llvm::mapped_iterator<llvm::ilist_iterator<llvm::ilist_detail::node_options<circt::igraph::InstanceGraphNode, true, false, void>, false, false>, circt::igraph::InstanceGraphNode* (*)(circt::igraph::InstanceGraphNode&), circt::igraph::InstanceGraphNode*>::operator*() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:364:44
#11 0x000055d94eceb505 fixupAllModules(circt::firrtl::InstanceGraph&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/Dedup.cpp:1386:19
#12 0x000055d94eced206 (anonymous namespace)::DedupPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/Dedup.cpp:0:5
#13 0x000055d94f6a0c5f mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:17
#14 0x000055d94f6a0c5f void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
#15 0x000055d94f6a0c5f llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
#16 0x000055d94f6a0c5f void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7
#17 0x000055d94f6a0c5f mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:497:21
#18 0x000055d94f6a14a2 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#19 0x000055d94f6a14a2 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#20 0x000055d94f6a14a2 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:569:9
#21 0x000055d94f6a4716 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:794:5
#22 0x000055d94f6a27bb mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#23 0x000055d94f6a27bb mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#24 0x000055d94f6a27bb mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:11
#25 0x000055d94f6a27bb mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#26 0x000055d94f6a27bb mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:799:14
#27 0x000055d94f6a0e18 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5
#28 0x000055d94f6a0e18 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:501:20
#29 0x000055d94f6a0e18 void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
#30 0x000055d94f6a0e18 llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
#31 0x000055d94f6a0e18 void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7
#32 0x000055d94f6a0e18 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:497:21
#33 0x000055d94f6a35a5 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#34 0x000055d94f6a35a5 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#35 0x000055d94f6a35a5 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:569:9
#36 0x000055d94f6a35a5 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:880:10
#37 0x000055d94f6a35a5 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:860:60
#38 0x000055d94eb763ab mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#39 0x000055d94eb763ab mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#40 0x000055d94eb763ab processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:412:7
#41 0x000055d94eb752b8 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:484:12
#42 0x000055d94eb74e25 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:500:12
#43 0x000055d94eb74e25 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:585:14
#44 0x000055d94eb74a0f mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#45 0x000055d94eb74a0f mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#46 0x000055d94eb74a0f main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:656:8
#47 0x00007f86e6416ace __libc_start_call_main (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x23ace)
#48 0x00007f86e6416b89 __libc_start_main@GLIBC_2.2.5 (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x23b89)
#49 0x000055d94eb74825 _start (./build/bin/firtool+0x584825)","$ firtool --version
LLVM (http://llvm.org/):
  LLVM version 18.0.0git
  Optimized build with assertions.
CIRCT firtool-1.53.0-40-gbcaeecf2d",,,,,,,
6059,[FIRRTL][IMDCE] Annotations on ports are not preserved when moving to wires,2023-09-06T16:02:17Z,open,"bug, FIRRTL","Input:
```mlir
// -----
// Test that annotations keep ports alive.
// CHECK-LABEL: ""AnnoAlivePort""
firrtl.circuit ""AnnoAlivePort"" {
  // CHECK: module private @AnnoPort
  firrtl.module private @AnnoPort(out %dead : !firrtl.uint<5> [{class = ""circt.test""}]) {}
  firrtl.module @AnnoAlivePort() {
    // CHECK: firrtl.instance
    %inst_dead = firrtl.instance inst @AnnoPort(out dead : !firrtl.uint<5>)
  }
}
```

The port is dead at instantiation sites but alive within the module, so port is dropped and wire is created for it (maybe it's written/read locally, so on).

Looks like annotations are not moved to the wire, however, here's the current output pointing IMDCE at the above:
```mlir
firrtl.circuit ""AnnoAlivePort"" {
  firrtl.module private @AnnoPort() {
    %0 = firrtl.wire : !firrtl.uint<5>
  }
  firrtl.module @AnnoAlivePort() {
    firrtl.instance inst @AnnoPort()
  }
}
```

cc #6046 for more discussion on annotations and IMDCE, but not directly related.","// -----
// Test that annotations keep ports alive.
// CHECK-LABEL: ""AnnoAlivePort""
firrtl.circuit ""AnnoAlivePort"" {
  // CHECK: module private @AnnoPort
  firrtl.module private @AnnoPort(out %dead : !firrtl.uint<5> [{class = ""circt.test""}]) {}
  firrtl.module @AnnoAlivePort() {
    // CHECK: firrtl.instance
    %inst_dead = firrtl.instance inst @AnnoPort(out dead : !firrtl.uint<5>)
  }
}","firrtl.circuit ""AnnoAlivePort"" {
  firrtl.module private @AnnoPort() {
    %0 = firrtl.wire : !firrtl.uint<5>
  }
  firrtl.module @AnnoAlivePort() {
    firrtl.instance inst @AnnoPort()
  }
}",,,,,,,,
6035,[FIRRTL] ExtModule Ordering Affects File Emission,2023-09-02T04:27:58Z,closed,"bug, FIRRTL","An internal user reported that BlackBoxes have started showing up in unexpected situations. The problem is that when an external module with a `BlackBoxInlineAnno` does not dedup for valid reasons, e.g., it has different parameters or the user doesn't run dedup, then the order in which the external modules are declared determines the file order.

Consider the following example. Here, whichever of `BlackBox_1`, `BlackBox_2`, or `BlackBox_3` is declared _first_ will determine if the blackbox is, respectively, created in the `testbench/`, `./` (main design/DUT), or `gct/` directories.

```
FIRRTL version 4.0.0
circuit TestHarness: %[[
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~TestHarness|GrandCentral"",
    ""parent"": ""~TestHarness|TestHarness"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""Interface"",
      ""elements"": [
        {
          ""name"": ""uint"",
          ""description"": ""a wire called 'uint'"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""TestHarness"",
              ""module"": ""DUT"",
              ""path"": [],
              ""ref"": ""a"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  },
  {
    ""class"": ""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"": ""~TestHarness|DUT""
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"": ""gct"",
    ""filename"": ""bindings.sv""
  },
  {
    ""class"": ""sifive.enterprise.firrtl.TestBenchDirAnnotation"",
    ""dirname"": ""testbench""
  },
  {
    ""class"": ""firrtl.transforms.BlackBoxInlineAnno"",
    ""target"": ""~TestHarness|BlackBox_1"",
    ""name"": ""BlackBox.sv"",
    ""text"": ""// BlackBox_1\nmodule BlackBox #(parameter X=0)(output a);\nendmodule""
  },
  {
    ""class"": ""firrtl.transforms.BlackBoxInlineAnno"",
    ""target"": ""~TestHarness|BlackBox_2"",
    ""name"": ""BlackBox.sv"",
    ""text"": ""// BlackBox_2\nmodule BlackBox #(parameter X=0)(output a);\nendmodule""
  },
  {
    ""class"": ""firrtl.transforms.BlackBoxInlineAnno"",
    ""target"": ""~TestHarness|BlackBox_3"",
    ""name"": ""BlackBox.sv"",
    ""text"": ""// BlackBox_3\nmodule BlackBox #(parameter X=0)(output a);\nendmodule""
  },
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""target"":""~TestHarness|DUT"",
    ""prefix"":""SiFive_"",
    ""inclusive"":true
  }
]]

  extmodule BlackBox_1:
    output a: UInt<1>
    defname = BlackBox
    parameter X = 1

  extmodule BlackBox_2:
    output a: UInt<1>
    defname = BlackBox
    parameter X = 2

  extmodule BlackBox_3:
    output a: UInt<1>
    defname = BlackBox
    parameter X = 3

  module TestHarness:

    inst dut of DUT
    inst bbox of BlackBox_1

  module DUT:

    wire a: UInt<1>
    invalidate a

    inst bbox of BlackBox_2
    inst grandCentral of GrandCentral

  module GrandCentral:

    inst bbox of BlackBox_3
```

The three possible results are:

```verilog
// ----- 8< ----- FILE ""testbench/BlackBox.sv"" ----- 8< -----

// Generated by CIRCT firtool-1.52.0-152-gb07e210c1
// BlackBox_1
module BlackBox #(parameter X=0)(output a);
endmodule
```

```verilog
// ----- 8< ----- FILE ""./BlackBox.sv"" ----- 8< -----

// Generated by CIRCT firtool-1.52.0-152-gb07e210c1
// BlackBox_2
module BlackBox #(parameter X=0)(output a);
endmodule
```

```verilog
// ----- 8< ----- FILE ""gct/BlackBox.sv"" ----- 8< -----

// Generated by CIRCT firtool-1.52.0-152-gb07e210c1
// BlackBox_3
module BlackBox #(parameter X=0)(output a);
endmodule
```

Note: that this is ignoring a whole separate class of errors where the actual content of the `BlackBoxInlineAnno` annotation is not verified in any way. I placed a different comment in each of them. Put differently, it's dangerous to rely on `defname` with `BlackBoxInlineAnno` blindly. This should at least be checked that these are the same.","FIRRTL version 4.0.0
circuit TestHarness: %[[
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~TestHarness|GrandCentral"",
    ""parent"": ""~TestHarness|TestHarness"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""Interface"",
      ""elements"": [
        {
          ""name"": ""uint"",
          ""description"": ""a wire called 'uint'"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""TestHarness"",
              ""module"": ""DUT"",
              ""path"": [],
              ""ref"": ""a"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  },
  {
    ""class"": ""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"": ""~TestHarness|DUT""
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"": ""gct"",
    ""filename"": ""bindings.sv""
  },
  {
    ""class"": ""sifive.enterprise.firrtl.TestBenchDirAnnotation"",
    ""dirname"": ""testbench""
  },
  {
    ""class"": ""firrtl.transforms.BlackBoxInlineAnno"",
    ""target"": ""~TestHarness|BlackBox_1"",
    ""name"": ""BlackBox.sv"",
    ""text"": ""// BlackBox_1\nmodule BlackBox #(parameter X=0)(output a);\nendmodule""
  },
  {
    ""class"": ""firrtl.transforms.BlackBoxInlineAnno"",
    ""target"": ""~TestHarness|BlackBox_2"",
    ""name"": ""BlackBox.sv"",
    ""text"": ""// BlackBox_2\nmodule BlackBox #(parameter X=0)(output a);\nendmodule""
  },
  {
    ""class"": ""firrtl.transforms.BlackBoxInlineAnno"",
    ""target"": ""~TestHarness|BlackBox_3"",
    ""name"": ""BlackBox.sv"",
    ""text"": ""// BlackBox_3\nmodule BlackBox #(parameter X=0)(output a);\nendmodule""
  },
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""target"":""~TestHarness|DUT"",
    ""prefix"":""SiFive_"",
    ""inclusive"":true
  }
]]

  extmodule BlackBox_1:
    output a: UInt<1>
    defname = BlackBox
    parameter X = 1

  extmodule BlackBox_2:
    output a: UInt<1>
    defname = BlackBox
    parameter X = 2

  extmodule BlackBox_3:
    output a: UInt<1>
    defname = BlackBox
    parameter X = 3

  module TestHarness:

    inst dut of DUT
    inst bbox of BlackBox_1

  module DUT:

    wire a: UInt<1>
    invalidate a

    inst bbox of BlackBox_2
    inst grandCentral of GrandCentral

  module GrandCentral:

    inst bbox of BlackBox_3","// ----- 8< ----- FILE ""testbench/BlackBox.sv"" ----- 8< -----

// Generated by CIRCT firtool-1.52.0-152-gb07e210c1
// BlackBox_1
module BlackBox #(parameter X=0)(output a);
endmodule","// ----- 8< ----- FILE ""./BlackBox.sv"" ----- 8< -----

// Generated by CIRCT firtool-1.52.0-152-gb07e210c1
// BlackBox_2
module BlackBox #(parameter X=0)(output a);
endmodule","// ----- 8< ----- FILE ""gct/BlackBox.sv"" ----- 8< -----

// Generated by CIRCT firtool-1.52.0-152-gb07e210c1
// BlackBox_3
module BlackBox #(parameter X=0)(output a);
endmodule",,,,,,
6029,[FIRRTL] LowerClasses Support ExtModules,2023-09-01T19:28:05Z,closed,"bug, FIRRTL","Currently, FIRRTL external modules with either input or output property ports error during `LowerClasses`.

I haven't thought through exactly how this should work in terms of lowering. At a high level, this needs to work such that two OMIR dialect blobs are produced and then these are combined by the OMIR linker.

### Input Ports

```
FIRRTL version 4.0.0
circuit Foo:
  extmodule Bar:
    input a: Integer

  module Foo:
    inst bar of Bar
    propassign bar.a, Integer(42)
```

```
# firtool firrtl-snippets/ExtModuleInputProperty.fir
Assertion failed: (Index < this->size() && ""Invalid index!""), function operator[], file ArrayRef.h, line 443.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: firtool firrtl-snippets/ExtModuleInputProperty.fir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x00000001031ee300 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 88
1  firtool                  0x00000001031ee91c PrintStackTraceSignalHandler(void*) + 28
2  firtool                  0x00000001031ec4b0 llvm::sys::RunSignalHandlers() + 152
3  firtool                  0x00000001031efbf4 SignalHandler(int) + 276
4  libsystem_platform.dylib 0x0000000190b42a24 _sigtramp + 56
5  libsystem_pthread.dylib  0x0000000190b13c28 pthread_kill + 288
6  libsystem_c.dylib        0x0000000190a21ae8 abort + 180
7  libsystem_c.dylib        0x0000000190a20e44 err + 0
8  firtool                  0x00000001038a6338 llvm::MutableArrayRef<mlir::BlockArgument>::operator[](unsigned long) const + 124
9  firtool                  0x00000001038a619c mlir::Region::getArgument(unsigned int) + 56
10 firtool                  0x0000000103530344 (anonymous namespace)::LowerClassesPass::lowerClass((anonymous namespace)::ClassLoweringState&) + 604
```

### Output Ports

```
FIRRTL version 4.0.0
circuit Foo:
  extmodule Bar:
    output a: Integer

  module Foo:
    output a: Integer
    inst bar of Bar
    propassign a, bar.a
```

```
# firtool firrtl-snippets/ExtModuleOutputProperty.fir                         
firrtl-snippets/ExtModuleOutputProperty.fir:8:5: error: failed to legalize operation 'firrtl.instance' that was explicitly marked illegal
    inst bar of Bar
    ^
firrtl-snippets/ExtModuleOutputProperty.fir:8:5: note: see current operation: %0 = ""firrtl.instance""() {annotations = [], moduleName = @Bar, name = ""bar"", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [[]], portDirections = true, portNames = [""a""]} : () -> !firrtl.integer
```","FIRRTL version 4.0.0
circuit Foo:
  extmodule Bar:
    input a: Integer

  module Foo:
    inst bar of Bar
    propassign bar.a, Integer(42)","# firtool firrtl-snippets/ExtModuleInputProperty.fir
Assertion failed: (Index < this->size() && ""Invalid index!""), function operator[], file ArrayRef.h, line 443.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: firtool firrtl-snippets/ExtModuleInputProperty.fir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x00000001031ee300 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 88
1  firtool                  0x00000001031ee91c PrintStackTraceSignalHandler(void*) + 28
2  firtool                  0x00000001031ec4b0 llvm::sys::RunSignalHandlers() + 152
3  firtool                  0x00000001031efbf4 SignalHandler(int) + 276
4  libsystem_platform.dylib 0x0000000190b42a24 _sigtramp + 56
5  libsystem_pthread.dylib  0x0000000190b13c28 pthread_kill + 288
6  libsystem_c.dylib        0x0000000190a21ae8 abort + 180
7  libsystem_c.dylib        0x0000000190a20e44 err + 0
8  firtool                  0x00000001038a6338 llvm::MutableArrayRef<mlir::BlockArgument>::operator[](unsigned long) const + 124
9  firtool                  0x00000001038a619c mlir::Region::getArgument(unsigned int) + 56
10 firtool                  0x0000000103530344 (anonymous namespace)::LowerClassesPass::lowerClass((anonymous namespace)::ClassLoweringState&) + 604","FIRRTL version 4.0.0
circuit Foo:
  extmodule Bar:
    output a: Integer

  module Foo:
    output a: Integer
    inst bar of Bar
    propassign a, bar.a","# firtool firrtl-snippets/ExtModuleOutputProperty.fir                         
firrtl-snippets/ExtModuleOutputProperty.fir:8:5: error: failed to legalize operation 'firrtl.instance' that was explicitly marked illegal
    inst bar of Bar
    ^
firrtl-snippets/ExtModuleOutputProperty.fir:8:5: note: see current operation: %0 = ""firrtl.instance""() {annotations = [], moduleName = @Bar, name = ""bar"", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [[]], portDirections = true, portNames = [""a""]} : () -> !firrtl.integer",,,,,,
6013,[FIRRTL] Need to handle Macro Collision,2023-08-31T17:46:47Z,open,"bug, FIRRTL","If a FIRRTL name collides with a macro, the compiler currently crashes. `LowerToHW` and others need to disconnect the symbol creation from the name of the symbol. `sv.macro.decl` already has support for this. It is not used yet.

Consider:

```
FIRRTL version 4.0.0
circuit RANDOM:
  module RANDOM:
    input clock: Clock
    input d: UInt<1>
    output q: UInt<1>

    reg r: UInt<1>, clock

    connect r, d
    connect q, r
```

This errors during `LowerToHW` with:

```
<unknown>:0: error: Referenced macro doesn't exist ""ENABLE_INITIAL_MEM_""
<unknown>:0: note: see current operation: ""sv.macro.def""() {format_string = """", macroName = @ENABLE_INITIAL_MEM_, symbols = []} : () -> ()
```","FIRRTL version 4.0.0
circuit RANDOM:
  module RANDOM:
    input clock: Clock
    input d: UInt<1>
    output q: UInt<1>

    reg r: UInt<1>, clock

    connect r, d
    connect q, r","<unknown>:0: error: Referenced macro doesn't exist ""ENABLE_INITIAL_MEM_""
<unknown>:0: note: see current operation: ""sv.macro.def""() {format_string = """", macroName = @ENABLE_INITIAL_MEM_, symbols = []} : () -> ()",,,,,,,,
5991,[FIRRTL] Make `-lower-annotations-no-ref-type-ports` work for `MemTapAnnotation`,2023-08-29T21:52:29Z,closed,"bug, FIRRTL","The following fails and it shouldn't:

```
firtool ../test/Dialect/FIRRTL/SFCTests/mem-taps.fir -lower-annotations-no-ref-type-ports
```

This produces:

```
../test/Dialect/FIRRTL/SFCTests/mem-taps.fir:33:5: error: Wiring Problem source type '!firrtl.probe<vector<uint<8>, 8>>' does not match sink type '!firrtl.vector<uint<8>, 8>'
    cmem rf : UInt<8> [8]
    ^
../test/Dialect/FIRRTL/SFCTests/mem-taps.fir:48:5: note: The sink is here.
    wire memTap : UInt<8>[8]
    ^
```

This hidden option is a hack. It should still work.",firtool ../test/Dialect/FIRRTL/SFCTests/mem-taps.fir -lower-annotations-no-ref-type-ports,"../test/Dialect/FIRRTL/SFCTests/mem-taps.fir:33:5: error: Wiring Problem source type '!firrtl.probe<vector<uint<8>, 8>>' does not match sink type '!firrtl.vector<uint<8>, 8>'
    cmem rf : UInt<8> [8]
    ^
../test/Dialect/FIRRTL/SFCTests/mem-taps.fir:48:5: note: The sink is here.
    wire memTap : UInt<8>[8]
    ^",,,,,,,,
5983,[FIRRTL][InferWidths] Ignore propassign (+properties generally),2023-08-29T14:02:41Z,closed,"bug, FIRRTL","Presently width inference pass exits if encounters, e.g., propassign:

```
FIRRTL version 3.1.0
circuit StringAndUInt:
  module StringAndUInt:
    input x : UInt<5>
    output y : UInt
    output s : String

    connect y, x
    propassign s, String(""test"")
```

Error:
```
infer-widths-prop.fir:9:5: error: 'firrtl.propassign' op not supported in width inference
    propassign s, String(""test"")
    ^
infer-widths-prop.fir:9:5: note: see current operation: ""firrtl.propassign""(%arg2, %0) : (!firrtl.string, !firrtl.string) -> ()
```

Properties should be pass-through for this pass.","FIRRTL version 3.1.0
circuit StringAndUInt:
  module StringAndUInt:
    input x : UInt<5>
    output y : UInt
    output s : String

    connect y, x
    propassign s, String(""test"")","infer-widths-prop.fir:9:5: error: 'firrtl.propassign' op not supported in width inference
    propassign s, String(""test"")
    ^
infer-widths-prop.fir:9:5: note: see current operation: ""firrtl.propassign""(%arg2, %0) : (!firrtl.string, !firrtl.string) -> ()",,,,,,,,
5975,[ExtractInstances] Fix module prefix not being applied to NLA,2023-08-28T21:22:09Z,closed,"bug, FIRRTL","When instances are grouped after extraction, the group module would inherit the appropriate prefix from the DUT, but any hierarchical paths pointing to it would not include the prefix. Fix this by using the same name for the module and the hierarchical path.

Fixes #5961.
Backported to firtool 1.5 in #5971.",,,,,,,,,,
5971,[ExtractInstances] Fix module prefix not being applied to NLA,2023-08-28T18:11:59Z,closed,"bug, FIRRTL","When instances are grouped after extraction, the group module would inherit the appropriate prefix from the DUT, but any hierarchical paths pointing to it would not include the prefix. Fix this by using the same name for the module and the hierarchical path.

Fixes #5961.",,,,,,,,,,
5961,[FIRRTL] Clock gate extraction doesn't update hierpath,2023-08-25T23:29:17Z,closed,"bug, FIRRTL","Running the following input through `firtool input.mlir` (version `sifive-1.5.5`):
```mlir
// input.mlir
firrtl.circuit ""Foo"" attributes {annotations = [{
  class = ""sifive.enterprise.firrtl.ExtractClockGatesFileAnnotation"",
  filename = ""ckgates.txt"",
  group = ""ClockGates""
}]} {
  firrtl.hierpath @nla_1 [@Foo::@core, @Bar::@ckg, @EICG_wrapper]
  firrtl.extmodule private @EICG_wrapper() attributes {defname = ""EICG_wrapper""}
  firrtl.module private @Bar() {
    firrtl.instance ckg sym @ckg @EICG_wrapper()
  }
  firrtl.module @Foo() attributes {annotations = [
    {class = ""sifive.enterprise.firrtl.MarkDUTAnnotation""},
    {
      class = ""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
      inclusive = true,
      prefix = ""Plop_""
    }
  ]} {
    firrtl.instance core sym @core @Bar()
  }
}
```
Produces the following error:
```
error: 'firrtl.hierpath' op instance path is incorrect. \
  Expected module: ""Plop_ClockGates"" instead found: ""ClockGates""
    firrtl.hierpath @nla_1 [@Foo::@core, @Bar::@ckg, @EICG_wrapper]
    ^
```
It looks like `ExtractInstances` does not properly update `firrtl.hierpath`s if they aren't referenced anywhere.

Reduced testcase of something @jackkoenig came across in the wild.","// input.mlir
firrtl.circuit ""Foo"" attributes {annotations = [{
  class = ""sifive.enterprise.firrtl.ExtractClockGatesFileAnnotation"",
  filename = ""ckgates.txt"",
  group = ""ClockGates""
}]} {
  firrtl.hierpath @nla_1 [@Foo::@core, @Bar::@ckg, @EICG_wrapper]
  firrtl.extmodule private @EICG_wrapper() attributes {defname = ""EICG_wrapper""}
  firrtl.module private @Bar() {
    firrtl.instance ckg sym @ckg @EICG_wrapper()
  }
  firrtl.module @Foo() attributes {annotations = [
    {class = ""sifive.enterprise.firrtl.MarkDUTAnnotation""},
    {
      class = ""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
      inclusive = true,
      prefix = ""Plop_""
    }
  ]} {
    firrtl.instance core sym @core @Bar()
  }
}","error: 'firrtl.hierpath' op instance path is incorrect. \
  Expected module: ""Plop_ClockGates"" instead found: ""ClockGates""
    firrtl.hierpath @nla_1 [@Foo::@core, @Bar::@ckg, @EICG_wrapper]
    ^",,,,,,,,
5947,[FIRRTL] Annotations indexing cmem crash,2023-08-24T22:37:26Z,closed,"bug, FIRRTL","Input:
```firrtl
circuit CMemOops: %[[
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~CMemOops|CMemOops>mem.a""
  }
]]
  module CMemOops:
    cmem mem : UInt<4>[16]
```

Crashes during resolveEntities:

```
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool anno_cmem_indexing.fir
 #0 0x000055f1b83d8f96 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13
 #1 0x000055f1b83d7020 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18
 #2 0x000055f1b83d962b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007faa75dd7d30 __restore_rt (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38d30)
 #4 0x000055f1b84558a2 mlir::TypeStorage::getAbstractType() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/TypeSupport.h:160:5
 #5 0x000055f1b84558a2 mlir::Type::getTypeID() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Types.h:112:37
 #6 0x000055f1b84558a2 bool mlir::detail::StorageUserBase<circt::firrtl::BundleType, circt::firrtl::FIRRTLBaseType, circt::firrtl::detail::BundleTypeStorage, mlir::detail::TypeUniquer, circt::hw::FieldIDTypeInterface::Trait>::classof<mlir::Type>(mlir::Type) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:114:16
 #7 0x000055f1b84558a2 llvm::CastInfo<circt::firrtl::BundleType, mlir::Type const, void>::isPossible(mlir::Type) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Types.h:403:14
 #8 0x000055f1b84558a2 bool llvm::isa<circt::firrtl::BundleType, mlir::Type>(mlir::Type const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:549:10
 #9 0x000055f1b84558a2 bool circt::firrtl::type_isa<circt::firrtl::BundleType>(mlir::Type) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLTypes.h:474:7
#10 0x000055f1b881fcbb circt::firrtl::BundleType circt::firrtl::type_dyn_cast<circt::firrtl::BundleType>(mlir::Type) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLTypes.h:516:7
#11 0x000055f1b881fcbb findBundleElement(mlir::Operation*, mlir::Type, llvm::StringRef) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp:45:17
#12 0x000055f1b881fcbb findFieldID(circt::firrtl::AnnoTarget&, llvm::ArrayRef<circt::firrtl::TargetToken>) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp:102:21
#13 0x000055f1b881fcbb circt::firrtl::resolveEntities(circt::firrtl::TokenAnnoTarget, circt::firrtl::CircuitOp, mlir::SymbolTable&, circt::firrtl::CircuitTargetCache&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp:277:17
```

UBSAN reports:
```
/home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Types.h:112:37: runtime error: member call on null pointer of type 'mlir::TypeStorage'
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Types.h:112:37 in 
```
","circuit CMemOops: %[[
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~CMemOops|CMemOops>mem.a""
  }
]]
  module CMemOops:
    cmem mem : UInt<4>[16]","PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool anno_cmem_indexing.fir
 #0 0x000055f1b83d8f96 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13
 #1 0x000055f1b83d7020 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18
 #2 0x000055f1b83d962b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007faa75dd7d30 __restore_rt (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38d30)
 #4 0x000055f1b84558a2 mlir::TypeStorage::getAbstractType() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/TypeSupport.h:160:5
 #5 0x000055f1b84558a2 mlir::Type::getTypeID() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Types.h:112:37
 #6 0x000055f1b84558a2 bool mlir::detail::StorageUserBase<circt::firrtl::BundleType, circt::firrtl::FIRRTLBaseType, circt::firrtl::detail::BundleTypeStorage, mlir::detail::TypeUniquer, circt::hw::FieldIDTypeInterface::Trait>::classof<mlir::Type>(mlir::Type) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:114:16
 #7 0x000055f1b84558a2 llvm::CastInfo<circt::firrtl::BundleType, mlir::Type const, void>::isPossible(mlir::Type) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Types.h:403:14
 #8 0x000055f1b84558a2 bool llvm::isa<circt::firrtl::BundleType, mlir::Type>(mlir::Type const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:549:10
 #9 0x000055f1b84558a2 bool circt::firrtl::type_isa<circt::firrtl::BundleType>(mlir::Type) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLTypes.h:474:7
#10 0x000055f1b881fcbb circt::firrtl::BundleType circt::firrtl::type_dyn_cast<circt::firrtl::BundleType>(mlir::Type) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLTypes.h:516:7
#11 0x000055f1b881fcbb findBundleElement(mlir::Operation*, mlir::Type, llvm::StringRef) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp:45:17
#12 0x000055f1b881fcbb findFieldID(circt::firrtl::AnnoTarget&, llvm::ArrayRef<circt::firrtl::TargetToken>) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp:102:21
#13 0x000055f1b881fcbb circt::firrtl::resolveEntities(circt::firrtl::TokenAnnoTarget, circt::firrtl::CircuitOp, mlir::SymbolTable&, circt::firrtl::CircuitTargetCache&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp:277:17","/home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Types.h:112:37: runtime error: member call on null pointer of type 'mlir::TypeStorage'
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Types.h:112:37 in",,,,,,,
5941,[FIRRTL][Inliner] Don't crash on property ports,2023-08-24T19:01:58Z,closed,"bug, FIRRTL","Input:
```firrtl
FIRRTL version 3.1.0
circuit PropertySpec_Anon :%[[
  {
    ""class"":""firrtl.passes.InlineAnnotation"",
    ""target"":""PropertySpec_Anon._18_Anon""
  },
  {
    ""class"":""firrtl.transforms.NoDedupAnnotation"",
    ""target"":""~PropertySpec_Anon|_18_Anon""
  }
]]
  module _18_Anon :
    input propIn : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 237:24]
    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 238:25]

    propassign propOut, propIn @[src/test/scala/chiselTests/properties/PropertySpec.scala 239:17]

  module PropertySpec_Anon :
    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 242:23]

    inst passthru of _18_Anon @[src/test/scala/chiselTests/properties/PropertySpec.scala 236:28]
    propassign passthru.propIn, Integer(123) @[src/test/scala/chiselTests/properties/PropertySpec.scala 241:23]
    propassign propOut, passthru.propOut @[src/test/scala/chiselTests/properties/PropertySpec.scala 243:15]
```

This presently crashes in the Inliner, walking off the end of a TypeSwitch:

```
firtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:141: ResultT llvm::TypeSwitch<circt::firrtl::FIRRTLType, mlir::Value>::operator Value() [T = circt::firrtl::FIRRTLType, ResultT = mlir::Value]: Assertion `result && ""Fell off the end of a type-switch""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool inline-props.fir
 #0 0x0000562532b77ca6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13
 #1 0x0000562532b75d30 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18
 #2 0x0000562532b7833b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007f6a5b89cd30 __restore_rt (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38d30)
 #4 0x00007f6a5b8eba8c __pthread_kill_implementation (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x87a8c)
 #5 0x00007f6a5b89cc86 gsignal (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38c86)
 #6 0x00007f6a5b8868ba abort (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x228ba)
 #7 0x00007f6a5b8867d9 _nl_load_domain.cold (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x227d9)
 #8 0x00007f6a5b8959c6 (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x319c6)
 #9 0x0000562532d6cd28 auto (anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&)::$_3::operator()<circt::firrtl::RefType>(circt::firrtl::RefType) const /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:0:0
#10 0x0000562532d6cd28 llvm::TypeSwitch<circt::firrtl::FIRRTLType, mlir::Value>& llvm::TypeSwitch<circt::firrtl::FIRRTLType, mlir::Value>::Case<circt::firrtl::RefType, (anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&)::$_3>((anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&)::$_3&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:22
#11 0x0000562532d6cd28 (anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:920:14
#12 0x0000562532d68bd5 llvm::DenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseSetPair<mlir::Attribute>>::~DenseMap() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:782:5
#13 0x0000562532d68bd5 llvm::detail::DenseSetImpl<mlir::Attribute, llvm::DenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseSetPair<mlir::Attribute>>, llvm::DenseMapInfo<mlir::Attribute, void>>::~DenseSetImpl() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/DenseSet.h:54:7
#14 0x0000562532d68bd5 (anonymous namespace)::Inliner::inlineInstances(circt::firrtl::FModuleOp) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:1291:5
#15 0x0000562532d68bd5 (anonymous namespace)::Inliner::run() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:1416:7
#16 0x0000562532d658a6 (anonymous namespace)::InlinerPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:1539:5
(snip)
```","FIRRTL version 3.1.0
circuit PropertySpec_Anon :%[[
  {
    ""class"":""firrtl.passes.InlineAnnotation"",
    ""target"":""PropertySpec_Anon._18_Anon""
  },
  {
    ""class"":""firrtl.transforms.NoDedupAnnotation"",
    ""target"":""~PropertySpec_Anon|_18_Anon""
  }
]]
  module _18_Anon :
    input propIn : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 237:24]
    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 238:25]

    propassign propOut, propIn @[src/test/scala/chiselTests/properties/PropertySpec.scala 239:17]

  module PropertySpec_Anon :
    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 242:23]

    inst passthru of _18_Anon @[src/test/scala/chiselTests/properties/PropertySpec.scala 236:28]
    propassign passthru.propIn, Integer(123) @[src/test/scala/chiselTests/properties/PropertySpec.scala 241:23]
    propassign propOut, passthru.propOut @[src/test/scala/chiselTests/properties/PropertySpec.scala 243:15]","firtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:141: ResultT llvm::TypeSwitch<circt::firrtl::FIRRTLType, mlir::Value>::operator Value() [T = circt::firrtl::FIRRTLType, ResultT = mlir::Value]: Assertion `result && ""Fell off the end of a type-switch""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool inline-props.fir
 #0 0x0000562532b77ca6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13
 #1 0x0000562532b75d30 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18
 #2 0x0000562532b7833b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007f6a5b89cd30 __restore_rt (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38d30)
 #4 0x00007f6a5b8eba8c __pthread_kill_implementation (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x87a8c)
 #5 0x00007f6a5b89cc86 gsignal (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38c86)
 #6 0x00007f6a5b8868ba abort (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x228ba)
 #7 0x00007f6a5b8867d9 _nl_load_domain.cold (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x227d9)
 #8 0x00007f6a5b8959c6 (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x319c6)
 #9 0x0000562532d6cd28 auto (anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&)::$_3::operator()<circt::firrtl::RefType>(circt::firrtl::RefType) const /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:0:0
#10 0x0000562532d6cd28 llvm::TypeSwitch<circt::firrtl::FIRRTLType, mlir::Value>& llvm::TypeSwitch<circt::firrtl::FIRRTLType, mlir::Value>::Case<circt::firrtl::RefType, (anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&)::$_3>((anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&)::$_3&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:22
#11 0x0000562532d6cd28 (anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:920:14
#12 0x0000562532d68bd5 llvm::DenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseSetPair<mlir::Attribute>>::~DenseMap() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:782:5
#13 0x0000562532d68bd5 llvm::detail::DenseSetImpl<mlir::Attribute, llvm::DenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseSetPair<mlir::Attribute>>, llvm::DenseMapInfo<mlir::Attribute, void>>::~DenseSetImpl() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/DenseSet.h:54:7
#14 0x0000562532d68bd5 (anonymous namespace)::Inliner::inlineInstances(circt::firrtl::FModuleOp) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:1291:5
#15 0x0000562532d68bd5 (anonymous namespace)::Inliner::run() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:1416:7
#16 0x0000562532d658a6 (anonymous namespace)::InlinerPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:1539:5
(snip)",,,,,,,,
5940,"[FIRRTL][IMCP] Don't crash on processing properties, getBaseType can be null",2023-08-24T19:00:30Z,closed,"bug, FIRRTL","Input:
```
FIRRTL version 3.1.0
circuit PropertySpec_Anon :
  module _16_Anon :
    input propIn : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 219:24]
    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 220:25]

    propassign propOut, propIn @[src/test/scala/chiselTests/properties/PropertySpec.scala 221:17]

  module PropertySpec_Anon :
    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 224:23]

    inst passthru of _16_Anon @[src/test/scala/chiselTests/properties/PropertySpec.scala 218:28]
    propassign passthru.propIn, Integer(123) @[src/test/scala/chiselTests/properties/PropertySpec.scala 223:23]
    propassign propOut, passthru.propOut @[src/test/scala/chiselTests/properties/PropertySpec.scala 225:15]
```

Crashes in IMCP, which expects getBaseType to never return null (it didn't previously, FWIW, but regardless).

This issue does not include the ask for IMCP to propagate property constants themselves, but to start with don't crash when encountering them.","FIRRTL version 3.1.0
circuit PropertySpec_Anon :
  module _16_Anon :
    input propIn : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 219:24]
    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 220:25]

    propassign propOut, propIn @[src/test/scala/chiselTests/properties/PropertySpec.scala 221:17]

  module PropertySpec_Anon :
    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 224:23]

    inst passthru of _16_Anon @[src/test/scala/chiselTests/properties/PropertySpec.scala 218:28]
    propassign passthru.propIn, Integer(123) @[src/test/scala/chiselTests/properties/PropertySpec.scala 223:23]
    propassign propOut, passthru.propOut @[src/test/scala/chiselTests/properties/PropertySpec.scala 225:15]",,,,,,,,,
5898,[FIRRTL][IMDCE] Forceable support,2023-08-21T23:27:23Z,closed,"bug, FIRRTL","Consider this input:
```firrtl
circuit RWProbeDCE:
  module RWProbeDCE:
    input x : UInt<5>
    output p : RWProbe<UInt<5>>
    wire w : UInt<5>
    w <= x
    define p = rwprobe(w)
```

Which currently generates:
```
// Generated by CIRCT 1.51.0g20230821_61e2b9a
module RWProbeDCE(
  input [4:0] x
);

  wire [4:0] w = 5'bz;
endmodule


// ----- 8< ----- FILE ""ref_RWProbeDCE_RWProbeDCE.sv"" ----- 8< -----

// Generated by CIRCT 1.51.0g20230821_61e2b9a
`define ref_RWProbeDCE_RWProbeDCE_p w
```

----

IR before IMDCE:

```mlir
firrtl.circuit ""RWProbeDCE"" {
  firrtl.module @RWProbeDCE(in %x: !firrtl.uint<5>, out %p: !firrtl.rwprobe<uint<5>>) attributes {convention = #firrtl<convention scalarized>} {
    %w, %w_ref = firrtl.wire forceable : !firrtl.uint<5>, !firrtl.rwprobe<uint<5>>
    firrtl.strictconnect %w, %x : !firrtl.uint<5>
    firrtl.ref.define %p, %w_ref : !firrtl.rwprobe<uint<5>>
  }
}
```

After (` circt-opt --pass-pipeline='builtin.module(firrtl-imdeadcodeelim)' rwprobe_imdce.mlir`):
```mlir
firrtl.circuit ""RWProbeDCE"" {
  firrtl.module @RWProbeDCE(in %x: !firrtl.uint<5>, out %p: !firrtl.rwprobe<uint<5>>) attributes {convention = #firrtl<convention scalarized>} {
    %w, %w_ref = firrtl.wire forceable : !firrtl.uint<5>, !firrtl.rwprobe<uint<5>>
    firrtl.ref.define %p, %w_ref : !firrtl.rwprobe<uint<5>>
  }
}
```

IMDCE drops the connect /to/ the declaration, not noticing that a live use of the forceable result keeps the declaration alive.","circuit RWProbeDCE:
  module RWProbeDCE:
    input x : UInt<5>
    output p : RWProbe<UInt<5>>
    wire w : UInt<5>
    w <= x
    define p = rwprobe(w)","// Generated by CIRCT 1.51.0g20230821_61e2b9a
module RWProbeDCE(
  input [4:0] x
);

  wire [4:0] w = 5'bz;
endmodule


// ----- 8< ----- FILE ""ref_RWProbeDCE_RWProbeDCE.sv"" ----- 8< -----

// Generated by CIRCT 1.51.0g20230821_61e2b9a
`define ref_RWProbeDCE_RWProbeDCE_p w","firrtl.circuit ""RWProbeDCE"" {
  firrtl.module @RWProbeDCE(in %x: !firrtl.uint<5>, out %p: !firrtl.rwprobe<uint<5>>) attributes {convention = #firrtl<convention scalarized>} {
    %w, %w_ref = firrtl.wire forceable : !firrtl.uint<5>, !firrtl.rwprobe<uint<5>>
    firrtl.strictconnect %w, %x : !firrtl.uint<5>
    firrtl.ref.define %p, %w_ref : !firrtl.rwprobe<uint<5>>
  }
}","firrtl.circuit ""RWProbeDCE"" {
  firrtl.module @RWProbeDCE(in %x: !firrtl.uint<5>, out %p: !firrtl.rwprobe<uint<5>>) attributes {convention = #firrtl<convention scalarized>} {
    %w, %w_ref = firrtl.wire forceable : !firrtl.uint<5>, !firrtl.rwprobe<uint<5>>
    firrtl.ref.define %p, %w_ref : !firrtl.rwprobe<uint<5>>
  }
}",,,,,,
5886,[FIRRTL] Enum with uninferred reset,2023-08-18T16:04:53Z,open,"bug, FIRRTL, Arc","Input:
```
circuit ResetEnum:
  module ResetEnum:
    input in : {| Some: UInt<1> |}
    output out: {| Some: Reset |}
    out <= in
```

Crashes during parsing, related: #5322 .","circuit ResetEnum:
  module ResetEnum:
    input in : {| Some: UInt<1> |}
    output out: {| Some: Reset |}
    out <= in",,,,,,,,,
5884,[FIRRTL] Can't parse const enum (and therefore can't parse enum w/const elements),2023-08-18T16:00:26Z,open,"bug, FIRRTL","Enum's must be const if their elements are const, but the way we parse constructs a non-const enum (with the parsed element types) before converting it to const.

Consider:

```
circuit EnumConst:
  module EnumConst:
    input e : {| Some : const UInt<8>, None |}
```
Which is invalid and should diagnose the invalid enum type.

or this legal enum:

```
circuit ConstEnumConst:
  module ConstEnumConst:
    input e : const {| Some : const UInt<8>, None |}
```","circuit EnumConst:
  module EnumConst:
    input e : {| Some : const UInt<8>, None |}","circuit ConstEnumConst:
  module ConstEnumConst:
    input e : const {| Some : const UInt<8>, None |}",,,,,,,,
5859,[FIRRTL] internalPaths crash,2023-08-16T15:43:02Z,closed,"bug, FIRRTL","Input:
```
firrtl.circuit ""Test"" {
  firrtl.extmodule @GCTDataTap(out probe: !firrtl.rwprobe<uint<5>>, out baz_qux: !firrtl.probe<uint<1>>, out baz_quz: !firrtl.probe<uint<1>>) attributes {defname = ""BlackBox"", internalPaths = [""baz.qux"", ""baz.quz""]}
  firrtl.module @Test() {
    %0:3 = firrtl.instance inst @GCTDataTap(out probe: !firrtl.rwprobe<uint<5>>, out baz_qux: !firrtl.probe<uint<1>>, out baz_quz: !firrtl.probe<uint<1>>)
  }
}
```

This is reachable from an input that already has a probe port and more are inserted using grand central taps.
""internalPaths"" should be reworked to support having paths for some (use ABI) and not others.

This crashes in LowerXMR but really the IR model is wrong.","firrtl.circuit ""Test"" {
  firrtl.extmodule @GCTDataTap(out probe: !firrtl.rwprobe<uint<5>>, out baz_qux: !firrtl.probe<uint<1>>, out baz_quz: !firrtl.probe<uint<1>>) attributes {defname = ""BlackBox"", internalPaths = [""baz.qux"", ""baz.quz""]}
  firrtl.module @Test() {
    %0:3 = firrtl.instance inst @GCTDataTap(out probe: !firrtl.rwprobe<uint<5>>, out baz_qux: !firrtl.probe<uint<1>>, out baz_quz: !firrtl.probe<uint<1>>)
  }
}",,,,,,,,,
5816,[FIRRTL][LowerToHW] race on attribute dictionary,2023-08-09T13:38:13Z,closed,bug,"Looks to be introduced with https://github.com/llvm/circt/pull/5726 .

Modifying the new module's attribute dictionary to clear out the moved symbol while other threads are creating instances to the module and accessing its arg/result attributes.

<details>
<summary> Example TSAN report</summary>

```
FAIL: CIRCT :: Dialect/FIRRTL/SFCTests/data-taps.fir (21 of 641)
******************** TEST 'CIRCT :: Dialect/FIRRTL/SFCTests/data-taps.fir' FAILED ********************
Script:
--
: 'RUN: at line 1';   /build/sifive/tsan/bin/firtool --split-input-file /home/will/src/sifive/circt/test/Dialect/FIRRTL/SFCTests/data-taps.fir | /build/sifive/tsan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/FIRRTL/SFCTests/data-taps.fir
--
Exit Code: 66

Command Output (stderr):
--
==================
WARNING: ThreadSanitizer: data race (pid=3539269)
  Read of size 8 at 0x7b1800028e38 by thread T2:
    #0 mlir::detail::StorageUserBase<mlir::DictionaryAttr, mlir::Attribute, mlir::detail::DictionaryAttrStorage, mlir::detail::AttributeUniquer>::getImpl() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:211:68 (firtool+0xbd4eac)
    #1 mlir::DictionaryAttr::getValue() const /build/sifive/tsan/tools/mlir/include/mlir/IR/BuiltinAttributes.cpp.inc:253:10 (firtool+0xbd4eac)
    #2 mlir::DictionaryAttr::begin() const /home/will/src/sifive/circt/llvm/mlir/lib/IR/BuiltinAttributes.cpp:194:10 (firtool+0xbd4eac)
    #3 mlir::DictionaryAttr::get(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/IR/BuiltinAttributes.cpp:167:34 (firtool+0xbd4eac)
    #4 mlir::Operation::getAttr(llvm::StringRef) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:507:18 (firtool+0x143f9b8)
    #5 mlir::ArrayAttr mlir::Operation::getAttrOfType<mlir::ArrayAttr>(llvm::StringRef) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:516:46 (firtool+0x143f9b8)
    #6 circt::hw::instance_like_impl::getHWModuleArgAndResultNames(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/HW/InstanceImplementation.cpp:20:19 (firtool+0x143f9b8)
    #7 circt::hw::InstanceOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Operation*, mlir::StringAttr, llvm::ArrayRef<mlir::Value>, mlir::ArrayAttr, circt::hw::InnerSymAttr) /home/will/src/sifive/circt/lib/Dialect/HW/HWOps.cpp:1485:7 (firtool+0x13a878f)
    #8 circt::hw::InstanceOp mlir::OpBuilder::create<circt::hw::InstanceOp, mlir::Operation*&, mlir::StringAttr, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&>(mlir::Location, mlir::Operation*&, mlir::StringAttr&&, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Builders.h:494:5 (firtool+0xd898e3)
    #9 circt::hw::InstanceOp mlir::ImplicitLocOpBuilder::create<circt::hw::InstanceOp, mlir::Operation*&, mlir::StringAttr, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&>(mlir::Operation*&, mlir::StringAttr&&, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/ImplicitLocOpBuilder.h:67:23 (firtool+0xd6df5a)
    #10 (anonymous namespace)::FIRRTLLowering::visitDecl(circt::firrtl::InstanceOp) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:3232:30 (firtool+0xd6df5a)
    #11 mlir::LogicalResult circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::InstanceOp>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:281:28 (firtool+0xd6df5a)
    #12 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::firrtl::InstanceOp, circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*)::'lambda'(auto)&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:22 (firtool+0xd6df5a)
    #13 circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:279:19 (firtool+0xd6df5a)
    #14 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::visitInvalidStmt(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:340:18 (firtool+0xd6429b)
    #15 mlir::LogicalResult circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchStmtVisitor(mlir::Operation*)::'lambda0'(auto)::operator()<mlir::Operation*>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:225:28 (firtool+0xd6429b)
    #16 mlir::LogicalResult llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Default<circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchStmtVisitor(mlir::Operation*)::'lambda0'(auto)>(auto&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:131:12 (firtool+0xd6429b)
    #17 circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchStmtVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:224:10 (firtool+0xd6429b)
    #18 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::visitInvalidExpr(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:337:18 (firtool+0xd58b14)
    #19 mlir::LogicalResult circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)::operator()<mlir::Operation*>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:69:28 (firtool+0xd58b14)
    #20 mlir::LogicalResult llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Default<circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)>(auto&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:131:12 (firtool+0xd58b14)
    #21 circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:68:10 (firtool+0xd58b14)
    #22 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:332:18 (firtool+0xd49af0)
    #23 (anonymous namespace)::FIRRTLLowering::run() /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1784:27 (firtool+0xd49af0)
    #24 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleOperations(circt::hw::HWModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1767:48 (firtool+0xd49af0)
    #25 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1410:10 (firtool+0xd49af0)
    #26 auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5::operator()<unsigned long>(unsigned long) const /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:663:16 (firtool+0xd72dc1)
    #27 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:62:18 (firtool+0xd72dc1)
    #28 llvm::detail::SafeIntIterator<unsigned long, false> std::__invoke_impl<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>(std::__invoke_other, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0xd72dc1)
    #29 std::enable_if<is_invocable_r_v<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>, llvm::detail::SafeIntIterator<unsigned long, false>>::type std::__invoke_r<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>((anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0xd72dc1)
    #30 std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0xd72dc1)
    #31 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7a5d07)
    #32 llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/ThreadPool.h:135:15 (firtool+0x7a5d07)
    #33 void std::__invoke_impl<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(std::__invoke_other, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7a5d07)
    #34 std::enable_if<is_invocable_r_v<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>, void>::type std::__invoke_r<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0x7a5d07)
    #35 std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0x7a5d07)
    #36 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7aa839)
    #37 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:101:5 (firtool+0x7aa839)
    #38 llvm::ThreadPool::grow(int)::$_0::operator()() const /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:49:7 (firtool+0x7ab85e)
    #39 auto void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)::operator()<llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:43:11 (firtool+0x7ab85e)
    #40 auto std::__invoke_impl<void, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(std::__invoke_other, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)&&, llvm::ThreadPool::grow(int)::$_0&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7ab85e)
    #41 std::__invoke_result<auto, auto...>::type std::__invoke<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:96:14 (firtool+0x7ab85e)
    #42 decltype(auto) std::__apply_impl<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&, 0ul>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::integer_sequence<unsigned long, 0ul>) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1852:14 (firtool+0x7ab85e)
    #43 decltype(auto) std::apply<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1863:14 (firtool+0x7ab85e)
    #44 void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:41:5 (firtool+0x7ab85e)
    #45 void* llvm::thread::ThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:55:5 (firtool+0x7ab85e)

  Previous write of size 8 at 0x7b1800028e38 by thread T14:
    #0 mlir::Operation::removeAttr(mlir::StringAttr) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:571:13 (firtool+0x7c2a7b)
    #1 circt::hw::HWModuleOp::removeResAttrsAttr() /build/sifive/tsan/tools/circt/include/circt/Dialect/HW/HW.cpp.inc:4059:17 (firtool+0x13ead34)
    #2 mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<circt::hw::HWModuleOp>::removeResAttrsAttr(mlir::detail::FunctionOpInterfaceInterfaceTraits::Concept const*, mlir::Operation*) /build/sifive/tsan/tools/mlir/include/mlir/IR/FunctionOpInterfaces.h.inc:1136:56 (firtool+0x1375d97)
    #3 mlir::FunctionOpInterface::removeResAttrsAttr() /build/sifive/tsan/tools/mlir/include/mlir/IR/FunctionOpInterfaces.cpp.inc:51:14 (firtool+0xcc92e7)
    #4 void removeArgResAttrs<false>(mlir::FunctionOpInterface) /home/will/src/sifive/circt/llvm/mlir/lib/IR/FunctionInterfaces.cpp:81:8 (firtool+0xcc92e7)
    #5 void setArgResAttrDict<false>(mlir::FunctionOpInterface, unsigned int, unsigned int, mlir::DictionaryAttr) /home/will/src/sifive/circt/llvm/mlir/lib/IR/FunctionInterfaces.cpp:146:12 (firtool+0xcc92e7)
    #6 mlir::function_interface_impl::setResultAttrs(mlir::FunctionOpInterface, unsigned int, mlir::DictionaryAttr) /home/will/src/sifive/circt/llvm/mlir/lib/IR/FunctionInterfaces.cpp:184:10 (firtool+0xcc9430)
    #7 mlir::detail::FunctionOpInterfaceTrait<circt::hw::HWModuleOp>::setResultAttrs(unsigned int, mlir::DictionaryAttr) /build/sifive/tsan/tools/mlir/include/mlir/IR/FunctionOpInterfaces.h.inc:1051:7 (firtool+0x1417c7f)
    #8 mlir::Attribute mlir::function_interface_impl::removeResultAttr<circt::hw::HWModuleOp>(circt::hw::HWModuleOp, unsigned int, mlir::StringAttr) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/FunctionInterfaces.h:159:8 (firtool+0x1417c7f)
    #9 circt::hw::HWModuleOp::setPortSymbolAttr(unsigned long, circt::hw::InnerSymAttr) /build/sifive/tsan/tools/circt/include/circt/Dialect/HW/HW.cpp.inc:4229:5 (firtool+0x13ec9ac)
    #10 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1392:19 (firtool+0xd48b16)
    #11 auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5::operator()<unsigned long>(unsigned long) const /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:663:16 (firtool+0xd72dc1)
    #12 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:62:18 (firtool+0xd72dc1)
    #13 llvm::detail::SafeIntIterator<unsigned long, false> std::__invoke_impl<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>(std::__invoke_other, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0xd72dc1)
    #14 std::enable_if<is_invocable_r_v<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>, llvm::detail::SafeIntIterator<unsigned long, false>>::type std::__invoke_r<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>((anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0xd72dc1)
    #15 std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0xd72dc1)
    #16 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7a5d07)
    #17 llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/ThreadPool.h:135:15 (firtool+0x7a5d07)
    #18 void std::__invoke_impl<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(std::__invoke_other, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7a5d07)
    #19 std::enable_if<is_invocable_r_v<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>, void>::type std::__invoke_r<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0x7a5d07)
    #20 std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0x7a5d07)
    #21 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7aa839)
    #22 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:101:5 (firtool+0x7aa839)
    #23 llvm::ThreadPool::grow(int)::$_0::operator()() const /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:49:7 (firtool+0x7ab85e)
    #24 auto void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)::operator()<llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:43:11 (firtool+0x7ab85e)
    #25 auto std::__invoke_impl<void, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(std::__invoke_other, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)&&, llvm::ThreadPool::grow(int)::$_0&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7ab85e)
    #26 std::__invoke_result<auto, auto...>::type std::__invoke<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:96:14 (firtool+0x7ab85e)
    #27 decltype(auto) std::__apply_impl<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&, 0ul>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::integer_sequence<unsigned long, 0ul>) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1852:14 (firtool+0x7ab85e)
    #28 decltype(auto) std::apply<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1863:14 (firtool+0x7ab85e)
    #29 void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:41:5 (firtool+0x7ab85e)
    #30 void* llvm::thread::ThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:55:5 (firtool+0x7ab85e)

  Location is heap block of size 88 at 0x7b1800028e00 allocated by main thread:
    #0 malloc <null> (firtool+0x5cacef)
    #1 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:113:46 (firtool+0xcf1039)
    #2 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:74:10 (firtool+0xcf0af8)
    #3 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:57:7 (firtool+0xcf0af8)
    #4 mlir::Operation::create(mlir::OperationState const&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:35:7 (firtool+0xcf0935)
    #5 mlir::OpBuilder::create(mlir::OperationState const&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Builders.cpp:447:17 (firtool+0xbcf18d)
    #6 circt::hw::HWModuleOp mlir::OpBuilder::create<circt::hw::HWModuleOp, mlir::StringAttr&, llvm::SmallVector<circt::hw::PortInfo, 8u>&>(mlir::Location, mlir::StringAttr&, llvm::SmallVector<circt::hw::PortInfo, 8u>&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Builders.h:495:16 (firtool+0xd75f24)
    #7 (anonymous namespace)::FIRRTLModuleLowering::lowerModule(circt::firrtl::FModuleOp, mlir::Block*, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1117:15 (firtool+0xd40388)
    #8 auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_0::operator()<circt::firrtl::FModuleOp>(circt::firrtl::FModuleOp) const /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:580:29 (firtool+0xd40388)
    #9 llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::FModuleOp, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_0>((anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_0&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:169:7 (firtool+0xd40388)
    #10 (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:579:10 (firtool+0xd40388)
    #11 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:485:17 (firtool+0x1651571)
    #12 void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12 (firtool+0x1651571)
    #13 llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12 (firtool+0x1651571)
    #14 void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7 (firtool+0x1651571)
    #15 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:479:21 (firtool+0x1651571)
    #16 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:551:16 (firtool+0x165567f)
    #17 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:860:10 (firtool+0x165567f)
    #18 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:840:60 (firtool+0x165567f)
    #19 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:358:17 (firtool+0x6397c9)
    #20 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:490:12 (firtool+0x6386fc)
    #21 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/tools/firtool/firtool.cpp:524:16 (firtool+0x63a684)
    #22 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12 (firtool+0x63a684)
    #23 llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12 (firtool+0xb79fda)
    #24 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16 (firtool+0xb79fda)
    #25 void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2101:5 (firtool+0xb79a49)
    #26 void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2119:3 (firtool+0xb79a49)
    #27 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3 (firtool+0xb79a49)
    #28 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:521:10 (firtool+0x63811c)
    #29 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:591:14 (firtool+0x63811c)
    #30 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:650:17 (firtool+0x6379a4)

<<snip due to limits>>

SUMMARY: ThreadSanitizer: data race /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:211:68 in mlir::detail::StorageUserBase<mlir::DictionaryAttr, mlir::Attribute, mlir::detail::DictionaryAttrStorage, mlir::detail::AttributeUniquer>::getImpl() const
```
</details>","FAIL: CIRCT :: Dialect/FIRRTL/SFCTests/data-taps.fir (21 of 641)
******************** TEST 'CIRCT :: Dialect/FIRRTL/SFCTests/data-taps.fir' FAILED ********************
Script:
--
: 'RUN: at line 1';   /build/sifive/tsan/bin/firtool --split-input-file /home/will/src/sifive/circt/test/Dialect/FIRRTL/SFCTests/data-taps.fir | /build/sifive/tsan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/FIRRTL/SFCTests/data-taps.fir
--
Exit Code: 66

Command Output (stderr):
--
==================
WARNING: ThreadSanitizer: data race (pid=3539269)
  Read of size 8 at 0x7b1800028e38 by thread T2:
    #0 mlir::detail::StorageUserBase<mlir::DictionaryAttr, mlir::Attribute, mlir::detail::DictionaryAttrStorage, mlir::detail::AttributeUniquer>::getImpl() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:211:68 (firtool+0xbd4eac)
    #1 mlir::DictionaryAttr::getValue() const /build/sifive/tsan/tools/mlir/include/mlir/IR/BuiltinAttributes.cpp.inc:253:10 (firtool+0xbd4eac)
    #2 mlir::DictionaryAttr::begin() const /home/will/src/sifive/circt/llvm/mlir/lib/IR/BuiltinAttributes.cpp:194:10 (firtool+0xbd4eac)
    #3 mlir::DictionaryAttr::get(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/IR/BuiltinAttributes.cpp:167:34 (firtool+0xbd4eac)
    #4 mlir::Operation::getAttr(llvm::StringRef) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:507:18 (firtool+0x143f9b8)
    #5 mlir::ArrayAttr mlir::Operation::getAttrOfType<mlir::ArrayAttr>(llvm::StringRef) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:516:46 (firtool+0x143f9b8)
    #6 circt::hw::instance_like_impl::getHWModuleArgAndResultNames(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/HW/InstanceImplementation.cpp:20:19 (firtool+0x143f9b8)
    #7 circt::hw::InstanceOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Operation*, mlir::StringAttr, llvm::ArrayRef<mlir::Value>, mlir::ArrayAttr, circt::hw::InnerSymAttr) /home/will/src/sifive/circt/lib/Dialect/HW/HWOps.cpp:1485:7 (firtool+0x13a878f)
    #8 circt::hw::InstanceOp mlir::OpBuilder::create<circt::hw::InstanceOp, mlir::Operation*&, mlir::StringAttr, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&>(mlir::Location, mlir::Operation*&, mlir::StringAttr&&, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Builders.h:494:5 (firtool+0xd898e3)
    #9 circt::hw::InstanceOp mlir::ImplicitLocOpBuilder::create<circt::hw::InstanceOp, mlir::Operation*&, mlir::StringAttr, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&>(mlir::Operation*&, mlir::StringAttr&&, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/ImplicitLocOpBuilder.h:67:23 (firtool+0xd6df5a)
    #10 (anonymous namespace)::FIRRTLLowering::visitDecl(circt::firrtl::InstanceOp) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:3232:30 (firtool+0xd6df5a)
    #11 mlir::LogicalResult circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::InstanceOp>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:281:28 (firtool+0xd6df5a)
    #12 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::firrtl::InstanceOp, circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*)::'lambda'(auto)&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:22 (firtool+0xd6df5a)
    #13 circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:279:19 (firtool+0xd6df5a)
    #14 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::visitInvalidStmt(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:340:18 (firtool+0xd6429b)
    #15 mlir::LogicalResult circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchStmtVisitor(mlir::Operation*)::'lambda0'(auto)::operator()<mlir::Operation*>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:225:28 (firtool+0xd6429b)
    #16 mlir::LogicalResult llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Default<circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchStmtVisitor(mlir::Operation*)::'lambda0'(auto)>(auto&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:131:12 (firtool+0xd6429b)
    #17 circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchStmtVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:224:10 (firtool+0xd6429b)
    #18 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::visitInvalidExpr(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:337:18 (firtool+0xd58b14)
    #19 mlir::LogicalResult circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)::operator()<mlir::Operation*>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:69:28 (firtool+0xd58b14)
    #20 mlir::LogicalResult llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Default<circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)>(auto&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:131:12 (firtool+0xd58b14)
    #21 circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:68:10 (firtool+0xd58b14)
    #22 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:332:18 (firtool+0xd49af0)
    #23 (anonymous namespace)::FIRRTLLowering::run() /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1784:27 (firtool+0xd49af0)
    #24 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleOperations(circt::hw::HWModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1767:48 (firtool+0xd49af0)
    #25 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1410:10 (firtool+0xd49af0)
    #26 auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5::operator()<unsigned long>(unsigned long) const /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:663:16 (firtool+0xd72dc1)
    #27 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:62:18 (firtool+0xd72dc1)
    #28 llvm::detail::SafeIntIterator<unsigned long, false> std::__invoke_impl<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>(std::__invoke_other, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0xd72dc1)
    #29 std::enable_if<is_invocable_r_v<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>, llvm::detail::SafeIntIterator<unsigned long, false>>::type std::__invoke_r<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>((anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0xd72dc1)
    #30 std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0xd72dc1)
    #31 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7a5d07)
    #32 llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/ThreadPool.h:135:15 (firtool+0x7a5d07)
    #33 void std::__invoke_impl<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(std::__invoke_other, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7a5d07)
    #34 std::enable_if<is_invocable_r_v<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>, void>::type std::__invoke_r<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0x7a5d07)
    #35 std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0x7a5d07)
    #36 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7aa839)
    #37 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:101:5 (firtool+0x7aa839)
    #38 llvm::ThreadPool::grow(int)::$_0::operator()() const /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:49:7 (firtool+0x7ab85e)
    #39 auto void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)::operator()<llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:43:11 (firtool+0x7ab85e)
    #40 auto std::__invoke_impl<void, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(std::__invoke_other, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)&&, llvm::ThreadPool::grow(int)::$_0&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7ab85e)
    #41 std::__invoke_result<auto, auto...>::type std::__invoke<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:96:14 (firtool+0x7ab85e)
    #42 decltype(auto) std::__apply_impl<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&, 0ul>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::integer_sequence<unsigned long, 0ul>) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1852:14 (firtool+0x7ab85e)
    #43 decltype(auto) std::apply<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1863:14 (firtool+0x7ab85e)
    #44 void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:41:5 (firtool+0x7ab85e)
    #45 void* llvm::thread::ThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:55:5 (firtool+0x7ab85e)

  Previous write of size 8 at 0x7b1800028e38 by thread T14:
    #0 mlir::Operation::removeAttr(mlir::StringAttr) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:571:13 (firtool+0x7c2a7b)
    #1 circt::hw::HWModuleOp::removeResAttrsAttr() /build/sifive/tsan/tools/circt/include/circt/Dialect/HW/HW.cpp.inc:4059:17 (firtool+0x13ead34)
    #2 mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<circt::hw::HWModuleOp>::removeResAttrsAttr(mlir::detail::FunctionOpInterfaceInterfaceTraits::Concept const*, mlir::Operation*) /build/sifive/tsan/tools/mlir/include/mlir/IR/FunctionOpInterfaces.h.inc:1136:56 (firtool+0x1375d97)
    #3 mlir::FunctionOpInterface::removeResAttrsAttr() /build/sifive/tsan/tools/mlir/include/mlir/IR/FunctionOpInterfaces.cpp.inc:51:14 (firtool+0xcc92e7)
    #4 void removeArgResAttrs<false>(mlir::FunctionOpInterface) /home/will/src/sifive/circt/llvm/mlir/lib/IR/FunctionInterfaces.cpp:81:8 (firtool+0xcc92e7)
    #5 void setArgResAttrDict<false>(mlir::FunctionOpInterface, unsigned int, unsigned int, mlir::DictionaryAttr) /home/will/src/sifive/circt/llvm/mlir/lib/IR/FunctionInterfaces.cpp:146:12 (firtool+0xcc92e7)
    #6 mlir::function_interface_impl::setResultAttrs(mlir::FunctionOpInterface, unsigned int, mlir::DictionaryAttr) /home/will/src/sifive/circt/llvm/mlir/lib/IR/FunctionInterfaces.cpp:184:10 (firtool+0xcc9430)
    #7 mlir::detail::FunctionOpInterfaceTrait<circt::hw::HWModuleOp>::setResultAttrs(unsigned int, mlir::DictionaryAttr) /build/sifive/tsan/tools/mlir/include/mlir/IR/FunctionOpInterfaces.h.inc:1051:7 (firtool+0x1417c7f)
    #8 mlir::Attribute mlir::function_interface_impl::removeResultAttr<circt::hw::HWModuleOp>(circt::hw::HWModuleOp, unsigned int, mlir::StringAttr) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/FunctionInterfaces.h:159:8 (firtool+0x1417c7f)
    #9 circt::hw::HWModuleOp::setPortSymbolAttr(unsigned long, circt::hw::InnerSymAttr) /build/sifive/tsan/tools/circt/include/circt/Dialect/HW/HW.cpp.inc:4229:5 (firtool+0x13ec9ac)
    #10 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1392:19 (firtool+0xd48b16)
    #11 auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5::operator()<unsigned long>(unsigned long) const /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:663:16 (firtool+0xd72dc1)
    #12 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:62:18 (firtool+0xd72dc1)
    #13 llvm::detail::SafeIntIterator<unsigned long, false> std::__invoke_impl<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>(std::__invoke_other, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0xd72dc1)
    #14 std::enable_if<is_invocable_r_v<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>, llvm::detail::SafeIntIterator<unsigned long, false>>::type std::__invoke_r<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>((anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0xd72dc1)
    #15 std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0xd72dc1)
    #16 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7a5d07)
    #17 llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/ThreadPool.h:135:15 (firtool+0x7a5d07)
    #18 void std::__invoke_impl<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(std::__invoke_other, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7a5d07)
    #19 std::enable_if<is_invocable_r_v<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>, void>::type std::__invoke_r<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0x7a5d07)
    #20 std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0x7a5d07)
    #21 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7aa839)
    #22 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:101:5 (firtool+0x7aa839)
    #23 llvm::ThreadPool::grow(int)::$_0::operator()() const /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:49:7 (firtool+0x7ab85e)
    #24 auto void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)::operator()<llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:43:11 (firtool+0x7ab85e)
    #25 auto std::__invoke_impl<void, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(std::__invoke_other, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)&&, llvm::ThreadPool::grow(int)::$_0&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7ab85e)
    #26 std::__invoke_result<auto, auto...>::type std::__invoke<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:96:14 (firtool+0x7ab85e)
    #27 decltype(auto) std::__apply_impl<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&, 0ul>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::integer_sequence<unsigned long, 0ul>) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1852:14 (firtool+0x7ab85e)
    #28 decltype(auto) std::apply<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1863:14 (firtool+0x7ab85e)
    #29 void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:41:5 (firtool+0x7ab85e)
    #30 void* llvm::thread::ThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:55:5 (firtool+0x7ab85e)

  Location is heap block of size 88 at 0x7b1800028e00 allocated by main thread:
    #0 malloc <null> (firtool+0x5cacef)
    #1 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:113:46 (firtool+0xcf1039)
    #2 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:74:10 (firtool+0xcf0af8)
    #3 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:57:7 (firtool+0xcf0af8)
    #4 mlir::Operation::create(mlir::OperationState const&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:35:7 (firtool+0xcf0935)
    #5 mlir::OpBuilder::create(mlir::OperationState const&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Builders.cpp:447:17 (firtool+0xbcf18d)
    #6 circt::hw::HWModuleOp mlir::OpBuilder::create<circt::hw::HWModuleOp, mlir::StringAttr&, llvm::SmallVector<circt::hw::PortInfo, 8u>&>(mlir::Location, mlir::StringAttr&, llvm::SmallVector<circt::hw::PortInfo, 8u>&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Builders.h:495:16 (firtool+0xd75f24)
    #7 (anonymous namespace)::FIRRTLModuleLowering::lowerModule(circt::firrtl::FModuleOp, mlir::Block*, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1117:15 (firtool+0xd40388)
    #8 auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_0::operator()<circt::firrtl::FModuleOp>(circt::firrtl::FModuleOp) const /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:580:29 (firtool+0xd40388)
    #9 llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::FModuleOp, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_0>((anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_0&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:169:7 (firtool+0xd40388)
    #10 (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:579:10 (firtool+0xd40388)
    #11 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:485:17 (firtool+0x1651571)
    #12 void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12 (firtool+0x1651571)
    #13 llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12 (firtool+0x1651571)
    #14 void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7 (firtool+0x1651571)
    #15 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:479:21 (firtool+0x1651571)
    #16 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:551:16 (firtool+0x165567f)
    #17 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:860:10 (firtool+0x165567f)
    #18 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:840:60 (firtool+0x165567f)
    #19 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:358:17 (firtool+0x6397c9)
    #20 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:490:12 (firtool+0x6386fc)
    #21 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/tools/firtool/firtool.cpp:524:16 (firtool+0x63a684)
    #22 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12 (firtool+0x63a684)
    #23 llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12 (firtool+0xb79fda)
    #24 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16 (firtool+0xb79fda)
    #25 void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2101:5 (firtool+0xb79a49)
    #26 void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2119:3 (firtool+0xb79a49)
    #27 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3 (firtool+0xb79a49)
    #28 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:521:10 (firtool+0x63811c)
    #29 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:591:14 (firtool+0x63811c)
    #30 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:650:17 (firtool+0x6379a4)

<<snip due to limits>>

SUMMARY: ThreadSanitizer: data race /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:211:68 in mlir::detail::StorageUserBase<mlir::DictionaryAttr, mlir::Attribute, mlir::detail::DictionaryAttrStorage, mlir::detail::AttributeUniquer>::getImpl() const",,,,,,,,,
5772,[Comb] comb.concat doesn't work with type alias,2023-08-03T13:32:25Z,open,"bug, Comb","```
hw.type_scope @__hw_typedecls {
  hw.typedecl @foo : i1
}

hw.module @Top(%arg0: !hw.typealias<@__hw_typedecls::@foo,i1>) {
  %0 = comb.concat %arg0 : !hw.typealias<@__hw_typedecls::@foo,i1>
}
```

```
circt-opt: /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `isa<To>(Val) && ""cast<Ty>() argument of incompatible type!""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.      Program arguments: ./build/bin/circt-opt foo.mlir
1.      MLIR Parser: custom op parser 'hw.module'
2.      MLIR Parser: custom op parser 'comb.concat'
 #0 0x0000000000447057 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x00000000004451e0 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x000000000044796f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007fe418fd6cf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)
 #4 0x00007fe417e61aff raise (/lib64/libc.so.6+0x4eaff)
 #5 0x00007fe417e34ea5 abort (/lib64/libc.so.6+0x21ea5)
 #6 0x00007fe417e34d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)
 #7 0x00007fe417e5a456 (/lib64/libc.so.6+0x47456)
 #8 0x0000000000609c3b (./build/bin/circt-opt+0x609c3b)
 #9 0x000000000060c749 circt::comb::ConcatOp::inferReturnTypes(mlir::MLIRContext*, std::optional<mlir::Location>, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::RegionRange, llvm::SmallVectorImpl<mlir::Type>&) /scratch/hidetou/circt/lib/Dialect/Comb/CombOps.cpp:270:21
#10 0x000000000060c749 circt::comb::ConcatOp::parse(mlir::OpAsmParser&, mlir::OperationState&) /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/Comb/Comb.cpp.inc:948:22
#11 0x00000000014d521f mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#12 0x00000000014d521f mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43
#13 0x00000000014d521f (anonymous namespace)::CustomOpAsmParser::parseOperation(mlir::OperationState&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1491:9
#14 0x00000000014d521f (anonymous namespace)::OperationParser::parseCustomOperation(llvm::ArrayRef<std::tuple<llvm::StringRef, unsigned int, llvm::SMLoc>>) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1987:19
#15 0x00000000014d521f (anonymous namespace)::OperationParser::parseOperation() /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1146:10
#16 0x00000000014e0ac0 mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#17 0x00000000014e0ac0 mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43
#18 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlockBody(mlir::Block*) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2263:9
#19 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2193:12
```","hw.type_scope @__hw_typedecls {
  hw.typedecl @foo : i1
}

hw.module @Top(%arg0: !hw.typealias<@__hw_typedecls::@foo,i1>) {
  %0 = comb.concat %arg0 : !hw.typealias<@__hw_typedecls::@foo,i1>
}","circt-opt: /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `isa<To>(Val) && ""cast<Ty>() argument of incompatible type!""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.      Program arguments: ./build/bin/circt-opt foo.mlir
1.      MLIR Parser: custom op parser 'hw.module'
2.      MLIR Parser: custom op parser 'comb.concat'
 #0 0x0000000000447057 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x00000000004451e0 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x000000000044796f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007fe418fd6cf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)
 #4 0x00007fe417e61aff raise (/lib64/libc.so.6+0x4eaff)
 #5 0x00007fe417e34ea5 abort (/lib64/libc.so.6+0x21ea5)
 #6 0x00007fe417e34d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)
 #7 0x00007fe417e5a456 (/lib64/libc.so.6+0x47456)
 #8 0x0000000000609c3b (./build/bin/circt-opt+0x609c3b)
 #9 0x000000000060c749 circt::comb::ConcatOp::inferReturnTypes(mlir::MLIRContext*, std::optional<mlir::Location>, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::RegionRange, llvm::SmallVectorImpl<mlir::Type>&) /scratch/hidetou/circt/lib/Dialect/Comb/CombOps.cpp:270:21
#10 0x000000000060c749 circt::comb::ConcatOp::parse(mlir::OpAsmParser&, mlir::OperationState&) /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/Comb/Comb.cpp.inc:948:22
#11 0x00000000014d521f mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#12 0x00000000014d521f mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43
#13 0x00000000014d521f (anonymous namespace)::CustomOpAsmParser::parseOperation(mlir::OperationState&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1491:9
#14 0x00000000014d521f (anonymous namespace)::OperationParser::parseCustomOperation(llvm::ArrayRef<std::tuple<llvm::StringRef, unsigned int, llvm::SMLoc>>) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1987:19
#15 0x00000000014d521f (anonymous namespace)::OperationParser::parseOperation() /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1146:10
#16 0x00000000014e0ac0 mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#17 0x00000000014e0ac0 mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43
#18 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlockBody(mlir::Block*) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2263:9
#19 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2193:12",,,,,,,,
5765,[ExportVerilog] Fix Expr/PropertyEmitter token buffer crash,2023-08-02T23:13:13Z,closed,"bug, ExportVerilog","Fix an issue in `ExportVerilog` where `ExprEmitter`s and `PropertyEmitter`s would not properly use a token buffer passed in as a constructor argument. The emitters have a local buffer of tokens that is used by default if no external one is provided. However, parts of the emitters failed to use `buffer.tokens` to access either the externally provided or the local buffer, and instead would always use the local `tokens` buffer. This caused parentheses and end tokens to be lost if an external buffer was provided, since the emitter would modify the unused local `tokens` buffer.

This fixes the issue by properly using `buffer.tokens` everywhere and renaming `tokens` to `localTokens` to make misuse more obvious.

Fixes #5763.",,,,,,,,,,
5763,[ExportVerilog] verif.assert triggers pretty printer assertion,2023-08-02T22:44:05Z,closed,"bug, ExportVerilog","```
hw.module @Foo(%a: i3) {
  %c-1_i3 = hw.constant -1 : i3
  %0 = comb.extract %a from 0 : (i3) -> i1
  %1 = comb.icmp bin eq %a, %c-1_i3 : i3
  %2 = comb.and bin %1, %0 : i1
  verif.assert %2 : i1
}
```
Running this through `firtool` (no options needed) triggers an assertion in the pretty printer:
```
firtool: /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:285: auto circt::pretty::PrettyPrinter::print(const circt::pretty::PrettyPrinter::FormattedToken &)::(anonymous class)::operator()(const circt::pretty::EndToken *) const: Assertion `!printStack.empty() && ""more ends than begins?""' failed.
[...]
#10 0x000055f64008abe2 circt::pretty::Token::getKind() const /home/fabian/code/circt/include/circt/Support/PrettyPrinter.h:102:43
#11 0x000055f64008abe2 circt::pretty::TokenBase<circt::pretty::BreakToken, (circt::pretty::Token::Kind)1>::classof(circt::pretty::Token const*) /home/fabian/code/circt/include/circt/Support/PrettyPrinter.h:108:51
[...]
#22 0x000055f64008abe2 circt::pretty::PrettyPrinter::advanceLeft() /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:224:14
#23 0x000055f64008ae03 circt::pretty::PrettyPrinter::checkStream() /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:203:10
#24 0x000055f64008a509 circt::pretty::PrettyPrinter::add(circt::pretty::Token) /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:118:3
#25 0x000055f63f993fcb emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*) /home/fabian/code/circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:0:0
[...]
#31 0x000055f63f9c7490 circt::ExportVerilog::StringOrOpToEmit::setString(llvm::StringRef) /home/fabian/code/circt/lib/Conversion/ExportVerilog/ExportVerilogInternals.h:201:5
#32 0x000055f63f9c7490 circt::ExportVerilog::SharedEmitterState::emitOps(std::vector<circt::ExportVerilog::StringOrOpToEmit, std::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_65::operator()(circt::ExportVerilog::StringOrOpToEmit&) const /home/fabian/code/circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:5899:16
[...]
```
Probably related to the emission of `verif.assert` doing something fishy. I was tracking down a different failure related to `verif.assert` where the number of opening and closing parentheses don't match. Accidentally stumbled across this there.","hw.module @Foo(%a: i3) {
  %c-1_i3 = hw.constant -1 : i3
  %0 = comb.extract %a from 0 : (i3) -> i1
  %1 = comb.icmp bin eq %a, %c-1_i3 : i3
  %2 = comb.and bin %1, %0 : i1
  verif.assert %2 : i1
}","firtool: /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:285: auto circt::pretty::PrettyPrinter::print(const circt::pretty::PrettyPrinter::FormattedToken &)::(anonymous class)::operator()(const circt::pretty::EndToken *) const: Assertion `!printStack.empty() && ""more ends than begins?""' failed.
[...]
#10 0x000055f64008abe2 circt::pretty::Token::getKind() const /home/fabian/code/circt/include/circt/Support/PrettyPrinter.h:102:43
#11 0x000055f64008abe2 circt::pretty::TokenBase<circt::pretty::BreakToken, (circt::pretty::Token::Kind)1>::classof(circt::pretty::Token const*) /home/fabian/code/circt/include/circt/Support/PrettyPrinter.h:108:51
[...]
#22 0x000055f64008abe2 circt::pretty::PrettyPrinter::advanceLeft() /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:224:14
#23 0x000055f64008ae03 circt::pretty::PrettyPrinter::checkStream() /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:203:10
#24 0x000055f64008a509 circt::pretty::PrettyPrinter::add(circt::pretty::Token) /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:118:3
#25 0x000055f63f993fcb emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*) /home/fabian/code/circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:0:0
[...]
#31 0x000055f63f9c7490 circt::ExportVerilog::StringOrOpToEmit::setString(llvm::StringRef) /home/fabian/code/circt/lib/Conversion/ExportVerilog/ExportVerilogInternals.h:201:5
#32 0x000055f63f9c7490 circt::ExportVerilog::SharedEmitterState::emitOps(std::vector<circt::ExportVerilog::StringOrOpToEmit, std::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_65::operator()(circt::ExportVerilog::StringOrOpToEmit&) const /home/fabian/code/circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:5899:16
[...]",,,,,,,,
5727,[FIRRTL] Lower XMR assumes unique port names,2023-07-28T21:07:23Z,open,"bug, FIRRTL","FIRRTL's `LoweXMR` pass will currently produce invalid IR if it is given a module which has duplicate port names.

```mlir
firrtl.circuit ""Foo"" {
  firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [""a"", ""a""]} {
    %b = firrtl.wire interesting_name : !firrtl.uint<1>
    %0 = firrtl.ref.send %b : !firrtl.uint<1>
    firrtl.ref.define %a, %0 : !firrtl.probe<uint<1>>
    %1 = firrtl.ref.send %b : !firrtl.uint<1>
    firrtl.ref.define %a0, %1 : !firrtl.probe<uint<1>>
  }
}
```

This produces:

```
# circt-opt Foo.mlir -firrtl-lower-xmr                                   
firrtl-snippets/issues/x.mlir:3:5: error: redefinition of symbol named 'ref_Foo_Foo_a'
    firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [""a"", ""a""]} {
    ^
firrtl-snippets/issues/x.mlir:3:5: note: see current operation: ""sv.macro.decl""() {sym_name = ""ref_Foo_Foo_a""} : () -> ()
firrtl-snippets/issues/x.mlir:3:5: note: see existing symbol definition here
```","firrtl.circuit ""Foo"" {
  firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [""a"", ""a""]} {
    %b = firrtl.wire interesting_name : !firrtl.uint<1>
    %0 = firrtl.ref.send %b : !firrtl.uint<1>
    firrtl.ref.define %a, %0 : !firrtl.probe<uint<1>>
    %1 = firrtl.ref.send %b : !firrtl.uint<1>
    firrtl.ref.define %a0, %1 : !firrtl.probe<uint<1>>
  }
}","# circt-opt Foo.mlir -firrtl-lower-xmr                                   
firrtl-snippets/issues/x.mlir:3:5: error: redefinition of symbol named 'ref_Foo_Foo_a'
    firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [""a"", ""a""]} {
    ^
firrtl-snippets/issues/x.mlir:3:5: note: see current operation: ""sv.macro.decl""() {sym_name = ""ref_Foo_Foo_a""} : () -> ()
firrtl-snippets/issues/x.mlir:3:5: note: see existing symbol definition here",,,,,,,,
5721,[FIRRTL] FIRRTL Exporter needs to unique names,2023-07-28T17:58:04Z,open,"bug, good first issue","Currently, the FIRRTL exporter will not properly unique names during emission (like what `ExportVerilog` does). Consider the following:

```mlir
firrtl.circuit ""Foo"" {
  firrtl.module @Foo() {
    %0 = firrtl.wire {name = ""a""} : !firrtl.uint<1>
    %1 = firrtl.wire {name = ""a""} : !firrtl.uint<1>
  }
}
```

This produces the following illegal FIRRTL (`circt-translate -export-firrtl Foo.mlir`):
```
FIRRTL version 3.1.0
circuit Foo :
  module Foo : 
    wire a : UInt<1> 
    wire a : UInt<1> 
```

`wire a` is defined twice.","firrtl.circuit ""Foo"" {
  firrtl.module @Foo() {
    %0 = firrtl.wire {name = ""a""} : !firrtl.uint<1>
    %1 = firrtl.wire {name = ""a""} : !firrtl.uint<1>
  }
}","FIRRTL version 3.1.0
circuit Foo :
  module Foo : 
    wire a : UInt<1> 
    wire a : UInt<1>",,,,,,,,
5665,[SVExtractTestCode] Instance inlining doesn't update inner symbols and clone sv.bind,2023-07-24T11:37:59Z,closed,"bug, Verilog/SystemVerilog","```scala
circuit Top:
  module Assert:
    input clock: Clock
    input a: UInt<1>
    assert(clock, a, a, ""foo"")

  module Top:
    input clock: Clock
    input a: UInt<1>
    input b: UInt<1>
    inst a1 of Assert
    a1.a <= a
    a1.clock <= clock
    inst a2 of Assert
    a2.a <= b
    a2.clock <= clock
```

The current output with `firtool -extract-test-code`. 

```verilog
// Generated by CIRCT firtool-1.48.0-44-gf453a87cd
// VCS coverage exclude_file
module Assert_assert(
  input a,
        clock
);

  always @(posedge clock) begin
    if (a)
      assert(a) else $error(""foo"");
  end // always @(posedge)
endmodule

module Top(
  input clock,
        a,
        b
);

endmodule


// ----- 8< ----- FILE ""bindfile.sv"" ----- 8< -----

// Generated by CIRCT firtool-1.48.0-44-gf453a87cd
bind Top Assert_assert Assert_assert (
  .a     (a),
  .clock (clock)
);
```

The second assertion is not emitted in the bind file. This is because bind op is not cloned properly when input only modules are inlined and the first instance (in the instance graph ndoe iterator) is preserved.  This bug was first introduced by https://github.com/llvm/circt/commit/0d5cf22e970a4085488fafd472aa51517c360312 which was included in 1.17.0.","circuit Top:
  module Assert:
    input clock: Clock
    input a: UInt<1>
    assert(clock, a, a, ""foo"")

  module Top:
    input clock: Clock
    input a: UInt<1>
    input b: UInt<1>
    inst a1 of Assert
    a1.a <= a
    a1.clock <= clock
    inst a2 of Assert
    a2.a <= b
    a2.clock <= clock","// Generated by CIRCT firtool-1.48.0-44-gf453a87cd
// VCS coverage exclude_file
module Assert_assert(
  input a,
        clock
);

  always @(posedge clock) begin
    if (a)
      assert(a) else $error(""foo"");
  end // always @(posedge)
endmodule

module Top(
  input clock,
        a,
        b
);

endmodule


// ----- 8< ----- FILE ""bindfile.sv"" ----- 8< -----

// Generated by CIRCT firtool-1.48.0-44-gf453a87cd
bind Top Assert_assert Assert_assert (
  .a     (a),
  .clock (clock)
);",,,,,,,,
5650,[FIRRTL] Canonicalizer creates invalid StrictConnect,2023-07-21T12:50:50Z,closed,"bug, FIRRTL","Input:
```
firrtl.circuit ""Child"" {
firrtl.module @Child(in %io_y: !firrtl.uint<1>, out %io_x: !firrtl.uint<1>) {
  %io = firrtl.wire : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
  %2 = firrtl.subfield %io[y] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
  firrtl.strictconnect %2, %io_y : !firrtl.uint<1>
  %3 = firrtl.subfield %io[x] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
  firrtl.strictconnect %io_x, %3 : !firrtl.uint<1>
  firrtl.strictconnect %3, %2 : !firrtl.uint<1>
}
}
```

```
$ circt-opt -canonicalize canonicalize_flips_strictconnect.mlir -mlir-print-ir-after-failure -mlir-print-assume-verified
canonicalize_flips_strictconnect.mlir:3:9: error: 'firrtl.strictconnect' op operand #0 must be a sized passive base type (contains no uninferred widths, or flips) or foreign type, but got '!firrtl.bundle<y flip: uint<1>, x: uint<1>>'
  %io = firrtl.wire : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
        ^
canonicalize_flips_strictconnect.mlir:3:9: note: see current operation: ""firrtl.strictconnect""(%0, %3) : (!firrtl.bundle<y flip: uint<1>, x: uint<1>>, !firrtl.bundle<y flip: uint<1>, x: uint<1>>) -> ()
// -----// IR Dump After Canonicalizer Failed (canonicalize) //----- //
module {
  firrtl.circuit ""Child"" {
    firrtl.module @Child(in %io_y: !firrtl.uint<1>, out %io_x: !firrtl.uint<1>) {
      %io = firrtl.wire : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
      %0 = firrtl.subfield %io[y] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
      %1 = firrtl.subfield %io[x] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
      firrtl.strictconnect %io_x, %1 : !firrtl.uint<1>
      %2 = firrtl.bundlecreate %io_y, %0 : (!firrtl.uint<1>, !firrtl.uint<1>) -> !firrtl.bundle<y flip: uint<1>, x: uint<1>>
      firrtl.strictconnect %io, %2 : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
    }
  }
}
```","firrtl.circuit ""Child"" {
firrtl.module @Child(in %io_y: !firrtl.uint<1>, out %io_x: !firrtl.uint<1>) {
  %io = firrtl.wire : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
  %2 = firrtl.subfield %io[y] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
  firrtl.strictconnect %2, %io_y : !firrtl.uint<1>
  %3 = firrtl.subfield %io[x] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
  firrtl.strictconnect %io_x, %3 : !firrtl.uint<1>
  firrtl.strictconnect %3, %2 : !firrtl.uint<1>
}
}","$ circt-opt -canonicalize canonicalize_flips_strictconnect.mlir -mlir-print-ir-after-failure -mlir-print-assume-verified
canonicalize_flips_strictconnect.mlir:3:9: error: 'firrtl.strictconnect' op operand #0 must be a sized passive base type (contains no uninferred widths, or flips) or foreign type, but got '!firrtl.bundle<y flip: uint<1>, x: uint<1>>'
  %io = firrtl.wire : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
        ^
canonicalize_flips_strictconnect.mlir:3:9: note: see current operation: ""firrtl.strictconnect""(%0, %3) : (!firrtl.bundle<y flip: uint<1>, x: uint<1>>, !firrtl.bundle<y flip: uint<1>, x: uint<1>>) -> ()
// -----// IR Dump After Canonicalizer Failed (canonicalize) //----- //
module {
  firrtl.circuit ""Child"" {
    firrtl.module @Child(in %io_y: !firrtl.uint<1>, out %io_x: !firrtl.uint<1>) {
      %io = firrtl.wire : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
      %0 = firrtl.subfield %io[y] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
      %1 = firrtl.subfield %io[x] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
      firrtl.strictconnect %io_x, %1 : !firrtl.uint<1>
      %2 = firrtl.bundlecreate %io_y, %0 : (!firrtl.uint<1>, !firrtl.uint<1>) -> !firrtl.bundle<y flip: uint<1>, x: uint<1>>
      firrtl.strictconnect %io, %2 : !firrtl.bundle<y flip: uint<1>, x: uint<1>>
    }
  }
}",,,,,,,,
5613,[ExportVerilog] Prepare for emission crashes on test in regression suit,2023-07-18T04:41:22Z,closed,"bug, ExportVerilog","Input:
```mlir
hw.module @LowerIntrinsicStyle(%a: i1, %b: i1) {
  verif.assert %2 : !ltl.sequence
  %0 = ltl.implication %2, %1 : !ltl.sequence, !ltl.property
  %1 = ltl.or %b, %3 : i1, !ltl.property
  %2 = ltl.and %b, %4 : i1, !ltl.sequence
  %3 = ltl.not %b : i1
  %4 = ltl.delay %a, 42 : i1
  hw.output
}
```

Command:
`./build/bin/circt-opt --pass-pipeline='builtin.module(hw.module(prepare-for-emission))'`","hw.module @LowerIntrinsicStyle(%a: i1, %b: i1) {
  verif.assert %2 : !ltl.sequence
  %0 = ltl.implication %2, %1 : !ltl.sequence, !ltl.property
  %1 = ltl.or %b, %3 : i1, !ltl.property
  %2 = ltl.and %b, %4 : i1, !ltl.sequence
  %3 = ltl.not %b : i1
  %4 = ltl.delay %a, 42 : i1
  hw.output
}",,,,,,,,,
5605,[ExportVerilog] Prepare for Emission Assertion Failure,2023-07-17T15:20:33Z,closed,"bug, ExportVerilog","The composition of `PrepareForEmission` and `ExportVerilog` can cause assertion failures for certain IR. Consider the example below. Here, `sv.system.sampled` is used twice. This needs to get duplicated so it is inlined into its assertion use sites. The `concat` will then throw an assertion during `ExportVerilog` as it was not spilled to a wire:

```mlir
hw.module @Foo(%foo: i25, %bar: i12, %clock: i1, %reset: i1) {
    %concat = comb.concat %foo, %bar : i25, i12
    %415 = sv.system.sampled %concat : i37
    sv.assert.concurrent posedge %clock, %reset label ""assert__verif"" message ""foo""(%415) : i37
    sv.assert.concurrent posedge %clock, %reset label ""assert__verif"" message ""bar""(%415) : i37
    hw.output
  }
```

It is reasonable if either the concat is inline into both use sites or if a temporary wire is created.

This hints at some problems with forward pass approach of `PrepareForEmission`. E.g., for the wire emission case, the concat should be spilled to a wire if it has more than one use. However, it only has more than one use if its one user becomes two. This is only know after visiting the sampled op which requires backtracking.

It would likely be cleaner to structure `PrepareForEmission` as a backwards pass over the IR as the logic for duplicating or wire spilling is all dependent on users.","hw.module @Foo(%foo: i25, %bar: i12, %clock: i1, %reset: i1) {
    %concat = comb.concat %foo, %bar : i25, i12
    %415 = sv.system.sampled %concat : i37
    sv.assert.concurrent posedge %clock, %reset label ""assert__verif"" message ""foo""(%415) : i37
    sv.assert.concurrent posedge %clock, %reset label ""assert__verif"" message ""bar""(%415) : i37
    hw.output
  }",,,,,,,,,
5598,[FIRRTL][Inliner] Handle inner symbols with fieldID != 0,2023-07-15T00:27:52Z,closed,"bug, FIRRTL","Inliner only handles top-level symbols.  Consider this small example modified from its lit test on renaming scenarios:

```mlir
firrtl.circuit ""CollidingSymbolsFields"" {
  hw.hierpath private @nla1 [@CollidingSymbolsFields::@foo, @Foo::@bar, @Bar]
  firrtl.module @Bar() attributes {annotations = [{circt.nonlocal = @nla1, class = ""nla1""}]} {}
  firrtl.module @Foo() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
    %b = firrtl.wire sym [<@b,1,public>] : !firrtl.bundle<a: uint<1>, b: uint<1>>
    firrtl.instance bar sym @bar @Bar()
  }
  firrtl.module @CollidingSymbolsFields() {
    firrtl.instance foo sym @foo @Foo()
    %collision_b = firrtl.wire sym @b : !firrtl.uint<1>
    %collision_bar = firrtl.wire sym [<@bar,1,public>] : !firrtl.bundle<a: uint<1>, b: uint<1>>
  }
}
```

Point inliner at it (` circt-opt -firrtl-inliner`) to see the resulting failure due to not understanding/inspecting/handling symbols that aren't on fieldID=0:

```
inliner-perfield-nocheck.mlir:10:20: error: redefinition of inner symbol named 'b'
    %collision_b = firrtl.wire sym @b : !firrtl.uint<1>
                   ^
inliner-perfield-nocheck.mlir:10:20: note: see current operation: %1 = ""firrtl.wire""() {annotations = [], inner_sym = #hw<innerSym@b>, name = ""collision_b"", nameKind = #firrtl<name_kind droppable_name>} : () -> !firrtl.uint<1>
inliner-perfield-nocheck.mlir:5:10: note: see existing inner symbol definition here
    %b = firrtl.wire sym [<@b,1,public>] : !firrtl.bundle<a: uint<1>, b: uint<1>>
```","firrtl.circuit ""CollidingSymbolsFields"" {
  hw.hierpath private @nla1 [@CollidingSymbolsFields::@foo, @Foo::@bar, @Bar]
  firrtl.module @Bar() attributes {annotations = [{circt.nonlocal = @nla1, class = ""nla1""}]} {}
  firrtl.module @Foo() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
    %b = firrtl.wire sym [<@b,1,public>] : !firrtl.bundle<a: uint<1>, b: uint<1>>
    firrtl.instance bar sym @bar @Bar()
  }
  firrtl.module @CollidingSymbolsFields() {
    firrtl.instance foo sym @foo @Foo()
    %collision_b = firrtl.wire sym @b : !firrtl.uint<1>
    %collision_bar = firrtl.wire sym [<@bar,1,public>] : !firrtl.bundle<a: uint<1>, b: uint<1>>
  }
}","inliner-perfield-nocheck.mlir:10:20: error: redefinition of inner symbol named 'b'
    %collision_b = firrtl.wire sym @b : !firrtl.uint<1>
                   ^
inliner-perfield-nocheck.mlir:10:20: note: see current operation: %1 = ""firrtl.wire""() {annotations = [], inner_sym = #hw<innerSym@b>, name = ""collision_b"", nameKind = #firrtl<name_kind droppable_name>} : () -> !firrtl.uint<1>
inliner-perfield-nocheck.mlir:5:10: note: see existing inner symbol definition here
    %b = firrtl.wire sym [<@b,1,public>] : !firrtl.bundle<a: uint<1>, b: uint<1>>",,,,,,,,
5592,"[FIRRTL][LowerTypes] Memory with symbols blindly drops symbol, spawns new ones?",2023-07-14T18:14:11Z,closed,"bug, FIRRTL","Code path not under test, should probably be an error (?).

Input:
```
firrtl.circuit ""Mem2"" {
  firrtl.module @Mem2(in %clock: !firrtl.clock, in %rAddr: !firrtl.uint<4>, in %rEn: !firrtl.uint<1>, out %rData: !firrtl.bundle<a: uint<8>, b: uint<8>>, in %wAddr: !firrtl.uint<4>, in %wEn: !firrtl.uint<1>, in %wMask: !firrtl.bundle<a: uint<1>, b: uint<1>>, in %wData: !firrtl.bundle<a: uint<8>, b: uint<8>>) {
    %memory_r, %memory_w = firrtl.mem sym @X Undefined {depth = 16 : i64, name = ""memory"", portNames = [""r"", ""w""], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>, !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>
    %0 = firrtl.subfield %memory_r[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>
    firrtl.connect %0, %clock : !firrtl.clock, !firrtl.clock
    %1 = firrtl.subfield %memory_r[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>
    firrtl.connect %1, %rEn : !firrtl.uint<1>, !firrtl.uint<1>
    %2 = firrtl.subfield %memory_r[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>
    firrtl.connect %2, %rAddr : !firrtl.uint<4>, !firrtl.uint<4>
    %3 = firrtl.subfield %memory_r[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>
    firrtl.connect %rData, %3 : !firrtl.bundle<a: uint<8>, b: uint<8>>, !firrtl.bundle<a: uint<8>, b: uint<8>>
    %4 = firrtl.subfield %memory_w[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>
    firrtl.connect %4, %clock : !firrtl.clock, !firrtl.clock
    %5 = firrtl.subfield %memory_w[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>
    firrtl.connect %5, %wEn : !firrtl.uint<1>, !firrtl.uint<1>
    %6 = firrtl.subfield %memory_w[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>
    firrtl.connect %6, %wAddr : !firrtl.uint<4>, !firrtl.uint<4>
    %7 = firrtl.subfield %memory_w[mask] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>
    firrtl.connect %7, %wMask : !firrtl.bundle<a: uint<1>, b: uint<1>>, !firrtl.bundle<a: uint<1>, b: uint<1>>
    %8 = firrtl.subfield %memory_w[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>
    firrtl.connect %8, %wData : !firrtl.bundle<a: uint<8>, b: uint<8>>, !firrtl.bundle<a: uint<8>, b: uint<8>>
  }
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@Mem2::@X>]}
}
```

(Verbatim as generic inner-sym user that would be broken by this behavior)

Running through ` circt-opt --firrtl-lower-types memsym.mlir` produces the following invalid IR (not caught by verified presently but it should):

```
module {
  firrtl.circuit ""Mem2"" {
    firrtl.module @Mem2(in %clock: !firrtl.clock, in %rAddr: !firrtl.uint<4>, in %rEn: !firrtl.uint<1>, out %rData_a: !firrtl.uint<8>, out %rData_b: !firrtl.uint<8>, in %wAddr: !firrtl.uint<4>, in %wEn: !firrtl.uint<1>, in %wMask_a: !firrtl.uint<1>, in %wMask_b: !firrtl.uint<1>, in %wData_a: !firrtl.uint<8>, in %wData_b: !firrtl.uint<8>) {
      %memory_r_addr = firrtl.wire : !firrtl.uint<4>
      %memory_r_en = firrtl.wire : !firrtl.uint<1>
      %memory_r_clk = firrtl.wire : !firrtl.clock
      %memory_r_data_a = firrtl.wire : !firrtl.uint<8>
      %memory_r_data_b = firrtl.wire : !firrtl.uint<8>
      %memory_w_addr = firrtl.wire : !firrtl.uint<4>
      %memory_w_en = firrtl.wire : !firrtl.uint<1>
      %memory_w_clk = firrtl.wire : !firrtl.clock
      %memory_w_data_a = firrtl.wire : !firrtl.uint<8>
      %memory_w_data_b = firrtl.wire : !firrtl.uint<8>
      %memory_w_mask_a = firrtl.wire : !firrtl.uint<1>
      %memory_w_mask_b = firrtl.wire : !firrtl.uint<1>
      %memory_a_r, %memory_a_w = firrtl.mem sym @Xmemory_a Undefined {depth = 16 : i64, name = ""memory_a"", portNames = [""r"", ""w""], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>, !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      %memory_b_r, %memory_b_w = firrtl.mem sym @Xmemory_b Undefined {depth = 16 : i64, name = ""memory_b"", portNames = [""r"", ""w""], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>, !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      %0 = firrtl.subfield %memory_a_r[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %0, %memory_r_addr : !firrtl.uint<4>
      %1 = firrtl.subfield %memory_b_r[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %1, %memory_r_addr : !firrtl.uint<4>
      %2 = firrtl.subfield %memory_a_r[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %2, %memory_r_en : !firrtl.uint<1>
      %3 = firrtl.subfield %memory_b_r[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %3, %memory_r_en : !firrtl.uint<1>
      %4 = firrtl.subfield %memory_a_r[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %4, %memory_r_clk : !firrtl.clock
      %5 = firrtl.subfield %memory_b_r[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %5, %memory_r_clk : !firrtl.clock
      %6 = firrtl.subfield %memory_a_r[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %memory_r_data_a, %6 : !firrtl.uint<8>
      %7 = firrtl.subfield %memory_b_r[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %memory_r_data_b, %7 : !firrtl.uint<8>
      %8 = firrtl.subfield %memory_a_w[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %8, %memory_w_addr : !firrtl.uint<4>
      %9 = firrtl.subfield %memory_b_w[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %9, %memory_w_addr : !firrtl.uint<4>
      %10 = firrtl.subfield %memory_a_w[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %10, %memory_w_en : !firrtl.uint<1>
      %11 = firrtl.subfield %memory_b_w[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %11, %memory_w_en : !firrtl.uint<1>
      %12 = firrtl.subfield %memory_a_w[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %12, %memory_w_clk : !firrtl.clock
      %13 = firrtl.subfield %memory_b_w[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %13, %memory_w_clk : !firrtl.clock
      %14 = firrtl.subfield %memory_a_w[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %14, %memory_w_data_a : !firrtl.uint<8>
      %15 = firrtl.subfield %memory_b_w[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %15, %memory_w_data_b : !firrtl.uint<8>
      %16 = firrtl.subfield %memory_a_w[mask] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %16, %memory_w_mask_a : !firrtl.uint<1>
      %17 = firrtl.subfield %memory_b_w[mask] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %17, %memory_w_mask_b : !firrtl.uint<1>
      firrtl.connect %memory_r_clk, %clock : !firrtl.clock, !firrtl.clock
      firrtl.connect %memory_r_en, %rEn : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %memory_r_addr, %rAddr : !firrtl.uint<4>, !firrtl.uint<4>
      firrtl.strictconnect %rData_a, %memory_r_data_a : !firrtl.uint<8>
      firrtl.strictconnect %rData_b, %memory_r_data_b : !firrtl.uint<8>
      firrtl.connect %memory_w_clk, %clock : !firrtl.clock, !firrtl.clock
      firrtl.connect %memory_w_en, %wEn : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %memory_w_addr, %wAddr : !firrtl.uint<4>, !firrtl.uint<4>
      firrtl.strictconnect %memory_w_mask_a, %wMask_a : !firrtl.uint<1>
      firrtl.strictconnect %memory_w_mask_b, %wMask_b : !firrtl.uint<1>
      firrtl.strictconnect %memory_w_data_a, %wData_a : !firrtl.uint<8>
      firrtl.strictconnect %memory_w_data_b, %wData_b : !firrtl.uint<8>
    }
    sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@Mem2::@X>]}
  }
}
```

Code: https://github.com/llvm/circt/blob/db3918a3797ae1a9e066468b63a052a3678a51f1/lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp#L279 .","firrtl.circuit ""Mem2"" {
  firrtl.module @Mem2(in %clock: !firrtl.clock, in %rAddr: !firrtl.uint<4>, in %rEn: !firrtl.uint<1>, out %rData: !firrtl.bundle<a: uint<8>, b: uint<8>>, in %wAddr: !firrtl.uint<4>, in %wEn: !firrtl.uint<1>, in %wMask: !firrtl.bundle<a: uint<1>, b: uint<1>>, in %wData: !firrtl.bundle<a: uint<8>, b: uint<8>>) {
    %memory_r, %memory_w = firrtl.mem sym @X Undefined {depth = 16 : i64, name = ""memory"", portNames = [""r"", ""w""], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>, !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>
    %0 = firrtl.subfield %memory_r[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>
    firrtl.connect %0, %clock : !firrtl.clock, !firrtl.clock
    %1 = firrtl.subfield %memory_r[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>
    firrtl.connect %1, %rEn : !firrtl.uint<1>, !firrtl.uint<1>
    %2 = firrtl.subfield %memory_r[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>
    firrtl.connect %2, %rAddr : !firrtl.uint<4>, !firrtl.uint<4>
    %3 = firrtl.subfield %memory_r[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>
    firrtl.connect %rData, %3 : !firrtl.bundle<a: uint<8>, b: uint<8>>, !firrtl.bundle<a: uint<8>, b: uint<8>>
    %4 = firrtl.subfield %memory_w[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>
    firrtl.connect %4, %clock : !firrtl.clock, !firrtl.clock
    %5 = firrtl.subfield %memory_w[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>
    firrtl.connect %5, %wEn : !firrtl.uint<1>, !firrtl.uint<1>
    %6 = firrtl.subfield %memory_w[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>
    firrtl.connect %6, %wAddr : !firrtl.uint<4>, !firrtl.uint<4>
    %7 = firrtl.subfield %memory_w[mask] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>
    firrtl.connect %7, %wMask : !firrtl.bundle<a: uint<1>, b: uint<1>>, !firrtl.bundle<a: uint<1>, b: uint<1>>
    %8 = firrtl.subfield %memory_w[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>
    firrtl.connect %8, %wData : !firrtl.bundle<a: uint<8>, b: uint<8>>, !firrtl.bundle<a: uint<8>, b: uint<8>>
  }
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@Mem2::@X>]}
}","module {
  firrtl.circuit ""Mem2"" {
    firrtl.module @Mem2(in %clock: !firrtl.clock, in %rAddr: !firrtl.uint<4>, in %rEn: !firrtl.uint<1>, out %rData_a: !firrtl.uint<8>, out %rData_b: !firrtl.uint<8>, in %wAddr: !firrtl.uint<4>, in %wEn: !firrtl.uint<1>, in %wMask_a: !firrtl.uint<1>, in %wMask_b: !firrtl.uint<1>, in %wData_a: !firrtl.uint<8>, in %wData_b: !firrtl.uint<8>) {
      %memory_r_addr = firrtl.wire : !firrtl.uint<4>
      %memory_r_en = firrtl.wire : !firrtl.uint<1>
      %memory_r_clk = firrtl.wire : !firrtl.clock
      %memory_r_data_a = firrtl.wire : !firrtl.uint<8>
      %memory_r_data_b = firrtl.wire : !firrtl.uint<8>
      %memory_w_addr = firrtl.wire : !firrtl.uint<4>
      %memory_w_en = firrtl.wire : !firrtl.uint<1>
      %memory_w_clk = firrtl.wire : !firrtl.clock
      %memory_w_data_a = firrtl.wire : !firrtl.uint<8>
      %memory_w_data_b = firrtl.wire : !firrtl.uint<8>
      %memory_w_mask_a = firrtl.wire : !firrtl.uint<1>
      %memory_w_mask_b = firrtl.wire : !firrtl.uint<1>
      %memory_a_r, %memory_a_w = firrtl.mem sym @Xmemory_a Undefined {depth = 16 : i64, name = ""memory_a"", portNames = [""r"", ""w""], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>, !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      %memory_b_r, %memory_b_w = firrtl.mem sym @Xmemory_b Undefined {depth = 16 : i64, name = ""memory_b"", portNames = [""r"", ""w""], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>, !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      %0 = firrtl.subfield %memory_a_r[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %0, %memory_r_addr : !firrtl.uint<4>
      %1 = firrtl.subfield %memory_b_r[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %1, %memory_r_addr : !firrtl.uint<4>
      %2 = firrtl.subfield %memory_a_r[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %2, %memory_r_en : !firrtl.uint<1>
      %3 = firrtl.subfield %memory_b_r[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %3, %memory_r_en : !firrtl.uint<1>
      %4 = firrtl.subfield %memory_a_r[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %4, %memory_r_clk : !firrtl.clock
      %5 = firrtl.subfield %memory_b_r[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %5, %memory_r_clk : !firrtl.clock
      %6 = firrtl.subfield %memory_a_r[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %memory_r_data_a, %6 : !firrtl.uint<8>
      %7 = firrtl.subfield %memory_b_r[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>
      firrtl.strictconnect %memory_r_data_b, %7 : !firrtl.uint<8>
      %8 = firrtl.subfield %memory_a_w[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %8, %memory_w_addr : !firrtl.uint<4>
      %9 = firrtl.subfield %memory_b_w[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %9, %memory_w_addr : !firrtl.uint<4>
      %10 = firrtl.subfield %memory_a_w[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %10, %memory_w_en : !firrtl.uint<1>
      %11 = firrtl.subfield %memory_b_w[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %11, %memory_w_en : !firrtl.uint<1>
      %12 = firrtl.subfield %memory_a_w[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %12, %memory_w_clk : !firrtl.clock
      %13 = firrtl.subfield %memory_b_w[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %13, %memory_w_clk : !firrtl.clock
      %14 = firrtl.subfield %memory_a_w[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %14, %memory_w_data_a : !firrtl.uint<8>
      %15 = firrtl.subfield %memory_b_w[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %15, %memory_w_data_b : !firrtl.uint<8>
      %16 = firrtl.subfield %memory_a_w[mask] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %16, %memory_w_mask_a : !firrtl.uint<1>
      %17 = firrtl.subfield %memory_b_w[mask] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>
      firrtl.strictconnect %17, %memory_w_mask_b : !firrtl.uint<1>
      firrtl.connect %memory_r_clk, %clock : !firrtl.clock, !firrtl.clock
      firrtl.connect %memory_r_en, %rEn : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %memory_r_addr, %rAddr : !firrtl.uint<4>, !firrtl.uint<4>
      firrtl.strictconnect %rData_a, %memory_r_data_a : !firrtl.uint<8>
      firrtl.strictconnect %rData_b, %memory_r_data_b : !firrtl.uint<8>
      firrtl.connect %memory_w_clk, %clock : !firrtl.clock, !firrtl.clock
      firrtl.connect %memory_w_en, %wEn : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %memory_w_addr, %wAddr : !firrtl.uint<4>, !firrtl.uint<4>
      firrtl.strictconnect %memory_w_mask_a, %wMask_a : !firrtl.uint<1>
      firrtl.strictconnect %memory_w_mask_b, %wMask_b : !firrtl.uint<1>
      firrtl.strictconnect %memory_w_data_a, %wData_a : !firrtl.uint<8>
      firrtl.strictconnect %memory_w_data_b, %wData_b : !firrtl.uint<8>
    }
    sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@Mem2::@X>]}
  }
}",,,,,,,,
5590,"[FIRRTL][LowerToHW] Zero-width signals with inner symbol are silently deleted, breaking users",2023-07-14T17:16:38Z,open,"bug, FIRRTL","Consider this MLIR example:

```
module {
  firrtl.circuit ""OMIRField"" {
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0>, out %y_b: !firrtl.uint<0>) {
      %n_b = firrtl.node sym @omir_sym %x_b : !firrtl.uint<0>
      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>
    }
  }
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
}
```

Feeding through LowerToHW: `circt-opt --lower-firrtl-to-hw` produces:

```
module {
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
  hw.module @OMIRField() {
    hw.output
  }
}
```

And if run through `firtool` directly, produces:
```
omir_zw_field_issue.mlir:8:3: error: cannot get name for symbol #hw.innerNameRef<@OMIRField::@omir_sym>
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
  ^
omir_zw_field_issue.mlir:8:3: note: see current operation: ""sv.verbatim""() {format_string = ""Testing {{0}}"", symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]} : () -> ()
// Generated by CIRCT 1.46.0g20230714_98d0bf5
Testing <INVALID>	// omir_zw_field_issue.mlir:8:3
module OMIRField();	// omir_zw_field_issue.mlir:3:5
endmodule
```

The non-failing error isn't great and should be fixed (cc #4770 for similar in adjacent code).
Also, this should be caught by the verifier in HW but that support isn't in place yet (cc #3526).

---

Moving the symbol to a port produces an error, modified input:

```
module {
  firrtl.circuit ""OMIRField"" {
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {
      %n_b = firrtl.node %x_b : !firrtl.uint<0>
      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>
    }
  }
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
}
```

Error:
```
omir_zw_field_issue.mlir:3:33: error: zero width port ""x_b"" is referenced by name [#hw<innerSym@omir_sym>] (e.g. in an XMR) but must be removed
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {
                                ^
```","module {
  firrtl.circuit ""OMIRField"" {
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0>, out %y_b: !firrtl.uint<0>) {
      %n_b = firrtl.node sym @omir_sym %x_b : !firrtl.uint<0>
      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>
    }
  }
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
}","module {
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
  hw.module @OMIRField() {
    hw.output
  }
}","omir_zw_field_issue.mlir:8:3: error: cannot get name for symbol #hw.innerNameRef<@OMIRField::@omir_sym>
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
  ^
omir_zw_field_issue.mlir:8:3: note: see current operation: ""sv.verbatim""() {format_string = ""Testing {{0}}"", symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]} : () -> ()
// Generated by CIRCT 1.46.0g20230714_98d0bf5
Testing <INVALID>	// omir_zw_field_issue.mlir:8:3
module OMIRField();	// omir_zw_field_issue.mlir:3:5
endmodule","module {
  firrtl.circuit ""OMIRField"" {
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {
      %n_b = firrtl.node %x_b : !firrtl.uint<0>
      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>
    }
  }
  sv.verbatim ""Testing {{0}}"" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}
}","omir_zw_field_issue.mlir:3:33: error: zero width port ""x_b"" is referenced by name [#hw<innerSym@omir_sym>] (e.g. in an XMR) but must be removed
    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {
                                ^",,,,,
5566,[SV] Crash in `P/BPAssignOp` verifiers for `hw.inout` ports,2023-07-12T07:32:39Z,open,"bug, good first issue, Verilog/SystemVerilog","[In the SV `P/BPAssignOp` verifiers](https://github.com/llvm/circt/blob/main/lib/Dialect/SV/SVOps.cpp#L1142-L1156) it is assumed that the target argument is defined by an op (`isa` used on `getDefiningOp`). Hence, in the case of a `hw.inout` input port, the verifier crashes.

i.e.:
```mlir
hw.module @unsupported(%a: !hw.inout<i42>) {
  %clock = hw.constant 1 : i1
  %c42 = hw.constant 42 : i42
  sv.alwaysff(posedge %clock) {
    sv.passign %a, %c42 : i42
  }
}
```

","hw.module @unsupported(%a: !hw.inout<i42>) {
  %clock = hw.constant 1 : i1
  %c42 = hw.constant 42 : i42
  sv.alwaysff(posedge %clock) {
    sv.passign %a, %c42 : i42
  }
}",,,,,,,,,
5562,[FIRRTL][LowerToHW] An uninstantiated module can crash LowerToHW,2023-07-10T23:17:06Z,open,"bug, FIRRTL","I came across the following failure. The problem occurs if a module which is not under the main module in the instance graph includes reference type ports:

```mlir
firrtl.circuit ""Foo"" {
  firrtl.module @Foo() {}
  firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.probe<uint<1>>) {
    %0 = firrtl.ref.send %a : !firrtl.uint<1>
    firrtl.ref.define %b, %0 : !firrtl.probe<uint<1>>
  }
}
```

The failure trips an assert in `LowerToHW` [here](https://github.com/llvm/circt/blob/main/lib/Conversion/FIRRTLToHW/LowerToHW.cpp#L2337):

```
Assertion failed: ((!result || !isa<FIRRTLType>(result.getType())) && ""Lowering didn't turn a FIRRTL value into a non-FIRRTL value""), function setLowering, file LowerToHW.cpp, line 2338.
```","firrtl.circuit ""Foo"" {
  firrtl.module @Foo() {}
  firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.probe<uint<1>>) {
    %0 = firrtl.ref.send %a : !firrtl.uint<1>
    firrtl.ref.define %b, %0 : !firrtl.probe<uint<1>>
  }
}","Assertion failed: ((!result || !isa<FIRRTLType>(result.getType())) && ""Lowering didn't turn a FIRRTL value into a non-FIRRTL value""), function setLowering, file LowerToHW.cpp, line 2338.",,,,,,,,
5552,"[FIRRTL] handle zero-width deletion: rwprobe/forceable, force+friends",2023-07-07T18:16:27Z,closed,"bug, FIRRTL","Consider:

```
circuit Foo:
  module Foo:
    wire x : UInt<0>
    x <= UInt(0)
    force_initial(rwprobe(x), UInt<0>(0))
```

Presently this dies in LowerToHW.  Presently LowerXMR is responsible for examining all ref uses and dropping if zero-width, so bug (I think) is LowerXMR preserving the force operation and keeps declarations forceable.","circuit Foo:
  module Foo:
    wire x : UInt<0>
    x <= UInt(0)
    force_initial(rwprobe(x), UInt<0>(0))",,,,,,,,,
5524,"[FIRRTL] AndCvtU canonicalization crash, wrong result (when widths aren't same)",2023-06-30T05:09:45Z,closed,"bug, FIRRTL","```
circuit Top:
  module Top:
    input x: UInt<1>
    output out: UInt<2>
    out <= and(cvt(x), SInt<4>(2))
```

```
[firtool] Running ""firrtl.module(canonicalize{  max-iterations=10 max-num-rewrites=-1 region-simplify=false test-convergence=false top-down=true},firrtl-infer-rw)""
firtool: /scratch/hidetou/circt/llvm/llvm/lib/Support/APInt.cpp:973: llvm::APInt llvm::APInt::zext(unsigned int) const: Assertion `width >= BitWidth && ""Invalid APInt ZeroExtend request""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
 #0 0x0000000000450677 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x000000000044e800 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x0000000000450f8f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007f56ed87acf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)
 #4 0x00007f56ec705aff raise (/lib64/libc.so.6+0x4eaff)
 #5 0x00007f56ec6d8ea5 abort (/lib64/libc.so.6+0x21ea5)
 #6 0x00007f56ec6d8d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)
 #7 0x00007f56ec6fe456 (/lib64/libc.so.6+0x47456)
 #8 0x000000000045becf (/scratch/hidetou/circt/build/bin/firtool+0x45becf)
 #9 0x000000000088652f circt::firrtl::patterns::AndCvtU::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/FIRRTL/FIRRTLCanonicalization.h.inc:0:167
#10 0x0000000000b03131 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>)::$
```","circuit Top:
  module Top:
    input x: UInt<1>
    output out: UInt<2>
    out <= and(cvt(x), SInt<4>(2))","[firtool] Running ""firrtl.module(canonicalize{  max-iterations=10 max-num-rewrites=-1 region-simplify=false test-convergence=false top-down=true},firrtl-infer-rw)""
firtool: /scratch/hidetou/circt/llvm/llvm/lib/Support/APInt.cpp:973: llvm::APInt llvm::APInt::zext(unsigned int) const: Assertion `width >= BitWidth && ""Invalid APInt ZeroExtend request""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
 #0 0x0000000000450677 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x000000000044e800 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x0000000000450f8f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #3 0x00007f56ed87acf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)
 #4 0x00007f56ec705aff raise (/lib64/libc.so.6+0x4eaff)
 #5 0x00007f56ec6d8ea5 abort (/lib64/libc.so.6+0x21ea5)
 #6 0x00007f56ec6d8d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)
 #7 0x00007f56ec6fe456 (/lib64/libc.so.6+0x47456)
 #8 0x000000000045becf (/scratch/hidetou/circt/build/bin/firtool+0x45becf)
 #9 0x000000000088652f circt::firrtl::patterns::AndCvtU::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/FIRRTL/FIRRTLCanonicalization.h.inc:0:167
#10 0x0000000000b03131 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>)::$",,,,,,,,
5506,[FIRRTL] Bundle-of-alias crashes,2023-06-28T14:09:55Z,closed,"bug, FIRRTL","```
circuit AliasBundle:
  type Foo = { a : UInt<1> }
  type Bar = { a : Foo }
  module AliasBundle:
     input b : Bar
```

Which crashes presently, in InferWidths, in debug builds, reporting unsupported type encountered (Alias).","circuit AliasBundle:
  type Foo = { a : UInt<1> }
  type Bar = { a : Foo }
  module AliasBundle:
     input b : Bar",,,,,,,,,
5494,[FIRRTL] Crash parsing agg-of-properties or non-FieldIDTypeInterface,2023-06-27T16:09:03Z,closed,"bug, FIRRTL","Sample input:

```firrtl
circuit BundleOfProps:
  module BundleOfProps:
    input x : {a : String}
```

We require all elements of aggregates to also be FieldIDTypeInterface's, should be verifier and/or checked when parsing.

Presently the above crashes.","circuit BundleOfProps:
  module BundleOfProps:
    input x : {a : String}",,,,,,,,,
5483,[ExportVerilog] Missing `hw.struct_explode` support?,2023-06-26T22:23:43Z,open,"bug, HW","Running `circt-opt <file.mlir> --export-verilog` with `file.mlir` having the following content:
```mlir
module {
  hw.module @EXPLODE(%0: i64, %1: i64) -> (arg1: i64, arg2: i64) {
    %2 = hw.struct_create (%0, %1) : !hw.struct<arg1: i64, arg2: i64>
    %arg1, %arg2 = hw.struct_explode %2 : !hw.struct<arg1: i64, arg2: i64>

    hw.output %arg1, %arg2 : i64, i64
  }
}
```
triggers the following assertion:
```
circt-opt: circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:3295:
void (anonymous namespace)::NameCollector::collectNames(mlir::Block &): 
Assertion `(!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options))
 && ""If 'op' is a verilog expression, the expression must be inlinable. "" 
 ""Otherwise, it is a bug of PrepareForEmission""' failed.
```

This seems to be strongly related to the `hw.struct_explode` operation, because replacing it with `hw.struct_extract` ops works just fine.

(Yes, I know that in this case, the canonicalizer would optimize `hw.struct_create` and `hw.struct_explode` away. But this is the smallest example that I could come up with to reproduce the bug.)","module {
  hw.module @EXPLODE(%0: i64, %1: i64) -> (arg1: i64, arg2: i64) {
    %2 = hw.struct_create (%0, %1) : !hw.struct<arg1: i64, arg2: i64>
    %arg1, %arg2 = hw.struct_explode %2 : !hw.struct<arg1: i64, arg2: i64>

    hw.output %arg1, %arg2 : i64, i64
  }
}","circt-opt: circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:3295:
void (anonymous namespace)::NameCollector::collectNames(mlir::Block &): 
Assertion `(!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options))
 && ""If 'op' is a verilog expression, the expression must be inlinable. "" 
 ""Otherwise, it is a bug of PrepareForEmission""' failed.",,,,,,,,
5462,"[FIRRTL][CheckCombCycles] Missed cycles, sensitive to presence of node?",2023-06-22T23:52:10Z,open,"bug, FIRRTL","Input, `--preserve-aggregate=all`:

```firrtl
circuit Loop:
  module Loop:
    wire w : {a: UInt<8>}
    node n = w
    w <= n
```

For some reason the node is needed for this to be missed (?).

This was reduced from slightly more complicated interprocedural inputs like:

```firrtl
circuit Loop:
  module Child:
    input bundle : { a : UInt<1>, b : UInt<1> }
    output p : {a : UInt<1>, b : UInt<1> }

    node n = bundle

    p <= n
  module Loop:
    input x : UInt<1>

    inst c of Child
    c.bundle.a <= x
    c.bundle.b <= c.p.b
```

----

Does not appear to be limited to cycles entirely unreachable/disconnected from the rest of the design/ports, FWIW, consider:

```firrtl
circuit Loop:
  module Loop:
    input in : {a: UInt<8>}
    output out : {a: UInt<8>}
    input c : UInt<1>

    wire w : {a: UInt<8>}
    node n = w
    w <= mux(c, n, in)

    out <= w
```","circuit Loop:
  module Loop:
    wire w : {a: UInt<8>}
    node n = w
    w <= n","circuit Loop:
  module Child:
    input bundle : { a : UInt<1>, b : UInt<1> }
    output p : {a : UInt<1>, b : UInt<1> }

    node n = bundle

    p <= n
  module Loop:
    input x : UInt<1>

    inst c of Child
    c.bundle.a <= x
    c.bundle.b <= c.p.b","circuit Loop:
  module Loop:
    input in : {a: UInt<8>}
    output out : {a: UInt<8>}
    input c : UInt<1>

    wire w : {a: UInt<8>}
    node n = w
    w <= mux(c, n, in)

    out <= w",,,,,,,
5447,[FIRRTL][InferWidths] Make checkCycles Iterative,2023-06-21T15:58:20Z,open,"bug, FIRRTL","The method `InferWidths::checkCycles` is currently recursive. If `firtool` is spawned in a thread which has an abnormally low stack size (i.e., on MacOS running Chisel tests using Scalatest), this can result in stack overflows. Fix this method to make it recursive. This is similar to https://github.com/llvm/circt/pull/5305.",,,,,,,,,,
5391,[FIRRTL] Width inference bug as of 1.40.0,2023-06-13T14:15:35Z,closed,"bug, FIRRTL, infer width","Input:

```firrtl
circuit Widths:
  module Widths:
    input x : UInt<1>
    input y : UInt<2>
    output out1 : UInt
    output out2 : UInt

    wire w : UInt
    w <= x
    w <= y

    out1 <= w

    wire wx : UInt
    wx <= x

    out2 <= wx
```

firtool:

```systemverilog
// Generated by CIRCT firtool-1.43.0-53-g60763f2c0
module Widths(
  input        x,
  input  [1:0] y,
  output [1:0] out1,
               out2
);

  assign out1 = y;
  assign out2 = {1'h0, x};
endmodule
```

Note that `wx` / `out2` are inferred to have width 2 instead of the expected 1.

firtool 1.39.0 infers this correctly: (1.40.0 does not-- first release w/uninferred width cast FWIW)
```systemverilog
// Generated by CIRCT firtool-1.39.0
module Widths(
  input        x,
  input  [1:0] y,
  output [1:0] out1,
  output       out2
);

  assign out1 = y;
  assign out2 = x;
endmodule
```","circuit Widths:
  module Widths:
    input x : UInt<1>
    input y : UInt<2>
    output out1 : UInt
    output out2 : UInt

    wire w : UInt
    w <= x
    w <= y

    out1 <= w

    wire wx : UInt
    wx <= x

    out2 <= wx","// Generated by CIRCT firtool-1.43.0-53-g60763f2c0
module Widths(
  input        x,
  input  [1:0] y,
  output [1:0] out1,
               out2
);

  assign out1 = y;
  assign out2 = {1'h0, x};
endmodule","// Generated by CIRCT firtool-1.39.0
module Widths(
  input        x,
  input  [1:0] y,
  output [1:0] out1,
  output       out2
);

  assign out1 = y;
  assign out2 = x;
endmodule",,,,,,,
5355,[HWLegalizeModules] Legalize array concat op,2023-06-10T10:18:04Z,open,"bug, HW","Support hw.array_concat in HWLegalizeModules
```mlir
$ ./build/bin/firtool perf/regress/chipyard.TestHarness.RocketSmall1Medium1Big1_BoomMedium1Large1Mega1.top.v.hi.fir -o foo.sv --lowering-options=disallowLocalVariables,disallowPackedArrays
Arbiters.scala:42:16: error: unsupported packed array expression
Arbiters.scala:42:16: note: see current operation: %57 = ""hw.array_concat""(%3, %56) : (!hw.array<3xi1>, !hw.array<5xi1>) -> !hw.array<8xi1>
```
","$ ./build/bin/firtool perf/regress/chipyard.TestHarness.RocketSmall1Medium1Big1_BoomMedium1Large1Mega1.top.v.hi.fir -o foo.sv --lowering-options=disallowLocalVariables,disallowPackedArrays
Arbiters.scala:42:16: error: unsupported packed array expression
Arbiters.scala:42:16: note: see current operation: %57 = ""hw.array_concat""(%3, %56) : (!hw.array<3xi1>, !hw.array<5xi1>) -> !hw.array<8xi1>",,,,,,,,,
5333,[FIRRTL] infer resets doesn't work with const-cast of aggregates,2023-06-07T14:52:37Z,closed,"bug, FIRRTL","Input:

```
module {
  firrtl.circuit ""ConstReset"" {
    firrtl.module @ConstReset(in %in: !firrtl.const.bundle<a: reset, b: uint<1>>, out %out: !firrtl.bundle<a: asyncreset>, out %out2: !firrtl.bundle<a: reset, b: uint<1>>) {
      %out_a = firrtl.subfield %out[a] : !firrtl.bundle<a: asyncreset>
      %in_a = firrtl.subfield %in[a] : !firrtl.const.bundle<a: reset, b: uint<1>>
      %in_a_asyncreset = firrtl.resetCast %in_a : (!firrtl.const.reset) -> !firrtl.const.asyncreset
      %in_a_asyncreset_noconst = firrtl.constCast %in_a_asyncreset : (!firrtl.const.asyncreset) -> !firrtl.asyncreset
      firrtl.strictconnect %out_a, %in_a_asyncreset_noconst : !firrtl.asyncreset

      %in_noconst = firrtl.constCast %in : (!firrtl.const.bundle<a: reset, b: uint<1>>) -> !firrtl.bundle<a: reset, b : uint<1>>
      firrtl.strictconnect %out2, %in_noconst : !firrtl.bundle<a: reset, b: uint<1>>
    }
  }
}
```

Looks like InferResets only updates the constcast types if they're ground reset types?

Error after InferResets:

```
$ ./build/bin/firtool const-reset.mlir --mlir-print-ir-before=firrtl-infer-resets
// -----// IR Dump Before InferResets (firrtl-infer-resets) //----- //
firrtl.circuit ""ConstReset"" {
  firrtl.module @ConstReset(in %in: !firrtl.const.bundle<a: reset, b: uint<1>>, out %out: !firrtl.bundle<a: asyncreset>, out %out2: !firrtl.bundle<a: reset, b: uint<1>>) {
    %0 = firrtl.subfield %out[a] : !firrtl.bundle<a: asyncreset>
    %1 = firrtl.subfield %in[a] : !firrtl.const.bundle<a: reset, b: uint<1>>
    %2 = firrtl.resetCast %1 : (!firrtl.const.reset) -> !firrtl.const.asyncreset
    %3 = firrtl.constCast %2 : (!firrtl.const.asyncreset) -> !firrtl.asyncreset
    firrtl.strictconnect %0, %3 : !firrtl.asyncreset
    %4 = firrtl.constCast %in : (!firrtl.const.bundle<a: reset, b: uint<1>>) -> !firrtl.bundle<a: reset, b: uint<1>>
    firrtl.strictconnect %out2, %4 : !firrtl.bundle<a: reset, b: uint<1>>
  }
}

const-reset.mlir:10:21: error: 'firrtl.constCast' op '!firrtl.const.bundle<a: asyncreset, b: uint<1>>' is not 'const'-castable to '!firrtl.bundle<a: reset, b: uint<1>>'
      %in_noconst = firrtl.constCast %in : (!firrtl.const.bundle<a: reset, b: uint<1>>) -> !firrtl.bundle<a: reset, b : uint<1>>
                    ^
const-reset.mlir:10:21: note: see current operation: %3 = ""firrtl.constCast""(%arg0) : (!firrtl.const.bundle<a: asyncreset, b: uint<1>>) -> !firrtl.bundle<a: reset, b: uint<1>>
```","module {
  firrtl.circuit ""ConstReset"" {
    firrtl.module @ConstReset(in %in: !firrtl.const.bundle<a: reset, b: uint<1>>, out %out: !firrtl.bundle<a: asyncreset>, out %out2: !firrtl.bundle<a: reset, b: uint<1>>) {
      %out_a = firrtl.subfield %out[a] : !firrtl.bundle<a: asyncreset>
      %in_a = firrtl.subfield %in[a] : !firrtl.const.bundle<a: reset, b: uint<1>>
      %in_a_asyncreset = firrtl.resetCast %in_a : (!firrtl.const.reset) -> !firrtl.const.asyncreset
      %in_a_asyncreset_noconst = firrtl.constCast %in_a_asyncreset : (!firrtl.const.asyncreset) -> !firrtl.asyncreset
      firrtl.strictconnect %out_a, %in_a_asyncreset_noconst : !firrtl.asyncreset

      %in_noconst = firrtl.constCast %in : (!firrtl.const.bundle<a: reset, b: uint<1>>) -> !firrtl.bundle<a: reset, b : uint<1>>
      firrtl.strictconnect %out2, %in_noconst : !firrtl.bundle<a: reset, b: uint<1>>
    }
  }
}","$ ./build/bin/firtool const-reset.mlir --mlir-print-ir-before=firrtl-infer-resets
// -----// IR Dump Before InferResets (firrtl-infer-resets) //----- //
firrtl.circuit ""ConstReset"" {
  firrtl.module @ConstReset(in %in: !firrtl.const.bundle<a: reset, b: uint<1>>, out %out: !firrtl.bundle<a: asyncreset>, out %out2: !firrtl.bundle<a: reset, b: uint<1>>) {
    %0 = firrtl.subfield %out[a] : !firrtl.bundle<a: asyncreset>
    %1 = firrtl.subfield %in[a] : !firrtl.const.bundle<a: reset, b: uint<1>>
    %2 = firrtl.resetCast %1 : (!firrtl.const.reset) -> !firrtl.const.asyncreset
    %3 = firrtl.constCast %2 : (!firrtl.const.asyncreset) -> !firrtl.asyncreset
    firrtl.strictconnect %0, %3 : !firrtl.asyncreset
    %4 = firrtl.constCast %in : (!firrtl.const.bundle<a: reset, b: uint<1>>) -> !firrtl.bundle<a: reset, b: uint<1>>
    firrtl.strictconnect %out2, %4 : !firrtl.bundle<a: reset, b: uint<1>>
  }
}

const-reset.mlir:10:21: error: 'firrtl.constCast' op '!firrtl.const.bundle<a: asyncreset, b: uint<1>>' is not 'const'-castable to '!firrtl.bundle<a: reset, b: uint<1>>'
      %in_noconst = firrtl.constCast %in : (!firrtl.const.bundle<a: reset, b: uint<1>>) -> !firrtl.bundle<a: reset, b : uint<1>>
                    ^
const-reset.mlir:10:21: note: see current operation: %3 = ""firrtl.constCast""(%arg0) : (!firrtl.const.bundle<a: asyncreset, b: uint<1>>) -> !firrtl.bundle<a: reset, b: uint<1>>",,,,,,,,
5324,"[FIRRTL] crash, need getFieldName (and friends?) support for enums",2023-06-06T22:10:53Z,closed,"bug, FIRRTL","Following input crashes due to getFieldName not being supported (used to report error in InferWidths):

```firrtl
circuit NoWidthEnum:
  module NoWidthEnum:
    output o : {| Some : UInt, None |}
```

","circuit NoWidthEnum:
  module NoWidthEnum:
    output o : {| Some : UInt, None |}",,,,,,,,,
5322,[FIRRTL] Assertion failure parsing input connecting compatible (?) enums of different width inferred-ness,2023-06-06T20:17:16Z,closed,"bug, FIRRTL","Input:

```firrtl
circuit EnumWidths:
  module EnumWidths:
    input i : {| Some : UInt<8>, None |}
    input i2 : {| Some : UInt, None |}
    output o : {| Some : UInt, None |}
    output o2 : {| Some : UInt<8>, None |}
    o <= i
    o2 <= i2
```

Either connection causes an assertion failure during parsing (as of 6ff3acee7):

```
firtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::detail::TypedValue<circt::firrtl::IntType>, From = mlir::OpResult]: Assertion `isa<To>(Val) && ""cast<Ty>() argument of incompatible type!""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool ./enum-widths.fir
 #0 0x000055778c477435 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x000055778c475550 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x000055778c477aad SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007f22f9308d60 __restore_rt (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x38d60)
 #4 0x00007f22f9357adc __pthread_kill_implementation (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x87adc)
 #5 0x00007f22f9308cb6 gsignal (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x38cb6)
 #6 0x00007f22f92f28ba abort (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x228ba)
 #7 0x00007f22f92f27d9 _nl_load_domain.cold (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x227d9)
 #8 0x00007f22f93019c6 (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x319c6)
 #9 0x000055778ca660c4 circt::firrtl::emitConnect(mlir::ImplicitLocOpBuilder&, mlir::Value, mlir::Value) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLUtils.cpp:134:3
#10 0x000055778c4e1b89 (anonymous namespace)::FIRStmtParser::parseLeadingExpStmt(mlir::Value) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:0:5
#11 0x000055778c4db18e (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:0:0
#12 0x000055778c4dab35 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2111:17
#13 0x000055778c4dab35 (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2104:9
#14 0x000055778c4da5df mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#15 0x000055778c4da5df mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#16 0x000055778c4da5df (anonymous namespace)::FIRCircuitParser::parseModuleBody((anonymous namespace)::FIRCircuitParser::DeferredModuleToParse&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4077:7
#17 0x000055778c4da5df (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14::operator()(unsigned long) const /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4237:13
#18 0x000055778c4d5b01 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#19 0x000055778c4d5b01 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#20 0x000055778c4d5b01 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:11
#21 0x000055778c4d5b01 mlir::LogicalResult mlir::failableParallelForEach<llvm::iota_range<unsigned long>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14>(mlir::MLIRContext*, llvm::iota_range<unsigned long>&&, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#22 0x000055778c4d5b01 mlir::LogicalResult mlir::failableParallelForEachN<(anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14>(mlir::MLIRContext*, unsigned long, unsigned long, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:107:10
#23 0x000055778c4d5b01 (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4235:20
#24 0x000055778c4d5b01 circt::firrtl::importFIRFile(llvm::SourceMgr&, mlir::MLIRContext*, mlir::TimingScope&, circt::firrtl::FIRParserOptions) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4305:12
#25 0x000055778c3cbb62 std::enable_if<__and_<std::__not_<std::__is_tuple_like<mlir::ModuleOp>>, std::is_move_constructible<mlir::ModuleOp>, std::is_move_assignable<mlir::ModuleOp>>::value, void>::type std::swap<mlir::ModuleOp>(mlir::ModuleOp&, mlir::ModuleOp&) /nix/store/aafdki1nf49k5vxq6gx2yabiybk2bjmw-gcc-12.2.0/include/c++/12.2.0/bits/move.h:205:11
#26 0x000055778c3cbb62 mlir::OwningOpRef<mlir::ModuleOp>::release() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OwningOpRef.h:68:5
#27 0x000055778c3cbb62 mlir::OwningOpRef<mlir::ModuleOp>::operator=(mlir::OwningOpRef<mlir::ModuleOp>&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OwningOpRef.h:45:16
#28 0x000055778c3cbb62 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:286:12
#29 0x000055778c3cb56f processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:452:12
#30 0x000055778c3cb105 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:468:12
#31 0x000055778c3cb105 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:552:14
#32 0x000055778c3cace6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#33 0x000055778c3cace6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#34 0x000055778c3cace6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:616:8
#35 0x00007f22f92f3ace __libc_start_call_main (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x23ace)
#36 0x00007f22f92f3b89 __libc_start_main@GLIBC_2.2.5 (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x23b89)
#37 0x000055778c3cab15 _start (./build/bin/firtool+0x50db15)
zsh: IOT instruction (core dumped)  ./build/bin/firtool ./enum-widths.fir
```","circuit EnumWidths:
  module EnumWidths:
    input i : {| Some : UInt<8>, None |}
    input i2 : {| Some : UInt, None |}
    output o : {| Some : UInt, None |}
    output o2 : {| Some : UInt<8>, None |}
    o <= i
    o2 <= i2","firtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::detail::TypedValue<circt::firrtl::IntType>, From = mlir::OpResult]: Assertion `isa<To>(Val) && ""cast<Ty>() argument of incompatible type!""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool ./enum-widths.fir
 #0 0x000055778c477435 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x000055778c475550 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x000055778c477aad SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007f22f9308d60 __restore_rt (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x38d60)
 #4 0x00007f22f9357adc __pthread_kill_implementation (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x87adc)
 #5 0x00007f22f9308cb6 gsignal (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x38cb6)
 #6 0x00007f22f92f28ba abort (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x228ba)
 #7 0x00007f22f92f27d9 _nl_load_domain.cold (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x227d9)
 #8 0x00007f22f93019c6 (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x319c6)
 #9 0x000055778ca660c4 circt::firrtl::emitConnect(mlir::ImplicitLocOpBuilder&, mlir::Value, mlir::Value) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLUtils.cpp:134:3
#10 0x000055778c4e1b89 (anonymous namespace)::FIRStmtParser::parseLeadingExpStmt(mlir::Value) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:0:5
#11 0x000055778c4db18e (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:0:0
#12 0x000055778c4dab35 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2111:17
#13 0x000055778c4dab35 (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2104:9
#14 0x000055778c4da5df mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#15 0x000055778c4da5df mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#16 0x000055778c4da5df (anonymous namespace)::FIRCircuitParser::parseModuleBody((anonymous namespace)::FIRCircuitParser::DeferredModuleToParse&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4077:7
#17 0x000055778c4da5df (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14::operator()(unsigned long) const /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4237:13
#18 0x000055778c4d5b01 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#19 0x000055778c4d5b01 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#20 0x000055778c4d5b01 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:11
#21 0x000055778c4d5b01 mlir::LogicalResult mlir::failableParallelForEach<llvm::iota_range<unsigned long>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14>(mlir::MLIRContext*, llvm::iota_range<unsigned long>&&, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#22 0x000055778c4d5b01 mlir::LogicalResult mlir::failableParallelForEachN<(anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14>(mlir::MLIRContext*, unsigned long, unsigned long, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:107:10
#23 0x000055778c4d5b01 (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4235:20
#24 0x000055778c4d5b01 circt::firrtl::importFIRFile(llvm::SourceMgr&, mlir::MLIRContext*, mlir::TimingScope&, circt::firrtl::FIRParserOptions) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4305:12
#25 0x000055778c3cbb62 std::enable_if<__and_<std::__not_<std::__is_tuple_like<mlir::ModuleOp>>, std::is_move_constructible<mlir::ModuleOp>, std::is_move_assignable<mlir::ModuleOp>>::value, void>::type std::swap<mlir::ModuleOp>(mlir::ModuleOp&, mlir::ModuleOp&) /nix/store/aafdki1nf49k5vxq6gx2yabiybk2bjmw-gcc-12.2.0/include/c++/12.2.0/bits/move.h:205:11
#26 0x000055778c3cbb62 mlir::OwningOpRef<mlir::ModuleOp>::release() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OwningOpRef.h:68:5
#27 0x000055778c3cbb62 mlir::OwningOpRef<mlir::ModuleOp>::operator=(mlir::OwningOpRef<mlir::ModuleOp>&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OwningOpRef.h:45:16
#28 0x000055778c3cbb62 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:286:12
#29 0x000055778c3cb56f processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:452:12
#30 0x000055778c3cb105 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:468:12
#31 0x000055778c3cb105 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:552:14
#32 0x000055778c3cace6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#33 0x000055778c3cace6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#34 0x000055778c3cace6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:616:8
#35 0x00007f22f92f3ace __libc_start_call_main (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x23ace)
#36 0x00007f22f92f3b89 __libc_start_main@GLIBC_2.2.5 (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x23b89)
#37 0x000055778c3cab15 _start (./build/bin/firtool+0x50db15)
zsh: IOT instruction (core dumped)  ./build/bin/firtool ./enum-widths.fir",,,,,,,,
5312,[Pipeline] Valgrind/ASAN error in StageSeparatorToStage,2023-06-05T15:05:35Z,closed,"bug, Pipeline","<details>
<summary>From Nightly CI -- valgrind report</summary>

https://github.com/llvm/circt/actions/runs/5176839396/jobs/9326172211:
```
FAIL: CIRCT :: Dialect/Pipeline/Transforms/stagesep-to-stages.mlir (423 of 535)
******************** TEST 'CIRCT :: Dialect/Pipeline/Transforms/stagesep-to-stages.mlir' FAILED ********************
Script:
--
: 'RUN: at line 1';   /__w/circt/circt/build/bin/circt-opt -pass-pipeline='builtin.module(hw.module(pipeline.pipeline(pipeline-stagesep-to-stage)))' /__w/circt/circt/test/Dialect/Pipeline/Transforms/stagesep-to-stages.mlir | /__w/circt/circt/build/bin/FileCheck /__w/circt/circt/test/Dialect/Pipeline/Transforms/stagesep-to-stages.mlir
--
Exit Code: 123

Command Output (stderr):
--
==12804== Thread 2 llvm-worker-0:
==12804== Invalid read of size 1
==12804==    at 0x14D6B13: circt::pipeline::StageSeparatingRegOp::getInputs() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDD8F: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD75E1: llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Address 0x6a5282e is 94 bytes inside a block of size 224 free'd
==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Block was alloc'd at
==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804== 
==12804== Invalid read of size 4
==12804==    at 0x14D6B19: circt::pipeline::StageSeparatingRegOp::getInputs() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDD8F: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD75E1: llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Address 0x6a52844 is 116 bytes inside a block of size 224 free'd
==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Block was alloc'd at
==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804== 
==12804== Invalid read of size 8
==12804==    at 0x14D6B1C: circt::pipeline::StageSeparatingRegOp::getInputs() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDD8F: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD75E1: llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Address 0x6a52848 is 120 bytes inside a block of size 224 free'd
==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Block was alloc'd at
==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804== 
==12804== Invalid read of size 8
==12804==    at 0x16CF019: mlir::detail::OperandStorage::setOperands(mlir::Operation*, unsigned int, unsigned int, mlir::ValueRange) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14D2E46: circt::pipeline::StageReturnOp::setOperands(mlir::Value, mlir::ValueRange, mlir::ValueRange) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDDE0: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Address 0x6a52868 is 152 bytes inside a block of size 224 free'd
==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Block was alloc'd at
==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804== 

--
```
</details>","FAIL: CIRCT :: Dialect/Pipeline/Transforms/stagesep-to-stages.mlir (423 of 535)
******************** TEST 'CIRCT :: Dialect/Pipeline/Transforms/stagesep-to-stages.mlir' FAILED ********************
Script:
--
: 'RUN: at line 1';   /__w/circt/circt/build/bin/circt-opt -pass-pipeline='builtin.module(hw.module(pipeline.pipeline(pipeline-stagesep-to-stage)))' /__w/circt/circt/test/Dialect/Pipeline/Transforms/stagesep-to-stages.mlir | /__w/circt/circt/build/bin/FileCheck /__w/circt/circt/test/Dialect/Pipeline/Transforms/stagesep-to-stages.mlir
--
Exit Code: 123

Command Output (stderr):
--
==12804== Thread 2 llvm-worker-0:
==12804== Invalid read of size 1
==12804==    at 0x14D6B13: circt::pipeline::StageSeparatingRegOp::getInputs() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDD8F: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD75E1: llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Address 0x6a5282e is 94 bytes inside a block of size 224 free'd
==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Block was alloc'd at
==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804== 
==12804== Invalid read of size 4
==12804==    at 0x14D6B19: circt::pipeline::StageSeparatingRegOp::getInputs() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDD8F: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD75E1: llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Address 0x6a52844 is 116 bytes inside a block of size 224 free'd
==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Block was alloc'd at
==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804== 
==12804== Invalid read of size 8
==12804==    at 0x14D6B1C: circt::pipeline::StageSeparatingRegOp::getInputs() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDD8F: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD75E1: llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Address 0x6a52848 is 120 bytes inside a block of size 224 free'd
==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Block was alloc'd at
==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804== 
==12804== Invalid read of size 8
==12804==    at 0x16CF019: mlir::detail::OperandStorage::setOperands(mlir::Operation*, unsigned int, unsigned int, mlir::ValueRange) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14D2E46: circt::pipeline::StageReturnOp::setOperands(mlir::Value, mlir::ValueRange, mlir::ValueRange) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDDE0: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Address 0x6a52868 is 152 bytes inside a block of size 224 free'd
==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==  Block was alloc'd at
==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)
==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)
==12804== 

--",,,,,,,,,
5284,[DependenceAnalysis] Analysis indiscriminately gathers loop nests,2023-05-26T21:33:33Z,closed,"bug, Scheduling","Within `MemoryDependenceAnalysis`, I think the affine analysis API is being misused given a certain type of input IR. Initially, the memory ops within a function are gathered:

https://github.com/llvm/circt/blob/e5312a24e51a6027e936de00287c17f33380c797/lib/Analysis/DependenceAnalysis.cpp#L136-L140

This becomes a problem one step deeper in the call stack at `checkMemrefAccessDependence()`, because the memory ops `src` and `dst` have not been separated by the loop nesting they belong to.
https://github.com/llvm/circt/blob/e5312a24e51a6027e936de00287c17f33380c797/lib/Analysis/DependenceAnalysis.cpp#L47-L48

The code gets confused because the other memory op in the dependence is not in the same nesting, and it throws the error I think being seen in #4814.

This becomes a problem as soon as there are nests of `affine.for` in parallel like such:
```
affine.for %arg2 = 0 to 270 {
  affine.for %arg3 = 0 to 474 {
    affine.for %arg4 = 0 to 7 {
      ...
}}}
affine.for %arg2 = 0 to 270 {
  affine.for %arg3 = 0 to 474 {
    affine.for %arg4 = 0 to 7 {
      ...
}}}
```","affine.for %arg2 = 0 to 270 {
  affine.for %arg3 = 0 to 474 {
    affine.for %arg4 = 0 to 7 {
      ...
}}}
affine.for %arg2 = 0 to 270 {
  affine.for %arg3 = 0 to 474 {
    affine.for %arg4 = 0 to 7 {
      ...
}}}",,,,,,,,,
5242,ESI Cosim CMakeLists.txt updates not compatible with older CMake versions,2023-05-22T19:16:27Z,closed,"bug, ESI","It looks like https://github.com/llvm/circt/commit/f0bfdf6c79a128db85af362395f28544a303fd59 added the use of `FILE_SET` to some ESI Cosim related CMakeLists.txt files.

This feature appears to have been added to the `target_sources` and `install` CMake commands in version 3.23: https://cmake.org/cmake/help/latest/command/target_sources.html#file-sets.

But we only declare a minimum CMake version of 3.13: https://github.com/llvm/circt/blob/c7100bed69631f6ee4849c1e0a5f73d4aa926c15/CMakeLists.txt#L7

Looks like we are using CMake 3.23 in CI, so this wasn't caught. I noticed because I happen to use 3.22 locally, and build with ESI Cosim enabled. Can we either make the CMakeLists.txt compatible with the declared minimum CMake version, or bump that minimum?

CMake 3.23 is fairly recent, but I guess we could consider requiring a newer version. That might cause friction on users who will need to install a newer CMake than their platform's default to use CIRCT, so I think it might be preferable to achieve the goal without use of `FILE_SET`.

@teqdruid what do you think?",,,,,,,,,,
5231,[ExportVerilog] Indenting/formatting wrong after macro def,2023-05-19T16:09:25Z,closed,"bug, FIRRTL","Input:

```
sv.macro.decl @TEST_COND

hw.module @TestCond() {
  sv.ifdef ""TEST_COND_"" {
   sv.macro.def @TEST_COND ""TEST_COND_""
  } else {
   sv.macro.def @TEST_COND ""1""
  }
  hw.output
}
```

Current output:

```
// Generated by CIRCT 1.42.0g20230517_6043aa4
module TestCond();	// macro.mlir:3:1
  `ifdef TEST_COND_	// macro.mlir:4:3
    `define TEST_COND TEST_COND_
    `else  // TEST_COND_
    `define TEST_COND 1
    `endif // TEST_COND_
endmodule
```

Should be:
```
module TestCond();	// macro.mlir:3:1
  `ifdef TEST_COND_	// macro.mlir:4:3
    `define TEST_COND TEST_COND_
  `else  // TEST_COND_
    `define TEST_COND 1
  `endif // TEST_COND_
endmodule
```","sv.macro.decl @TEST_COND

hw.module @TestCond() {
  sv.ifdef ""TEST_COND_"" {
   sv.macro.def @TEST_COND ""TEST_COND_""
  } else {
   sv.macro.def @TEST_COND ""1""
  }
  hw.output
}","// Generated by CIRCT 1.42.0g20230517_6043aa4
module TestCond();	// macro.mlir:3:1
  `ifdef TEST_COND_	// macro.mlir:4:3
    `define TEST_COND TEST_COND_
    `else  // TEST_COND_
    `define TEST_COND 1
    `endif // TEST_COND_
endmodule","module TestCond();	// macro.mlir:3:1
  `ifdef TEST_COND_	// macro.mlir:4:3
    `define TEST_COND TEST_COND_
  `else  // TEST_COND_
    `define TEST_COND 1
  `endif // TEST_COND_
endmodule",,,,,,,
5205,"[FIRRTL] Exporter prints invalid probe of constant (, inline expressions?)",2023-05-16T15:34:54Z,open,"bug, FIRRTL","Cannot probe inline expressions, probe target must be a static reference to a declaration (in current spec anyway).

Consider:

```mlir
firrtl.circuit ""ProbeConstant"" {
  firrtl.module @ProbeConstant(out %bore: !firrtl.probe<uint<1>>) {
    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1> {name = ""internalWire""}
    %0 = firrtl.ref.send %c0_ui1 : !firrtl.uint<1>
    firrtl.ref.define %bore, %0 : !firrtl.probe<uint<1>>
  }
}
```

Which becomes:

```firrtl
circuit ProbeConstant :
  module ProbeConstant :
    output bore : Probe<UInt<1>>

    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]
```

Which is invalid and does not parse:

```
<stdin>:5:25: error: use of unknown declaration 'UInt'
    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]
```

Not sure what approach works best with Exporter, but strategies such as giving expression a name with a node (or wire if non-passive) would give something to probe.","firrtl.circuit ""ProbeConstant"" {
  firrtl.module @ProbeConstant(out %bore: !firrtl.probe<uint<1>>) {
    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1> {name = ""internalWire""}
    %0 = firrtl.ref.send %c0_ui1 : !firrtl.uint<1>
    firrtl.ref.define %bore, %0 : !firrtl.probe<uint<1>>
  }
}","circuit ProbeConstant :
  module ProbeConstant :
    output bore : Probe<UInt<1>>

    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]","<stdin>:5:25: error: use of unknown declaration 'UInt'
    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]",,,,,,,
5204,[FIRRTL] Register with Self Connection Crashes Exporter,2023-05-16T02:21:20Z,open,"bug, FIRRTL","Consider the following FIRRTL Dialect:

```mlir
firrtl.circuit ""Foo"" {
  firrtl.module @Foo(in %clock: !firrtl.clock, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>
    %0 = firrtl.wire : !firrtl.uint<1>
    %r = firrtl.regreset interesting_name %clock, %c1_ui1, %0 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.strictconnect %0, %r : !firrtl.uint<1>
  }
}
```

This produces a nice crash in the exporter (`circt-translate -export-firrtl Bar.mlir`):

```
Assertion failed: (!s->text().empty() && ""empty string token""), function operator(), file PrettyPrinter.cpp, line 91.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.      Program arguments: circt-translate -export-firrtl Bar.mlir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  circt-translate          0x00000001079167ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  circt-translate          0x0000000107916d5b PrintStackTraceSignalHandler(void*) + 27
2  circt-translate          0x0000000107914896 llvm::sys::RunSignalHandlers() + 134
3  circt-translate          0x0000000107918b8f SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff81820c5ed _sigtramp + 29
5  libsystem_platform.dylib 0x00007ff7b877dd20 _sigtramp + 18446744072104646480
6  libsystem_c.dylib        0x00007ff818105b45 abort + 123
7  libsystem_c.dylib        0x00007ff818104e5e err + 0
8  circt-translate          0x0000000108746000 circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1::operator()(circt::pretty::StringToken*) const + 176
9  circt-translate          0x0000000108745ee8 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::TypeSwitch<circt::pretty::Token*, void>::Case<circt::pretty::StringToken, circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 88
10 circt-translate          0x0000000108744af5 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<circt::pretty::Token*, void>, circt::pretty::Token*>::Case<circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 53
11 circt-translate          0x0000000108744a03 circt::pretty::PrettyPrinter::add(circt::pretty::Token) + 99
12 circt-translate          0x000000010819d235 std::__1::enable_if<std::is_base_of_v<circt::pretty::Token, circt::pretty::StringToken>, void>::type circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::add<circt::pretty::StringToken, llvm::StringRef&>(llvm::StringRef&) + 101
13 circt-translate          0x000000010819d1c1 circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::literal(llvm::StringRef) + 33
14 circt-translate          0x000000010819c118 circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::operator<<(circt::pretty::PPExtString const&) + 56
15 circt-translate          0x00000001081c2fa8 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5::operator()() const + 104
16 circt-translate          0x00000001081c2f35 decltype(static_cast<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(fp)()) std::__1::__invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 21
17 circt-translate          0x00000001081c2e5d std::__1::invoke_result<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>::type std::__1::invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 29
18 circt-translate          0x00000001081c2d96 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(circt::pretty::PP&&, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&, circt::pretty::Token) + 102
19 circt-translate          0x00000001081c2d13 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp) + 179
20 circt-translate          0x00000001081c2808 auto (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16::operator()<circt::firrtl::WireOp>(circt::firrtl::WireOp) const + 40
21 circt-translate          0x00000001081c278b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::WireOp, (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&>((anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&) + 107
22 circt-translate          0x000000010819ea0d (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&) + 365
23 circt-translate          0x000000010819e669 (anonymous namespace)::Emitter::emitModule(circt::firrtl::FModuleOp)::$_1::operator()() const + 217
```","firrtl.circuit ""Foo"" {
  firrtl.module @Foo(in %clock: !firrtl.clock, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>
    %0 = firrtl.wire : !firrtl.uint<1>
    %r = firrtl.regreset interesting_name %clock, %c1_ui1, %0 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.strictconnect %0, %r : !firrtl.uint<1>
  }
}","Assertion failed: (!s->text().empty() && ""empty string token""), function operator(), file PrettyPrinter.cpp, line 91.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.      Program arguments: circt-translate -export-firrtl Bar.mlir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  circt-translate          0x00000001079167ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  circt-translate          0x0000000107916d5b PrintStackTraceSignalHandler(void*) + 27
2  circt-translate          0x0000000107914896 llvm::sys::RunSignalHandlers() + 134
3  circt-translate          0x0000000107918b8f SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff81820c5ed _sigtramp + 29
5  libsystem_platform.dylib 0x00007ff7b877dd20 _sigtramp + 18446744072104646480
6  libsystem_c.dylib        0x00007ff818105b45 abort + 123
7  libsystem_c.dylib        0x00007ff818104e5e err + 0
8  circt-translate          0x0000000108746000 circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1::operator()(circt::pretty::StringToken*) const + 176
9  circt-translate          0x0000000108745ee8 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::TypeSwitch<circt::pretty::Token*, void>::Case<circt::pretty::StringToken, circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 88
10 circt-translate          0x0000000108744af5 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<circt::pretty::Token*, void>, circt::pretty::Token*>::Case<circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 53
11 circt-translate          0x0000000108744a03 circt::pretty::PrettyPrinter::add(circt::pretty::Token) + 99
12 circt-translate          0x000000010819d235 std::__1::enable_if<std::is_base_of_v<circt::pretty::Token, circt::pretty::StringToken>, void>::type circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::add<circt::pretty::StringToken, llvm::StringRef&>(llvm::StringRef&) + 101
13 circt-translate          0x000000010819d1c1 circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::literal(llvm::StringRef) + 33
14 circt-translate          0x000000010819c118 circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::operator<<(circt::pretty::PPExtString const&) + 56
15 circt-translate          0x00000001081c2fa8 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5::operator()() const + 104
16 circt-translate          0x00000001081c2f35 decltype(static_cast<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(fp)()) std::__1::__invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 21
17 circt-translate          0x00000001081c2e5d std::__1::invoke_result<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>::type std::__1::invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 29
18 circt-translate          0x00000001081c2d96 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(circt::pretty::PP&&, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&, circt::pretty::Token) + 102
19 circt-translate          0x00000001081c2d13 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp) + 179
20 circt-translate          0x00000001081c2808 auto (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16::operator()<circt::firrtl::WireOp>(circt::firrtl::WireOp) const + 40
21 circt-translate          0x00000001081c278b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::WireOp, (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&>((anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&) + 107
22 circt-translate          0x000000010819ea0d (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&) + 365
23 circt-translate          0x000000010819e669 (anonymous namespace)::Emitter::emitModule(circt::firrtl::FModuleOp)::$_1::operator()() const + 217",,,,,,,,
5202,[FIRRTL] Incorrect Register Parsing,2023-05-15T21:22:04Z,open,"bug, FIRRTL","The FIRRTL parser uses the reset initial value being the reset as a shorthand for ""this is a reset-less register"". However, it only narrowly means that if the reset signal is `UInt<1>(0)`. Consider the following:

```
circuit Foo :
  module Foo :
    input clock: Clock
    input a: UInt<1>
    output b: UInt<1>

    reg r: UInt<1>, clock with: (reset => (UInt<1>(1), r))

    r <= a
    b <= r
```

This register never exits an indeterminate state and can be optimized to some constant. CIRCT currently thinks this is a reset-less register:

```verilog
module Foo(
  input  clock,
         a,
  output b
);

  reg r;
  always @(posedge clock)
    r <= a;
  assign b = r;
endmodule
```

SFC will produce:
```verilog
module Foo(
  input   clock,
  input   a,
  output  b
);
  assign b = 1'h0;
endmodule
```

Note: this code is impossible to emit from Chisel due to limitations of how it works.","circuit Foo :
  module Foo :
    input clock: Clock
    input a: UInt<1>
    output b: UInt<1>

    reg r: UInt<1>, clock with: (reset => (UInt<1>(1), r))

    r <= a
    b <= r","module Foo(
  input  clock,
         a,
  output b
);

  reg r;
  always @(posedge clock)
    r <= a;
  assign b = r;
endmodule","module Foo(
  input   clock,
  input   a,
  output  b
);
  assign b = 1'h0;
endmodule",,,,,,,
5031,[scf-to-calyx] Mark `cf` operations illegal,2023-04-13T16:30:52Z,open,"bug, Calyx","Hi! I just posted on the #circt channel on discord about a model I had that I tried to pass to CIRCT to lower to Calyx via `-lower-scf-to-calyx`. It seems like it takes a few hours at least, and sometime just crashes my machine - which is very strange, since the model is pretty simple with mostly arithmetic operations and 163 if statements that are represented with conditional branches (they were `scf.if` statements, but converted to `cf` with [convert-scf-to-cf](https://mlir.llvm.org/docs/Passes/#-convert-scf-to-cf-convert-scf-dialect-to-controlflow-dialect-replacing-structured-control-flow-with-a-cfg). 

This is the model: https://gist.github.com/asraa/93f10e86abcc3fe386eec172cb918e5c

I'll be poking around the conversion code near the conditional branch handling, just in case, and if I see something suspicious I'll update this thread. https://github.com/llvm/circt/blob/4a2ae91b421c71841c69153f81fc4277fe5409ef/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp#L1016

Thank you!

@mikeurbach for CC, thank you for responding in the chat!
",,,,,,,,,,
5011,[FIRRTL] LowerToHW replaces uses of output ports and doesn't preserve dontTouch (symbol),2023-04-11T22:10:30Z,closed,"bug, FIRRTL","More unexpected behavior with output ports, dontTouch, and reading them within a module.

Similar to #5008 .

Consider this FIRRTL input:

```firrtl
circuit Producer : %[[
 { ""class"": ""firrtl.transforms.DontTouchAnnotation"",
   ""target"": ""~Producer|Producer>out"" },
 { ""class"": ""firrtl.transforms.DontTouchAnnotation"",
   ""target"": ""~Producer|Producer>n"" }
]]
  module Producer:
    input clock: Clock
    output out: UInt<5>

    ; Simple constant output.
    node n = UInt<5>(1)
    out <= n

    assert(clock, neq(out, UInt<5>(3)), UInt<1>(1), ""out was changed"")
```

Which w/`-ir-fir` we get (good so far):

```mlir
module {
  firrtl.circuit ""Producer"" {
    firrtl.module @Producer(in %clock: !firrtl.clock, out %out: !firrtl.uint<5> [{class = ""firrtl.transforms.DontTouchAnnotation""}]) attributes {convention = #firrtl<convention scalarized>} {
      %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>
      %c3_ui5 = firrtl.constant 3 : !firrtl.uint<5>
      %c1_ui5 = firrtl.constant 1 : !firrtl.uint<5>
      %n = firrtl.node %c1_ui5 {annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}]} : !firrtl.uint<5>
      firrtl.strictconnect %out, %n : !firrtl.uint<5>
      %0 = firrtl.neq %out, %c3_ui5 : (!firrtl.uint<5>, !firrtl.uint<5>) -> !firrtl.uint<1>
      firrtl.assert %clock, %0, %c1_ui1, ""out was changed"" : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>  {eventControl = 0 : i32, isConcurrent = false}
    }
  }
}
```

Piping the above through `circt-opt --lower-firrtl-to-hw` yields:

```mlir
module {
  hw.module @Producer(%clock: i1) -> (out: i5 {hw.exportPort = #hw<innerSym@__Producer__out>}) {
    %c1_i5 = hw.constant 1 : i5
    %c3_i5 = hw.constant 3 : i5
    %true = hw.constant true
    %.out.output = hw.wire %n  : i5
    %n = hw.wire %c1_i5 sym @__Producer__n  : i5
    %0 = comb.icmp bin ne %.out.output, %c3_i5 : i5
    sv.always posedge %clock {
      sv.if %true {
        sv.assert %0, immediate message ""out was changed""
      }
    }
    hw.output %.out.output : i5
  }
}
```

Where the use of the output port is replaced with a wire (`%.out.output`) which lacks the ""dontTouch""-y symbol.

As a result, running this input through the pipeline currently produces:

```systemverilog
// Generated by CIRCT 1.37.0g20230411_c9c3591
module Producer(
  input        clock,
  output [4:0] out
);

  wire [4:0] n = 5'h1;
  always @(posedge clock)
    assert(n != 5'h3) else $error(""out was changed"");
  assign out = n;
endmodule
```","circuit Producer : %[[
 { ""class"": ""firrtl.transforms.DontTouchAnnotation"",
   ""target"": ""~Producer|Producer>out"" },
 { ""class"": ""firrtl.transforms.DontTouchAnnotation"",
   ""target"": ""~Producer|Producer>n"" }
]]
  module Producer:
    input clock: Clock
    output out: UInt<5>

    ; Simple constant output.
    node n = UInt<5>(1)
    out <= n

    assert(clock, neq(out, UInt<5>(3)), UInt<1>(1), ""out was changed"")","module {
  firrtl.circuit ""Producer"" {
    firrtl.module @Producer(in %clock: !firrtl.clock, out %out: !firrtl.uint<5> [{class = ""firrtl.transforms.DontTouchAnnotation""}]) attributes {convention = #firrtl<convention scalarized>} {
      %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>
      %c3_ui5 = firrtl.constant 3 : !firrtl.uint<5>
      %c1_ui5 = firrtl.constant 1 : !firrtl.uint<5>
      %n = firrtl.node %c1_ui5 {annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}]} : !firrtl.uint<5>
      firrtl.strictconnect %out, %n : !firrtl.uint<5>
      %0 = firrtl.neq %out, %c3_ui5 : (!firrtl.uint<5>, !firrtl.uint<5>) -> !firrtl.uint<1>
      firrtl.assert %clock, %0, %c1_ui1, ""out was changed"" : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>  {eventControl = 0 : i32, isConcurrent = false}
    }
  }
}","module {
  hw.module @Producer(%clock: i1) -> (out: i5 {hw.exportPort = #hw<innerSym@__Producer__out>}) {
    %c1_i5 = hw.constant 1 : i5
    %c3_i5 = hw.constant 3 : i5
    %true = hw.constant true
    %.out.output = hw.wire %n  : i5
    %n = hw.wire %c1_i5 sym @__Producer__n  : i5
    %0 = comb.icmp bin ne %.out.output, %c3_i5 : i5
    sv.always posedge %clock {
      sv.if %true {
        sv.assert %0, immediate message ""out was changed""
      }
    }
    hw.output %.out.output : i5
  }
}","// Generated by CIRCT 1.37.0g20230411_c9c3591
module Producer(
  input        clock,
  output [4:0] out
);

  wire [4:0] n = 5'h1;
  always @(posedge clock)
    assert(n != 5'h3) else $error(""out was changed"");
  assign out = n;
endmodule",,,,,,
5008,[FIRRTL][IMCP] Don't const-prop through read of dontTouch'd output port,2023-04-11T21:30:50Z,closed,"bug, FIRRTL","Example input:

```firrtl
circuit Producer : %[[
 { ""class"": ""firrtl.transforms.DontTouchAnnotation"",
   ""target"": ""~Producer|Producer>foo"" },
 { ""class"": ""firrtl.transforms.DontTouchAnnotation"",
   ""target"": ""~Producer|Producer>out"" }
]]
  module Producer:
    output out: UInt<5>
    
    ; Simple constant output.
    node n = UInt<5>(1)
    out <= n

    ; Output port drives internal wire.
    wire foo : UInt<5>
    foo <= out
```

Current output (as well as back to, randomly, 1.25.0):

```systemverilog
// Generated by CIRCT 1.37.0g20230411_c9c3591
module Producer(
  output [4:0] out
);

  wire [4:0] foo = 5'h1;
  assign out = 5'h1;
endmodule
```","circuit Producer : %[[
 { ""class"": ""firrtl.transforms.DontTouchAnnotation"",
   ""target"": ""~Producer|Producer>foo"" },
 { ""class"": ""firrtl.transforms.DontTouchAnnotation"",
   ""target"": ""~Producer|Producer>out"" }
]]
  module Producer:
    output out: UInt<5>
    
    ; Simple constant output.
    node n = UInt<5>(1)
    out <= n

    ; Output port drives internal wire.
    wire foo : UInt<5>
    foo <= out","// Generated by CIRCT 1.37.0g20230411_c9c3591
module Producer(
  output [4:0] out
);

  wire [4:0] foo = 5'h1;
  assign out = 5'h1;
endmodule",,,,,,,,
4941,[FIRRTL] plusarg intrinsics should lower to a register.,2023-04-05T15:48:07Z,closed,"bug, FIRRTL","plusargs should cache in a register loaded from an initial block like this:
```
module PlusArgsValueTop(
  input         clock,
                reset,
  output        io_wf,
  output [31:0] io_wv,
  output        io_xf,
  output [15:0] io_xv_a,
                io_xv_b
);

  logic [31:0]                                     _pargs;
  struct packed {logic [15:0] a; logic [15:0] b; } _pargs_0;
  logic _pf, _pf_0;
  initial begin
    _pf = $value$plusargs(""FOO=%d"", _pargs);
    _pf_0 = $value$plusargs(""BAR=%d"", _pargs_0);
  end
  assign io_wf = _pf;
  assign io_wv = _pargs;
  assign io_xf = _pf_0;
  assign io_xv_a = _pargs_0.a;
  assign io_xv_b = _pargs_0.b;
endmodule
```

rather than trying to be an inline expression.  This will make lint checking easier.","module PlusArgsValueTop(
  input         clock,
                reset,
  output        io_wf,
  output [31:0] io_wv,
  output        io_xf,
  output [15:0] io_xv_a,
                io_xv_b
);

  logic [31:0]                                     _pargs;
  struct packed {logic [15:0] a; logic [15:0] b; } _pargs_0;
  logic _pf, _pf_0;
  initial begin
    _pf = $value$plusargs(""FOO=%d"", _pargs);
    _pf_0 = $value$plusargs(""BAR=%d"", _pargs_0);
  end
  assign io_wf = _pf;
  assign io_wv = _pargs;
  assign io_xf = _pf_0;
  assign io_xv_a = _pargs_0.a;
  assign io_xv_b = _pargs_0.b;
endmodule",,,,,,,,,
4921,"[FIRRTL][Inliner] UNREACHABLE ""the default constructor for MutableNLA should never be used""",2023-04-03T14:08:13Z,open,"bug, FIRRTL","Variant of inliner crash test case in #4920 .  This crashes on 1.35.0 and 1.37.0:

```firrtl
module {
  firrtl.circuit ""Unreachable"" {
    hw.hierpath private @nla_5560 [@Unreachable::@w, @Bar2]
    hw.hierpath private @nla_5561 [@Bar1::@w, @Bar3]
    firrtl.module private @Bar2() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      %x = firrtl.wire sym @x {annotations = [{circt.nonlocal = @nla_5560, class = ""test0""}]} : !firrtl.uint<8>
      firrtl.instance no sym @no @Bar1()
    }
    firrtl.module private @Bar1() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      firrtl.instance bar3 sym @w @Bar3()
    }
    firrtl.module private @Bar3() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @nla_5561, class = ""test0""}]} : !firrtl.uint<8>
    }
    firrtl.module @Unreachable() {
      firrtl.instance no sym @no @Bar1()
      firrtl.instance bar2 sym @w @Bar2()
    }
  }
}
```

Error:

```
the default constructor for MutableNLA should never be used
UNREACHABLE executed at /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:130!
```

Backtrace:

```
* thread #1, name = 'circt-opt', stop reason = signal SIGABRT
  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295
    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22
    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215
    frame #3: 0x00005555561857bf circt-opt`llvm::llvm_unreachable_internal(msg=<unavailable>, file=<unavailable>, line=<unavailable>) at ErrorHandling.cpp:212:3
    frame #4: 0x0000555556788dba circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] (anonymous namespace)::MutableNLA::MutableNLA(this=<unavailable>) at ModuleInliner.cpp:129:5
    frame #5: 0x0000555556788d2e circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>* llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (this=<unavailable>, TheBucket=<unavailable>, Key=0x00007fffffff3db8)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::InsertIntoBucket<mlir::Attribute const&>(llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>*, mlir::Attribute const&) at DenseMap.h:563:37
    frame #6: 0x0000555556788d20 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::FindAndConstruct(this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:339:13
    frame #7: 0x0000555556788ce2 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:343:12
    frame #8: 0x0000555556789f68 circt-opt`(anonymous namespace)::Inliner::setActiveHierPaths(this=0x00007fffffff4588, moduleName=StringAttr @ rbx, instInnerSym=StringAttr @ scalar) at ModuleInliner.cpp:596:11
    frame #9: 0x000055555678e194 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=(Data = ""bar2_"", Length = 5), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, beb=0x00007fffffff41a0, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3f18, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1094:5
    frame #10: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7
    frame #11: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7
    frame #12: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13
    frame #13: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17
    frame #14: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #15: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #16: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000330afe0, irUnits=ArrayRef<mlir::IRUnit> @ 0x000000000331dee0, args=0x0000555557bfe4f0)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #17: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfe4f0, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #18: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be0d10, op=0x0000555557bfd560, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16
    frame #19: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557c00380)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36
    frame #20: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18
    frame #21: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10
    frame #22: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14
    frame #23: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5
    frame #24: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20
    frame #25: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #26: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #27: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003435460, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000038b4fc0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #28: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #29: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16
    frame #30: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfd5c0, am=AnalysisManager @ scalar) at Pass.cpp:857:10
    frame #31: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfd5c0) at Pass.cpp:837:60
    frame #32: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc9000, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17
    frame #33: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12
    frame #34: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12
    frame #35: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12
    frame #36: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12
    frame #37: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12
    frame #38: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10
    frame #39: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14
    frame #40: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23
    frame #41: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126
    frame #42: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137
    frame #43: 0x0000555556160415 circt-opt`_start + 37
```","module {
  firrtl.circuit ""Unreachable"" {
    hw.hierpath private @nla_5560 [@Unreachable::@w, @Bar2]
    hw.hierpath private @nla_5561 [@Bar1::@w, @Bar3]
    firrtl.module private @Bar2() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      %x = firrtl.wire sym @x {annotations = [{circt.nonlocal = @nla_5560, class = ""test0""}]} : !firrtl.uint<8>
      firrtl.instance no sym @no @Bar1()
    }
    firrtl.module private @Bar1() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      firrtl.instance bar3 sym @w @Bar3()
    }
    firrtl.module private @Bar3() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @nla_5561, class = ""test0""}]} : !firrtl.uint<8>
    }
    firrtl.module @Unreachable() {
      firrtl.instance no sym @no @Bar1()
      firrtl.instance bar2 sym @w @Bar2()
    }
  }
}","the default constructor for MutableNLA should never be used
UNREACHABLE executed at /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:130!","* thread #1, name = 'circt-opt', stop reason = signal SIGABRT
  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295
    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22
    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215
    frame #3: 0x00005555561857bf circt-opt`llvm::llvm_unreachable_internal(msg=<unavailable>, file=<unavailable>, line=<unavailable>) at ErrorHandling.cpp:212:3
    frame #4: 0x0000555556788dba circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] (anonymous namespace)::MutableNLA::MutableNLA(this=<unavailable>) at ModuleInliner.cpp:129:5
    frame #5: 0x0000555556788d2e circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>* llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (this=<unavailable>, TheBucket=<unavailable>, Key=0x00007fffffff3db8)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::InsertIntoBucket<mlir::Attribute const&>(llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>*, mlir::Attribute const&) at DenseMap.h:563:37
    frame #6: 0x0000555556788d20 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::FindAndConstruct(this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:339:13
    frame #7: 0x0000555556788ce2 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:343:12
    frame #8: 0x0000555556789f68 circt-opt`(anonymous namespace)::Inliner::setActiveHierPaths(this=0x00007fffffff4588, moduleName=StringAttr @ rbx, instInnerSym=StringAttr @ scalar) at ModuleInliner.cpp:596:11
    frame #9: 0x000055555678e194 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=(Data = ""bar2_"", Length = 5), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, beb=0x00007fffffff41a0, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3f18, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1094:5
    frame #10: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7
    frame #11: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7
    frame #12: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13
    frame #13: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17
    frame #14: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #15: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #16: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000330afe0, irUnits=ArrayRef<mlir::IRUnit> @ 0x000000000331dee0, args=0x0000555557bfe4f0)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #17: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfe4f0, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #18: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be0d10, op=0x0000555557bfd560, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16
    frame #19: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557c00380)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36
    frame #20: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18
    frame #21: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10
    frame #22: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14
    frame #23: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5
    frame #24: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20
    frame #25: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #26: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #27: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003435460, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000038b4fc0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #28: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #29: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16
    frame #30: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfd5c0, am=AnalysisManager @ scalar) at Pass.cpp:857:10
    frame #31: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfd5c0) at Pass.cpp:837:60
    frame #32: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc9000, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17
    frame #33: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12
    frame #34: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12
    frame #35: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12
    frame #36: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12
    frame #37: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12
    frame #38: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10
    frame #39: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14
    frame #40: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23
    frame #41: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126
    frame #42: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137
    frame #43: 0x0000555556160415 circt-opt`_start + 37",,,,,,,
4920,[FIRRTL][Inliner] Mutable NLA did not contain symbol,2023-04-03T13:59:00Z,closed,"bug, FIRRTL","Test case:
```firrtl
module {
  firrtl.circuit ""DidNotContainSymbol"" {
    hw.hierpath private @path [@Bar1::@w, @Bar3]
    firrtl.module private @Bar2() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      firrtl.instance no sym @no @Bar1()
    }
    firrtl.module private @Bar1() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      firrtl.instance bar3 sym @w @Bar3()
    }
    firrtl.module private @Bar3() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @path , class = ""test0""}]} : !firrtl.uint<8>
    }
    firrtl.module @DidNotContainSymbol() {
      firrtl.instance bar2 sym @w @Bar2()
    }
  }
}
```

Assertion failure:

```
lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:384: void (anonymous namespace)::MutableNLA::setInnerSym(mlir::Attribute, mlir::StringAttr): Assertion `symIdx.count(module) && ""Mutable NLA did not contain symbol""' failed.
```

```
* thread #1, name = 'circt-opt', stop reason = signal SIGABRT
  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295
    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22
    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215
    frame #3: 0x00007ffff7a283d9 libc.so.6`__assert_fail_base.cold.0 + 15
    frame #4: 0x00007ffff7a367b6 libc.so.6`__assert_fail + 70
    frame #5: 0x000055555678c03c circt-opt`(anonymous namespace)::MutableNLA::setInnerSym(this=<unavailable>, module=<unavailable>, innerSym=<unavailable>) at ModuleInliner.cpp:384:5
    frame #6: 0x000055555678d4d7 circt-opt`(anonymous namespace)::Inliner::rename(this=0x00007fffffff4588, prefix=<unavailable>, op=0x0000555557c073a0, moduleNamespace=<unavailable>) at ModuleInliner.cpp:673:14
    frame #7: 0x000055555678c7d3 circt-opt`void llvm::function_ref<void (mlir::Operation*)>::callback_fn<(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2>(long, mlir::Operation*) at ModuleInliner.cpp:880:7
    frame #8: 0x000055555678c6e8 circt-opt`void llvm::function_ref<void (mlir::Operation*)>::callback_fn<(anonymous namespace)::Inliner::cloneAndRename(callable=140737488304200, params=0x0000555557bfa070)::$_2>(long, mlir::Operation*) at STLFunctionalExtras.h:45:12
    frame #9: 0x0000555556214546 circt-opt`void mlir::detail::walk<mlir::ForwardIterator>(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) [inlined] llvm::function_ref<void (mlir::Operation*)>::operator(this=<unavailable>, params=0x0000555557bfa070)(mlir::Operation*) const at STLFunctionalExtras.h:68:12
    frame #10: 0x000055555621453d circt-opt`void mlir::detail::walk<mlir::ForwardIterator>(op=0x0000555557bfa070, callback=mlir::function_ref<void (mlir::Operation *)> @ 0x0000000003b98e80, order=PreOrder)>, mlir::WalkOrder) at Visitors.h:174:5
    frame #11: 0x000055555678c5ad circt-opt`(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&) [inlined] std::enable_if<llvm::is_one_of<mlir::Operation*, mlir::Operation*, mlir::Region*, mlir::Block*>::value, void>::type mlir::detail::walk<(op=0x0000555557bfa070, callback=0x00007fffffff3848)0, mlir::ForwardIterator, (anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2, mlir::Operation*, void>(mlir::Operation*, (anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2&&) at Visitors.h:313:10
    frame #12: 0x000055555678c597 circt-opt`(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&) [inlined] std::enable_if<(llvm::function_traits<std::decay<(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2>::type>::num_args) == (1), void>::type mlir::Operation::walk<(this=0x0000555557bfa070, callback=0x00007fffffff3848)0, mlir::ForwardIterator, (anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2, void>((anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2&&) at Operation.h:641:12
    frame #13: 0x000055555678c597 circt-opt`(anonymous namespace)::Inliner::cloneAndRename(this=0x00007fffffff4588, prefix=(Data = ""bar2_no_bar3_"", Length = 13), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, op=0x0000555557bfa070, symbolRenames=0x00007fffffff3d60, localSymbols=0x00007fffffff3b40, moduleNamespace=0x00007fffffff4510) at ModuleInliner.cpp:866:6
    frame #14: 0x000055555678dafc circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=<unavailable>, b=<unavailable>, mapper=<unavailable>, beb=<unavailable>, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff39f8, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at SmallVector.h:0:10
    frame #15: 0x000055555678e593 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=<unavailable>, b=<unavailable>, mapper=<unavailable>, beb=<unavailable>, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3c78, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1109:7
    frame #16: 0x000055555678e593 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=<unavailable>, b=<unavailable>, mapper=<unavailable>, beb=<unavailable>, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3ef8, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1109:7
    frame #17: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7
    frame #18: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7
    frame #19: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13
    frame #20: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17
    frame #21: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #22: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #23: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003d9ef60, irUnits=ArrayRef<mlir::IRUnit> @ 0x0000000003e53480, args=0x0000555557bfcc80)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #24: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfcc80, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #25: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be10c0, op=0x0000555557bfbcf0, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16
    frame #26: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557bfeb30)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36
    frame #27: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18
    frame #28: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10
    frame #29: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14
    frame #30: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5
    frame #31: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20
    frame #32: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #33: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #34: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000411f1f0, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000041820c0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #35: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #36: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16
    frame #37: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfbd50, am=AnalysisManager @ scalar) at Pass.cpp:857:10
    frame #38: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfbd50) at Pass.cpp:837:60
    frame #39: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc93b0, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17
    frame #40: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12
    frame #41: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12
    frame #42: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12
    frame #43: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12
    frame #44: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12
    frame #45: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10
    frame #46: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14
    frame #47: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23
    frame #48: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126
    frame #49: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137
    frame #50: 0x0000555556160415 circt-opt`_start + 37
```

cc #4915 .","module {
  firrtl.circuit ""DidNotContainSymbol"" {
    hw.hierpath private @path [@Bar1::@w, @Bar3]
    firrtl.module private @Bar2() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      firrtl.instance no sym @no @Bar1()
    }
    firrtl.module private @Bar1() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      firrtl.instance bar3 sym @w @Bar3()
    }
    firrtl.module private @Bar3() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @path , class = ""test0""}]} : !firrtl.uint<8>
    }
    firrtl.module @DidNotContainSymbol() {
      firrtl.instance bar2 sym @w @Bar2()
    }
  }
}","lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:384: void (anonymous namespace)::MutableNLA::setInnerSym(mlir::Attribute, mlir::StringAttr): Assertion `symIdx.count(module) && ""Mutable NLA did not contain symbol""' failed.","* thread #1, name = 'circt-opt', stop reason = signal SIGABRT
  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295
    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22
    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215
    frame #3: 0x00007ffff7a283d9 libc.so.6`__assert_fail_base.cold.0 + 15
    frame #4: 0x00007ffff7a367b6 libc.so.6`__assert_fail + 70
    frame #5: 0x000055555678c03c circt-opt`(anonymous namespace)::MutableNLA::setInnerSym(this=<unavailable>, module=<unavailable>, innerSym=<unavailable>) at ModuleInliner.cpp:384:5
    frame #6: 0x000055555678d4d7 circt-opt`(anonymous namespace)::Inliner::rename(this=0x00007fffffff4588, prefix=<unavailable>, op=0x0000555557c073a0, moduleNamespace=<unavailable>) at ModuleInliner.cpp:673:14
    frame #7: 0x000055555678c7d3 circt-opt`void llvm::function_ref<void (mlir::Operation*)>::callback_fn<(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2>(long, mlir::Operation*) at ModuleInliner.cpp:880:7
    frame #8: 0x000055555678c6e8 circt-opt`void llvm::function_ref<void (mlir::Operation*)>::callback_fn<(anonymous namespace)::Inliner::cloneAndRename(callable=140737488304200, params=0x0000555557bfa070)::$_2>(long, mlir::Operation*) at STLFunctionalExtras.h:45:12
    frame #9: 0x0000555556214546 circt-opt`void mlir::detail::walk<mlir::ForwardIterator>(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) [inlined] llvm::function_ref<void (mlir::Operation*)>::operator(this=<unavailable>, params=0x0000555557bfa070)(mlir::Operation*) const at STLFunctionalExtras.h:68:12
    frame #10: 0x000055555621453d circt-opt`void mlir::detail::walk<mlir::ForwardIterator>(op=0x0000555557bfa070, callback=mlir::function_ref<void (mlir::Operation *)> @ 0x0000000003b98e80, order=PreOrder)>, mlir::WalkOrder) at Visitors.h:174:5
    frame #11: 0x000055555678c5ad circt-opt`(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&) [inlined] std::enable_if<llvm::is_one_of<mlir::Operation*, mlir::Operation*, mlir::Region*, mlir::Block*>::value, void>::type mlir::detail::walk<(op=0x0000555557bfa070, callback=0x00007fffffff3848)0, mlir::ForwardIterator, (anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2, mlir::Operation*, void>(mlir::Operation*, (anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2&&) at Visitors.h:313:10
    frame #12: 0x000055555678c597 circt-opt`(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&) [inlined] std::enable_if<(llvm::function_traits<std::decay<(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2>::type>::num_args) == (1), void>::type mlir::Operation::walk<(this=0x0000555557bfa070, callback=0x00007fffffff3848)0, mlir::ForwardIterator, (anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2, void>((anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2&&) at Operation.h:641:12
    frame #13: 0x000055555678c597 circt-opt`(anonymous namespace)::Inliner::cloneAndRename(this=0x00007fffffff4588, prefix=(Data = ""bar2_no_bar3_"", Length = 13), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, op=0x0000555557bfa070, symbolRenames=0x00007fffffff3d60, localSymbols=0x00007fffffff3b40, moduleNamespace=0x00007fffffff4510) at ModuleInliner.cpp:866:6
    frame #14: 0x000055555678dafc circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=<unavailable>, b=<unavailable>, mapper=<unavailable>, beb=<unavailable>, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff39f8, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at SmallVector.h:0:10
    frame #15: 0x000055555678e593 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=<unavailable>, b=<unavailable>, mapper=<unavailable>, beb=<unavailable>, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3c78, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1109:7
    frame #16: 0x000055555678e593 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=<unavailable>, b=<unavailable>, mapper=<unavailable>, beb=<unavailable>, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3ef8, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1109:7
    frame #17: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7
    frame #18: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7
    frame #19: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13
    frame #20: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17
    frame #21: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #22: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #23: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003d9ef60, irUnits=ArrayRef<mlir::IRUnit> @ 0x0000000003e53480, args=0x0000555557bfcc80)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #24: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfcc80, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #25: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be10c0, op=0x0000555557bfbcf0, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16
    frame #26: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557bfeb30)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36
    frame #27: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18
    frame #28: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10
    frame #29: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14
    frame #30: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5
    frame #31: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20
    frame #32: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12
    frame #33: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12
    frame #34: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000411f1f0, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000041820c0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7
    frame #35: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21
    frame #36: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16
    frame #37: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfbd50, am=AnalysisManager @ scalar) at Pass.cpp:857:10
    frame #38: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfbd50) at Pass.cpp:837:60
    frame #39: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc93b0, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17
    frame #40: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12
    frame #41: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12
    frame #42: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12
    frame #43: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12
    frame #44: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12
    frame #45: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10
    frame #46: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14
    frame #47: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23
    frame #48: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126
    frame #49: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137
    frame #50: 0x0000555556160415 circt-opt`_start + 37",,,,,,,
4896,[FIRRTL] Verify annotation symbol uses!,2023-03-28T00:07:06Z,open,"bug, good first issue, FIRRTL","Currently there is no verification that the symbols used by annotations exist at all, nevermind any sense of being appropriate/correct.  This should be fixed.  Example:

```firrtl
module {
  firrtl.circuit ""Oops"" {
    firrtl.module private @Child() attributes {annotations = [{circt.nonlocal = @nla, class = ""circt.test""}]} {
    }
    firrtl.module @Oops() {
      firrtl.instance child @Child()
    }
  }
}
```

Presently, `circt-opt` round-trips this, and `firtool` makes it all the way to `PrefixModules` before something notices.

There may be support for Attribute symbol-use verification, so look for such as that would be ideal.  Otherwise we may need to find a way to expose the uses to the symbol verifier, there are interfaces for exposing subelement's that may be appropriate here.  A final but offhand seemingly less-than-ideal approach to consider would be SymbolUserOpInterface's `verifySymbolUses` (I suppose on all our operations that take annotations).","module {
  firrtl.circuit ""Oops"" {
    firrtl.module private @Child() attributes {annotations = [{circt.nonlocal = @nla, class = ""circt.test""}]} {
    }
    firrtl.module @Oops() {
      firrtl.instance child @Child()
    }
  }
}",,,,,,,,,
4886,[FIRRTL] InferResets Not Duplicating Modules When Necessary,2023-03-24T22:32:02Z,open,"bug, FIRRTL","In the following FIRRTL, we have a module instantiated twice, once in a FullAsyncReset domain, and once not in any domain.

```
circuit Top : %[[
  {
    ""class"":""sifive.enterprise.firrtl.FullAsyncResetAnnotation"",
    ""target"":""~Top|FullAsyncWrapper>rf_reset""
  }
]]
  module Child :
    input clock : Clock
    input foo : UInt<8>
    output bar : UInt<8>

    reg r : UInt<8>, clock
    r <= foo
    bar <= r

  module FullAsyncWrapper :
    input clock : Clock
    input rf_reset : AsyncReset
    input foo : UInt<8>
    output bar : UInt<8>

    inst c of Child
    c.clock <= clock
    c.foo <= foo
    bar <= c.bar

  module Top :
    input clock : Clock
    input rf_reset : AsyncReset
    input foo : UInt<8>
    output bar : UInt<8>

    inst wrap of FullAsyncWrapper
    wrap.clock <= clock
    wrap.rf_reset <= rf_reset
    wrap.foo <= foo

    inst child of Child
    child.clock <= clock
    child.foo <= foo

    bar <= and(wrap.bar, child.bar)
```

Run this with firtool 1.36.0 and you will get
```
test.fir:7:10: error: module 'Child' instantiated in different reset domains
  module Child :
         ^
test.fir:7:10: note: see current operation: 
""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<8>, %arg2: !firrtl.uint<8>):
  %0 = ""firrtl.reg""(%arg0) {annotations = [], name = ""r"", nameKind = #firrtl<name_kind droppable_name>} : (!firrtl.clock) -> !firrtl.uint<8>
  ""firrtl.strictconnect""(%0, %arg1) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()
  ""firrtl.strictconnect""(%arg2, %0) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()
}) {annotations = [], portAnnotations = [], portDirections = -4 : i3, portLocations = [loc(""test.fir"":8:11), loc(""test.fir"":9:11), loc(""test.fir"":10:12)], portNames = [""clock"", ""foo"", ""bar""], portSyms = [], portTypes = [!firrtl.clock, !firrtl.uint<8>, !firrtl.uint<8>], sym_name = ""Child"", sym_visibility = ""private""} : () -> ()
test.fir:22:5: note: instance 'wrap/c' is in reset domain rooted at 'rf_reset' of module 'FullAsyncWrapper'
    inst c of Child
    ^
test.fir:18:11: note: reset domain 'rf_reset' of module 'FullAsyncWrapper' declared here:
    input rf_reset : AsyncReset
          ^
test.fir:38:5: note: instance 'child' is in no reset domain
    inst child of Child
    ^
```

This is a very similar issue to https://github.com/llvm/circt/issues/4586","circuit Top : %[[
  {
    ""class"":""sifive.enterprise.firrtl.FullAsyncResetAnnotation"",
    ""target"":""~Top|FullAsyncWrapper>rf_reset""
  }
]]
  module Child :
    input clock : Clock
    input foo : UInt<8>
    output bar : UInt<8>

    reg r : UInt<8>, clock
    r <= foo
    bar <= r

  module FullAsyncWrapper :
    input clock : Clock
    input rf_reset : AsyncReset
    input foo : UInt<8>
    output bar : UInt<8>

    inst c of Child
    c.clock <= clock
    c.foo <= foo
    bar <= c.bar

  module Top :
    input clock : Clock
    input rf_reset : AsyncReset
    input foo : UInt<8>
    output bar : UInt<8>

    inst wrap of FullAsyncWrapper
    wrap.clock <= clock
    wrap.rf_reset <= rf_reset
    wrap.foo <= foo

    inst child of Child
    child.clock <= clock
    child.foo <= foo

    bar <= and(wrap.bar, child.bar)","test.fir:7:10: error: module 'Child' instantiated in different reset domains
  module Child :
         ^
test.fir:7:10: note: see current operation: 
""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<8>, %arg2: !firrtl.uint<8>):
  %0 = ""firrtl.reg""(%arg0) {annotations = [], name = ""r"", nameKind = #firrtl<name_kind droppable_name>} : (!firrtl.clock) -> !firrtl.uint<8>
  ""firrtl.strictconnect""(%0, %arg1) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()
  ""firrtl.strictconnect""(%arg2, %0) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()
}) {annotations = [], portAnnotations = [], portDirections = -4 : i3, portLocations = [loc(""test.fir"":8:11), loc(""test.fir"":9:11), loc(""test.fir"":10:12)], portNames = [""clock"", ""foo"", ""bar""], portSyms = [], portTypes = [!firrtl.clock, !firrtl.uint<8>, !firrtl.uint<8>], sym_name = ""Child"", sym_visibility = ""private""} : () -> ()
test.fir:22:5: note: instance 'wrap/c' is in reset domain rooted at 'rf_reset' of module 'FullAsyncWrapper'
    inst c of Child
    ^
test.fir:18:11: note: reset domain 'rf_reset' of module 'FullAsyncWrapper' declared here:
    input rf_reset : AsyncReset
          ^
test.fir:38:5: note: instance 'child' is in no reset domain
    inst child of Child
    ^",,,,,,,,
4862,[Arc] Simple input crashes SplitLoops,2023-03-20T20:30:36Z,closed,"bug, Arc","The following input crashes `circt-opt --arc-split-loops`:
```mlir
arc.define @Rocket_arc(%arg0: i1, %arg1: i1, %arg2: i1) -> (i1, i1) {
  %0 = comb.xor %arg0, %arg1 : i1
  %1 = comb.xor %arg2, %arg1 : i1
  %2 = comb.xor %0, %1 : i1
  arc.output %1, %2 : i1, i1
}
hw.module @Rocket(%a: i1) -> (x: i1, y: i1) {
  %0, %1 = arc.state @Rocket_arc(%a, %a, %a) lat 0 : (i1, i1, i1) -> (i1, i1)
  hw.output %0, %1 : i1, i1
}
```","arc.define @Rocket_arc(%arg0: i1, %arg1: i1, %arg2: i1) -> (i1, i1) {
  %0 = comb.xor %arg0, %arg1 : i1
  %1 = comb.xor %arg2, %arg1 : i1
  %2 = comb.xor %0, %1 : i1
  arc.output %1, %2 : i1, i1
}
hw.module @Rocket(%a: i1) -> (x: i1, y: i1) {
  %0, %1 = arc.state @Rocket_arc(%a, %a, %a) lat 0 : (i1, i1, i1) -> (i1, i1)
  hw.output %0, %1 : i1, i1
}",,,,,,,,,
4859,[FIRRTL][InferWidths] Uninferred uint vector in invalidvalue op triggers assertion,2023-03-20T17:38:28Z,closed,"bug, FIRRTL","The following reduced version of some input seen in the wild (BOOM core) trips up width inferences:
```mlir
firrtl.circuit ""Foo"" {
  firrtl.module @Foo() {
    %invalid = firrtl.invalidvalue : !firrtl.bundle<a: vector<uint, 2>>
    %0 = firrtl.subfield %invalid[a] : !firrtl.bundle<a: vector<uint, 2>>
    %1 = firrtl.subindex %0[0] : !firrtl.vector<uint, 2>
  }
}
```
Running this through `circt-opt --firrtl-infer-widths` produces:
```
circt-opt: lib/Dialect/FIRRTL/Transforms/InferWidths.cpp:1780:
  (anonymous namespace)::Expr *(anonymous namespace)::InferenceMapping::getExpr(circt::FieldRef):
  Assertion `expr && ""constraint expr should have been constructed for value""' failed.
```","firrtl.circuit ""Foo"" {
  firrtl.module @Foo() {
    %invalid = firrtl.invalidvalue : !firrtl.bundle<a: vector<uint, 2>>
    %0 = firrtl.subfield %invalid[a] : !firrtl.bundle<a: vector<uint, 2>>
    %1 = firrtl.subindex %0[0] : !firrtl.vector<uint, 2>
  }
}","circt-opt: lib/Dialect/FIRRTL/Transforms/InferWidths.cpp:1780:
  (anonymous namespace)::Expr *(anonymous namespace)::InferenceMapping::getExpr(circt::FieldRef):
  Assertion `expr && ""constraint expr should have been constructed for value""' failed.",,,,,,,,
4849,[ExportVerilog][SV] sv.interface instance name not Verilog-keyword mangled,2023-03-17T21:27:52Z,open,"bug, ExportVerilog","The instance name of an SV interface op is not mangled if it collides with a Verilog keyword when it should be.

Consider:

```mlir
module {
  sv.interface @wire {}
  hw.module private @Foo() {
    %module = sv.interface.instance : !sv.interface<@wire>
    hw.output
  }
}
```

This is being output as the following when using `circt-opt -export-verilog Foo.mlir`:

```verilog
// Generated by CIRCT unknown git version
interface module_0;
endinterface

module Foo();	// Foo.mlir:3:3
  wire_0 module();	// Foo.mlir:4:15
endmodule
```","module {
  sv.interface @wire {}
  hw.module private @Foo() {
    %module = sv.interface.instance : !sv.interface<@wire>
    hw.output
  }
}","// Generated by CIRCT unknown git version
interface module_0;
endinterface

module Foo();	// Foo.mlir:3:3
  wire_0 module();	// Foo.mlir:4:15
endmodule",,,,,,,,
4842,[Lower Calyx to FSM] Pass can fail if not canonicalized before running,2023-03-16T16:28:01Z,open,"bug, Calyx, need triage","This works:
```bash
$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --canonicalize --lower-calyx-to-fsm
```

But the following (without the `--canonicalize`) triggers an assertion:
```bash
$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm
circt-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed
```

`simple_arith.mlir` can be found [here](https://github.com/llvm/circt/blob/main/integration_test/Dialect/Calyx/simple_arith.mlir).

Backtrace:
```
circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm   
circt-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ../../circt/build/bin/circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm
 #0 0x000055d161ee52d4 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:22
 #1 0x000055d161ee56a6 PrintStackTraceSignalHandler(void*) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:676:1
 #2 0x000055d161ee2d57 llvm::sys::RunSignalHandlers() /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Signals.cpp:104:20
 #3 0x000055d161ee4c32 SignalHandler(int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #4 0x00007f117de51f50 (/usr/lib/libc.so.6+0x38f50)
 #5 0x00007f117dea08ec (/usr/lib/libc.so.6+0x878ec)
 #6 0x00007f117de51ea8 raise (/usr/lib/libc.so.6+0x38ea8)
 #7 0x00007f117de3b53d abort (/usr/lib/libc.so.6+0x2253d)
 #8 0x00007f117de3b45c (/usr/lib/libc.so.6+0x2245c)
 #9 0x00007f117de4a9f6 (/usr/lib/libc.so.6+0x319f6)
#10 0x000055d1621313f5 llvm::SmallVectorTemplateCommon<std::pair<mlir::Operation*, circt::fsm::StateOp>, void>::front() /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:304:17
#11 0x000055d16212bf8b (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:196:26
#12 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#13 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#14 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#15 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#16 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#17 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#18 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#19 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#20 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#21 0x000055d16212b958 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp)::'lambda'(mlir::Value, llvm::StringRef, bool, mlir::Operation*)::operator()(mlir::Value, llvm::StringRef, bool, mlir::Operation*) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:147:15
#22 0x000055d16212bb0e (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:153:13
#23 0x000055d16212dbe3 auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::IfOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#24 0x000055d16212dc60 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::IfOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#25 0x000055d16212b320 Case<circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#26 0x000055d16212b320 Case<circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42
#27 0x000055d16212b320 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42
#28 0x000055d16212b320 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#29 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#30 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#31 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#32 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#33 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#34 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#35 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#36 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#37 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#38 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#39 0x000055d16212cada (anonymous namespace)::CalyxToFSMPass::runOnOperation() /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:307:13
#40 0x000055d164764cc4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:471:27
#41 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15
#42 0x000055d1647660e8 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:754:47
#43 0x000055d164768e17 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:46:17
#44 0x000055d1647681df mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:94:1
#45 0x000055d164766627 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:764:13
#46 0x000055d164765ab9 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:658:1
#47 0x000055d164764ca5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:468:28
#48 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15
#49 0x000055d164766e06 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:843:40
#50 0x000055d164766c66 mlir::PassManager::run(mlir::Operation*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:823:69
#51 0x000055d16397c887 performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:175:13
#52 0x000055d16397ccf5 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPool*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:221:26
#53 0x000055d16397ce21 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:262:25
#54 0x000055d16397dcd2 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:52
#55 0x000055d1639bae6b llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
#56 0x000055d1639ba6ff mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:28:30
#57 0x000055d16397cfd2 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:265:31
#58 0x000055d16397d8cf mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:354:13
#59 0x000055d161ddc13e main /home/xerpi/Desktop/Research/circt/tools/circt-opt/circt-opt.cpp:70:22
#60 0x00007f117de3c790 (/usr/lib/libc.so.6+0x23790)
#61 0x00007f117de3c84a __libc_start_main (/usr/lib/libc.so.6+0x2384a)
#62 0x000055d161ddbec5 _start (../../circt/build/bin/circt-opt+0x119ec5)
Aborted (core dumped)
```",$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --canonicalize --lower-calyx-to-fsm,"$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm
circt-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed","circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm   
circt-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ../../circt/build/bin/circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm
 #0 0x000055d161ee52d4 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:22
 #1 0x000055d161ee56a6 PrintStackTraceSignalHandler(void*) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:676:1
 #2 0x000055d161ee2d57 llvm::sys::RunSignalHandlers() /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Signals.cpp:104:20
 #3 0x000055d161ee4c32 SignalHandler(int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1
 #4 0x00007f117de51f50 (/usr/lib/libc.so.6+0x38f50)
 #5 0x00007f117dea08ec (/usr/lib/libc.so.6+0x878ec)
 #6 0x00007f117de51ea8 raise (/usr/lib/libc.so.6+0x38ea8)
 #7 0x00007f117de3b53d abort (/usr/lib/libc.so.6+0x2253d)
 #8 0x00007f117de3b45c (/usr/lib/libc.so.6+0x2245c)
 #9 0x00007f117de4a9f6 (/usr/lib/libc.so.6+0x319f6)
#10 0x000055d1621313f5 llvm::SmallVectorTemplateCommon<std::pair<mlir::Operation*, circt::fsm::StateOp>, void>::front() /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:304:17
#11 0x000055d16212bf8b (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:196:26
#12 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#13 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#14 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#15 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#16 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#17 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#18 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#19 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#20 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#21 0x000055d16212b958 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp)::'lambda'(mlir::Value, llvm::StringRef, bool, mlir::Operation*)::operator()(mlir::Value, llvm::StringRef, bool, mlir::Operation*) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:147:15
#22 0x000055d16212bb0e (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:153:13
#23 0x000055d16212dbe3 auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::IfOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#24 0x000055d16212dc60 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::IfOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#25 0x000055d16212b320 Case<circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#26 0x000055d16212b320 Case<circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42
#27 0x000055d16212b320 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42
#28 0x000055d16212b320 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#29 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#30 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#31 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#32 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#33 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#34 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15
#35 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79
#36 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28
#37 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40
#38 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55
#39 0x000055d16212cada (anonymous namespace)::CalyxToFSMPass::runOnOperation() /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:307:13
#40 0x000055d164764cc4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:471:27
#41 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15
#42 0x000055d1647660e8 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:754:47
#43 0x000055d164768e17 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:46:17
#44 0x000055d1647681df mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:94:1
#45 0x000055d164766627 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:764:13
#46 0x000055d164765ab9 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:658:1
#47 0x000055d164764ca5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:468:28
#48 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15
#49 0x000055d164766e06 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:843:40
#50 0x000055d164766c66 mlir::PassManager::run(mlir::Operation*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:823:69
#51 0x000055d16397c887 performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:175:13
#52 0x000055d16397ccf5 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPool*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:221:26
#53 0x000055d16397ce21 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:262:25
#54 0x000055d16397dcd2 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:52
#55 0x000055d1639bae6b llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
#56 0x000055d1639ba6ff mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:28:30
#57 0x000055d16397cfd2 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:265:31
#58 0x000055d16397d8cf mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:354:13
#59 0x000055d161ddc13e main /home/xerpi/Desktop/Research/circt/tools/circt-opt/circt-opt.cpp:70:22
#60 0x00007f117de3c790 (/usr/lib/libc.so.6+0x23790)
#61 0x00007f117de3c84a __libc_start_main (/usr/lib/libc.so.6+0x2384a)
#62 0x000055d161ddbec5 _start (../../circt/build/bin/circt-opt+0x119ec5)
Aborted (core dumped)",,,,,,,
4835,[FIRRTL][Seq] Running without randomization needs Async Reset reg initialization,2023-03-15T21:28:07Z,closed,"bug, good first issue, FIRRTL, Seq","The following FIRRTL compiled to Verilog needs to have an `initial` block that does a reset if reset is asserted. This happens without randomization, but not with:

```
circuit Foo :
  module Foo :
    input clock : Clock
    input reset : AsyncReset
    input d : UInt<1>
    output q : UInt<1>

    reg q_REG : UInt<1>, clock with :
      reset => (reset, UInt<1>(""h0""))
    q_REG <= d
    q <= q_REG
```

This compiles to:

```Verilog
// Generated by CIRCT unknown git version
module Foo(
  input  clock,
         reset,
         d,
  output q
);

  reg q_REG;
  always @(posedge clock or posedge reset) begin
    if (reset)
      q_REG <= 1'h0;
    else
      q_REG <= d;
  end // always @(posedge, posedge)
  assign q = q_REG;
endmodule
```

This should have the following, possibly guarded only by `ifndef SYNTHESIS`:
```
initial begin
  if (reset)
    q_REG = 1'h0;
end
```","circuit Foo :
  module Foo :
    input clock : Clock
    input reset : AsyncReset
    input d : UInt<1>
    output q : UInt<1>

    reg q_REG : UInt<1>, clock with :
      reset => (reset, UInt<1>(""h0""))
    q_REG <= d
    q <= q_REG","// Generated by CIRCT unknown git version
module Foo(
  input  clock,
         reset,
         d,
  output q
);

  reg q_REG;
  always @(posedge clock or posedge reset) begin
    if (reset)
      q_REG <= 1'h0;
    else
      q_REG <= d;
  end // always @(posedge, posedge)
  assign q = q_REG;
endmodule","initial begin
  if (reset)
    q_REG = 1'h0;
end",,,,,,,
4834,[FIRRTL] Inline + MarkDUT + MemTap crasher,2023-03-15T17:12:30Z,open,"bug, FIRRTL","Inline+MarkDUTAnnotation already don't seem compatible, but FWIW we crash in LowerToHW on this input.

Input:
```firrtl
circuit Top : %[[
  {
    ""class"": ""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""~Top|DUTModule""
  },
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top>memTap""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.MemTapAnnotation"",
    ""source"":""~Top|DUTModule>rf"",
    ""sink"":[
      ""~Top|Top>memTap[0]"",
      ""~Top|Top>memTap[1]"",
      ""~Top|Top>memTap[2]"",
      ""~Top|Top>memTap[3]"",
      ""~Top|Top>memTap[4]"",
      ""~Top|Top>memTap[5]"",
      ""~Top|Top>memTap[6]"",
      ""~Top|Top>memTap[7]""
    ]
  },
  {
    ""class"": ""firrtl.passes.InlineAnnotation"",
    ""target"": ""~Top|DUTModule""
  }
]]
  module DUTModule :
    input clock : Clock
    input reset : Reset
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    cmem rf : UInt<8> [8]
    infer mport read = rf[io.addr], clock
    io.dataOut <= read
    when io.wen :
      infer mport write = rf[io.addr], clock
      write <= io.dataIn

  module Top :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    inst dut of DUTModule
    dut.clock <= clock
    dut.reset <= reset
    wire memTap : UInt<8>[8]
    memTap is invalid
    io.dataOut <= dut.io.dataOut
    dut.io.wen <= io.wen
    dut.io.dataIn <= io.dataIn
    dut.io.addr <= io.addr
```

This is basically our `mem-taps.fir` lit test with the Inline annotation added.

With threading disabled, see the following error: `invalid element for hw.inout type '!firrtl.ref<uint<8>>'`, FWIW.","circuit Top : %[[
  {
    ""class"": ""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""~Top|DUTModule""
  },
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top>memTap""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.MemTapAnnotation"",
    ""source"":""~Top|DUTModule>rf"",
    ""sink"":[
      ""~Top|Top>memTap[0]"",
      ""~Top|Top>memTap[1]"",
      ""~Top|Top>memTap[2]"",
      ""~Top|Top>memTap[3]"",
      ""~Top|Top>memTap[4]"",
      ""~Top|Top>memTap[5]"",
      ""~Top|Top>memTap[6]"",
      ""~Top|Top>memTap[7]""
    ]
  },
  {
    ""class"": ""firrtl.passes.InlineAnnotation"",
    ""target"": ""~Top|DUTModule""
  }
]]
  module DUTModule :
    input clock : Clock
    input reset : Reset
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    cmem rf : UInt<8> [8]
    infer mport read = rf[io.addr], clock
    io.dataOut <= read
    when io.wen :
      infer mport write = rf[io.addr], clock
      write <= io.dataIn

  module Top :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    inst dut of DUTModule
    dut.clock <= clock
    dut.reset <= reset
    wire memTap : UInt<8>[8]
    memTap is invalid
    io.dataOut <= dut.io.dataOut
    dut.io.wen <= io.wen
    dut.io.dataIn <= io.dataIn
    dut.io.addr <= io.addr",,,,,,,,,
4816,Late pipeline passes should not be doing type coercion.,2023-03-13T23:26:33Z,open,bug,"              Please do not do this.  The goal is to remove this logic entirely and stop duplicating it in every pass.  We should never get to this point in the pass with the register reset value being the wrong type for the register.  That should be fixed in parsing.

_Originally posted by @darthscsi in https://github.com/llvm/circt/pull/4788#pullrequestreview-1338110528_
            ",,,,,,,,,,
4796,[FIRRTL][InferWidths] Honor upper bounds on AttachOp,2023-03-09T18:00:45Z,closed,"bug, FIRRTL","Fix an issue in `InferWidths` where analog values attached to each other would not produce proper errors if the widths are unsatisfiable. For example, the following is unsatisfiable but successfully infers to an incorrect width:

```
firrtl.module @AnalogWidths(
  in %a: !firrtl.analog,
  out %b: !firrtl.analog<2>,
  out %c: !firrtl.analog<1>
) {
  firrtl.attach %a, %b : !firrtl.analog, !firrtl.analog<2>
  firrtl.attach %a, %c : !firrtl.analog, !firrtl.analog<1>
}
```

The `AttachOp` imposes a `lhs >= rhs` *and* `lhs <= rhs` constraint, which is supposed to devolve into `lhs == rhs`. However, `InferWidths` ignores upper bound constraints like `expr <= 42` since the original Scala implementation used to violate upper bounds in obscure and wild ways (see #1088).

This commit adds an optional upper bound to variables which is checked after width inference. Specifically `AttachOp` is made to generate these upper bound constraints. Proper error messages on unsatisfiable widths should now be produced.

Fixes #4786.","firrtl.module @AnalogWidths(
  in %a: !firrtl.analog,
  out %b: !firrtl.analog<2>,
  out %c: !firrtl.analog<1>
) {
  firrtl.attach %a, %b : !firrtl.analog, !firrtl.analog<2>
  firrtl.attach %a, %c : !firrtl.analog, !firrtl.analog<1>
}",,,,,,,,,
4785,[Scheduling] ModuloSimplex crashes with operator limits,2023-03-08T21:35:11Z,closed,"bug, Scheduling","The following SSP program crashes when run with `circt-opt -ssp-schedule=scheduler=simplex`:

```
  ssp.instance @test1 of ""ModuloProblem"" {
    library {
      operator_type @port0 [latency<1>, limit<1>]
      operator_type @port1 [latency<1>, limit<1>]
      operator_type @port2 [latency<1>, limit<1>]
      operator_type @comb [latency<0>]
    }
    graph {
      %0 = operation<@port0>()
      %1 = operation<@port1>()
      %2 = operation<@comb>(%0, %1)
      %3 = operation<@port2>(%2)
      operation<@comb>()
    }
  }
```

but the same problem without limits on the operator types does not crash. It seems there are still some bugs in the ModuloSimplex scheduler even after the overhaul.","ssp.instance @test1 of ""ModuloProblem"" {
    library {
      operator_type @port0 [latency<1>, limit<1>]
      operator_type @port1 [latency<1>, limit<1>]
      operator_type @port2 [latency<1>, limit<1>]
      operator_type @comb [latency<0>]
    }
    graph {
      %0 = operation<@port0>()
      %1 = operation<@port1>()
      %2 = operation<@comb>(%0, %1)
      %3 = operation<@port2>(%2)
      operation<@comb>()
    }
  }",,,,,,,,,
4781,[FIRRTL] comb cycle error has too many entries (?),2023-03-08T02:33:20Z,closed,"bug, FIRRTL","Consider this input:
```firrtl
circuit wut :
   module wut :

     wire x : UInt<8>
     wire y : UInt<8>
     x <= y
     y <= x
```

We currently produce this error:

```
wut.fir:2:11: error: detected combinational cycle in a FIRRTL module, sample path: wut.x <- wut.y <- wut.x <- wut.x
   module wut :
          ^
```

From brief testing, seems we print the beginning/end an extra time?  As shown here, that last `<- wut.x` is not actually present and describes a connection that doesn't exist (not directly anyway).

As a nit, it would be nice to point to one of the signals involved instead of the module?  If we are intentionally avoiding printing all the signals to avoid being too verbose that makes sense, but may be useful to enable as a debugging aid.","circuit wut :
   module wut :

     wire x : UInt<8>
     wire y : UInt<8>
     x <= y
     y <= x","wut.fir:2:11: error: detected combinational cycle in a FIRRTL module, sample path: wut.x <- wut.y <- wut.x <- wut.x
   module wut :
          ^",,,,,,,,
4780,"[FIRRTL] Missed comb cycle, crash in canonicalizer",2023-03-08T02:24:27Z,open,"bug, FIRRTL","Input:

```firrtl
circuit wut :
   module wut :
     output rwDataOut : UInt<8>

     rwDataOut <= rwDataOut
```

<details>
<summary>Crashes after making it to HW dialect:</summary>

```
firtool: /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:190: void mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith(ValueT &&) [OperandType = mlir::OpOperand, ValueT = mlir::Value &]: Assertion `(!newValue || this != OperandType::getUseList(newValue)) && ""cannot RAUW a value with itself""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool wut.fir
 #0 0x00000000006c71bb llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x00000000006c5450 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x00000000006c786d SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007f882063dbf0 __restore_rt (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3dbf0)
 #4 0x00007f882068abc7 __pthread_kill_implementation (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x8abc7)
 #5 0x00007f882063db46 gsignal (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3db46)
 #6 0x00007f88206284b5 abort (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x284b5)
 #7 0x00007f88206283d9 _nl_load_domain.cold.0 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x283d9)
 #8 0x00007f88206367b6 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x367b6)
 #9 0x0000000000a5476c std::enable_if<!(std::is_convertible<mlir::ValueRange&, mlir::Operation*>::value), void>::type mlir::ResultRange::replaceAllUsesWith<mlir::ValueRange&>(mlir::ValueRange&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/ValueRange.h:271:5
#10 0x0000000000a52ec3 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:275:61
#11 0x0000000000c31cb7 circt::sv::WireOp::canonicalize(circt::sv::WireOp, mlir::PatternRewriter&) /home/will/src/sifive/circt/lib/Dialect/SV/SVOps.cpp:1460:18
#12 0x0000000000e0ccb7 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25
#13 0x0000000000dd93ed (anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:229:19
#14 0x0000000000dd702d (anonymous namespace)::RegionPatternRewriteDriver::simplify() && /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:458:15
#15 0x0000000000dd702d mlir::applyPatternsAndFoldGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:487:47
#16 0x0000000000a66148 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#17 0x0000000000a66148 mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:115:70
#18 0x0000000000a66148 (anonymous namespace)::Canonicalizer::runOnOperation() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:61:9
#19 0x0000000000ee9829 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11
#20 0x0000000000ee9e61 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#21 0x0000000000ee9e61 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#22 0x0000000000ee9e61 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#23 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::size() const /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:919:66
#24 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1045:2
#25 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5
#26 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18
#27 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#28 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14
#29 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5
#30 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14
#31 0x0000000000eec3a3 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#32 0x0000000000eec3a3 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#33 0x0000000000eec3a3 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#34 0x0000000000eec3a3 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:843:10
#35 0x0000000000eec3a3 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:823:60
#36 0x000000000061a57b mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#37 0x000000000061a57b mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#38 0x000000000061a57b processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:856:7
#39 0x00000000006182bf processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:12
#40 0x0000000000617f42 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:968:12
#41 0x0000000000617f42 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1058:14
#42 0x00000000006179f6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#43 0x00000000006179f6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#44 0x00000000006179f6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1122:8
#45 0x00007f882062924e __libc_start_call_main (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x2924e)
#46 0x00007f8820629309 __libc_start_main@GLIBC_2.2.5 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x29309)
#47 0x0000000000617825 _start (./build/bin/firtool+0x617825)
zsh: IOT instruction (core dumped)  ./build/bin/firtool wut.fir
```

</details>

Dumping the IR shows this before the crash:

```
// -----// IR Dump Before Canonicalizer (canonicalize) //----- //
hw.module @wut() -> (rwDataOut: i8) {
  %.rwDataOut.output = sv.wire : !hw.inout<i8>
  %0 = sv.read_inout %.rwDataOut.output : !hw.inout<i8>
  sv.assign %.rwDataOut.output, %0 : i8
  hw.output %0 : i8
}
```","circuit wut :
   module wut :
     output rwDataOut : UInt<8>

     rwDataOut <= rwDataOut","firtool: /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:190: void mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith(ValueT &&) [OperandType = mlir::OpOperand, ValueT = mlir::Value &]: Assertion `(!newValue || this != OperandType::getUseList(newValue)) && ""cannot RAUW a value with itself""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool wut.fir
 #0 0x00000000006c71bb llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13
 #1 0x00000000006c5450 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x00000000006c786d SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007f882063dbf0 __restore_rt (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3dbf0)
 #4 0x00007f882068abc7 __pthread_kill_implementation (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x8abc7)
 #5 0x00007f882063db46 gsignal (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3db46)
 #6 0x00007f88206284b5 abort (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x284b5)
 #7 0x00007f88206283d9 _nl_load_domain.cold.0 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x283d9)
 #8 0x00007f88206367b6 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x367b6)
 #9 0x0000000000a5476c std::enable_if<!(std::is_convertible<mlir::ValueRange&, mlir::Operation*>::value), void>::type mlir::ResultRange::replaceAllUsesWith<mlir::ValueRange&>(mlir::ValueRange&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/ValueRange.h:271:5
#10 0x0000000000a52ec3 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:275:61
#11 0x0000000000c31cb7 circt::sv::WireOp::canonicalize(circt::sv::WireOp, mlir::PatternRewriter&) /home/will/src/sifive/circt/lib/Dialect/SV/SVOps.cpp:1460:18
#12 0x0000000000e0ccb7 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25
#13 0x0000000000dd93ed (anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:229:19
#14 0x0000000000dd702d (anonymous namespace)::RegionPatternRewriteDriver::simplify() && /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:458:15
#15 0x0000000000dd702d mlir::applyPatternsAndFoldGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:487:47
#16 0x0000000000a66148 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#17 0x0000000000a66148 mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:115:70
#18 0x0000000000a66148 (anonymous namespace)::Canonicalizer::runOnOperation() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:61:9
#19 0x0000000000ee9829 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11
#20 0x0000000000ee9e61 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#21 0x0000000000ee9e61 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#22 0x0000000000ee9e61 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#23 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::size() const /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:919:66
#24 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1045:2
#25 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5
#26 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18
#27 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#28 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14
#29 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5
#30 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14
#31 0x0000000000eec3a3 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#32 0x0000000000eec3a3 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#33 0x0000000000eec3a3 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#34 0x0000000000eec3a3 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:843:10
#35 0x0000000000eec3a3 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:823:60
#36 0x000000000061a57b mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#37 0x000000000061a57b mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#38 0x000000000061a57b processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:856:7
#39 0x00000000006182bf processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:12
#40 0x0000000000617f42 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:968:12
#41 0x0000000000617f42 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1058:14
#42 0x00000000006179f6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#43 0x00000000006179f6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#44 0x00000000006179f6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1122:8
#45 0x00007f882062924e __libc_start_call_main (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x2924e)
#46 0x00007f8820629309 __libc_start_main@GLIBC_2.2.5 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x29309)
#47 0x0000000000617825 _start (./build/bin/firtool+0x617825)
zsh: IOT instruction (core dumped)  ./build/bin/firtool wut.fir","// -----// IR Dump Before Canonicalizer (canonicalize) //----- //
hw.module @wut() -> (rwDataOut: i8) {
  %.rwDataOut.output = sv.wire : !hw.inout<i8>
  %0 = sv.read_inout %.rwDataOut.output : !hw.inout<i8>
  sv.assign %.rwDataOut.output, %0 : i8
  hw.output %0 : i8
}",,,,,,,
4771,[FIRRTL] attach of analog under when (+ subaccess)?,2023-03-06T14:58:23Z,open,"bug, FIRRTL","Generally, this may be more of a FIRRTL-spec consideration, but the following is accepted and only is rejected late in the pipeline:

```firrtl
circuit Foo :
  module Foo :
    output d : { a: UInt<2>, b: Analog<1>}
    input c : UInt<1>
    d is invalid
    when c :
      inst b of Bar
      attach(d.b, b.b.b[c])
    else :
      inst b2 of Bar
      attach(d.b, b2.b.b[c])

  extmodule Bar :
    output b : { a : UInt<2>, b : Analog<1>[2]}
 ```
 
 Output:
 
 ```
analog.fir:11:11: error: operand isn't an inout type
      d.b <- b2.b.b[c]
          ^
analog.fir:11:11: note: see current operation: ""firrtl.attach""(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()
analog.fir:11:11: error: 'firrtl.attach' op LowerToHW couldn't handle this operation
      d.b <- b2.b.b[c]
          ^
analog.fir:11:11: note: see current operation: ""firrtl.attach""(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> () 
 ```
 
*Does conditional attach make sense?* (is it unconditional even under `when`?)
","circuit Foo :
  module Foo :
    output d : { a: UInt<2>, b: Analog<1>}
    input c : UInt<1>
    d is invalid
    when c :
      inst b of Bar
      attach(d.b, b.b.b[c])
    else :
      inst b2 of Bar
      attach(d.b, b2.b.b[c])

  extmodule Bar :
    output b : { a : UInt<2>, b : Analog<1>[2]}","analog.fir:11:11: error: operand isn't an inout type
      d.b <- b2.b.b[c]
          ^
analog.fir:11:11: note: see current operation: ""firrtl.attach""(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()
analog.fir:11:11: error: 'firrtl.attach' op LowerToHW couldn't handle this operation
      d.b <- b2.b.b[c]
          ^
analog.fir:11:11: note: see current operation: ""firrtl.attach""(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()",,,,,,,,
4770,"[ExportVerilog] ""$name is not allowed in Verilog output"" error does not fail pass",2023-03-06T14:37:28Z,open,"bug, ExportVerilog","Encountered crafting test over here: https://github.com/llvm/circt/pull/4589#discussion_r1126488967 .

Is currently reachable + executed as part of the `verilog-errors.mlir` test case:

```mlir
hw.module.extern @parameter ()
```

=>

```
verilog-error.mlir:4:1: error: name ""parameter"" is not allowed in Verilog output
hw.module.extern @parameter ()
^
verilog-error.mlir:4:1: note: see current operation: 
""hw.module.extern""() ({
}) {argLocs = [], argNames = [], comment = """", function_type = () -> (), parameters = [], resultLocs = [], resultNames = [], sym_name = ""parameter""} : () -> ()
// Generated by CIRCT 1.34.0g20230304_3ddf879
// external module parameter
```

As an aside, getting our error tests to check that pass/execution is not successful would be great, cc #4553 .",hw.module.extern @parameter (),"verilog-error.mlir:4:1: error: name ""parameter"" is not allowed in Verilog output
hw.module.extern @parameter ()
^
verilog-error.mlir:4:1: note: see current operation: 
""hw.module.extern""() ({
}) {argLocs = [], argNames = [], comment = """", function_type = () -> (), parameters = [], resultLocs = [], resultNames = [], sym_name = ""parameter""} : () -> ()
// Generated by CIRCT 1.34.0g20230304_3ddf879
// external module parameter",,,,,,,,
4753,[FIRRTL] Crash with out-of-bounds Index,2023-03-02T16:55:07Z,open,"bug, FIRRTL","I noticed that the following is crashing:

```
circuit Foo:
  module Foo:
    input a: UInt<8>[3]
    output b: UInt<8>

    b <= a[UInt<99>(300)]
```

This throws an error (doesn't exit) and then crashes (`firtool Foo.fir`):

```
Foo.fir:6:12: error: out of range index '300' in vector type '!firrtl.vector<uint<8>, 3>'
    b <= a[UInt<99>(300)]
           ^
LLVM ERROR: Failed to infer result type(s).
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: firtool Foo.fir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x00000001039cf21d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x00000001039cf79b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x00000001039cd566 llvm::sys::RunSignalHandlers() + 134
3  firtool                  0x00000001039d14cf SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff80f497dfd _sigtramp + 29
5  firtool                  0x00000001037856e5 std::__1::__libcpp_deallocate(void*, unsigned long, unsigned long) + 85
6  libsystem_c.dylib        0x00007ff80f3cdd24 abort + 123
7  firtool                  0x000000010389f2d4 llvm::report_fatal_error(llvm::Twine const&, bool) + 388
8  firtool                  0x000000010389f145 llvm::report_fatal_error(char const*, bool) + 53
9  firtool                  0x000000010479c065 circt::firrtl::SubindexOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Value, unsigned int) + 533
10 firtool                  0x0000000103ed526c circt::firrtl::SubindexOp mlir::OpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::Location, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 220
11 firtool                  0x0000000103ed4fd1 circt::firrtl::SubindexOp mlir::ImplicitLocOpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 81
```","circuit Foo:
  module Foo:
    input a: UInt<8>[3]
    output b: UInt<8>

    b <= a[UInt<99>(300)]","Foo.fir:6:12: error: out of range index '300' in vector type '!firrtl.vector<uint<8>, 3>'
    b <= a[UInt<99>(300)]
           ^
LLVM ERROR: Failed to infer result type(s).
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: firtool Foo.fir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x00000001039cf21d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x00000001039cf79b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x00000001039cd566 llvm::sys::RunSignalHandlers() + 134
3  firtool                  0x00000001039d14cf SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff80f497dfd _sigtramp + 29
5  firtool                  0x00000001037856e5 std::__1::__libcpp_deallocate(void*, unsigned long, unsigned long) + 85
6  libsystem_c.dylib        0x00007ff80f3cdd24 abort + 123
7  firtool                  0x000000010389f2d4 llvm::report_fatal_error(llvm::Twine const&, bool) + 388
8  firtool                  0x000000010389f145 llvm::report_fatal_error(char const*, bool) + 53
9  firtool                  0x000000010479c065 circt::firrtl::SubindexOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Value, unsigned int) + 533
10 firtool                  0x0000000103ed526c circt::firrtl::SubindexOp mlir::OpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::Location, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 220
11 firtool                  0x0000000103ed4fd1 circt::firrtl::SubindexOp mlir::ImplicitLocOpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 81",,,,,,,,
4734,[FIRRTL] Incorrect behavior for size == 1 CHIRRTL smems with write first read-under-write behavior,2023-02-28T00:06:36Z,closed,"bug, FIRRTL","h/t to @seldridge for helping me debug this.

[Chisel is unable to use firtool v1.32.0](https://github.com/chipsalliance/chisel3/pull/3040) because of this change in behavior from firtool v1.31.0, presumably this is due to https://github.com/llvm/circt/pull/4687. According to https://github.com/llvm/circt/issues/4588, firtool officially does not support read-under-write modifiers for CHIRRTL mem constructs. But in practice, it implements all CHIRRTL smems as ""write first"". This behavior is relied upon by Chisel Queue and is the current behavior of firtool with the exception of when they have a size == 1.

Consider the following simplified FIRRTL output from Chisel Queue with size == 1:
```
circuit Queue :
  module Queue :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}

    smem ram : UInt<1> [1] new
    reg full : UInt<1>, clock with :
      reset => (reset, UInt<1>(""h0""))
    io.count <= full
    io.enq.ready <= not(full)
    io.deq.valid <= full

    node do_enq = and(io.enq.ready, io.enq.valid)
    node do_deq = and(io.deq.ready, io.deq.valid)

    when full :
      full <= not(io.deq.ready)
    else :
      full <= io.enq.valid

    when do_enq :
      infer mport MPORT = ram[UInt<1>(""h0"")], clock
      MPORT <= io.enq.bits

    read mport io_deq_bits_MPORT = ram[UInt<1>(""h0"")], clock
    io.deq.bits <= io_deq_bits_MPORT
```

Using firtool 1.31.0 this compiles to
```verilog
// Generated by CIRCT firtool-1.31.0
module ram_combMem(
  input  R0_addr,
         R0_en,
         R0_clk,
         W0_addr,
         W0_en,
         W0_clk,
         W0_data,
  output R0_data
);

  reg Memory[0:0];
  reg _GEN;
  reg _GEN_0;
  always @(posedge R0_clk) begin
    _GEN <= R0_en;
    _GEN_0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _GEN ? Memory[_GEN_0] : 1'bx;
endmodule

module Queue(
  input  clock,
         reset,
         io_enq_valid,
         io_enq_bits,
         io_deq_ready,
  output io_enq_ready,
         io_deq_valid,
         io_deq_bits,
         io_count
);

  reg full;
  always @(posedge clock) begin
    if (reset)
      full <= 1'h0;
    else if (full)
      full <= ~io_deq_ready;
    else
      full <= io_enq_valid;
  end // always @(posedge)
  ram_combMem ram_ext (
    .R0_addr (1'h0),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .W0_addr (1'h0),
    .W0_en   (~full & io_enq_valid),
    .W0_clk  (clock),
    .W0_data (io_enq_bits),
    .R0_data (io_deq_bits)
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = full;
  assign io_count = full;
endmodule
```

Using firtool 1.32.0 this compiles to:
```verilog
// Generated by CIRCT firtool-1.32.0
module Queue(
  input  clock,
         reset,
         io_enq_valid,
         io_enq_bits,
         io_deq_ready,
  output io_enq_ready,
         io_deq_valid,
         io_deq_bits,
         io_count
);

  reg ram;
  reg ram_data_0;
  reg full;
  always @(posedge clock) begin
    if (~full & io_enq_valid)
      ram <= io_enq_bits;
    ram_data_0 <= ram;
    if (reset)
      full <= 1'h0;
    else if (full)
      full <= ~io_deq_ready;
    else
      full <= io_enq_valid;
  end // always @(posedge)
  assign io_enq_ready = ~full;
  assign io_deq_valid = full;
  assign io_deq_bits = ram_data_0;
  assign io_count = full;
endmodule
```

The firtool 1.32.0 output is much nicer but is not semantically equivalent since it is adding an extra cycle of latency from `io_enq_bits` to `io_deq_bits`.

It can also be nice to look at this change as a diff:
```diff
diff --git a/test.1.31.0.v b/test.1.32.0.v
index 4569e6e48..3aa05a4a9 100644
--- a/test.1.31.0.v
+++ b/test.1.32.0.v
@@ -1,29 +1,4 @@
-// Generated by CIRCT firtool-1.31.0
-module ram_combMem(
-  input  R0_addr,
-         R0_en,
-         R0_clk,
-         W0_addr,
-         W0_en,
-         W0_clk,
-         W0_data,
-  output R0_data
-);
-
-  reg Memory[0:0];
-  reg _GEN;
-  reg _GEN_0;
-  always @(posedge R0_clk) begin
-    _GEN <= R0_en;
-    _GEN_0 <= R0_addr;
-  end // always @(posedge)
-  always @(posedge W0_clk) begin
-    if (W0_en)
-      Memory[W0_addr] <= W0_data;
-  end // always @(posedge)
-  assign R0_data = _GEN ? Memory[_GEN_0] : 1'bx;
-endmodule
-
+// Generated by CIRCT firtool-1.32.0
 module Queue(
   input  clock,
          reset,
@@ -36,8 +11,13 @@ module Queue(
          io_count
 );
 
+  reg ram;
+  reg ram_data_0;
   reg full;
   always @(posedge clock) begin
+    if (~full & io_enq_valid)
+      ram <= io_enq_bits;
+    ram_data_0 <= ram;
     if (reset)
       full <= 1'h0;
     else if (full)
@@ -45,18 +25,9 @@ module Queue(
     else
       full <= io_enq_valid;
   end // always @(posedge)
-  ram_combMem ram_ext (
-    .R0_addr (1'h0),
-    .R0_en   (1'h1),
-    .R0_clk  (clock),
-    .W0_addr (1'h0),
-    .W0_en   (~full & io_enq_valid),
-    .W0_clk  (clock),
-    .W0_data (io_enq_bits),
-    .R0_data (io_deq_bits)
-  );
   assign io_enq_ready = ~full;
   assign io_deq_valid = full;
+  assign io_deq_bits = ram_data_0;
   assign io_count = full;
 endmodule
 ```","circuit Queue :
  module Queue :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}

    smem ram : UInt<1> [1] new
    reg full : UInt<1>, clock with :
      reset => (reset, UInt<1>(""h0""))
    io.count <= full
    io.enq.ready <= not(full)
    io.deq.valid <= full

    node do_enq = and(io.enq.ready, io.enq.valid)
    node do_deq = and(io.deq.ready, io.deq.valid)

    when full :
      full <= not(io.deq.ready)
    else :
      full <= io.enq.valid

    when do_enq :
      infer mport MPORT = ram[UInt<1>(""h0"")], clock
      MPORT <= io.enq.bits

    read mport io_deq_bits_MPORT = ram[UInt<1>(""h0"")], clock
    io.deq.bits <= io_deq_bits_MPORT","// Generated by CIRCT firtool-1.31.0
module ram_combMem(
  input  R0_addr,
         R0_en,
         R0_clk,
         W0_addr,
         W0_en,
         W0_clk,
         W0_data,
  output R0_data
);

  reg Memory[0:0];
  reg _GEN;
  reg _GEN_0;
  always @(posedge R0_clk) begin
    _GEN <= R0_en;
    _GEN_0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _GEN ? Memory[_GEN_0] : 1'bx;
endmodule

module Queue(
  input  clock,
         reset,
         io_enq_valid,
         io_enq_bits,
         io_deq_ready,
  output io_enq_ready,
         io_deq_valid,
         io_deq_bits,
         io_count
);

  reg full;
  always @(posedge clock) begin
    if (reset)
      full <= 1'h0;
    else if (full)
      full <= ~io_deq_ready;
    else
      full <= io_enq_valid;
  end // always @(posedge)
  ram_combMem ram_ext (
    .R0_addr (1'h0),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .W0_addr (1'h0),
    .W0_en   (~full & io_enq_valid),
    .W0_clk  (clock),
    .W0_data (io_enq_bits),
    .R0_data (io_deq_bits)
  );
  assign io_enq_ready = ~full;
  assign io_deq_valid = full;
  assign io_count = full;
endmodule","// Generated by CIRCT firtool-1.32.0
module Queue(
  input  clock,
         reset,
         io_enq_valid,
         io_enq_bits,
         io_deq_ready,
  output io_enq_ready,
         io_deq_valid,
         io_deq_bits,
         io_count
);

  reg ram;
  reg ram_data_0;
  reg full;
  always @(posedge clock) begin
    if (~full & io_enq_valid)
      ram <= io_enq_bits;
    ram_data_0 <= ram;
    if (reset)
      full <= 1'h0;
    else if (full)
      full <= ~io_deq_ready;
    else
      full <= io_enq_valid;
  end // always @(posedge)
  assign io_enq_ready = ~full;
  assign io_deq_valid = full;
  assign io_deq_bits = ram_data_0;
  assign io_count = full;
endmodule","diff --git a/test.1.31.0.v b/test.1.32.0.v
index 4569e6e48..3aa05a4a9 100644
--- a/test.1.31.0.v
+++ b/test.1.32.0.v
@@ -1,29 +1,4 @@
-// Generated by CIRCT firtool-1.31.0
-module ram_combMem(
-  input  R0_addr,
-         R0_en,
-         R0_clk,
-         W0_addr,
-         W0_en,
-         W0_clk,
-         W0_data,
-  output R0_data
-);
-
-  reg Memory[0:0];
-  reg _GEN;
-  reg _GEN_0;
-  always @(posedge R0_clk) begin
-    _GEN <= R0_en;
-    _GEN_0 <= R0_addr;
-  end // always @(posedge)
-  always @(posedge W0_clk) begin
-    if (W0_en)
-      Memory[W0_addr] <= W0_data;
-  end // always @(posedge)
-  assign R0_data = _GEN ? Memory[_GEN_0] : 1'bx;
-endmodule
-
+// Generated by CIRCT firtool-1.32.0
 module Queue(
   input  clock,
          reset,
@@ -36,8 +11,13 @@ module Queue(
          io_count
 );
 
+  reg ram;
+  reg ram_data_0;
   reg full;
   always @(posedge clock) begin
+    if (~full & io_enq_valid)
+      ram <= io_enq_bits;
+    ram_data_0 <= ram;
     if (reset)
       full <= 1'h0;
     else if (full)
@@ -45,18 +25,9 @@ module Queue(
     else
       full <= io_enq_valid;
   end // always @(posedge)
-  ram_combMem ram_ext (
-    .R0_addr (1'h0),
-    .R0_en   (1'h1),
-    .R0_clk  (clock),
-    .W0_addr (1'h0),
-    .W0_en   (~full & io_enq_valid),
-    .W0_clk  (clock),
-    .W0_data (io_enq_bits),
-    .R0_data (io_deq_bits)
-  );
   assign io_enq_ready = ~full;
   assign io_deq_valid = full;
+  assign io_deq_bits = ram_data_0;
   assign io_count = full;
 endmodule",,,,,,
4680,Fix Combinational Component Builder,2023-02-19T21:59:03Z,closed,"bug, Calyx",This llvm bump [commit](https://github.com/llvm/circt/commit/88c5572224dcc4a631c22a197f2d2714bad33a30#diff-bbfc48ed5eafd91f51b04a279d09004575d95b14c830dbff851af86fc2169c94) broke building CombComponentOps using the `buildComponentLike` function. This PR fixes the issue by deciding to call a different `getFunctionTypeAttrName` function based on whether we are building a comb or regular component.,,,,,,,,,,
4634,"[firtool] Stripping debug info causes ""block argument locations should match signature""",2023-02-07T01:08:23Z,closed,"bug, FIRRTL","Consider this dummy input:
```mlir
// loc-issue.mlir
hw.module @Foo(%a: i1) -> () {}
```

Running this through `firtool --strip-debug-info loc-issue.mlir` produces the error:
```
<unknown>:0: error: 'hw.module' op block argument locations should match signature locations
<unknown>:0: note: see current operation:
""hw.module""() ({
^bb0(%arg0: i1):
  ""hw.output""() : () -> ()
}) {
  argLocs = [loc(""loc-issue.mlir"":1:16)],
  argNames = [""a""],
  comment = """",
  function_type = (i1) -> (),
  parameters = [],
  resultLocs = [],
  resultNames = [],
  sym_name = ""Foo""
} : () -> ()
```
(Stripping removes all the locations, but leaves the `argLocs` and `resultLocs` attributes unmodified.)

Running this through `firtool loc-issue.mlir` works and produces the expected:
```verilog
// Generated by CIRCT unknown git version
module Foo(	// loc-issue.mlir:1:1
  input a	// loc-issue.mlir:1:16
);

endmodule
```","// loc-issue.mlir
hw.module @Foo(%a: i1) -> () {}","<unknown>:0: error: 'hw.module' op block argument locations should match signature locations
<unknown>:0: note: see current operation:
""hw.module""() ({
^bb0(%arg0: i1):
  ""hw.output""() : () -> ()
}) {
  argLocs = [loc(""loc-issue.mlir"":1:16)],
  argNames = [""a""],
  comment = """",
  function_type = (i1) -> (),
  parameters = [],
  resultLocs = [],
  resultNames = [],
  sym_name = ""Foo""
} : () -> ()","// Generated by CIRCT unknown git version
module Foo(	// loc-issue.mlir:1:1
  input a	// loc-issue.mlir:1:16
);

endmodule",,,,,,,
4631,[firtool] Strip Debug Info Crashing,2023-02-06T17:21:07Z,closed,bug,"FIRRTL source locators which do not match the debug info stripping predicate (""ends with .fir"") seem to cause a crash.

Consider:

```
circuit Foo:
  module Foo:
    input a: UInt<1> @[Foo.scala 1:1]
    output b: UInt<1> @[Foo.scala 2:1]

    b <= a
```

Running with `firtool -strip-debug-info Foo.fir` produces:

```
<unknown>:0: error: 'hw.module' op block argument locations should match signature locations
<unknown>:0: note: see current operation: 
""hw.module""() ({
^bb0(%arg0: i1):
  ""hw.output""(%arg0) : (i1) -> ()
}) {argLocs = [loc(""Foo.scala"":1:1)], argNames = [""a""], arg_attrs = [{}], comment = """", function_type = (i1) -> i1, parameters = [], res_attrs = [{}], resultLocs = [loc(""Foo.scala"":2:1)], resultNames = [""b""], sym_name = ""Foo""} : () -> ()
```

The generic MLIR before the pass is:

```mlir
#loc = loc(""Foo.scala"":1:1)
#loc1 = loc(""Foo.scala"":2:1)
""builtin.module""() ({
  ""hw.module""() ({
  ^bb0(%arg0: i1):
    ""hw.output""(%arg0) : (i1) -> ()
  }) {argLocs = [#loc], argNames = [""a""], arg_attrs = [{}], comment = """", function_type = (i1) -> i1, parameters = [], res_attrs = [{}], resultLocs = [#loc1], resultNames = [""b""], sym_name = ""Foo""} : () -> ()
}) : () -> ()
```","circuit Foo:
  module Foo:
    input a: UInt<1> @[Foo.scala 1:1]
    output b: UInt<1> @[Foo.scala 2:1]

    b <= a","<unknown>:0: error: 'hw.module' op block argument locations should match signature locations
<unknown>:0: note: see current operation: 
""hw.module""() ({
^bb0(%arg0: i1):
  ""hw.output""(%arg0) : (i1) -> ()
}) {argLocs = [loc(""Foo.scala"":1:1)], argNames = [""a""], arg_attrs = [{}], comment = """", function_type = (i1) -> i1, parameters = [], res_attrs = [{}], resultLocs = [loc(""Foo.scala"":2:1)], resultNames = [""b""], sym_name = ""Foo""} : () -> ()","#loc = loc(""Foo.scala"":1:1)
#loc1 = loc(""Foo.scala"":2:1)
""builtin.module""() ({
  ""hw.module""() ({
  ^bb0(%arg0: i1):
    ""hw.output""(%arg0) : (i1) -> ()
  }) {argLocs = [#loc], argNames = [""a""], arg_attrs = [{}], comment = """", function_type = (i1) -> i1, parameters = [], res_attrs = [{}], resultLocs = [#loc1], resultNames = [""b""], sym_name = ""Foo""} : () -> ()
}) : () -> ()",,,,,,,
4620,"[FIRRTL] ""exprInEventControl"" not working for big designs",2023-02-03T23:04:24Z,closed,"bug, ExportVerilog","Hi, while we was trying to compile CY designs using CIRCT & push it through tools (Genus), we found bugs in CIRCT that prevents us from doing this : async resets are being emitted in a way that synthesis tools like Genus do not like.
Specifically, we get something of the form:
```
 wire reset = ~_some_reset;
 always @(posedge clock or posedge reset)
 	if (~_some_reset)
 		...
```
even though we are using the `exprInEventControl` flag (related to ucb-bar/chipyard#1324)

Do you have any ideas on how we can fix this issue?

Here are the input files & commands to reproduce the issue.
- Link to FIRRTL file
(https://drive.google.com/file/d/1PVcPzgWd6xWPN7_rEkfovpgSWH6E6LBS/view?usp=share_link).

- Compile command
```
firtool \
   --lowering-options=emittedLineLength=2048,noAlwaysComb,exprInEventControl,disallowPackedArrays,disallowLocalVariables,explicitBitcast,verifLabels,locationInfoStyle=wrapInAtSquareBracket \
  chipyard.TestHarness.TinyRocketConfig.sfc.fir
```

- Problematic code is (120th line below the ChipTop module)
```
  wire        debug_reset_syncd = ~_debug_reset_syncd_debug_reset_sync_io_q;	// @[Periphery.scala:288:40, ShiftReg.scala:45:23]
  always @(posedge _system_auto_subsystem_cbus_fixedClockNode_out_clock or posedge debug_reset_syncd) begin	// @[ChipTop.scala:28:35, Periphery.scala:288:40]
    if (~_debug_reset_syncd_debug_reset_sync_io_q)	// @[ChipTop.scala:28:35, Periphery.scala:288:40, ShiftReg.scala:45:23]
      clock_en <= 1'h1;	// @[Periphery.scala:296:29]
    else	// @[ChipTop.scala:28:35]
      clock_en <= _dmactiveAck_dmactiveAck_io_q;	// @[Periphery.scala:296:29, ShiftReg.scala:45:23]
  end // always @(posedge, posedge)
```","wire reset = ~_some_reset;
 always @(posedge clock or posedge reset)
 	if (~_some_reset)
 		...","firtool \
   --lowering-options=emittedLineLength=2048,noAlwaysComb,exprInEventControl,disallowPackedArrays,disallowLocalVariables,explicitBitcast,verifLabels,locationInfoStyle=wrapInAtSquareBracket \
  chipyard.TestHarness.TinyRocketConfig.sfc.fir","wire        debug_reset_syncd = ~_debug_reset_syncd_debug_reset_sync_io_q;	// @[Periphery.scala:288:40, ShiftReg.scala:45:23]
  always @(posedge _system_auto_subsystem_cbus_fixedClockNode_out_clock or posedge debug_reset_syncd) begin	// @[ChipTop.scala:28:35, Periphery.scala:288:40]
    if (~_debug_reset_syncd_debug_reset_sync_io_q)	// @[ChipTop.scala:28:35, Periphery.scala:288:40, ShiftReg.scala:45:23]
      clock_en <= 1'h1;	// @[Periphery.scala:296:29]
    else	// @[ChipTop.scala:28:35]
      clock_en <= _dmactiveAck_dmactiveAck_io_q;	// @[Periphery.scala:296:29, ShiftReg.scala:45:23]
  end // always @(posedge, posedge)",,,,,,,
4586,[FIRRTL] PrefixModules Not Duplicating Modules When Necessary,2023-01-25T01:29:48Z,open,"bug, FIRRTL","I hit a situation where `PrefixModules` should be duplicating modules, but it is not.

Consider the following:

```
circuit Top : %[[
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""target"":""~Top|Foo"",
    ""prefix"":""A_"",
    ""inclusive"":true
  },
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""target"":""~Top|Foo_1"",
    ""prefix"":""B_"",
    ""inclusive"":true
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|Foo>in""
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|Foo_1>in""
  }
]]
  module Foo :
    input in : UInt<8>

  module Foo_1 :
    input in : UInt<8>

  module Top :
    input in : UInt<8>

    inst f1 of Foo
    inst f2 of Foo_1
    f1.in <= in
    f2.in <= in
```

If I run this with `firtool -dedup`, I get the following Verilog:

```verilog
module A_Foo(
  input [7:0] in);

endmodule

module Top(
  input [7:0] in);

  A_Foo f1 (
    .in (in)
  );
  A_Foo f2 (
    .in (in)
  );
endmodule
```

If I run without dedup, I get two modules (expectedly):

```verilog
module A_Foo(
  input [7:0] in);

endmodule

module B_Foo_1(
  input [7:0] in);

endmodule

module Top(
  input [7:0] in);

  A_Foo f1 (
    .in (in)
  );
  B_Foo_1 f2 (
    .in (in)
  );
endmodule
```

Basically, I'm expecting to see both an `A_` and `B_` prefix in the output and I only get an `A_` prefix.","circuit Top : %[[
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""target"":""~Top|Foo"",
    ""prefix"":""A_"",
    ""inclusive"":true
  },
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""target"":""~Top|Foo_1"",
    ""prefix"":""B_"",
    ""inclusive"":true
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|Foo>in""
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|Foo_1>in""
  }
]]
  module Foo :
    input in : UInt<8>

  module Foo_1 :
    input in : UInt<8>

  module Top :
    input in : UInt<8>

    inst f1 of Foo
    inst f2 of Foo_1
    f1.in <= in
    f2.in <= in","module A_Foo(
  input [7:0] in);

endmodule

module Top(
  input [7:0] in);

  A_Foo f1 (
    .in (in)
  );
  A_Foo f2 (
    .in (in)
  );
endmodule","module A_Foo(
  input [7:0] in);

endmodule

module B_Foo_1(
  input [7:0] in);

endmodule

module Top(
  input [7:0] in);

  A_Foo f1 (
    .in (in)
  );
  B_Foo_1 f2 (
    .in (in)
  );
endmodule",,,,,,,
4584,[FIRRTL] Raw Param Difference vs. SFC,2023-01-24T22:34:55Z,closed,"bug, FIRRTL","Currently, CIRCT will squash ""raw"" FIRRTL external module parameters into string parameters. This produces a difference with the SFC. Consider:

```
circuit Foo:
  extmodule Bar:
    output a: UInt<1>
    parameter foo = 'hello'
    parameter bar = ""world""

  module Foo:
    output a: UInt<1>

    inst bar of Bar
    a <= bar.a
```

This compiles with CIRCT to:

```verilog
module Foo(
  output a);

  Bar #(
    .foo(""hello""),
    .bar(""world"")
  ) bar (
    .a (a)
  );
endmodule
```

With SFC, this produces:

```verilog
module Foo(
  output  a
);
  wire  bar_a;
  Bar #(.foo(hello), .bar(""world"")) bar (
    .a(bar_a)
  );
  assign a = bar_a;
endmodule
```","circuit Foo:
  extmodule Bar:
    output a: UInt<1>
    parameter foo = 'hello'
    parameter bar = ""world""

  module Foo:
    output a: UInt<1>

    inst bar of Bar
    a <= bar.a","module Foo(
  output a);

  Bar #(
    .foo(""hello""),
    .bar(""world"")
  ) bar (
    .a (a)
  );
endmodule","module Foo(
  output  a
);
  wire  bar_a;
  Bar #(.foo(hello), .bar(""world"")) bar (
    .a(bar_a)
  );
  assign a = bar_a;
endmodule",,,,,,,
4564,"[FIRRTL] Parsing broken for ""an instance called module""",2023-01-20T23:43:10Z,closed,"bug, FIRRTL","FIRRTL parsing is broken for the following circuit:

```
circuit Foo:
  module Bar:
    skip

  module Foo:

    inst module of Bar
```

The parser thinks that `module` has to be the first token when it can be an identifier:

```
build/Bar.fir:7:10: error: 'module' must be first token on its line
    inst module of Bar
         ^
```

h/t @chick for finding this one.","circuit Foo:
  module Bar:
    skip

  module Foo:

    inst module of Bar","build/Bar.fir:7:10: error: 'module' must be first token on its line
    inst module of Bar
         ^",,,,,,,,
4554,[FIRRTL] Mark DUT AddSeqMemPorts ports dontTouch,2023-01-18T21:27:32Z,closed,"bug, FIRRTL","Change the AddSeqMemPorts pass to mark ports created on the DUT (or the
top module) with DontTouchAnnotations.  This is done to avoid having
these ports be deleted.  This is currently a problem for output ports
that the pass creates and bores upwards.  The final instance port of the
DUT does not have a user which causes all the ports (except the one on
the memory) to be deletion candidates.

Signed-off-by: Schuyler Eldridge <schuyler.eldridge@sifive.com>

### Example

An end-to-end example showing the problem is the following circuit:

```firrtl
circuit TestHarness : %[[
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""TestHarness.DUTModule""
  },
  {
    ""class"":""sifive.enterprise.firrtl.AddSeqMemPortsFileAnnotation"",
    ""filename"":""SeqMems.txt""
  },
  {
    ""class"":""sifive.enterprise.firrtl.AddSeqMemPortAnnotation"",
    ""name"":""foo"",
    ""input"":false,
    ""width"":16
  },
  {
    ""class"":""sifive.enterprise.firrtl.AddSeqMemPortAnnotation"",
    ""name"":""bar"",
    ""input"":true,
    ""width"":32
  }
]]
  module DUTModule :
    input clock : Clock
    input reset : Reset
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    smem mem : UInt<8> [8]
    infer mport read = mem[io.addr], clock
    io.dataOut <= read
    when io.wen :
      infer mport write = mem[io.addr], clock
      write <= io.dataIn

  module TestHarness :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    inst dut of DUTModule
    dut.clock <= clock
    dut.reset <= reset
    io.dataOut <= dut.io.dataOut
    dut.io.wen <= io.wen
    dut.io.dataIn <= io.dataIn
    dut.io.addr <= io.addr
```

Without this PR, this compiles to:

```verilog
// Generated by CIRCT unknown git version
module DUTModule(
  input         clock,
  input  [2:0]  io_addr,
  input  [7:0]  io_dataIn,
  input         io_wen,
  input  [31:0] sram_0_bar,
  output [7:0]  io_dataOut);

  mem mem (
    .R0_addr    (io_addr),
    .R0_clk     (clock),
    .W0_addr    (io_addr),
    .W0_en      (io_wen),
    .W0_clk     (clock),
    .W0_data    (io_dataIn),
    .sram_0_bar (sram_0_bar),
    .R0_data    (io_dataOut)
  );
endmodule

module TestHarness(
  input        clock,
               reset,
  input  [2:0] io_addr,
  input  [7:0] io_dataIn,
  input        io_wen,
  output [7:0] io_dataOut);

  DUTModule dut (
    .clock      (clock),
    .io_addr    (io_addr),
    .io_dataIn  (io_dataIn),
    .io_wen     (io_wen),
    .sram_0_bar (32'h0),
    .io_dataOut (io_dataOut)
  );
endmodule

module mem(
  input  [2:0]  R0_addr,
  input         R0_clk,
  input  [2:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [7:0]  W0_data,
  input  [31:0] sram_0_bar,
  output [7:0]  R0_data);

  wire [15:0] _mem_ext_foo;
  mem_ext mem_ext (
    .R0_addr (R0_addr),
    .R0_en   (1'h1),
    .R0_clk  (R0_clk),
    .W0_addr (W0_addr),
    .W0_en   (W0_en),
    .W0_clk  (W0_clk),
    .W0_data (W0_data),
    .bar     (sram_0_bar),
    .R0_data (R0_data),
    .foo     (_mem_ext_foo)
  );
endmodule

// external module mem_ext
```

With this PR, this compiles to:
```verilog
// Generated by CIRCT unknown git version
module DUTModule(
  input         clock,
  input  [2:0]  io_addr,
  input  [7:0]  io_dataIn,
  input         io_wen,
  input  [31:0] sram_0_bar,
  output [7:0]  io_dataOut,
  output [15:0] sram_0_foo);

  mem mem (
    .R0_addr    (io_addr),
    .R0_clk     (clock),
    .W0_addr    (io_addr),
    .W0_en      (io_wen),
    .W0_clk     (clock),
    .W0_data    (io_dataIn),
    .sram_0_bar (sram_0_bar),
    .R0_data    (io_dataOut),
    .sram_0_foo (sram_0_foo)
  );
endmodule

module TestHarness(
  input        clock,
               reset,
  input  [2:0] io_addr,
  input  [7:0] io_dataIn,
  input        io_wen,
  output [7:0] io_dataOut);

  wire [15:0] _dut_sram_0_foo;
  DUTModule dut (
    .clock      (clock),
    .io_addr    (io_addr),
    .io_dataIn  (io_dataIn),
    .io_wen     (io_wen),
    .sram_0_bar (32'h0),
    .io_dataOut (io_dataOut),
    .sram_0_foo (_dut_sram_0_foo)
  );
endmodule

module mem(
  input  [2:0]  R0_addr,
  input         R0_clk,
  input  [2:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [7:0]  W0_data,
  input  [31:0] sram_0_bar,
  output [7:0]  R0_data,
  output [15:0] sram_0_foo);

  mem_ext mem_ext (
    .R0_addr (R0_addr),
    .R0_en   (1'h1),
    .R0_clk  (R0_clk),
    .W0_addr (W0_addr),
    .W0_en   (W0_en),
    .W0_clk  (W0_clk),
    .W0_data (W0_data),
    .bar     (sram_0_bar),
    .R0_data (R0_data),
    .foo     (sram_0_foo)
  );
endmodule

// external module mem_ext
```

Diff:

```diff
diff --git a/Foo.old.sv b/Foo.new.sv
index aab54df64..beb951ea0 100644
--- a/Foo.old.sv
+++ b/Foo.new.sv
@@ -5,7 +5,8 @@ module DUTModule(
   input  [7:0]  io_dataIn,
   input         io_wen,
   input  [31:0] sram_0_bar,
-  output [7:0]  io_dataOut);
+  output [7:0]  io_dataOut,
+  output [15:0] sram_0_foo);
 
   mem mem (
     .R0_addr    (io_addr),
@@ -15,7 +16,8 @@ module DUTModule(
     .W0_clk     (clock),
     .W0_data    (io_dataIn),
     .sram_0_bar (sram_0_bar),
-    .R0_data    (io_dataOut)
+    .R0_data    (io_dataOut),
+    .sram_0_foo (sram_0_foo)
   );
 endmodule
 
@@ -27,13 +29,15 @@ module TestHarness(
   input        io_wen,
   output [7:0] io_dataOut);
 
+  wire [15:0] _dut_sram_0_foo;
   DUTModule dut (
     .clock      (clock),
     .io_addr    (io_addr),
     .io_dataIn  (io_dataIn),
     .io_wen     (io_wen),
     .sram_0_bar (32'h0),
-    .io_dataOut (io_dataOut)
+    .io_dataOut (io_dataOut),
+    .sram_0_foo (_dut_sram_0_foo)
   );
 endmodule
 
@@ -45,9 +49,9 @@ module mem(
                 W0_clk,
   input  [7:0]  W0_data,
   input  [31:0] sram_0_bar,
-  output [7:0]  R0_data);
+  output [7:0]  R0_data,
+  output [15:0] sram_0_foo);
 
-  wire [15:0] _mem_ext_foo;
   mem_ext mem_ext (
     .R0_addr (R0_addr),
     .R0_en   (1'h1),
@@ -58,7 +62,7 @@ module mem(
     .W0_data (W0_data),
     .bar     (sram_0_bar),
     .R0_data (R0_data),
-    .foo     (_mem_ext_foo)
+    .foo     (sram_0_foo)
   );
 endmodule
```","circuit TestHarness : %[[
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""TestHarness.DUTModule""
  },
  {
    ""class"":""sifive.enterprise.firrtl.AddSeqMemPortsFileAnnotation"",
    ""filename"":""SeqMems.txt""
  },
  {
    ""class"":""sifive.enterprise.firrtl.AddSeqMemPortAnnotation"",
    ""name"":""foo"",
    ""input"":false,
    ""width"":16
  },
  {
    ""class"":""sifive.enterprise.firrtl.AddSeqMemPortAnnotation"",
    ""name"":""bar"",
    ""input"":true,
    ""width"":32
  }
]]
  module DUTModule :
    input clock : Clock
    input reset : Reset
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    smem mem : UInt<8> [8]
    infer mport read = mem[io.addr], clock
    io.dataOut <= read
    when io.wen :
      infer mport write = mem[io.addr], clock
      write <= io.dataIn

  module TestHarness :
    input clock : Clock
    input reset : UInt<1>
    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}

    inst dut of DUTModule
    dut.clock <= clock
    dut.reset <= reset
    io.dataOut <= dut.io.dataOut
    dut.io.wen <= io.wen
    dut.io.dataIn <= io.dataIn
    dut.io.addr <= io.addr","// Generated by CIRCT unknown git version
module DUTModule(
  input         clock,
  input  [2:0]  io_addr,
  input  [7:0]  io_dataIn,
  input         io_wen,
  input  [31:0] sram_0_bar,
  output [7:0]  io_dataOut);

  mem mem (
    .R0_addr    (io_addr),
    .R0_clk     (clock),
    .W0_addr    (io_addr),
    .W0_en      (io_wen),
    .W0_clk     (clock),
    .W0_data    (io_dataIn),
    .sram_0_bar (sram_0_bar),
    .R0_data    (io_dataOut)
  );
endmodule

module TestHarness(
  input        clock,
               reset,
  input  [2:0] io_addr,
  input  [7:0] io_dataIn,
  input        io_wen,
  output [7:0] io_dataOut);

  DUTModule dut (
    .clock      (clock),
    .io_addr    (io_addr),
    .io_dataIn  (io_dataIn),
    .io_wen     (io_wen),
    .sram_0_bar (32'h0),
    .io_dataOut (io_dataOut)
  );
endmodule

module mem(
  input  [2:0]  R0_addr,
  input         R0_clk,
  input  [2:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [7:0]  W0_data,
  input  [31:0] sram_0_bar,
  output [7:0]  R0_data);

  wire [15:0] _mem_ext_foo;
  mem_ext mem_ext (
    .R0_addr (R0_addr),
    .R0_en   (1'h1),
    .R0_clk  (R0_clk),
    .W0_addr (W0_addr),
    .W0_en   (W0_en),
    .W0_clk  (W0_clk),
    .W0_data (W0_data),
    .bar     (sram_0_bar),
    .R0_data (R0_data),
    .foo     (_mem_ext_foo)
  );
endmodule

// external module mem_ext","// Generated by CIRCT unknown git version
module DUTModule(
  input         clock,
  input  [2:0]  io_addr,
  input  [7:0]  io_dataIn,
  input         io_wen,
  input  [31:0] sram_0_bar,
  output [7:0]  io_dataOut,
  output [15:0] sram_0_foo);

  mem mem (
    .R0_addr    (io_addr),
    .R0_clk     (clock),
    .W0_addr    (io_addr),
    .W0_en      (io_wen),
    .W0_clk     (clock),
    .W0_data    (io_dataIn),
    .sram_0_bar (sram_0_bar),
    .R0_data    (io_dataOut),
    .sram_0_foo (sram_0_foo)
  );
endmodule

module TestHarness(
  input        clock,
               reset,
  input  [2:0] io_addr,
  input  [7:0] io_dataIn,
  input        io_wen,
  output [7:0] io_dataOut);

  wire [15:0] _dut_sram_0_foo;
  DUTModule dut (
    .clock      (clock),
    .io_addr    (io_addr),
    .io_dataIn  (io_dataIn),
    .io_wen     (io_wen),
    .sram_0_bar (32'h0),
    .io_dataOut (io_dataOut),
    .sram_0_foo (_dut_sram_0_foo)
  );
endmodule

module mem(
  input  [2:0]  R0_addr,
  input         R0_clk,
  input  [2:0]  W0_addr,
  input         W0_en,
                W0_clk,
  input  [7:0]  W0_data,
  input  [31:0] sram_0_bar,
  output [7:0]  R0_data,
  output [15:0] sram_0_foo);

  mem_ext mem_ext (
    .R0_addr (R0_addr),
    .R0_en   (1'h1),
    .R0_clk  (R0_clk),
    .W0_addr (W0_addr),
    .W0_en   (W0_en),
    .W0_clk  (W0_clk),
    .W0_data (W0_data),
    .bar     (sram_0_bar),
    .R0_data (R0_data),
    .foo     (sram_0_foo)
  );
endmodule

// external module mem_ext","diff --git a/Foo.old.sv b/Foo.new.sv
index aab54df64..beb951ea0 100644
--- a/Foo.old.sv
+++ b/Foo.new.sv
@@ -5,7 +5,8 @@ module DUTModule(
   input  [7:0]  io_dataIn,
   input         io_wen,
   input  [31:0] sram_0_bar,
-  output [7:0]  io_dataOut);
+  output [7:0]  io_dataOut,
+  output [15:0] sram_0_foo);
 
   mem mem (
     .R0_addr    (io_addr),
@@ -15,7 +16,8 @@ module DUTModule(
     .W0_clk     (clock),
     .W0_data    (io_dataIn),
     .sram_0_bar (sram_0_bar),
-    .R0_data    (io_dataOut)
+    .R0_data    (io_dataOut),
+    .sram_0_foo (sram_0_foo)
   );
 endmodule
 
@@ -27,13 +29,15 @@ module TestHarness(
   input        io_wen,
   output [7:0] io_dataOut);
 
+  wire [15:0] _dut_sram_0_foo;
   DUTModule dut (
     .clock      (clock),
     .io_addr    (io_addr),
     .io_dataIn  (io_dataIn),
     .io_wen     (io_wen),
     .sram_0_bar (32'h0),
-    .io_dataOut (io_dataOut)
+    .io_dataOut (io_dataOut),
+    .sram_0_foo (_dut_sram_0_foo)
   );
 endmodule
 
@@ -45,9 +49,9 @@ module mem(
                 W0_clk,
   input  [7:0]  W0_data,
   input  [31:0] sram_0_bar,
-  output [7:0]  R0_data);
+  output [7:0]  R0_data,
+  output [15:0] sram_0_foo);
 
-  wire [15:0] _mem_ext_foo;
   mem_ext mem_ext (
     .R0_addr (R0_addr),
     .R0_en   (1'h1),
@@ -58,7 +62,7 @@ module mem(
     .W0_data (W0_data),
     .bar     (sram_0_bar),
     .R0_data (R0_data),
-    .foo     (_mem_ext_foo)
+    .foo     (sram_0_foo)
   );
 endmodule",,,,,,
4485,[ExportVerilog] Assertion Firing for icmp -> sampled,2022-12-24T01:34:15Z,closed,"bug, ExportVerilog","I stumbled across the following assertion failure due to prepare for emission not generating a wire for an `icmp` operation.

Consider:

```mlir
module {
  hw.module @Top() {
    %c0_i4 = hw.constant 0 : i4
    %v = sv.reg  {sv.namehint = ""value""} : !hw.inout<i4>
    %0 = sv.read_inout %v : !hw.inout<i4>
    %1 = comb.icmp eq %0, %c0_i4 {sv.namehint = ""foo""} : i4
    %2 = sv.system.sampled %1 : i1
    hw.output
  }
}
```

Compiling this with `circt-opt Tmp.mlir -export-verilog` produces a nice crash:

```
# circt-opt Tmp.mlir -export-verilog
Assertion failed: ((!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options)) && ""If 'op' is a verilog expression, the expression must be inlinable. "" ""Otherwise, it is a bug of PrepareForEmission""), function collectNames, file ExportVerilog.cpp, line 2895.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  circt-opt                0x0000000102eb930d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  circt-opt                0x0000000102eb988b PrintStackTraceSignalHandler(void*) + 27
2  circt-opt                0x0000000102eb7696 llvm::sys::RunSignalHandlers() + 134
3  circt-opt                0x0000000102ebb5bf SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff81f38fdfd _sigtramp + 29
5  circt-opt                0x0000000104f1b3cd std::__1::__optional_storage_base<mlir::RegisteredOperationName, false>::__optional_storage_base<mlir::RegisteredOperationName>(std::__1::in_place_t, mlir::RegisteredOperationName&&) + 29
6  libsystem_c.dylib        0x00007ff81f2c5d24 abort + 123
7  libsystem_c.dylib        0x00007ff81f2c50cb err + 0
8  circt-opt                0x0000000103213bb3 (anonymous namespace)::NameCollector::collectNames(mlir::Block&) + 947
9  circt-opt                0x0000000103213576 (anonymous namespace)::StmtEmitter::collectNamesAndCalculateDeclarationWidths(mlir::Block&) + 54
10 circt-opt                0x0000000103213483 (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31::operator()() const + 115
11 circt-opt                0x0000000103213405 decltype(static_cast<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>(fp)()) std::__1::__invoke<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>((anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31&&) + 21
12 circt-opt                0x000000010321332d std::__1::invoke_result<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>::type std::__1::invoke<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>((anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31&&) + 29
13 circt-opt                0x00000001032132b6 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>(circt::pretty::PP&&, (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31&&, circt::pretty::Token) + 102
14 circt-opt                0x0000000103203cc4 (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&) + 116
15 circt-opt                0x00000001032027b1 (anonymous namespace)::ModuleEmitter::emitHWModule(circt::hw::HWModuleOp) + 2897
16 circt-opt                0x0000000103201c14 auto emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*)::$_101::operator()<circt::hw::HWModuleOp>(circt::hw::HWModuleOp) const + 68
17 circt-opt                0x000000010320186b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::hw::HWModuleOp, emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*)::$_101>(emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*)::$_101&&) + 107
18 circt-opt                0x00000001031fa415 emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*) + 53
19 circt-opt                0x0000000103277586 circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46::operator()(circt::ExportVerilog::StringOrOpToEmit&) const + 278
20 circt-opt                0x0000000103277380 auto void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)::operator()<circt::ExportVerilog::StringOrOpToEmit&>(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&) const + 48
21 circt-opt                0x0000000103279259 mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()::operator()() const + 169
22 circt-opt                0x00000001032791a5 decltype(static_cast<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>>(fp)()) std::__1::__invoke<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()&>(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&) + 21
23 circt-opt                0x000000010327915d void std::__1::__invoke_void_return_wrapper<void, true>::__call<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()&>(mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()&) + 29
24 circt-opt                0x000000010327912d std::__1::__function::__alloc_func<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()>, void ()>::operator()() + 29
25 circt-opt                0x0000000103278179 std::__1::__function::__func<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()>, void ()>::operator()() + 25
26 circt-opt                0x0000000104fea852 std::__1::__function::__value_func<void ()>::operator()() const + 50
27 circt-opt                0x0000000104fea815 std::__1::function<void ()>::operator()() const + 21
28 circt-opt                0x0000000104fea7dd llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()::operator()() const + 29
29 circt-opt                0x0000000104fea7a5 decltype(static_cast<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(fp)()) std::__1::__invoke<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 21
30 circt-opt                0x0000000104fea75d void std::__1::__invoke_void_return_wrapper<void, true>::__call<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 29
31 circt-opt                0x0000000104fea72d std::__1::__function::__alloc_func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 29
32 circt-opt                0x0000000104fe9519 std::__1::__function::__func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 25
33 circt-opt                0x0000000104fea852 std::__1::__function::__value_func<void ()>::operator()() const + 50
34 circt-opt                0x0000000104fea815 std::__1::function<void ()>::operator()() const + 21
35 circt-opt                0x0000000102e0cc92 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) + 546
36 circt-opt                0x0000000102e10373 llvm::ThreadPool::grow(int)::$_0::operator()() const + 51
37 circt-opt                0x0000000102e10305 void llvm::thread::Apply<llvm::ThreadPool::grow(int)::$_0>(std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::__1::integer_sequence<unsigned long>) + 37
38 circt-opt                0x0000000102e102c3 void llvm::thread::GenericThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 51
39 circt-opt                0x0000000102e0fff5 void* llvm::thread::ThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 21
40 libsystem_pthread.dylib  0x00007ff81f37a4e1 _pthread_start + 125
41 libsystem_pthread.dylib  0x00007ff81f375f6b thread_start + 15
```","module {
  hw.module @Top() {
    %c0_i4 = hw.constant 0 : i4
    %v = sv.reg  {sv.namehint = ""value""} : !hw.inout<i4>
    %0 = sv.read_inout %v : !hw.inout<i4>
    %1 = comb.icmp eq %0, %c0_i4 {sv.namehint = ""foo""} : i4
    %2 = sv.system.sampled %1 : i1
    hw.output
  }
}","# circt-opt Tmp.mlir -export-verilog
Assertion failed: ((!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options)) && ""If 'op' is a verilog expression, the expression must be inlinable. "" ""Otherwise, it is a bug of PrepareForEmission""), function collectNames, file ExportVerilog.cpp, line 2895.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  circt-opt                0x0000000102eb930d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  circt-opt                0x0000000102eb988b PrintStackTraceSignalHandler(void*) + 27
2  circt-opt                0x0000000102eb7696 llvm::sys::RunSignalHandlers() + 134
3  circt-opt                0x0000000102ebb5bf SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff81f38fdfd _sigtramp + 29
5  circt-opt                0x0000000104f1b3cd std::__1::__optional_storage_base<mlir::RegisteredOperationName, false>::__optional_storage_base<mlir::RegisteredOperationName>(std::__1::in_place_t, mlir::RegisteredOperationName&&) + 29
6  libsystem_c.dylib        0x00007ff81f2c5d24 abort + 123
7  libsystem_c.dylib        0x00007ff81f2c50cb err + 0
8  circt-opt                0x0000000103213bb3 (anonymous namespace)::NameCollector::collectNames(mlir::Block&) + 947
9  circt-opt                0x0000000103213576 (anonymous namespace)::StmtEmitter::collectNamesAndCalculateDeclarationWidths(mlir::Block&) + 54
10 circt-opt                0x0000000103213483 (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31::operator()() const + 115
11 circt-opt                0x0000000103213405 decltype(static_cast<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>(fp)()) std::__1::__invoke<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>((anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31&&) + 21
12 circt-opt                0x000000010321332d std::__1::invoke_result<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>::type std::__1::invoke<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>((anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31&&) + 29
13 circt-opt                0x00000001032132b6 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>(circt::pretty::PP&&, (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31&&, circt::pretty::Token) + 102
14 circt-opt                0x0000000103203cc4 (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&) + 116
15 circt-opt                0x00000001032027b1 (anonymous namespace)::ModuleEmitter::emitHWModule(circt::hw::HWModuleOp) + 2897
16 circt-opt                0x0000000103201c14 auto emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*)::$_101::operator()<circt::hw::HWModuleOp>(circt::hw::HWModuleOp) const + 68
17 circt-opt                0x000000010320186b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::hw::HWModuleOp, emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*)::$_101>(emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*)::$_101&&) + 107
18 circt-opt                0x00000001031fa415 emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*) + 53
19 circt-opt                0x0000000103277586 circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46::operator()(circt::ExportVerilog::StringOrOpToEmit&) const + 278
20 circt-opt                0x0000000103277380 auto void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)::operator()<circt::ExportVerilog::StringOrOpToEmit&>(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&) const + 48
21 circt-opt                0x0000000103279259 mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()::operator()() const + 169
22 circt-opt                0x00000001032791a5 decltype(static_cast<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>>(fp)()) std::__1::__invoke<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()&>(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&) + 21
23 circt-opt                0x000000010327915d void std::__1::__invoke_void_return_wrapper<void, true>::__call<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()&>(mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()&) + 29
24 circt-opt                0x000000010327912d std::__1::__function::__alloc_func<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()>, void ()>::operator()() + 29
25 circt-opt                0x0000000103278179 std::__1::__function::__func<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()>, void ()>::operator()() + 25
26 circt-opt                0x0000000104fea852 std::__1::__function::__value_func<void ()>::operator()() const + 50
27 circt-opt                0x0000000104fea815 std::__1::function<void ()>::operator()() const + 21
28 circt-opt                0x0000000104fea7dd llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()::operator()() const + 29
29 circt-opt                0x0000000104fea7a5 decltype(static_cast<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(fp)()) std::__1::__invoke<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 21
30 circt-opt                0x0000000104fea75d void std::__1::__invoke_void_return_wrapper<void, true>::__call<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 29
31 circt-opt                0x0000000104fea72d std::__1::__function::__alloc_func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 29
32 circt-opt                0x0000000104fe9519 std::__1::__function::__func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 25
33 circt-opt                0x0000000104fea852 std::__1::__function::__value_func<void ()>::operator()() const + 50
34 circt-opt                0x0000000104fea815 std::__1::function<void ()>::operator()() const + 21
35 circt-opt                0x0000000102e0cc92 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) + 546
36 circt-opt                0x0000000102e10373 llvm::ThreadPool::grow(int)::$_0::operator()() const + 51
37 circt-opt                0x0000000102e10305 void llvm::thread::Apply<llvm::ThreadPool::grow(int)::$_0>(std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::__1::integer_sequence<unsigned long>) + 37
38 circt-opt                0x0000000102e102c3 void llvm::thread::GenericThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 51
39 circt-opt                0x0000000102e0fff5 void* llvm::thread::ThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 21
40 libsystem_pthread.dylib  0x00007ff81f37a4e1 _pthread_start + 125
41 libsystem_pthread.dylib  0x00007ff81f375f6b thread_start + 15",,,,,,,,
4456,"Signedness-related failures on ""test2.fir"", ""test3.fir"" during IMCP",2022-12-16T01:22:52Z,closed,"bug, FIRRTL","Looks like we're failing/asserting out with signedness-related errors in IMCP on both [test2.fir](https://github.com/circt/perf/blob/trunk/regress/test2.fir) and [test3.fir](https://github.com/circt/perf/blob/trunk/regress/test3.fir) from the perf regression tests, starting 2022-11-24:

https://github.com/circt/perf/blob/gh-pages/test2-2022-11-24.log
https://github.com/circt/perf/blob/gh-pages/test3-2022-11-24.log

Reproduced both on latest master.

Since test2.fir crashes instead of a diagnostic, here's a more complete backtrace:
<details>
<summary>test2 backtrace</summary>

```
firtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APSInt.h:129: llvm::APSInt llvm::APSInt::operator%(const llvm::APSInt &) const: Assertion `IsUnsigned == RHS.IsUnsigned && ""Signedness mismatch!""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ../build/bin/firtool /home/will/src/sifive/perf/regress/test2.fir -o /dev/null
 #0 0x00000000006593e6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:567:13
 #1 0x0000000000657895 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x000000000065977f SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007f65a2a3dbf0 __restore_rt (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x3dbf0)
 #4 0x00007f65a2a8abc7 __pthread_kill_implementation (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x8abc7)
 #5 0x00007f65a2a3db46 gsignal (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x3db46)
 #6 0x00007f65a2a284b5 abort (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x284b5)
 #7 0x00007f65a2a283d9 _nl_load_domain.cold.0 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x283d9)
 #8 0x00007f65a2a367b6 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x367b6)
 #9 0x0000000000a590b9 llvm::APInt llvm::function_ref<llvm::APInt (llvm::APSInt, llvm::APSInt)>::callback_fn<circt::firrtl::RemPrimOp::fold(llvm::ArrayRef<mlir::Attribute>)::$_4>(long, llvm::APSInt, llvm::APSInt) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:0:0
#10 0x0000000000a4b385 llvm::APInt::isSingleWord() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APInt.h:305:47
#11 0x0000000000a4b385 llvm::APInt::needsCleanup() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APInt.h:1837:39
#12 0x0000000000a4b385 llvm::APInt::~APInt() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APInt.h:168:9
#13 0x0000000000a4b385 llvm::function_ref<llvm::APInt (llvm::APSInt, llvm::APSInt)>::operator()(llvm::APSInt, llvm::APSInt) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:5
#14 0x0000000000a4b385 constFoldFIRRTLBinaryOp(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, BinOpKind, llvm::function_ref<llvm::APInt (llvm::APSInt, llvm::APSInt)> const&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:249:23
#15 0x0000000000a4bc91 circt::firrtl::RemPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:0:10
#16 0x0000000000a40a58 llvm::PointerUnion<mlir::Attribute, mlir::Value>::isNull() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:142:33
#17 0x0000000000a40a58 llvm::PointerUnion<mlir::Attribute, mlir::Value>::operator bool() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:144:44
#18 0x0000000000a40a58 mlir::LogicalResult mlir::Op<circt::firrtl::RemPrimOp, mlir::OpTrait::ZeroRegions, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::IntType>::Impl, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::NOperands<2u>::Impl, mlir::OpTrait::OpInvariants, circt::firrtl::SameOperandsIntTypeKind, mlir::OpAsmOpInterface::Trait, mlir::InferTypeOpInterface::Trait, mlir::ConditionallySpeculatable::Trait, mlir::OpTrait::AlwaysSpeculatableImplTrait, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::RemPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1779:10
#19 0x00000000009affe3 llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>::operator()(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:409:12
#20 0x00000000009affe3 mlir::RegisteredOperationName::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:334:12
#21 0x00000000009affe3 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:495:31
#22 0x00000000007b192b (anonymous namespace)::IMConstPropPass::visitOperation(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:0:0
#23 0x00000000007b192b (anonymous namespace)::IMConstPropPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:346:9
#24 0x0000000000dd7900 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11
#25 0x0000000000dd7f57 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#26 0x0000000000dd7f57 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#27 0x0000000000dd7f57 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:9
#28 0x0000000000dd960d std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/8xmmwmb6r6hc6f3cdh64mbi138p96vpg-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1046:25
#29 0x0000000000dd960d mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:754:5
#30 0x0000000000dd960d mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18
#31 0x0000000000dd960d mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#32 0x0000000000dd960d mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:14
#33 0x0000000000dd793e mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5
#34 0x0000000000dd793e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:463:14
#35 0x0000000000dda3a1 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#36 0x0000000000dda3a1 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#37 0x0000000000dda3a1 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:9
#38 0x0000000000dda3a1 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:834:10
#39 0x0000000000dda3a1 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:814:60
#40 0x000000000059f627 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#41 0x000000000059f627 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#42 0x000000000059f627 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:841:7
#43 0x000000000059d5f8 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:935:12
#44 0x000000000059d1d1 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:951:12
#45 0x000000000059d1d1 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1035:14
#46 0x000000000059cdc1 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#47 0x000000000059cdc1 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#48 0x000000000059cdc1 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1099:8
#49 0x00007f65a2a2924e __libc_start_call_main (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x2924e)
#50 0x00007f65a2a29309 __libc_start_main@GLIBC_2.2.5 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x29309)
#51 0x000000000059cbf5 _start (../build/bin/firtool+0x59cbf5)
```
</details>

And for test3.fir sometimes there are multiple errors, for example:

```
/home/will/src/sifive/perf/regress/test3.fir:166372:5: error: firrtl.constant attribute has wrong sign
    wire _tmp3120: UInt<15>
    ^

/home/will/src/sifive/perf/regress/test3.fir:166372:5: note: see current operation: %8 = ""firrtl.constant""() {value = -12133 : si15} : () -> !firrtl.uint<15>
/home/will/src/sifive/perf/regress/test3.fir:864443:16: error: firrtl.constant attribute has wrong sign
    tmp4132 <= cat(asSInt(UInt<28>(""o1046442110"")), inp_c.inp_hd.inp_oi)
               ^
```

Something wonky re:folds happening around then, maybe?","firtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APSInt.h:129: llvm::APSInt llvm::APSInt::operator%(const llvm::APSInt &) const: Assertion `IsUnsigned == RHS.IsUnsigned && ""Signedness mismatch!""' failed.
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump:
0.	Program arguments: ../build/bin/firtool /home/will/src/sifive/perf/regress/test2.fir -o /dev/null
 #0 0x00000000006593e6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:567:13
 #1 0x0000000000657895 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18
 #2 0x000000000065977f SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007f65a2a3dbf0 __restore_rt (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x3dbf0)
 #4 0x00007f65a2a8abc7 __pthread_kill_implementation (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x8abc7)
 #5 0x00007f65a2a3db46 gsignal (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x3db46)
 #6 0x00007f65a2a284b5 abort (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x284b5)
 #7 0x00007f65a2a283d9 _nl_load_domain.cold.0 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x283d9)
 #8 0x00007f65a2a367b6 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x367b6)
 #9 0x0000000000a590b9 llvm::APInt llvm::function_ref<llvm::APInt (llvm::APSInt, llvm::APSInt)>::callback_fn<circt::firrtl::RemPrimOp::fold(llvm::ArrayRef<mlir::Attribute>)::$_4>(long, llvm::APSInt, llvm::APSInt) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:0:0
#10 0x0000000000a4b385 llvm::APInt::isSingleWord() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APInt.h:305:47
#11 0x0000000000a4b385 llvm::APInt::needsCleanup() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APInt.h:1837:39
#12 0x0000000000a4b385 llvm::APInt::~APInt() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APInt.h:168:9
#13 0x0000000000a4b385 llvm::function_ref<llvm::APInt (llvm::APSInt, llvm::APSInt)>::operator()(llvm::APSInt, llvm::APSInt) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:5
#14 0x0000000000a4b385 constFoldFIRRTLBinaryOp(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, BinOpKind, llvm::function_ref<llvm::APInt (llvm::APSInt, llvm::APSInt)> const&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:249:23
#15 0x0000000000a4bc91 circt::firrtl::RemPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:0:10
#16 0x0000000000a40a58 llvm::PointerUnion<mlir::Attribute, mlir::Value>::isNull() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:142:33
#17 0x0000000000a40a58 llvm::PointerUnion<mlir::Attribute, mlir::Value>::operator bool() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:144:44
#18 0x0000000000a40a58 mlir::LogicalResult mlir::Op<circt::firrtl::RemPrimOp, mlir::OpTrait::ZeroRegions, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::IntType>::Impl, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::NOperands<2u>::Impl, mlir::OpTrait::OpInvariants, circt::firrtl::SameOperandsIntTypeKind, mlir::OpAsmOpInterface::Trait, mlir::InferTypeOpInterface::Trait, mlir::ConditionallySpeculatable::Trait, mlir::OpTrait::AlwaysSpeculatableImplTrait, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::RemPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1779:10
#19 0x00000000009affe3 llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>::operator()(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:409:12
#20 0x00000000009affe3 mlir::RegisteredOperationName::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:334:12
#21 0x00000000009affe3 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:495:31
#22 0x00000000007b192b (anonymous namespace)::IMConstPropPass::visitOperation(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:0:0
#23 0x00000000007b192b (anonymous namespace)::IMConstPropPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:346:9
#24 0x0000000000dd7900 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11
#25 0x0000000000dd7f57 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#26 0x0000000000dd7f57 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#27 0x0000000000dd7f57 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:9
#28 0x0000000000dd960d std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/8xmmwmb6r6hc6f3cdh64mbi138p96vpg-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1046:25
#29 0x0000000000dd960d mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:754:5
#30 0x0000000000dd960d mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18
#31 0x0000000000dd960d mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#32 0x0000000000dd960d mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:14
#33 0x0000000000dd793e mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5
#34 0x0000000000dd793e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:463:14
#35 0x0000000000dda3a1 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#36 0x0000000000dda3a1 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#37 0x0000000000dda3a1 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:9
#38 0x0000000000dda3a1 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:834:10
#39 0x0000000000dda3a1 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:814:60
#40 0x000000000059f627 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#41 0x000000000059f627 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#42 0x000000000059f627 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:841:7
#43 0x000000000059d5f8 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:935:12
#44 0x000000000059d1d1 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:951:12
#45 0x000000000059d1d1 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1035:14
#46 0x000000000059cdc1 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#47 0x000000000059cdc1 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#48 0x000000000059cdc1 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1099:8
#49 0x00007f65a2a2924e __libc_start_call_main (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x2924e)
#50 0x00007f65a2a29309 __libc_start_main@GLIBC_2.2.5 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x29309)
#51 0x000000000059cbf5 _start (../build/bin/firtool+0x59cbf5)","/home/will/src/sifive/perf/regress/test3.fir:166372:5: error: firrtl.constant attribute has wrong sign
    wire _tmp3120: UInt<15>
    ^

/home/will/src/sifive/perf/regress/test3.fir:166372:5: note: see current operation: %8 = ""firrtl.constant""() {value = -12133 : si15} : () -> !firrtl.uint<15>
/home/will/src/sifive/perf/regress/test3.fir:864443:16: error: firrtl.constant attribute has wrong sign
    tmp4132 <= cat(asSInt(UInt<28>(""o1046442110"")), inp_c.inp_hd.inp_oi)
               ^",,,,,,,,
4448,[FIRRTL] WireDFT Needs Hardening,2022-12-14T16:38:05Z,closed,"bug, FIRRTL","The `WireDFT` pass makes some assumptions about the structure of modules with the `EICG_wrapper` name. Specifically, I think it assumes that any module that starts with `EICG_wrapper` has a second port that is supposed to be hooked up. I _don't_ think this validates the name, type, or directionality.

Consider:

```
circuit Top: %[[
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""~Top|Top""
  },
  {
    ""class"":""sifive.enterprise.firrtl.DFTTestModeEnableAnnotation"",
    ""target"":""~Top|Top>test_en""
    },
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top>test_en""
  }
]]
  extmodule EICG_wrapper_Bar:
    output a: UInt<1>
    output b: UInt<1>

  module Foo:
    inst bar of EICG_wrapper_Bar

  module Top:
    wire test_en: UInt<1>
    test_en is invalid

    inst foo of Foo
```

Running this with `firtool Foo.fir` produces:

```
# firtool Tmp.fir -mlir-print-ir-after=firrtl-dft                       
Tmp.fir:19:10: error: connect has invalid flow: the destination expression ""bar.b"" has source flow, expected sink or duplex flow
  module Foo:
         ^
Tmp.fir:20:5: note: the destination was defined here
    inst bar of EICG_wrapper_Bar
    ^
```

The output MLIR is:

```mlir
""firrtl.circuit""() ({
  ""firrtl.extmodule""() ({
  }) {annotations = [], internalPaths = [], parameters = [], portAnnotations = [], portDirections = -1 : i2, portNames = [""a"", ""b""], portSyms = [], portTypes = [!firrtl.uint<1>, !firrtl.uint<1>], sym_name = ""EICG_wrapper_Bar"", sym_visibility = ""private""} : () -> ()
  ""firrtl.module""() ({
  ^bb0(%arg0: !firrtl.uint<1>):
    %0:2 = ""firrtl.instance""() {annotations = [], moduleName = @EICG_wrapper_Bar, name = ""bar"", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [[], []], portDirections = -1 : i2, portNames = [""a"", ""b""]} : () -> (!firrtl.uint<1>, !firrtl.uint<1>)
    ""firrtl.connect""(%0#1, %arg0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  }) {annotations = [], portAnnotations = [], portDirections = false, portNames = [""test_en""], portSyms = [], portTypes = [!firrtl.uint<1>], sym_name = ""Foo"", sym_visibility = ""private""} : () -> ()
  ""firrtl.module""() ({
    %0 = ""firrtl.wire""() {annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}], name = ""test_en"", nameKind = #firrtl<name_kind droppable_name>} : () -> !firrtl.uint<1>
    %1 = ""firrtl.invalidvalue""() : () -> !firrtl.uint<1>
    ""firrtl.strictconnect""(%0, %1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
    %2 = ""firrtl.instance""() {annotations = [], moduleName = @Foo, name = ""foo"", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [[]], portDirections = false, portNames = [""test_en""]} : () -> !firrtl.uint<1>
    ""firrtl.connect""(%2, %0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  }) {annotations = [{class = ""sifive.enterprise.firrtl.MarkDUTAnnotation""}], portAnnotations = [], portDirections = 0 : i0, portNames = [], portSyms = [], portTypes = [], sym_name = ""Top""} : () -> ()
}) {annotations = [], name = ""Top""} : () -> ()
```","circuit Top: %[[
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""~Top|Top""
  },
  {
    ""class"":""sifive.enterprise.firrtl.DFTTestModeEnableAnnotation"",
    ""target"":""~Top|Top>test_en""
    },
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top>test_en""
  }
]]
  extmodule EICG_wrapper_Bar:
    output a: UInt<1>
    output b: UInt<1>

  module Foo:
    inst bar of EICG_wrapper_Bar

  module Top:
    wire test_en: UInt<1>
    test_en is invalid

    inst foo of Foo","# firtool Tmp.fir -mlir-print-ir-after=firrtl-dft                       
Tmp.fir:19:10: error: connect has invalid flow: the destination expression ""bar.b"" has source flow, expected sink or duplex flow
  module Foo:
         ^
Tmp.fir:20:5: note: the destination was defined here
    inst bar of EICG_wrapper_Bar
    ^","""firrtl.circuit""() ({
  ""firrtl.extmodule""() ({
  }) {annotations = [], internalPaths = [], parameters = [], portAnnotations = [], portDirections = -1 : i2, portNames = [""a"", ""b""], portSyms = [], portTypes = [!firrtl.uint<1>, !firrtl.uint<1>], sym_name = ""EICG_wrapper_Bar"", sym_visibility = ""private""} : () -> ()
  ""firrtl.module""() ({
  ^bb0(%arg0: !firrtl.uint<1>):
    %0:2 = ""firrtl.instance""() {annotations = [], moduleName = @EICG_wrapper_Bar, name = ""bar"", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [[], []], portDirections = -1 : i2, portNames = [""a"", ""b""]} : () -> (!firrtl.uint<1>, !firrtl.uint<1>)
    ""firrtl.connect""(%0#1, %arg0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  }) {annotations = [], portAnnotations = [], portDirections = false, portNames = [""test_en""], portSyms = [], portTypes = [!firrtl.uint<1>], sym_name = ""Foo"", sym_visibility = ""private""} : () -> ()
  ""firrtl.module""() ({
    %0 = ""firrtl.wire""() {annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}], name = ""test_en"", nameKind = #firrtl<name_kind droppable_name>} : () -> !firrtl.uint<1>
    %1 = ""firrtl.invalidvalue""() : () -> !firrtl.uint<1>
    ""firrtl.strictconnect""(%0, %1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
    %2 = ""firrtl.instance""() {annotations = [], moduleName = @Foo, name = ""foo"", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [[]], portDirections = false, portNames = [""test_en""]} : () -> !firrtl.uint<1>
    ""firrtl.connect""(%2, %0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  }) {annotations = [{class = ""sifive.enterprise.firrtl.MarkDUTAnnotation""}], portAnnotations = [], portDirections = 0 : i0, portNames = [], portSyms = [], portTypes = [], sym_name = ""Top""} : () -> ()
}) {annotations = [], name = ""Top""} : () -> ()",,,,,,,
4447,[FIRRTL] Verifier Crash from Invalid WireDFT Circuit,2022-12-14T16:34:42Z,closed,"bug, FIRRTL","I was able to get the verifier to crash with a circuit that is unanticipated by the `WireDFT` pass. Consider:

```
circuit Top: %[[
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""~Top|Top""
  },
  {
    ""class"":""sifive.enterprise.firrtl.DFTTestModeEnableAnnotation"",
    ""target"":""~Top|Top>test_en""
    },
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top>test_en""
  }
]]
  extmodule EICG_wrapper_Bar:

  module Foo:
    inst bar of EICG_wrapper_Bar

  module Top:
    wire test_en: UInt<1>
    test_en is invalid

    inst foo of Foo
```

This produces with `firtool Foo.fir`:

```
# firtool Tmp.fir
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x000000010fdc97fd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x000000010fdc9d7b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x000000010fdc7b66 llvm::sys::RunSignalHandlers() + 134
3  firtool                  0x000000010fdcb9bf SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff81f38fdfd _sigtramp + 29
5  libsystem_platform.dylib 0x00007ff5df040000 _sigtramp + 18446744064042402336
6  firtool                  0x000000011057e328 mlir::Type::getDialect() const + 24
7  firtool                  0x0000000110b2df35 circt::firrtl::FIRRTLBaseType::classof(mlir::Type) + 21
8  firtool                  0x0000000110b2df0d llvm::CastInfo<circt::firrtl::FIRRTLBaseType, mlir::Type const, void>::isPossible(mlir::Type) + 29
9  firtool                  0x0000000110b2dee0 bool llvm::isa<circt::firrtl::FIRRTLBaseType, mlir::Type>(mlir::Type const&) + 32
10 firtool                  0x0000000110b2db75 bool mlir::Type::isa<circt::firrtl::FIRRTLBaseType>() const + 21
11 firtool                  0x0000000110a9abc8 circt::firrtl::__mlir_ods_local_type_constraint_FIRRTL12(mlir::Operation*, mlir::Type, llvm::StringRef, unsigned int) + 72
12 firtool                  0x0000000110a9a9e6 circt::firrtl::ConnectOp::verifyInvariantsImpl() + 214
13 firtool                  0x0000000110939ab2 mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>::verifyTrait(mlir::Operation*) + 34
14 firtool                  0x0000000110939985 std::__1::enable_if<detect_has_verify_trait<mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>>::value, mlir::LogicalResult>::type mlir::op_definition_impl::verifyTrait<mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>>(mlir::Operation*) + 21
15 firtool                  0x000000011093983d mlir::LogicalResult mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<circt::firrtl::ConnectOp>, mlir::OpTrait::ZeroResults<circt::firrtl::ConnectOp>, mlir::OpTrait::ZeroSuccessors<circt::firrtl::ConnectOp>, mlir::OpTrait::NOperands<2u>::Impl<circt::firrtl::ConnectOp>, mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>, circt::firrtl::FConnectLike::Trait<circt::firrtl::ConnectOp>>(mlir::Operation*) + 189
16 firtool                  0x0000000110939725 mlir::Op<circt::firrtl::ConnectOp, mlir::OpTrait::ZeroRegions, mlir::OpTrait::ZeroResults, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::NOperands<2u>::Impl, mlir::OpTrait::OpInvariants, circt::firrtl::FConnectLike::Trait>::verifyInvariants(mlir::Operation*) + 21
17 firtool                  0x0000000110db1e28 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*>::CallImpl<mlir::LogicalResult (* const)(mlir::Operation*)>(void*, mlir::Operation*) + 56
18 firtool                  0x0000000110864757 llvm::unique_function<mlir::LogicalResult (mlir::Operation*) const>::operator()(mlir::Operation*) const + 55
19 firtool                  0x0000000110863457 mlir::RegisteredOperationName::verifyInvariants(mlir::Operation*) const + 39
20 firtool                  0x00000001108629de (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) + 734
21 firtool                  0x000000011086386e (anonymous namespace)::OperationVerifier::verifyBlock(mlir::Block&, llvm::SmallVectorImpl<mlir::Operation*>&) + 878
22 firtool                  0x0000000110862d13 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) + 1555
23 firtool                  0x0000000110862611 (anonymous namespace)::OperationVerifier::verifyOpAndDominance(mlir::Operation&) + 33
24 firtool                  0x0000000110865430 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0::operator()(mlir::Operation*) const + 32
25 firtool                  0x000000011086ae44 mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()::operator()() const + 148
26 firtool                  0x000000011086ada5 decltype(static_cast<mlir::Operation**>(fp)()) std::__1::__invoke<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()&>(mlir::Operation**&&) + 21
27 firtool                  0x000000011086ad5d void std::__1::__invoke_void_return_wrapper<void, true>::__call<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()&>(mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()&) + 29
28 firtool                  0x000000011086ad2d std::__1::__function::__alloc_func<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()>, void ()>::operator()() + 29
29 firtool                  0x0000000110869d79 std::__1::__function::__func<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()>, void ()>::operator()() + 25
30 firtool                  0x00000001111a4052 std::__1::__function::__value_func<void ()>::operator()() const + 50
31 firtool                  0x00000001111a4015 std::__1::function<void ()>::operator()() const + 21
32 firtool                  0x00000001111a3fdd llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()::operator()() const + 29
33 firtool                  0x00000001111a3fa5 decltype(static_cast<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(fp)()) std::__1::__invoke<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 21
34 firtool                  0x00000001111a3f5d void std::__1::__invoke_void_return_wrapper<void, true>::__call<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 29
35 firtool                  0x00000001111a3f2d std::__1::__function::__alloc_func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 29
36 firtool                  0x00000001111a2d19 std::__1::__function::__func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 25
37 firtool                  0x00000001111a4052 std::__1::__function::__value_func<void ()>::operator()() const + 50
38 firtool                  0x00000001111a4015 std::__1::function<void ()>::operator()() const + 21
39 firtool                  0x000000010fcffd12 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) + 546
40 firtool                  0x000000010fd033f3 llvm::ThreadPool::grow(int)::$_0::operator()() const + 51
41 firtool                  0x000000010fd03385 void llvm::thread::Apply<llvm::ThreadPool::grow(int)::$_0>(std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::__1::integer_sequence<unsigned long>) + 37
42 firtool                  0x000000010fd03343 void llvm::thread::GenericThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 51
43 firtool                  0x000000010fd03075 void* llvm::thread::ThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 21
44 libsystem_pthread.dylib  0x00007ff81f37a4e1 _pthread_start + 125
45 libsystem_pthread.dylib  0x00007ff81f375f6b thread_start + 15
```","circuit Top: %[[
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""~Top|Top""
  },
  {
    ""class"":""sifive.enterprise.firrtl.DFTTestModeEnableAnnotation"",
    ""target"":""~Top|Top>test_en""
    },
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top>test_en""
  }
]]
  extmodule EICG_wrapper_Bar:

  module Foo:
    inst bar of EICG_wrapper_Bar

  module Top:
    wire test_en: UInt<1>
    test_en is invalid

    inst foo of Foo","# firtool Tmp.fir
PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x000000010fdc97fd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x000000010fdc9d7b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x000000010fdc7b66 llvm::sys::RunSignalHandlers() + 134
3  firtool                  0x000000010fdcb9bf SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff81f38fdfd _sigtramp + 29
5  libsystem_platform.dylib 0x00007ff5df040000 _sigtramp + 18446744064042402336
6  firtool                  0x000000011057e328 mlir::Type::getDialect() const + 24
7  firtool                  0x0000000110b2df35 circt::firrtl::FIRRTLBaseType::classof(mlir::Type) + 21
8  firtool                  0x0000000110b2df0d llvm::CastInfo<circt::firrtl::FIRRTLBaseType, mlir::Type const, void>::isPossible(mlir::Type) + 29
9  firtool                  0x0000000110b2dee0 bool llvm::isa<circt::firrtl::FIRRTLBaseType, mlir::Type>(mlir::Type const&) + 32
10 firtool                  0x0000000110b2db75 bool mlir::Type::isa<circt::firrtl::FIRRTLBaseType>() const + 21
11 firtool                  0x0000000110a9abc8 circt::firrtl::__mlir_ods_local_type_constraint_FIRRTL12(mlir::Operation*, mlir::Type, llvm::StringRef, unsigned int) + 72
12 firtool                  0x0000000110a9a9e6 circt::firrtl::ConnectOp::verifyInvariantsImpl() + 214
13 firtool                  0x0000000110939ab2 mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>::verifyTrait(mlir::Operation*) + 34
14 firtool                  0x0000000110939985 std::__1::enable_if<detect_has_verify_trait<mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>>::value, mlir::LogicalResult>::type mlir::op_definition_impl::verifyTrait<mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>>(mlir::Operation*) + 21
15 firtool                  0x000000011093983d mlir::LogicalResult mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<circt::firrtl::ConnectOp>, mlir::OpTrait::ZeroResults<circt::firrtl::ConnectOp>, mlir::OpTrait::ZeroSuccessors<circt::firrtl::ConnectOp>, mlir::OpTrait::NOperands<2u>::Impl<circt::firrtl::ConnectOp>, mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>, circt::firrtl::FConnectLike::Trait<circt::firrtl::ConnectOp>>(mlir::Operation*) + 189
16 firtool                  0x0000000110939725 mlir::Op<circt::firrtl::ConnectOp, mlir::OpTrait::ZeroRegions, mlir::OpTrait::ZeroResults, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::NOperands<2u>::Impl, mlir::OpTrait::OpInvariants, circt::firrtl::FConnectLike::Trait>::verifyInvariants(mlir::Operation*) + 21
17 firtool                  0x0000000110db1e28 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*>::CallImpl<mlir::LogicalResult (* const)(mlir::Operation*)>(void*, mlir::Operation*) + 56
18 firtool                  0x0000000110864757 llvm::unique_function<mlir::LogicalResult (mlir::Operation*) const>::operator()(mlir::Operation*) const + 55
19 firtool                  0x0000000110863457 mlir::RegisteredOperationName::verifyInvariants(mlir::Operation*) const + 39
20 firtool                  0x00000001108629de (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) + 734
21 firtool                  0x000000011086386e (anonymous namespace)::OperationVerifier::verifyBlock(mlir::Block&, llvm::SmallVectorImpl<mlir::Operation*>&) + 878
22 firtool                  0x0000000110862d13 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) + 1555
23 firtool                  0x0000000110862611 (anonymous namespace)::OperationVerifier::verifyOpAndDominance(mlir::Operation&) + 33
24 firtool                  0x0000000110865430 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0::operator()(mlir::Operation*) const + 32
25 firtool                  0x000000011086ae44 mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()::operator()() const + 148
26 firtool                  0x000000011086ada5 decltype(static_cast<mlir::Operation**>(fp)()) std::__1::__invoke<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()&>(mlir::Operation**&&) + 21
27 firtool                  0x000000011086ad5d void std::__1::__invoke_void_return_wrapper<void, true>::__call<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()&>(mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()&) + 29
28 firtool                  0x000000011086ad2d std::__1::__function::__alloc_func<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()>, void ()>::operator()() + 29
29 firtool                  0x0000000110869d79 std::__1::__function::__func<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()>, void ()>::operator()() + 25
30 firtool                  0x00000001111a4052 std::__1::__function::__value_func<void ()>::operator()() const + 50
31 firtool                  0x00000001111a4015 std::__1::function<void ()>::operator()() const + 21
32 firtool                  0x00000001111a3fdd llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()::operator()() const + 29
33 firtool                  0x00000001111a3fa5 decltype(static_cast<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(fp)()) std::__1::__invoke<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 21
34 firtool                  0x00000001111a3f5d void std::__1::__invoke_void_return_wrapper<void, true>::__call<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 29
35 firtool                  0x00000001111a3f2d std::__1::__function::__alloc_func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 29
36 firtool                  0x00000001111a2d19 std::__1::__function::__func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 25
37 firtool                  0x00000001111a4052 std::__1::__function::__value_func<void ()>::operator()() const + 50
38 firtool                  0x00000001111a4015 std::__1::function<void ()>::operator()() const + 21
39 firtool                  0x000000010fcffd12 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) + 546
40 firtool                  0x000000010fd033f3 llvm::ThreadPool::grow(int)::$_0::operator()() const + 51
41 firtool                  0x000000010fd03385 void llvm::thread::Apply<llvm::ThreadPool::grow(int)::$_0>(std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::__1::integer_sequence<unsigned long>) + 37
42 firtool                  0x000000010fd03343 void llvm::thread::GenericThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 51
43 firtool                  0x000000010fd03075 void* llvm::thread::ThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 21
44 libsystem_pthread.dylib  0x00007ff81f37a4e1 _pthread_start + 125
45 libsystem_pthread.dylib  0x00007ff81f375f6b thread_start + 15",,,,,,,,
4378,[Calyx][ASAN] heap-use-after-free in lit tests,2022-11-30T15:43:01Z,closed,"bug, Calyx","Five lit tests, mostly SFCToCalyx, newly fail with heap-use-after-free.  cc #4353.

All error reports: https://gist.github.com/dtzSiFive/4561baec40ea6926de513c460cc6d19f .

First one is included below:
<details>
<summary>convert_pipeline.mlir</summary>

```
FAIL: CIRCT :: Conversion/PipelineToCalyx/convert_pipeline.mlir (490 of 494)
******************** TEST 'CIRCT :: Conversion/PipelineToCalyx/convert_pipeline.mlir' FAILED ********************
Script:
--
: 'RUN: at line 1';   /build/sifive/asan/bin/circt-opt /home/will/src/sifive/circt/test/Conversion/PipelineToCalyx/convert_pipeline.mlir -lower-static-logic-to-calyx -split-input-file | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Conversion/PipelineToCalyx/convert_pipeline.mlir
--
Exit Code: 2

Command Output (stderr):
--
=================================================================
==1442208==ERROR: AddressSanitizer: heap-use-after-free on address 0x6080000019c4 at pc 0x000002379ef0 bp 0x7fff22ee1f90 sp 0x7fff22ee1f88
READ of size 4 at 0x6080000019c4 thread T0
    #0 0x2379eef in mlir::Operation::getResults() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:333:12
    #1 0x2379eef in mlir::Operation::use_empty() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:629:29
    #2 0x5beb22a in mlir::isOpTriviallyDead(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Interfaces/SideEffectInterfaces.cpp:35:14
    #3 0x5865c88 in (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:211:11
    #4 0x5865c88 in mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:417:27
    #5 0x39389f7 in mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:71:10
    #6 0x39389f7 in circt::pipelinetocalyx::PipelineToCalyxPass::runPartialPattern(mlir::RewritePatternSet&, bool) /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1488:11
    #7 0x39250b9 in circt::pipelinetocalyx::PipelineToCalyxPass::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1602:39
    #8 0x5b4f689 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:465:11
    #9 0x5b508d5 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:16
    #10 0x5b555a9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:834:10
    #11 0x5b552ef in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:814:60
    #12 0x46557b2 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17
    #13 0x4654f21 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12
    #14 0x4654f21 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12
    #15 0x4654f21 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #16 0x46aaf96 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #17 0x46aace2 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16
    #18 0x46aa3b3 in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2045:3
    #19 0x46aa3b3 in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2067:3
    #20 0x46aa3b3 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3
    #21 0x465299f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10
    #22 0x4652cac in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:209:10
    #23 0x465365e in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:306:14
    #24 0x1f24651 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:70:23
    #25 0x7feae7e2924d in __libc_start_call_main (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 1433936b3a4bd2e8bc1129b0563f1c826138656f)
    #26 0x7feae7e29308 in __libc_start_main@GLIBC_2.2.5 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x29308) (BuildId: 1433936b3a4bd2e8bc1129b0563f1c826138656f)
    #27 0x1e2d424 in _start (/build/sifive/asan/bin/circt-opt+0x1e2d424)

0x6080000019c4 is located 36 bytes inside of 88-byte region [0x6080000019a0,0x6080000019f8)
freed by thread T0 here:
LLVMSymbolizer: error reading file: No such file or directory
    #0 0x1edca47 in __interceptor_free.part.0 (/build/sifive/asan/bin/circt-opt+0x1edca47)
    #1 0x3f1e1e0 in mlir::Operation::destroy() /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:171:3
    #2 0x3f315dc in llvm::ilist_traits<mlir::Operation>::deleteNode(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:371:7
    #3 0x3f315dc in llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation>>::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:269:5
    #4 0x3f315dc in llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation>>::erase(mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:273:39
    #5 0x3f1fdf2 in mlir::Operation::erase() /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:420:29
    #6 0x3f50de9 in mlir::RewriterBase::eraseOp(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:278:7
    #7 0x5868a72 in (anonymous namespace)::GreedyPatternRewriteDriver::eraseOp(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:379:20
    #8 0x397494f in circt::pipelinetocalyx::CleanupFuncOps::partiallyLowerFuncToComp(mlir::func::FuncOp, mlir::PatternRewriter&) const /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1356:14
    #9 0x3752c69 in circt::calyx::FuncOpPartialLoweringPattern::partiallyLower(mlir::func::FuncOp, mlir::PatternRewriter&) const /home/will/src/sifive/circt/lib/Dialect/Calyx/Transforms/CalyxLoweringUtils.cpp:390:10
    #10 0x371fa23 in circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const::'lambda'()::operator()() const /home/will/src/sifive/circt/include/circt/Dialect/Calyx/CalyxLoweringUtils.h:486:39
    #11 0x371fa23 in void mlir::RewriterBase::updateRootInPlace<circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const::'lambda'()>(mlir::Operation*, circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const::'lambda'()&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/PatternMatch.h:501:5
    #12 0x371d24f in circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const /home/will/src/sifive/circt/include/circt/Dialect/Calyx/CalyxLoweringUtils.h:485:14
    #13 0x371cf60 in mlir::detail::OpOrInterfaceRewritePatternBase<mlir::func::FuncOp>::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/PatternMatch.h:329:12
    #14 0x58f2a50 in mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25
    #15 0x58661aa in (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:274:19
    #16 0x58661aa in mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:417:27
    #17 0x39389f7 in mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:71:10
    #18 0x39389f7 in circt::pipelinetocalyx::PipelineToCalyxPass::runPartialPattern(mlir::RewritePatternSet&, bool) /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1488:11
    #19 0x39250b9 in circt::pipelinetocalyx::PipelineToCalyxPass::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1602:39
    #20 0x5b4f689 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:465:11
    #21 0x5b508d5 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:16
    #22 0x5b555a9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:834:10
    #23 0x5b552ef in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:814:60
    #24 0x46557b2 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17
    #25 0x4654f21 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12
    #26 0x4654f21 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12
    #27 0x4654f21 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #28 0x46aaf96 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #29 0x46aace2 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16
    #30 0x46aa3b3 in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2045:3
    #31 0x46aa3b3 in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2067:3
    #32 0x46aa3b3 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3
    #33 0x465299f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10
    #34 0x4652cac in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:209:10
    #35 0x465365e in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:306:14
    #36 0x1f24651 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:70:23
    #37 0x7feae7e2924d in __libc_start_call_main (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 1433936b3a4bd2e8bc1129b0563f1c826138656f)
    #38 0x7fff22ee72ee  ([stack]+0x202ee)

```
</details>

","FAIL: CIRCT :: Conversion/PipelineToCalyx/convert_pipeline.mlir (490 of 494)
******************** TEST 'CIRCT :: Conversion/PipelineToCalyx/convert_pipeline.mlir' FAILED ********************
Script:
--
: 'RUN: at line 1';   /build/sifive/asan/bin/circt-opt /home/will/src/sifive/circt/test/Conversion/PipelineToCalyx/convert_pipeline.mlir -lower-static-logic-to-calyx -split-input-file | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Conversion/PipelineToCalyx/convert_pipeline.mlir
--
Exit Code: 2

Command Output (stderr):
--
=================================================================
==1442208==ERROR: AddressSanitizer: heap-use-after-free on address 0x6080000019c4 at pc 0x000002379ef0 bp 0x7fff22ee1f90 sp 0x7fff22ee1f88
READ of size 4 at 0x6080000019c4 thread T0
    #0 0x2379eef in mlir::Operation::getResults() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:333:12
    #1 0x2379eef in mlir::Operation::use_empty() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:629:29
    #2 0x5beb22a in mlir::isOpTriviallyDead(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Interfaces/SideEffectInterfaces.cpp:35:14
    #3 0x5865c88 in (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:211:11
    #4 0x5865c88 in mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:417:27
    #5 0x39389f7 in mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:71:10
    #6 0x39389f7 in circt::pipelinetocalyx::PipelineToCalyxPass::runPartialPattern(mlir::RewritePatternSet&, bool) /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1488:11
    #7 0x39250b9 in circt::pipelinetocalyx::PipelineToCalyxPass::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1602:39
    #8 0x5b4f689 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:465:11
    #9 0x5b508d5 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:16
    #10 0x5b555a9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:834:10
    #11 0x5b552ef in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:814:60
    #12 0x46557b2 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17
    #13 0x4654f21 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12
    #14 0x4654f21 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12
    #15 0x4654f21 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #16 0x46aaf96 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #17 0x46aace2 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16
    #18 0x46aa3b3 in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2045:3
    #19 0x46aa3b3 in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2067:3
    #20 0x46aa3b3 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3
    #21 0x465299f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10
    #22 0x4652cac in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:209:10
    #23 0x465365e in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:306:14
    #24 0x1f24651 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:70:23
    #25 0x7feae7e2924d in __libc_start_call_main (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 1433936b3a4bd2e8bc1129b0563f1c826138656f)
    #26 0x7feae7e29308 in __libc_start_main@GLIBC_2.2.5 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x29308) (BuildId: 1433936b3a4bd2e8bc1129b0563f1c826138656f)
    #27 0x1e2d424 in _start (/build/sifive/asan/bin/circt-opt+0x1e2d424)

0x6080000019c4 is located 36 bytes inside of 88-byte region [0x6080000019a0,0x6080000019f8)
freed by thread T0 here:
LLVMSymbolizer: error reading file: No such file or directory
    #0 0x1edca47 in __interceptor_free.part.0 (/build/sifive/asan/bin/circt-opt+0x1edca47)
    #1 0x3f1e1e0 in mlir::Operation::destroy() /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:171:3
    #2 0x3f315dc in llvm::ilist_traits<mlir::Operation>::deleteNode(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:371:7
    #3 0x3f315dc in llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation>>::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:269:5
    #4 0x3f315dc in llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation>>::erase(mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:273:39
    #5 0x3f1fdf2 in mlir::Operation::erase() /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:420:29
    #6 0x3f50de9 in mlir::RewriterBase::eraseOp(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:278:7
    #7 0x5868a72 in (anonymous namespace)::GreedyPatternRewriteDriver::eraseOp(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:379:20
    #8 0x397494f in circt::pipelinetocalyx::CleanupFuncOps::partiallyLowerFuncToComp(mlir::func::FuncOp, mlir::PatternRewriter&) const /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1356:14
    #9 0x3752c69 in circt::calyx::FuncOpPartialLoweringPattern::partiallyLower(mlir::func::FuncOp, mlir::PatternRewriter&) const /home/will/src/sifive/circt/lib/Dialect/Calyx/Transforms/CalyxLoweringUtils.cpp:390:10
    #10 0x371fa23 in circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const::'lambda'()::operator()() const /home/will/src/sifive/circt/include/circt/Dialect/Calyx/CalyxLoweringUtils.h:486:39
    #11 0x371fa23 in void mlir::RewriterBase::updateRootInPlace<circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const::'lambda'()>(mlir::Operation*, circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const::'lambda'()&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/PatternMatch.h:501:5
    #12 0x371d24f in circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const /home/will/src/sifive/circt/include/circt/Dialect/Calyx/CalyxLoweringUtils.h:485:14
    #13 0x371cf60 in mlir::detail::OpOrInterfaceRewritePatternBase<mlir::func::FuncOp>::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/PatternMatch.h:329:12
    #14 0x58f2a50 in mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25
    #15 0x58661aa in (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:274:19
    #16 0x58661aa in mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:417:27
    #17 0x39389f7 in mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:71:10
    #18 0x39389f7 in circt::pipelinetocalyx::PipelineToCalyxPass::runPartialPattern(mlir::RewritePatternSet&, bool) /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1488:11
    #19 0x39250b9 in circt::pipelinetocalyx::PipelineToCalyxPass::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1602:39
    #20 0x5b4f689 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:465:11
    #21 0x5b508d5 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:16
    #22 0x5b555a9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:834:10
    #23 0x5b552ef in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:814:60
    #24 0x46557b2 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17
    #25 0x4654f21 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12
    #26 0x4654f21 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12
    #27 0x4654f21 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #28 0x46aaf96 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #29 0x46aace2 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16
    #30 0x46aa3b3 in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2045:3
    #31 0x46aa3b3 in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2067:3
    #32 0x46aa3b3 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3
    #33 0x465299f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10
    #34 0x4652cac in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:209:10
    #35 0x465365e in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:306:14
    #36 0x1f24651 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:70:23
    #37 0x7feae7e2924d in __libc_start_call_main (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 1433936b3a4bd2e8bc1129b0563f1c826138656f)
    #38 0x7fff22ee72ee  ([stack]+0x202ee)",,,,,,,,,
4375,[Scheduling] ModuloSimplexScheduler fails to resolve resource conflicts,2022-11-30T03:11:56Z,closed,"bug, Scheduling","*(initially reported by @matth2k in #4374)*

The following instance triggers an assertion while re-entering the scheduled operations after the II was increased to resolve a resource conflict.

```mlir
ssp.instance of ""ModuloProblem"" {
  library {
    operator_type @unlimited [latency<1>]
    operator_type @limited [latency<1>, limit<1>]
  }
  graph {
    %0 = operation<@unlimited>()
    %1 = operation<@limited>(%0)
    %2 = operation<@limited>(%0)
    %3 = operation<@limited>(%0)
    %4 = operation<@limited>(%0)
    operation<@unlimited>(%1, %2, %3, %4)
  }
}
```

Curiously, the bug is not triggered if we had only 3 limited operations. Hence, this could be about moving ops across the next multiple of the II, but further investigation is needed.","ssp.instance of ""ModuloProblem"" {
  library {
    operator_type @unlimited [latency<1>]
    operator_type @limited [latency<1>, limit<1>]
  }
  graph {
    %0 = operation<@unlimited>()
    %1 = operation<@limited>(%0)
    %2 = operation<@limited>(%0)
    %3 = operation<@limited>(%0)
    %4 = operation<@limited>(%0)
    operation<@unlimited>(%1, %2, %3, %4)
  }
}",,,,,,,,,
4357,[FIRRTL][LowerToHW] ForceNameAnnotation Not Working on Extmodule Instances,2022-11-23T15:59:20Z,closed,"bug, good first issue, FIRRTL","A `ForceNameAnnotation` on a module instance works, but an extmodule doesn't. Consider:

```mlir
firrtl.circuit ""ForceNameTop"" {
  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]
  firrtl.hierpath private @nla_3 [@ForceNameTop::@sym_baz, @ForceNameExtmodule]
  firrtl.module private @ForceNameSubmodule() attributes {annotations = [
    {circt.nonlocal = @nla_1,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Foo""}
  ]} {}
  firrtl.extmodule private @ForceNameExtmodule() attributes {annotations = [
    {circt.nonlocal = @nla_3,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Bar""}
  ]}
  firrtl.module @ForceNameTop() {
    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()
    firrtl.instance baz sym @sym_baz @ForceNameExtmodule()
  }
}
```

After lower-to-hw:

```mlir
module {
  hw.module private @ForceNameSubmodule() {
    hw.output
  }
  hw.module.extern private @ForceNameExtmodule()
  hw.module @ForceNameTop() {
    hw.instance ""foo"" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = ""Foo""}
    hw.instance ""baz"" sym @sym_baz @ForceNameExtmodule() -> ()
    hw.output
  }
}
```

This should add a `hw.verilogName = ""Bar""` attribute to the ""baz"" instance.","firrtl.circuit ""ForceNameTop"" {
  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]
  firrtl.hierpath private @nla_3 [@ForceNameTop::@sym_baz, @ForceNameExtmodule]
  firrtl.module private @ForceNameSubmodule() attributes {annotations = [
    {circt.nonlocal = @nla_1,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Foo""}
  ]} {}
  firrtl.extmodule private @ForceNameExtmodule() attributes {annotations = [
    {circt.nonlocal = @nla_3,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Bar""}
  ]}
  firrtl.module @ForceNameTop() {
    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()
    firrtl.instance baz sym @sym_baz @ForceNameExtmodule()
  }
}","module {
  hw.module private @ForceNameSubmodule() {
    hw.output
  }
  hw.module.extern private @ForceNameExtmodule()
  hw.module @ForceNameTop() {
    hw.instance ""foo"" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = ""Foo""}
    hw.instance ""baz"" sym @sym_baz @ForceNameExtmodule() -> ()
    hw.output
  }
}",,,,,,,,
4354,[LowerToHW] An Error Should Be Generated if ForceNameAnnotation Would Not Be Unique,2022-11-23T03:08:03Z,open,"bug, good first issue, FIRRTL","Currently, two `ForceNameAnnotation`s can set an instance within the same module to the same name. The later one will eventually lose when it is uniqued by `PrepareForEmission`/`ExporVerilog`. This should instead be an error:

Consider the following which is trying to set all instances inside `ForceNameTop` to be called `Foo`:

```mlir
firrtl.circuit ""ForceNameTop"" {
  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]
  firrtl.hierpath private @nla_2 [@ForceNameTop::@sym_bar, @ForceNameSubmodule]
  firrtl.module private @ForceNameSubmodule() attributes {annotations = [
    {circt.nonlocal = @nla_1,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Foo""},
    {circt.nonlocal = @nla_2,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Foo""}
  ]} {}
  firrtl.module @ForceNameTop() {
    firrtl.instance Foo @ForceNameSubmodule()
    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()
    firrtl.instance bar sym @sym_bar @ForceNameSubmodule()
  }
}
```

After `LowerToHW` this has two instances with the same `verilogName`:

```mlir
module {
  hw.module private @ForceNameSubmodule() {
    hw.output
  }
  hw.module @ForceNameTop() {
    hw.instance ""Foo"" @ForceNameSubmodule() -> ()
    hw.instance ""foo"" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = ""Foo""}
    hw.instance ""bar"" sym @sym_bar @ForceNameSubmodule() -> () {hw.verilogName = ""Foo""}
    hw.output
  }
}
```

This is fine and will generate sane Verilog below. However, this may be surprising to a user. Verilog is:

```verilog
// Generated by CIRCT unknown git version
module ForceNameSubmodule();
endmodule

module ForceNameTop();
  ForceNameSubmodule Foo_0 ();
  ForceNameSubmodule Foo ();
  ForceNameSubmodule Foo_1 ();
endmodule
```","firrtl.circuit ""ForceNameTop"" {
  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]
  firrtl.hierpath private @nla_2 [@ForceNameTop::@sym_bar, @ForceNameSubmodule]
  firrtl.module private @ForceNameSubmodule() attributes {annotations = [
    {circt.nonlocal = @nla_1,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Foo""},
    {circt.nonlocal = @nla_2,
     class = ""chisel3.util.experimental.ForceNameAnnotation"", name = ""Foo""}
  ]} {}
  firrtl.module @ForceNameTop() {
    firrtl.instance Foo @ForceNameSubmodule()
    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()
    firrtl.instance bar sym @sym_bar @ForceNameSubmodule()
  }
}","module {
  hw.module private @ForceNameSubmodule() {
    hw.output
  }
  hw.module @ForceNameTop() {
    hw.instance ""Foo"" @ForceNameSubmodule() -> ()
    hw.instance ""foo"" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = ""Foo""}
    hw.instance ""bar"" sym @sym_bar @ForceNameSubmodule() -> () {hw.verilogName = ""Foo""}
    hw.output
  }
}","// Generated by CIRCT unknown git version
module ForceNameSubmodule();
endmodule

module ForceNameTop();
  ForceNameSubmodule Foo_0 ();
  ForceNameSubmodule Foo ();
  ForceNameSubmodule Foo_1 ();
endmodule",,,,,,,
4342,"[Scheduling][solver] Assertion failure ""result == MPSolver::OPTIMAL""",2022-11-21T16:43:17Z,closed,"bug, Scheduling","When building w/or-tools, I'm seeing a lit test failure in `cyclic-problems.mlir` that occasionally doesn't happen but usually does.

```
lib/Scheduling/LPSchedulers.cpp:141: mlir::LogicalResult circt::scheduling::scheduleLP(circt::scheduling::CyclicProblem &, mlir::Operation *): Assertion `result == MPSolver::OPTIMAL' failed.
```

* or-tools: 9.4
* cbc: 2.10.4

FWIW also seeing Cbc print to stdout when run the circt-opt command manually:

```
/home/will/src/sifive/circt/test/Scheduling/or-tools/cyclic-problems.mlir:4:14: error: LP-LABEL: expected string not found in input
// LP-LABEL: cyclic
             ^
<stdin>:1:1: note: scanning from here
CoinSolver takes input from arguments ( - switches to stdin)
^
<stdin>:2:10: note: possible intended match here
Enter ? for list of commands or help
         ^

Input file: <stdin>
Check file: /home/will/src/sifive/circt/test/Scheduling/or-tools/cyclic-problems.mlir

-dump-input=help explains the following input dump.

Input was:
<<<<<<
           1: CoinSolver takes input from arguments ( - switches to stdin) 
label:4'0     X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ error: no match found
           2: Enter ? for list of commands or help 
label:4'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
label:4'1              ?                            possible intended match
           3: Coin:Coin:Coin:
label:4'0     ~~~~~~~~~~~~~~~
>>>>>>
```

It seems `--mlir-disable-threading` stops the test from failing AFAICT.

I have not tried using `or-tools` built using our script, these are from my distribution.

I thought perhaps `or-tools` was managing a `cbc` process given the REPL-y prompt it prints, but strace says its using cbc as a shared library.","lib/Scheduling/LPSchedulers.cpp:141: mlir::LogicalResult circt::scheduling::scheduleLP(circt::scheduling::CyclicProblem &, mlir::Operation *): Assertion `result == MPSolver::OPTIMAL' failed.","/home/will/src/sifive/circt/test/Scheduling/or-tools/cyclic-problems.mlir:4:14: error: LP-LABEL: expected string not found in input
// LP-LABEL: cyclic
             ^
<stdin>:1:1: note: scanning from here
CoinSolver takes input from arguments ( - switches to stdin)
^
<stdin>:2:10: note: possible intended match here
Enter ? for list of commands or help
         ^

Input file: <stdin>
Check file: /home/will/src/sifive/circt/test/Scheduling/or-tools/cyclic-problems.mlir

-dump-input=help explains the following input dump.

Input was:
<<<<<<
           1: CoinSolver takes input from arguments ( - switches to stdin) 
label:4'0     X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ error: no match found
           2: Enter ? for list of commands or help 
label:4'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
label:4'1              ?                            possible intended match
           3: Coin:Coin:Coin:
label:4'0     ~~~~~~~~~~~~~~~
>>>>>>",,,,,,,,
4277,[FIRRTL] Grand Central Views with trivial connections are erroring,2022-11-09T02:35:32Z,closed,"bug, FIRRTL","Grand Central Views are now throwing errors if the value driving the `node` source is not a `RefResolveOp` or a `ConstantOp`. However, you can wind up with arbitrary things here due to having a view inside a module that has a trivial connection.

This is a bug that showed up due to stricter checking and removal of a fallback code path in https://github.com/llvm/circt/commit/2d3a040f43053d10d195980626ed321a653a89f4.

h/t @jackkoenig for finding this.

The following is a minimal example:

```
circuit Bar:
  module Companion:
    input x: UInt<1>

    node c = x

  module Bar:
    input x: UInt<1>

    inst companion of Companion
    companion.x <= x
```

```json
[
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""View"",
    ""companion"": ""~Bar|Companion"",
    ""parent"": ""~Bar|Bar"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""c"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""Bar"",
              ""module"": ""Bar"",
              ""path"": [
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""companion""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Companion""
                  }
                }
              ],
              ""ref"": ""c"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Bar|Companion>c""
  }
]
```

This produces:

```
# firtool Bar.fir --annotation-file Bar.anno.json -mlir-print-ir-before=firrtl-grand-central -mlir-print-ir-after=firrtl-grand-central
// -----// IR Dump Before GrandCentral (firrtl-grand-central) //----- //
firrtl.circuit ""Bar""  attributes {annotations = [{class = ""sifive.enterprise.grandcentral.AugmentedBundleType"", defName = ""MyInterface"", elements = [{class = ""sifive.enterprise.grandcentral.AugmentedGroundType"", id = 1 : i64, name = ""c""}], id = 0 : i64, name = ""View""}]} {
  firrtl.hierpath private @nla [@Bar::@companion, @Companion]
  firrtl.module private @Companion(in %x: !firrtl.uint<1>) attributes {annotations = [{class = ""sifive.enterprise.grandcentral.ViewAnnotation.companion"", id = 0 : i64, name = ""View""}]} {
    %c = firrtl.node  %x  {annotations = [{circt.nonlocal = @nla, class = ""sifive.enterprise.grandcentral.AugmentedGroundType"", id = 1 : i64}, {class = ""firrtl.transforms.DontTouchAnnotation""}]} : !firrtl.uint<1>
  }
  firrtl.module @Bar(in %x: !firrtl.uint<1>) attributes {annotations = [{class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 0 : i64, name = ""View""}]} {
    %companion_x = firrtl.instance companion sym @companion  @Companion(in x: !firrtl.uint<1>)
    firrtl.strictconnect %companion_x, %x : !firrtl.uint<1>
  }
}

Bar.fir:5:5: error: Grand Central View ""View"" has an invalid leaf value (this must be a node of a constant or reftype)
    node c = x
    ^
// -----// IR Dump After GrandCentral Failed (firrtl-grand-central) //----- //
firrtl.circuit ""Bar""  {
  firrtl.hierpath private @nla [@Bar::@companion, @Companion]
  firrtl.module private @Companion(in %x: !firrtl.uint<1>) {
    %c = firrtl.node  %x  {annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}]} : !firrtl.uint<1>
  }
  firrtl.module @Bar(in %x: !firrtl.uint<1>) {
    %companion_x = firrtl.instance companion sym @companion  @Companion(in x: !firrtl.uint<1>)
    firrtl.strictconnect %companion_x, %x : !firrtl.uint<1>
  }
  sv.interface @MyInterface attributes {comment = ""VCS coverage exclude_file""} {
  }
}
```","circuit Bar:
  module Companion:
    input x: UInt<1>

    node c = x

  module Bar:
    input x: UInt<1>

    inst companion of Companion
    companion.x <= x","[
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""View"",
    ""companion"": ""~Bar|Companion"",
    ""parent"": ""~Bar|Bar"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""c"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""Bar"",
              ""module"": ""Bar"",
              ""path"": [
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""companion""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Companion""
                  }
                }
              ],
              ""ref"": ""c"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Bar|Companion>c""
  }
]","# firtool Bar.fir --annotation-file Bar.anno.json -mlir-print-ir-before=firrtl-grand-central -mlir-print-ir-after=firrtl-grand-central
// -----// IR Dump Before GrandCentral (firrtl-grand-central) //----- //
firrtl.circuit ""Bar""  attributes {annotations = [{class = ""sifive.enterprise.grandcentral.AugmentedBundleType"", defName = ""MyInterface"", elements = [{class = ""sifive.enterprise.grandcentral.AugmentedGroundType"", id = 1 : i64, name = ""c""}], id = 0 : i64, name = ""View""}]} {
  firrtl.hierpath private @nla [@Bar::@companion, @Companion]
  firrtl.module private @Companion(in %x: !firrtl.uint<1>) attributes {annotations = [{class = ""sifive.enterprise.grandcentral.ViewAnnotation.companion"", id = 0 : i64, name = ""View""}]} {
    %c = firrtl.node  %x  {annotations = [{circt.nonlocal = @nla, class = ""sifive.enterprise.grandcentral.AugmentedGroundType"", id = 1 : i64}, {class = ""firrtl.transforms.DontTouchAnnotation""}]} : !firrtl.uint<1>
  }
  firrtl.module @Bar(in %x: !firrtl.uint<1>) attributes {annotations = [{class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 0 : i64, name = ""View""}]} {
    %companion_x = firrtl.instance companion sym @companion  @Companion(in x: !firrtl.uint<1>)
    firrtl.strictconnect %companion_x, %x : !firrtl.uint<1>
  }
}

Bar.fir:5:5: error: Grand Central View ""View"" has an invalid leaf value (this must be a node of a constant or reftype)
    node c = x
    ^
// -----// IR Dump After GrandCentral Failed (firrtl-grand-central) //----- //
firrtl.circuit ""Bar""  {
  firrtl.hierpath private @nla [@Bar::@companion, @Companion]
  firrtl.module private @Companion(in %x: !firrtl.uint<1>) {
    %c = firrtl.node  %x  {annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}]} : !firrtl.uint<1>
  }
  firrtl.module @Bar(in %x: !firrtl.uint<1>) {
    %companion_x = firrtl.instance companion sym @companion  @Companion(in x: !firrtl.uint<1>)
    firrtl.strictconnect %companion_x, %x : !firrtl.uint<1>
  }
  sv.interface @MyInterface attributes {comment = ""VCS coverage exclude_file""} {
  }
}",,,,,,,
4234,[FIRRTL] Grand Central Views Aliasing Sub-interfaces,2022-11-03T03:54:49Z,closed,"bug, FIRRTL","Two Grand Central Views which have the same sub-interface can currently result in an alias where the first sub-interface is used in place of the second sub-interface. What this means is that Grand Central Views will produce invalid output Verilog for any two interfaces with the same sub-interface that is not identical, e.g., that is targeting two types with different widths.

Consider the following circuit. This has two different fields of different widths: `a_w1` with width 1 and `a_w2` with width 2. These are targeted by two separate interfaces: `View_w1` targeting `a_w1` and `View_w2` targeting `a_w2`. Inside the interface, these have a sub-interface with a name conflict: `SameName`. When I compile it, the `SameName` of both views will point at the same sub-interface and result in a width error (trying to connect a width 2 thing to a width 1 thing):

```
circuit Top :
  module Companion_w1 :
    skip

  module Companion_w2 :
    skip

  module DUT :
    wire a_w1 : UInt<1>
    a_w1 is invalid

    wire a_w2 : UInt<2>
    a_w2 is invalid

    inst companion_w1 of Companion_w1
    inst companion_w2 of Companion_w2

  module Top :
    inst dut of DUT
```

And annotation file:
```json
[
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|DUT>a_w1""
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|DUT>a_w2""
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"": ""View_w1"",
    ""companion"": ""~Top|Companion_w1"",
    ""parent"": ""~Top|DUT"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""SameName"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
            ""defName"": ""SameName"",
            ""elements"": [
              {
                ""name"": ""uint"",
                ""tpe"": {
                  ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
                  ""ref"": {
                    ""circuit"": ""Top"",
                    ""module"": ""Top"",
                    ""path"": [
                      {
                        ""_1"": {
                          ""class"": ""firrtl.annotations.TargetToken$Instance"",
                          ""value"": ""dut""
                        },
                        ""_2"": {
                          ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                          ""value"": ""DUT""
                        }
                      }
                    ],
                    ""ref"": ""a_w1"",
                    ""component"": []
                  },
                  ""tpe"": {
                    ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
                  }
                }
              }
            ]
          }
        }
      ]
    }
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"": ""View_w2"",
    ""companion"": ""~Top|Companion_w2"",
    ""parent"": ""~Top|DUT"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""SameName"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
            ""defName"": ""SameName"",
            ""elements"": [
              {
                ""name"": ""uint"",
                ""tpe"": {
                  ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
                  ""ref"": {
                    ""circuit"": ""Top"",
                    ""module"": ""Top"",
                    ""path"": [
                      {
                        ""_1"": {
                          ""class"": ""firrtl.annotations.TargetToken$Instance"",
                          ""value"": ""dut""
                        },
                        ""_2"": {
                          ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                          ""value"": ""DUT""
                        }
                      }
                    ],
                    ""ref"": ""a_w2"",
                    ""component"": []
                  },
                  ""tpe"": {
                    ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
                  }
                }
              }
            ]
          }
        }
      ]
    }
  },
  {
    ""class"": ""firrtl.transforms.NoDedupAnnotation"",
    ""target"": ""~Top|Companion_w1""
  },
  {
    ""class"": ""firrtl.transforms.NoDedupAnnotation"",
    ""target"": ""~Top|Companion_w2""
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"": ""."",
    ""filename"": ""bindings.sv""
  }
]
```

Compiling and running through Verilator I get:

```
# firtool firrtl/Top.fir -annotation-file firrtl/Top.anno.json -split-verilog -o mfc && verilator --lint-only -Imfc Top.sv bindings.sv
%Warning-WIDTH: mfc/Companion_w2.sv:5:32: Operator ASSIGNW expects 1 bits on the Assign RHS, but Assign RHS's VARXREF 'a_w2' generates 2 bits.
                                        : ... In instance Top.dut.companion_w2
    5 |   assign View_w2.SameName.uint = DUT.a_w2;
      |                                ^
                mfc/bindings.sv:5:1: ... note: In file included from bindings.sv
                ... For warning description see https://verilator.org/warn/WIDTH?v=4.222
                ... Use ""/* verilator lint_off WIDTH */"" and lint_on around source to disable this message.
%Error: Exiting due to 1 warning(s)
```

If I manually change the name of the second `SameName` to `SameName_w2`, then everything works.","circuit Top :
  module Companion_w1 :
    skip

  module Companion_w2 :
    skip

  module DUT :
    wire a_w1 : UInt<1>
    a_w1 is invalid

    wire a_w2 : UInt<2>
    a_w2 is invalid

    inst companion_w1 of Companion_w1
    inst companion_w2 of Companion_w2

  module Top :
    inst dut of DUT","[
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|DUT>a_w1""
  },
  {
    ""class"": ""firrtl.transforms.DontTouchAnnotation"",
    ""target"": ""~Top|DUT>a_w2""
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"": ""View_w1"",
    ""companion"": ""~Top|Companion_w1"",
    ""parent"": ""~Top|DUT"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""SameName"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
            ""defName"": ""SameName"",
            ""elements"": [
              {
                ""name"": ""uint"",
                ""tpe"": {
                  ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
                  ""ref"": {
                    ""circuit"": ""Top"",
                    ""module"": ""Top"",
                    ""path"": [
                      {
                        ""_1"": {
                          ""class"": ""firrtl.annotations.TargetToken$Instance"",
                          ""value"": ""dut""
                        },
                        ""_2"": {
                          ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                          ""value"": ""DUT""
                        }
                      }
                    ],
                    ""ref"": ""a_w1"",
                    ""component"": []
                  },
                  ""tpe"": {
                    ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
                  }
                }
              }
            ]
          }
        }
      ]
    }
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"": ""View_w2"",
    ""companion"": ""~Top|Companion_w2"",
    ""parent"": ""~Top|DUT"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""SameName"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
            ""defName"": ""SameName"",
            ""elements"": [
              {
                ""name"": ""uint"",
                ""tpe"": {
                  ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
                  ""ref"": {
                    ""circuit"": ""Top"",
                    ""module"": ""Top"",
                    ""path"": [
                      {
                        ""_1"": {
                          ""class"": ""firrtl.annotations.TargetToken$Instance"",
                          ""value"": ""dut""
                        },
                        ""_2"": {
                          ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                          ""value"": ""DUT""
                        }
                      }
                    ],
                    ""ref"": ""a_w2"",
                    ""component"": []
                  },
                  ""tpe"": {
                    ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
                  }
                }
              }
            ]
          }
        }
      ]
    }
  },
  {
    ""class"": ""firrtl.transforms.NoDedupAnnotation"",
    ""target"": ""~Top|Companion_w1""
  },
  {
    ""class"": ""firrtl.transforms.NoDedupAnnotation"",
    ""target"": ""~Top|Companion_w2""
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"": ""."",
    ""filename"": ""bindings.sv""
  }
]","# firtool firrtl/Top.fir -annotation-file firrtl/Top.anno.json -split-verilog -o mfc && verilator --lint-only -Imfc Top.sv bindings.sv
%Warning-WIDTH: mfc/Companion_w2.sv:5:32: Operator ASSIGNW expects 1 bits on the Assign RHS, but Assign RHS's VARXREF 'a_w2' generates 2 bits.
                                        : ... In instance Top.dut.companion_w2
    5 |   assign View_w2.SameName.uint = DUT.a_w2;
      |                                ^
                mfc/bindings.sv:5:1: ... note: In file included from bindings.sv
                ... For warning description see https://verilator.org/warn/WIDTH?v=4.222
                ... Use ""/* verilator lint_off WIDTH */"" and lint_on around source to disable this message.
%Error: Exiting due to 1 warning(s)",,,,,,,
4108,[LLHD] refrence binding to misaligned address (ubsan),2022-10-14T17:44:30Z,closed,"bug, LLHD","Here's the error:
```
Thread 1 ""llhd-sim"" hit Breakpoint 1, 0x0000000004197ae0 in __ubsan_on_report ()
(gdb) bt
#0  0x0000000004197ae0 in __ubsan_on_report ()
#1  0x0000000004191dcd in __ubsan::Diag::~Diag() ()
#2  0x0000000004196073 in handleTypeMismatchImpl(__ubsan::TypeMismatchData*, unsigned long, __ubsan::ReportOptions) ()
#3  0x00000000041971c7 in __ubsan_handle_type_mismatch_v1_abort ()
#4  0x00007ffff7d7cad0 in llvm::ArrayRef<unsigned long>::operator[] (this=<optimized out>, Index=Index@entry=0) at /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:257
#5  0x00007ffff7d6244b in llvm::APInt::initFromArray (this=<optimized out>, bigVal=...) at /home/will/src/sifive/circt/llvm/llvm/lib/Support/APInt.cpp:92
#6  0x00007ffff7d626b9 in llvm::APInt::APInt (this=0x1000, numBits=<optimized out>, bigVal=...) at /home/will/src/sifive/circt/llvm/llvm/lib/Support/APInt.cpp:106
#7  0x00007ffff7d56369 in circt::llhd::sim::Slot::insertChange (this=<optimized out>, index=<optimized out>, bitOffset=<optimized out>, bytes=<optimized out>, width=0) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/State.cpp:77
#8  0x00007ffff7d5661a in circt::llhd::sim::UpdateQueue::insertOrUpdate (this=<optimized out>, time=..., index=<optimized out>, bitOffset=<optimized out>, bytes=<optimized out>, width=<optimized out>) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/State.cpp:99
#9  0x00007ffff7d5459d in driveSignal (state=<optimized out>, detail=<optimized out>, value=<optimized out>, width=<optimized out>, time=<optimized out>, delta=<optimized out>, eps=<optimized out>) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/signals-runtime-wrappers.cpp:67
#10 0x00007ffff6a02203 in _mlir_root ()
#11 0x0000000004519ed7 in circt::llhd::sim::Engine::simulate (this=<optimized out>, n=<optimized out>, maxTime=<optimized out>) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/Engine.cpp:199
#12 0x000000000419b77f in main (argc=<optimized out>, argv=<optimized out>) at /home/will/src/sifive/circt/tools/llhd-sim/llhd-sim.cpp:219
(gdb) c
Continuing.
/home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:257:14: runtime error: reference binding to misaligned address 0x7ffffffef234 for type 'const unsigned long', which requires 8 byte alignment
0x7ffffffef234: note: pointer points here
  d0 f9 fe ff 00 00 ff ff  00 fb fe ff ff 7f 00 00  f0 f9 fe ff ff 7f 00 00  10 f9 fe ff ff 7f 00 00
              ^ 
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:257:14 in 
[LWP 1951347 exited]
[LWP 1951346 exited]
[LWP 1951345 exited]
[LWP 1951343 exited]
[LWP 1951340 exited]
[LWP 1951344 exited]
[New process 1951340]
[Inferior 1 (process 1951340) exited with code 01]
(gdb) 
```

(not sure why wasn't printing stack trace, so used gdb to grab it-- break on `__ubsan_on_report`)","Thread 1 ""llhd-sim"" hit Breakpoint 1, 0x0000000004197ae0 in __ubsan_on_report ()
(gdb) bt
#0  0x0000000004197ae0 in __ubsan_on_report ()
#1  0x0000000004191dcd in __ubsan::Diag::~Diag() ()
#2  0x0000000004196073 in handleTypeMismatchImpl(__ubsan::TypeMismatchData*, unsigned long, __ubsan::ReportOptions) ()
#3  0x00000000041971c7 in __ubsan_handle_type_mismatch_v1_abort ()
#4  0x00007ffff7d7cad0 in llvm::ArrayRef<unsigned long>::operator[] (this=<optimized out>, Index=Index@entry=0) at /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:257
#5  0x00007ffff7d6244b in llvm::APInt::initFromArray (this=<optimized out>, bigVal=...) at /home/will/src/sifive/circt/llvm/llvm/lib/Support/APInt.cpp:92
#6  0x00007ffff7d626b9 in llvm::APInt::APInt (this=0x1000, numBits=<optimized out>, bigVal=...) at /home/will/src/sifive/circt/llvm/llvm/lib/Support/APInt.cpp:106
#7  0x00007ffff7d56369 in circt::llhd::sim::Slot::insertChange (this=<optimized out>, index=<optimized out>, bitOffset=<optimized out>, bytes=<optimized out>, width=0) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/State.cpp:77
#8  0x00007ffff7d5661a in circt::llhd::sim::UpdateQueue::insertOrUpdate (this=<optimized out>, time=..., index=<optimized out>, bitOffset=<optimized out>, bytes=<optimized out>, width=<optimized out>) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/State.cpp:99
#9  0x00007ffff7d5459d in driveSignal (state=<optimized out>, detail=<optimized out>, value=<optimized out>, width=<optimized out>, time=<optimized out>, delta=<optimized out>, eps=<optimized out>) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/signals-runtime-wrappers.cpp:67
#10 0x00007ffff6a02203 in _mlir_root ()
#11 0x0000000004519ed7 in circt::llhd::sim::Engine::simulate (this=<optimized out>, n=<optimized out>, maxTime=<optimized out>) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/Engine.cpp:199
#12 0x000000000419b77f in main (argc=<optimized out>, argv=<optimized out>) at /home/will/src/sifive/circt/tools/llhd-sim/llhd-sim.cpp:219
(gdb) c
Continuing.
/home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:257:14: runtime error: reference binding to misaligned address 0x7ffffffef234 for type 'const unsigned long', which requires 8 byte alignment
0x7ffffffef234: note: pointer points here
  d0 f9 fe ff 00 00 ff ff  00 fb fe ff ff 7f 00 00  f0 f9 fe ff ff 7f 00 00  10 f9 fe ff ff 7f 00 00
              ^ 
SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:257:14 in 
[LWP 1951347 exited]
[LWP 1951346 exited]
[LWP 1951345 exited]
[LWP 1951343 exited]
[LWP 1951340 exited]
[LWP 1951344 exited]
[New process 1951340]
[Inferior 1 (process 1951340) exited with code 01]
(gdb)",,,,,,,,,
4107,[LLHD] alloc/dealloc mismatch (ASAN),2022-10-14T17:39:53Z,closed,"bug, LLHD","A number of lit tests trigger alloc/dealloc mismatch errors, I think they're all the same here's one of them:

```
********************
FAIL: CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir (26 of 495)
******************** TEST 'CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir' FAILED ********************
Script:
--
: 'RUN: at line 2';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=full -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=FULL
: 'RUN: at line 3';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=reduced -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=REDUCED
: 'RUN: at line 4';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=merged -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=MERGED
: 'RUN: at line 5';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=merged-reduce -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=MERGEDRED
: 'RUN: at line 6';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=named-only -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=NAMED
--
Exit Code: 2

Command Output (stderr):
--
Finished at 5000ps 0d 2e (18 cycles)
=================================================================
==1941963==ERROR: AddressSanitizer: alloc-dealloc-mismatch (malloc vs operator delete) on 0x60200001cb10
    #0 0x4198b27 in operator delete(void*) (/build/sifive/asan/bin/llhd-sim+0x4198b27)
    #1 0x7f63d141ba46 in std::default_delete<unsigned char>::operator()(unsigned char*) const /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:85:2
    #2 0x7f63d141ba46 in std::unique_ptr<unsigned char, std::default_delete<unsigned char> >::~unique_ptr() /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:361:4
    #3 0x7f63d14285f4 in circt::llhd::sim::Instance::~Instance() /home/will/src/sifive/circt/include/circt/Dialect/LLHD/Simulator/State.h:276:8
    #4 0x7f63d1421d74 in llvm::SmallVectorTemplateBase<circt::llhd::sim::Instance, false>::destroy_range(circt::llhd::sim::Instance*, circt::llhd::sim::Instance*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:344:11
    #5 0x7f63d1421d74 in llvm::SmallVector<circt::llhd::sim::Instance, 0u>::~SmallVector() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:1206:5
    #6 0x7f63d141eb60 in circt::llhd::sim::State::~State() /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/State.cpp:198:1
    #7 0x451c592 in std::default_delete<circt::llhd::sim::State>::operator()(circt::llhd::sim::State*) const /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:85:2
    #8 0x451c592 in std::unique_ptr<circt::llhd::sim::State, std::default_delete<circt::llhd::sim::State> >::~unique_ptr() /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:361:4
    #9 0x45182aa in circt::llhd::sim::Engine::~Engine() /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/Engine.cpp:61:17
    #10 0x419bb2e in main /home/will/src/sifive/circt/tools/llhd-sim/llhd-sim.cpp:223:1
    #11 0x7f63d0c2924d in __libc_start_call_main (/nix/store/bzd91shky9j9d43girrrj6vmqlw7x9m8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 48753e3935872af81d27236b831592ed06e477fb)
    #12 0x7f63d0c29308 in __libc_start_main@GLIBC_2.2.5 (/nix/store/bzd91shky9j9d43girrrj6vmqlw7x9m8-glibc-2.35-163/lib/libc.so.6+0x29308) (BuildId: 48753e3935872af81d27236b831592ed06e477fb)
    #13 0x40a43a4 in _start (/build/sifive/asan/bin/llhd-sim+0x40a43a4)

0x60200001cb10 is located 0 bytes inside of 1-byte region [0x60200001cb10,0x60200001cb11)
allocated by thread T0 here:
LLVMSymbolizer: error reading file: No such file or directory
    #0 0x41548cf in malloc (/build/sifive/asan/bin/llhd-sim+0x41548cf)
    #1 0x7f63d0204056  (<unknown module>)
    #2 0x451875b in circt::llhd::sim::Engine::simulate(int, unsigned long) /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/Engine.cpp:76:35
    #3 0x419b77e in main /home/will/src/sifive/circt/tools/llhd-sim/llhd-sim.cpp:219:10
    #4 0x7f63d0c2924d in __libc_start_call_main (/nix/store/bzd91shky9j9d43girrrj6vmqlw7x9m8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 48753e3935872af81d27236b831592ed06e477fb)
    #5 0x7ffd4db0030a  ([stack]+0x2130a)

SUMMARY: AddressSanitizer: alloc-dealloc-mismatch (/build/sifive/asan/bin/llhd-sim+0x4198b27) in operator delete(void*)
==1941963==HINT: if you don't care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0
==1941963==ABORTING
```","********************
FAIL: CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir (26 of 495)
******************** TEST 'CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir' FAILED ********************
Script:
--
: 'RUN: at line 2';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=full -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=FULL
: 'RUN: at line 3';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=reduced -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=REDUCED
: 'RUN: at line 4';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=merged -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=MERGED
: 'RUN: at line 5';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=merged-reduce -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=MERGEDRED
: 'RUN: at line 6';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=named-only -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=NAMED
--
Exit Code: 2

Command Output (stderr):
--
Finished at 5000ps 0d 2e (18 cycles)
=================================================================
==1941963==ERROR: AddressSanitizer: alloc-dealloc-mismatch (malloc vs operator delete) on 0x60200001cb10
    #0 0x4198b27 in operator delete(void*) (/build/sifive/asan/bin/llhd-sim+0x4198b27)
    #1 0x7f63d141ba46 in std::default_delete<unsigned char>::operator()(unsigned char*) const /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:85:2
    #2 0x7f63d141ba46 in std::unique_ptr<unsigned char, std::default_delete<unsigned char> >::~unique_ptr() /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:361:4
    #3 0x7f63d14285f4 in circt::llhd::sim::Instance::~Instance() /home/will/src/sifive/circt/include/circt/Dialect/LLHD/Simulator/State.h:276:8
    #4 0x7f63d1421d74 in llvm::SmallVectorTemplateBase<circt::llhd::sim::Instance, false>::destroy_range(circt::llhd::sim::Instance*, circt::llhd::sim::Instance*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:344:11
    #5 0x7f63d1421d74 in llvm::SmallVector<circt::llhd::sim::Instance, 0u>::~SmallVector() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:1206:5
    #6 0x7f63d141eb60 in circt::llhd::sim::State::~State() /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/State.cpp:198:1
    #7 0x451c592 in std::default_delete<circt::llhd::sim::State>::operator()(circt::llhd::sim::State*) const /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:85:2
    #8 0x451c592 in std::unique_ptr<circt::llhd::sim::State, std::default_delete<circt::llhd::sim::State> >::~unique_ptr() /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:361:4
    #9 0x45182aa in circt::llhd::sim::Engine::~Engine() /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/Engine.cpp:61:17
    #10 0x419bb2e in main /home/will/src/sifive/circt/tools/llhd-sim/llhd-sim.cpp:223:1
    #11 0x7f63d0c2924d in __libc_start_call_main (/nix/store/bzd91shky9j9d43girrrj6vmqlw7x9m8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 48753e3935872af81d27236b831592ed06e477fb)
    #12 0x7f63d0c29308 in __libc_start_main@GLIBC_2.2.5 (/nix/store/bzd91shky9j9d43girrrj6vmqlw7x9m8-glibc-2.35-163/lib/libc.so.6+0x29308) (BuildId: 48753e3935872af81d27236b831592ed06e477fb)
    #13 0x40a43a4 in _start (/build/sifive/asan/bin/llhd-sim+0x40a43a4)

0x60200001cb10 is located 0 bytes inside of 1-byte region [0x60200001cb10,0x60200001cb11)
allocated by thread T0 here:
LLVMSymbolizer: error reading file: No such file or directory
    #0 0x41548cf in malloc (/build/sifive/asan/bin/llhd-sim+0x41548cf)
    #1 0x7f63d0204056  (<unknown module>)
    #2 0x451875b in circt::llhd::sim::Engine::simulate(int, unsigned long) /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/Engine.cpp:76:35
    #3 0x419b77e in main /home/will/src/sifive/circt/tools/llhd-sim/llhd-sim.cpp:219:10
    #4 0x7f63d0c2924d in __libc_start_call_main (/nix/store/bzd91shky9j9d43girrrj6vmqlw7x9m8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 48753e3935872af81d27236b831592ed06e477fb)
    #5 0x7ffd4db0030a  ([stack]+0x2130a)

SUMMARY: AddressSanitizer: alloc-dealloc-mismatch (/build/sifive/asan/bin/llhd-sim+0x4198b27) in operator delete(void*)
==1941963==HINT: if you don't care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0
==1941963==ABORTING",,,,,,,,,
4097,[FIRRTL][SV] Grand Central w/ Extract Test Code Can Create Bind-under-bind,2022-10-13T21:36:28Z,open,"bug, FIRRTL","Nested binds are pedantically illegal SystemVerilog even though some tools support them. I have a situation where the combination of instantiating a module inside a Grand Central View that has assertions can result in extraction which produces a bind-under-bind.

Consider the following FIRRTL text and annotation file:

```
circuit Top :
  extmodule DataTap_2 :
    output _2 : UInt<1>
    output _1 : UInt<1>
    output _0 : Clock
    defname = DataTap_2

  module Wrapper :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>

    node _T = asUInt(reset)
    node _T_1 = eq(_T, UInt<1>(""h0""))
    when _T_1 :
      node _T_2 = eq(in, UInt<1>(""h0""))
      when _T_2 :
        printf(clock, UInt<1>(""h1""), ""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"") : printf
      assert(clock, in, UInt<1>(""h1""), """") : assert


  module MyView_companion :

    wire _WIRE : UInt<1>
    _WIRE <= UInt<1>(""h0"")
    wire clk : Clock
    wire rst : UInt<1>
    wire cond : UInt<1>
    inst DataTap_2 of DataTap_2
    DataTap_2._0 is invalid
    DataTap_2._1 is invalid
    DataTap_2._2 is invalid
    clk <= DataTap_2._0
    rst <= DataTap_2._1
    cond <= DataTap_2._2
    inst wrapper of Wrapper
    wrapper.clock <= clk
    wrapper.reset <= rst
    wrapper.in <= cond

  module DUT :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>

    wire w : UInt<1>
    w <= in
    inst MyView_companion of MyView_companion

  module Top :
    input clock : Clock
    input reset : UInt<1>
    input in : UInt<1>

    inst dut of DUT
    dut.clock <= clock
    dut.reset <= reset
    dut.in <= in
```

```json
[
  {
    ""class"":""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"":""~Top|DataTap_2"",
    ""keys"":[
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>clock"",
        ""portName"":""~Top|DataTap_2>_0""
      },
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>reset"",
        ""portName"":""~Top|DataTap_2>_1""
      },
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>w"",
        ""portName"":""~Top|DataTap_2>_2""
      }
    ]
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"":""MyView"",
    ""companion"":""~Top|MyView_companion"",
    ""parent"":""~Top|DUT"",
    ""view"":""{\""class\"":\""sifive.enterprise.grandcentral.AugmentedBundleType\"",\""defName\"":\""MyInterface\"",\""elements\"":[{\""name\"":\""ground\"",\""description\"":\""a ground type port\"",\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.AugmentedGroundType\"",\""ref\"":{\""circuit\"":\""Top\"",\""module\"":\""Top\"",\""path\"":[{\""_1\"":{\""class\"":\""firrtl.annotations.TargetToken$Instance\"",\""value\"":\""dut\""},\""_2\"":{\""class\"":\""firrtl.annotations.TargetToken$OfModule\"",\""value\"":\""DUT\""}}],\""ref\"":\""w\"",\""component\"":[]},\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\""}}}]}""
  },
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""Top.DUT""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""gct"",
    ""filename"":""bindings.sv""
  }
]
```

Compiling this with `firtool Top.fir -annotation-file Top.anno.json -extract-test-code` produces the illegal:

```
// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

// VCS coverage exclude_file
module Wrapper_assert(
  input in,
        reset,
        clock);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & ~in) begin
        if (`ASSERT_VERBOSE_COND_)
          $error(""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule

module DUT(
  input clock,
        reset,
        in);

  wire w = in;
  /* This instance is elsewhere emitted as a bind statement.
    MyView_companion MyView_companion ();
  */
endmodule

module Top(
  input clock,
        reset,
        in);

  DUT dut (
    .clock (clock),
    .reset (reset),
    .in    (in)
  );
endmodule


// ----- 8< ----- FILE ""gct/DataTap_2_impl_0.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// VCS coverage exclude_file
module DataTap_2_impl_0(
  output _2,
         _1,
         _0);

  assign _2 = DUT.w;
  assign _1 = DUT.reset;
  assign _0 = DUT.clock;
endmodule


// ----- 8< ----- FILE ""gct/MyView_companion.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

// VCS coverage exclude_file
module MyView_companion();
  wire _DataTap_2__2;
  wire _DataTap_2__1;
  wire _DataTap_2__0;
  MyInterface MyView();
  `ifndef SYNTHESIS
    always @(posedge _DataTap_2__0) begin
      if (~_DataTap_2__1 & ~_DataTap_2__2) begin
        if (`ASSERT_VERBOSE_COND_)
          $error(""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
  assign MyView.ground = DUT.w;
  DataTap_2_impl_0 DataTap_2 (
    ._2 (_DataTap_2__2),
    ._1 (_DataTap_2__1),
    ._0 (_DataTap_2__0)
  );
  /* This instance is elsewhere emitted as a bind statement.
    Wrapper_assert Wrapper_assert (
      .in    (_DataTap_2__2),
      .reset (_DataTap_2__1),
      .clock (_DataTap_2__0)
    );
  */
endmodule


// ----- 8< ----- FILE ""bindings.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
bind DUT MyView_companion MyView_companion ();

// ----- 8< ----- FILE ""gct/MyInterface.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// VCS coverage exclude_file
interface MyInterface;
  // a ground type port
  logic ground;
endinterface


// ----- 8< ----- FILE ""bindfile"" ----- 8< -----

// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

bind MyView_companion Wrapper_assert Wrapper_assert (
  .in    (_DataTap_2__2),
  .reset (_DataTap_2__1),
  .clock (_DataTap_2__0)
);
```

Notice that `MyView_companion` is bound into `DUT` and `Wrapper_assert` is bound into `MyView_companion`. Verilator happily accepts this, so I don't have a nice script to lint that this doesn't happen.","circuit Top :
  extmodule DataTap_2 :
    output _2 : UInt<1>
    output _1 : UInt<1>
    output _0 : Clock
    defname = DataTap_2

  module Wrapper :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>

    node _T = asUInt(reset)
    node _T_1 = eq(_T, UInt<1>(""h0""))
    when _T_1 :
      node _T_2 = eq(in, UInt<1>(""h0""))
      when _T_2 :
        printf(clock, UInt<1>(""h1""), ""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"") : printf
      assert(clock, in, UInt<1>(""h1""), """") : assert


  module MyView_companion :

    wire _WIRE : UInt<1>
    _WIRE <= UInt<1>(""h0"")
    wire clk : Clock
    wire rst : UInt<1>
    wire cond : UInt<1>
    inst DataTap_2 of DataTap_2
    DataTap_2._0 is invalid
    DataTap_2._1 is invalid
    DataTap_2._2 is invalid
    clk <= DataTap_2._0
    rst <= DataTap_2._1
    cond <= DataTap_2._2
    inst wrapper of Wrapper
    wrapper.clock <= clk
    wrapper.reset <= rst
    wrapper.in <= cond

  module DUT :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>

    wire w : UInt<1>
    w <= in
    inst MyView_companion of MyView_companion

  module Top :
    input clock : Clock
    input reset : UInt<1>
    input in : UInt<1>

    inst dut of DUT
    dut.clock <= clock
    dut.reset <= reset
    dut.in <= in","[
  {
    ""class"":""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"":""~Top|DataTap_2"",
    ""keys"":[
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>clock"",
        ""portName"":""~Top|DataTap_2>_0""
      },
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>reset"",
        ""portName"":""~Top|DataTap_2>_1""
      },
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/dut:DUT>w"",
        ""portName"":""~Top|DataTap_2>_2""
      }
    ]
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"":""MyView"",
    ""companion"":""~Top|MyView_companion"",
    ""parent"":""~Top|DUT"",
    ""view"":""{\""class\"":\""sifive.enterprise.grandcentral.AugmentedBundleType\"",\""defName\"":\""MyInterface\"",\""elements\"":[{\""name\"":\""ground\"",\""description\"":\""a ground type port\"",\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.AugmentedGroundType\"",\""ref\"":{\""circuit\"":\""Top\"",\""module\"":\""Top\"",\""path\"":[{\""_1\"":{\""class\"":\""firrtl.annotations.TargetToken$Instance\"",\""value\"":\""dut\""},\""_2\"":{\""class\"":\""firrtl.annotations.TargetToken$OfModule\"",\""value\"":\""DUT\""}}],\""ref\"":\""w\"",\""component\"":[]},\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\""}}}]}""
  },
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""Top.DUT""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""gct"",
    ""filename"":""bindings.sv""
  }
]","// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

// VCS coverage exclude_file
module Wrapper_assert(
  input in,
        reset,
        clock);

  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if (~reset & ~in) begin
        if (`ASSERT_VERBOSE_COND_)
          $error(""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
endmodule

module DUT(
  input clock,
        reset,
        in);

  wire w = in;
  /* This instance is elsewhere emitted as a bind statement.
    MyView_companion MyView_companion ();
  */
endmodule

module Top(
  input clock,
        reset,
        in);

  DUT dut (
    .clock (clock),
    .reset (reset),
    .in    (in)
  );
endmodule


// ----- 8< ----- FILE ""gct/DataTap_2_impl_0.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// VCS coverage exclude_file
module DataTap_2_impl_0(
  output _2,
         _1,
         _0);

  assign _2 = DUT.w;
  assign _1 = DUT.reset;
  assign _0 = DUT.clock;
endmodule


// ----- 8< ----- FILE ""gct/MyView_companion.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

// VCS coverage exclude_file
module MyView_companion();
  wire _DataTap_2__2;
  wire _DataTap_2__1;
  wire _DataTap_2__0;
  MyInterface MyView();
  `ifndef SYNTHESIS
    always @(posedge _DataTap_2__0) begin
      if (~_DataTap_2__1 & ~_DataTap_2__2) begin
        if (`ASSERT_VERBOSE_COND_)
          $error(""Assertion failed: hello\n    at AssertInView.scala:24 assert(in, \""hello\"")\n"");
        if (`STOP_COND_)
          $fatal;
      end
    end // always @(posedge)
  `endif // not def SYNTHESIS
  assign MyView.ground = DUT.w;
  DataTap_2_impl_0 DataTap_2 (
    ._2 (_DataTap_2__2),
    ._1 (_DataTap_2__1),
    ._0 (_DataTap_2__0)
  );
  /* This instance is elsewhere emitted as a bind statement.
    Wrapper_assert Wrapper_assert (
      .in    (_DataTap_2__2),
      .reset (_DataTap_2__1),
      .clock (_DataTap_2__0)
    );
  */
endmodule


// ----- 8< ----- FILE ""bindings.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
bind DUT MyView_companion MyView_companion ();

// ----- 8< ----- FILE ""gct/MyInterface.sv"" ----- 8< -----

// Generated by CIRCT unknown git version
// VCS coverage exclude_file
interface MyInterface;
  // a ground type port
  logic ground;
endinterface


// ----- 8< ----- FILE ""bindfile"" ----- 8< -----

// Standard header to adapt well known macros to our needs.

// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.
`ifdef ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)
`else  // ASSERT_VERBOSE_COND
  `define ASSERT_VERBOSE_COND_ 1
`endif // ASSERT_VERBOSE_COND

// Users can define 'STOP_COND' to add an extra gate to stop conditions.
`ifdef STOP_COND
  `define STOP_COND_ (`STOP_COND)
`else  // STOP_COND
  `define STOP_COND_ 1
`endif // STOP_COND

bind MyView_companion Wrapper_assert Wrapper_assert (
  .in    (_DataTap_2__2),
  .reset (_DataTap_2__1),
  .clock (_DataTap_2__0)
);",,,,,,,
4096,[FIRRTL][ExpandWhens] Add iterator to `HashTableStack`,2022-10-13T19:39:05Z,closed,"bug, FIRRTL","The HashTableStack iterator was reusing the underlying data structure's (MapVector) iterator.  The `HashTableStack::end()` function would create a default constructed iterator which was not tied to any `MapVector`.  When comparing the default constructed iterator to a real iterator on Windows, this would crash.

Running a Windows test on this branch here: https://github.com/llvm/circt/actions/runs/3245347009",,,,,,,,,,
4084,[ExportVerilog] Spill variable assigned but not declared,2022-10-12T01:52:00Z,closed,"bug, ExportVerilog","I ran into this curious behavior of `ExportVerilog` where it would sometimes spill to a variable without actually declaring that variable. This seems to be very difficult to trigger -- I've had a hard time reducing this down since any small changes or shortening of the concats causes the issue to disappear.

Input MLIR:
```mlir
hw.module public @Foo(%k0: i1, %k1: i1, %k2: i1) {
  %0 = comb.concat %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0 : i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1
  %1 = comb.concat %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1 : i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1
  %2 = comb.concat %k2, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1 : i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1
  %3 = comb.or %0, %1, %2 : i12
  %r = sv.reg : !hw.inout<i12>
  sv.initial {
    sv.passign %r, %3 : i12
  }
}
```

Running through firtool produces the following Verilog (my indentation for clarity):
```systemverilog
module Foo(input k0, k1, k2);
  reg [11:0] r;
  initial begin
    automatic logic [11:0] _GEN =
        {k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0};
    automatic logic [11:0] _GEN_0 =
        {k0, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1} |
        {k2, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1};
    automatic logic [11:0] _GEN_1 = _GEN_0;
    _GEN_2 = {k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0};
    // ^^^--- note how _GEN_2 has never been declared
    r <= _GEN_2 | _GEN_0;
  end
endmodule
```

No idea how this happens. (Hot, highly uneducated guess: something about spilling to a variable while already spilling to a variable, and somehow corrupting text buffer pointers.)","hw.module public @Foo(%k0: i1, %k1: i1, %k2: i1) {
  %0 = comb.concat %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0 : i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1
  %1 = comb.concat %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1 : i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1
  %2 = comb.concat %k2, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1 : i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1
  %3 = comb.or %0, %1, %2 : i12
  %r = sv.reg : !hw.inout<i12>
  sv.initial {
    sv.passign %r, %3 : i12
  }
}","module Foo(input k0, k1, k2);
  reg [11:0] r;
  initial begin
    automatic logic [11:0] _GEN =
        {k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0};
    automatic logic [11:0] _GEN_0 =
        {k0, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1} |
        {k2, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1};
    automatic logic [11:0] _GEN_1 = _GEN_0;
    _GEN_2 = {k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0};
    // ^^^--- note how _GEN_2 has never been declared
    r <= _GEN_2 | _GEN_0;
  end
endmodule",,,,,,,,
4081,[asan] hw-extract-test-code test triggers heap-user-after-free,2022-10-11T16:12:07Z,closed,bug,"Looks like we mutate the instance graph while iterating over it? Haven't investigated, here's the error:

```
==1579121==ERROR: AddressSanitizer: heap-use-after-free on address 0x606000010f10 at pc 0x00000284bd39 bp 0x7fffed234b40 sp 0x7fffed234b38
READ of size 8 at 0x606000010f10 thread T0
    #0 0x284bd38 in circt::hw::InstanceGraphNode::UseIterator::operator++() /home/will/src/sifive/circt/include/circt/Dialect/HW/InstanceGraphBase.h:126:26
    #1 0x377139d in inlineInputOnly(circt::hw::HWModuleOp, circt::hw::InstanceGraph&, llvm::DenseMap<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> >, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> > > >&) /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:383:32
    #2 0x377139d in (anonymous namespace)::SVExtractTestCodeImplPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:639:9
    #3 0x54bd7e9 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:469:11
    #4 0x54bea35 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:533:16
    #5 0x54c34e9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:836:10
    #6 0x54c3242 in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:816:60
    #7 0x40f6862 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17
    #8 0x40f5fd1 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12
    #9 0x40f5fd1 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12
    #10 0x40f5fd1 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #11 0x414e1f6 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #12 0x414df42 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16
    #13 0x414d67b in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1872:5
    #14 0x414d67b in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1890:3
    #15 0x414d67b in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3
    #16 0x40f3e4f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10
    #17 0x40f4123 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:205:10
    #18 0x40f4972 in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:298:14
    #19 0x1d660b5 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:64:23
    #20 0x7f28279fb236 in __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29236) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)
    #21 0x7f28279fb2f4 in __libc_start_main@GLIBC_2.2.5 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x292f4) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)
    #22 0x1c6ee90 in _start /build/glibc-2.34/csu/../sysdeps/x86_64/start.S:116

0x606000010f10 is located 48 bytes inside of 64-byte region [0x606000010ee0,0x606000010f20)
freed by thread T0 here:
LLVMSymbolizer: error reading file: No such file or directory
    #0 0x1d63617 in operator delete(void*) (/build/sifive/asan/bin/circt-opt+0x1d63617)
    #1 0x32bc1c0 in llvm::ilist_alloc_traits<circt::hw::InstanceRecord>::deleteNode(circt::hw::InstanceRecord*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:42:39
    #2 0x32bc1c0 in llvm::iplist_impl<llvm::simple_ilist<circt::hw::InstanceRecord>, llvm::ilist_traits<circt::hw::InstanceRecord> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<circt::hw::InstanceRecord, true, false, void>, false, false>) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:269:5
    #3 0x32bc1c0 in llvm::iplist_impl<llvm::simple_ilist<circt::hw::InstanceRecord>, llvm::ilist_traits<circt::hw::InstanceRecord> >::erase(circt::hw::InstanceRecord*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:273:39
    #4 0x32b774f in circt::hw::InstanceRecord::erase() /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:24:26
    #5 0x377130e in inlineInputOnly(circt::hw::HWModuleOp, circt::hw::InstanceGraph&, llvm::DenseMap<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> >, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> > > >&) /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:431:10
    #6 0x377130e in (anonymous namespace)::SVExtractTestCodeImplPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:639:9
    #7 0x54bd7e9 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:469:11
    #8 0x54bea35 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:533:16
    #9 0x54c34e9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:836:10
    #10 0x54c3242 in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:816:60
    #11 0x40f6862 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17
    #12 0x40f5fd1 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12
    #13 0x40f5fd1 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12
    #14 0x40f5fd1 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #15 0x414e1f6 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #16 0x414df42 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16
    #17 0x414d67b in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1872:5
    #18 0x414d67b in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1890:3
    #19 0x414d67b in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3
    #20 0x40f3e4f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10
    #21 0x40f4123 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:205:10
    #22 0x40f4972 in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:298:14
    #23 0x1d660b5 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:64:23
    #24 0x7f28279fb236 in __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29236) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)
    #25 0x7fffed23a110  ([stack]+0x20110)
    #26 0x73612f6576696668  (<unknown module>)

previously allocated by thread T0 here:
    #0 0x1d62c47 in operator new(unsigned long) (/build/sifive/asan/bin/circt-opt+0x1d62c47)
    #1 0x32b7803 in circt::hw::InstanceGraphNode::addInstance(circt::hw::HWInstanceLike, circt::hw::InstanceGraphNode*) /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:29:26
    #2 0x32bb2d3 in circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)::operator()(circt::hw::HWInstanceLike) const /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:63:20
    #3 0x32bb2d3 in std::enable_if<(!(llvm::is_one_of<circt::hw::HWInstanceLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), circt::hw::HWInstanceLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&)::'lambda'(mlir::Operation*)::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:195:7
    #4 0x32bb2d3 in void llvm::function_ref<void (mlir::Operation*)>::callback_fn<std::enable_if<(!(llvm::is_one_of<circt::hw::HWInstanceLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), circt::hw::HWInstanceLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&)::'lambda'(mlir::Operation*)>(long, mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #5 0x3b4d0a2 in llvm::function_ref<void (mlir::Operation*)>::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #6 0x3b4d0a2 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:70:5
    #7 0x3b4d008 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:65:9
    #8 0x32baf26 in std::enable_if<(!(llvm::is_one_of<circt::hw::HWInstanceLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), circt::hw::HWInstanceLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:197:10
    #9 0x32baf26 in std::enable_if<(llvm::function_traits<std::decay<circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)>::type>::num_args) == (1), void>::type mlir::Operation::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), void>(circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:575:12
    #10 0x32baf26 in std::enable_if<(llvm::function_traits<std::decay<circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)>::type>::num_args) == (1), void>::type mlir::OpState::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), void>(circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/OpDefinition.h:153:19
    #11 0x32baf26 in circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:60:12
    #12 0x32baf26 in std::enable_if<(!(llvm::is_one_of<circt::hw::HWModuleLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, circt::hw::HWModuleLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&)::'lambda'(mlir::Operation*)::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:195:7
    #13 0x32baf26 in void llvm::function_ref<void (mlir::Operation*)>::callback_fn<std::enable_if<(!(llvm::is_one_of<circt::hw::HWModuleLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, circt::hw::HWModuleLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&)::'lambda'(mlir::Operation*)>(long, mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #14 0x3b4d0a2 in llvm::function_ref<void (mlir::Operation*)>::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #15 0x3b4d0a2 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:70:5
    #16 0x3b4d008 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:65:9
    #17 0x32b7e8f in std::enable_if<(!(llvm::is_one_of<circt::hw::HWModuleLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, circt::hw::HWModuleLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:197:10
    #18 0x32b7e8f in std::enable_if<(llvm::function_traits<std::decay<circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0>::type>::num_args) == (1), void>::type mlir::Operation::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, void>(circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:575:12
    #19 0x32b7e8f in circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:54:11
    #20 0x32053db in circt::hw::InstanceGraph::InstanceGraph(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/HW/HWInstanceGraph.cpp:15:7
    #21 0x1f843c9 in mlir::detail::AnalysisModel<circt::hw::InstanceGraph>::AnalysisModel<mlir::ModuleOp&>(mlir::ModuleOp&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:119:9
    #22 0x1f843c9 in std::_MakeUniq<mlir::detail::AnalysisModel<circt::hw::InstanceGraph> >::__single_object std::make_unique<mlir::detail::AnalysisModel<circt::hw::InstanceGraph>, mlir::ModuleOp&>(mlir::ModuleOp&) /nix/store/kiwdwd6zw4svi9jlr95yg1p5pgpjxn1v-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:962:34
    #23 0x1f843c9 in auto mlir::detail::AnalysisMap::constructAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp, (void*)0>(mlir::AnalysisManager&, mlir::ModuleOp) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:232:12
    #24 0x1f843c9 in circt::hw::InstanceGraph& mlir::detail::AnalysisMap::getAnalysisImpl<circt::hw::InstanceGraph, mlir::ModuleOp>(mlir::PassInstrumentor*, mlir::ModuleOp, mlir::AnalysisManager&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:210:32
    #25 0x1f84103 in std::enable_if<(std::is_constructible<circt::hw::InstanceGraph, mlir::ModuleOp>::value) || (std::is_constructible<circt::hw::InstanceGraph, mlir::ModuleOp, mlir::AnalysisManager&>::value), circt::hw::InstanceGraph&>::type mlir::detail::AnalysisMap::getAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp>(mlir::PassInstrumentor*, mlir::AnalysisManager&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:166:12
    #26 0x1f84096 in circt::hw::InstanceGraph& mlir::AnalysisManager::getAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp>() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:325:27
    #27 0x1f83fdd in circt::hw::InstanceGraph& mlir::Pass::getAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp>() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/Pass.h:224:33
    #28 0x376fdb0 in circt::hw::InstanceGraph& mlir::OperationPass<mlir::ModuleOp>::getAnalysis<circt::hw::InstanceGraph>() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/Pass.h:372:18
    #29 0x376fdb0 in (anonymous namespace)::SVExtractTestCodeImplPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:610:25
    #30 0x54bd7e9 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:469:11
    #31 0x54bea35 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:533:16
    #32 0x54c34e9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:836:10
    #33 0x54c3242 in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:816:60
    #34 0x40f6862 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17
    #35 0x40f5fd1 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12
    #36 0x40f5fd1 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12
    #37 0x40f5fd1 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #38 0x414e1f6 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #39 0x414df42 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16
    #40 0x414d67b in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1872:5
    #41 0x414d67b in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1890:3
    #42 0x414d67b in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3
    #43 0x40f3e4f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10
    #44 0x40f4123 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:205:10
    #45 0x40f4972 in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:298:14
    #46 0x1d660b5 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:64:23
    #47 0x7f28279fb236 in __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29236) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)
    #48 0x7fffed23a110  ([stack]+0x20110)

SUMMARY: AddressSanitizer: heap-use-after-free /home/will/src/sifive/circt/include/circt/Dialect/HW/InstanceGraphBase.h:126:26 in circt::hw::InstanceGraphNode::UseIterator::operator++()
Shadow bytes around the buggy address:
  0x0c0c7fffa190: fa fa fa fa 00 00 00 00 00 00 00 00 fa fa fa fa
  0x0c0c7fffa1a0: 00 00 00 00 00 00 00 00 fa fa fa fa 00 00 00 00
  0x0c0c7fffa1b0: 00 00 00 00 fa fa fa fa 00 00 00 00 00 00 00 fa
  0x0c0c7fffa1c0: fa fa fa fa 00 00 00 00 00 00 00 fa fa fa fa fa
  0x0c0c7fffa1d0: 00 00 00 00 00 00 00 fa fa fa fa fa fd fd fd fd
=>0x0c0c7fffa1e0: fd fd[fd]fd fa fa fa fa 00 00 00 00 00 00 00 00
  0x0c0c7fffa1f0: fa fa fa fa 00 00 00 00 00 00 00 00 fa fa fa fa
  0x0c0c7fffa200: 00 00 00 00 00 00 00 00 fa fa fa fa 00 00 00 00
  0x0c0c7fffa210: 00 00 00 00 fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c0c7fffa220: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c0c7fffa230: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==1579121==ABORTING
```
","==1579121==ERROR: AddressSanitizer: heap-use-after-free on address 0x606000010f10 at pc 0x00000284bd39 bp 0x7fffed234b40 sp 0x7fffed234b38
READ of size 8 at 0x606000010f10 thread T0
    #0 0x284bd38 in circt::hw::InstanceGraphNode::UseIterator::operator++() /home/will/src/sifive/circt/include/circt/Dialect/HW/InstanceGraphBase.h:126:26
    #1 0x377139d in inlineInputOnly(circt::hw::HWModuleOp, circt::hw::InstanceGraph&, llvm::DenseMap<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> >, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> > > >&) /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:383:32
    #2 0x377139d in (anonymous namespace)::SVExtractTestCodeImplPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:639:9
    #3 0x54bd7e9 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:469:11
    #4 0x54bea35 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:533:16
    #5 0x54c34e9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:836:10
    #6 0x54c3242 in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:816:60
    #7 0x40f6862 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17
    #8 0x40f5fd1 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12
    #9 0x40f5fd1 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12
    #10 0x40f5fd1 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #11 0x414e1f6 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #12 0x414df42 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16
    #13 0x414d67b in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1872:5
    #14 0x414d67b in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1890:3
    #15 0x414d67b in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3
    #16 0x40f3e4f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10
    #17 0x40f4123 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:205:10
    #18 0x40f4972 in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:298:14
    #19 0x1d660b5 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:64:23
    #20 0x7f28279fb236 in __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29236) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)
    #21 0x7f28279fb2f4 in __libc_start_main@GLIBC_2.2.5 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x292f4) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)
    #22 0x1c6ee90 in _start /build/glibc-2.34/csu/../sysdeps/x86_64/start.S:116

0x606000010f10 is located 48 bytes inside of 64-byte region [0x606000010ee0,0x606000010f20)
freed by thread T0 here:
LLVMSymbolizer: error reading file: No such file or directory
    #0 0x1d63617 in operator delete(void*) (/build/sifive/asan/bin/circt-opt+0x1d63617)
    #1 0x32bc1c0 in llvm::ilist_alloc_traits<circt::hw::InstanceRecord>::deleteNode(circt::hw::InstanceRecord*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:42:39
    #2 0x32bc1c0 in llvm::iplist_impl<llvm::simple_ilist<circt::hw::InstanceRecord>, llvm::ilist_traits<circt::hw::InstanceRecord> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<circt::hw::InstanceRecord, true, false, void>, false, false>) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:269:5
    #3 0x32bc1c0 in llvm::iplist_impl<llvm::simple_ilist<circt::hw::InstanceRecord>, llvm::ilist_traits<circt::hw::InstanceRecord> >::erase(circt::hw::InstanceRecord*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:273:39
    #4 0x32b774f in circt::hw::InstanceRecord::erase() /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:24:26
    #5 0x377130e in inlineInputOnly(circt::hw::HWModuleOp, circt::hw::InstanceGraph&, llvm::DenseMap<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> >, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> > > >&) /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:431:10
    #6 0x377130e in (anonymous namespace)::SVExtractTestCodeImplPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:639:9
    #7 0x54bd7e9 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:469:11
    #8 0x54bea35 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:533:16
    #9 0x54c34e9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:836:10
    #10 0x54c3242 in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:816:60
    #11 0x40f6862 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17
    #12 0x40f5fd1 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12
    #13 0x40f5fd1 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12
    #14 0x40f5fd1 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #15 0x414e1f6 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #16 0x414df42 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16
    #17 0x414d67b in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1872:5
    #18 0x414d67b in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1890:3
    #19 0x414d67b in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3
    #20 0x40f3e4f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10
    #21 0x40f4123 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:205:10
    #22 0x40f4972 in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:298:14
    #23 0x1d660b5 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:64:23
    #24 0x7f28279fb236 in __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29236) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)
    #25 0x7fffed23a110  ([stack]+0x20110)
    #26 0x73612f6576696668  (<unknown module>)

previously allocated by thread T0 here:
    #0 0x1d62c47 in operator new(unsigned long) (/build/sifive/asan/bin/circt-opt+0x1d62c47)
    #1 0x32b7803 in circt::hw::InstanceGraphNode::addInstance(circt::hw::HWInstanceLike, circt::hw::InstanceGraphNode*) /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:29:26
    #2 0x32bb2d3 in circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)::operator()(circt::hw::HWInstanceLike) const /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:63:20
    #3 0x32bb2d3 in std::enable_if<(!(llvm::is_one_of<circt::hw::HWInstanceLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), circt::hw::HWInstanceLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&)::'lambda'(mlir::Operation*)::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:195:7
    #4 0x32bb2d3 in void llvm::function_ref<void (mlir::Operation*)>::callback_fn<std::enable_if<(!(llvm::is_one_of<circt::hw::HWInstanceLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), circt::hw::HWInstanceLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&)::'lambda'(mlir::Operation*)>(long, mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #5 0x3b4d0a2 in llvm::function_ref<void (mlir::Operation*)>::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #6 0x3b4d0a2 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:70:5
    #7 0x3b4d008 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:65:9
    #8 0x32baf26 in std::enable_if<(!(llvm::is_one_of<circt::hw::HWInstanceLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), circt::hw::HWInstanceLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:197:10
    #9 0x32baf26 in std::enable_if<(llvm::function_traits<std::decay<circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)>::type>::num_args) == (1), void>::type mlir::Operation::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), void>(circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:575:12
    #10 0x32baf26 in std::enable_if<(llvm::function_traits<std::decay<circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)>::type>::num_args) == (1), void>::type mlir::OpState::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), void>(circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/OpDefinition.h:153:19
    #11 0x32baf26 in circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:60:12
    #12 0x32baf26 in std::enable_if<(!(llvm::is_one_of<circt::hw::HWModuleLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, circt::hw::HWModuleLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&)::'lambda'(mlir::Operation*)::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:195:7
    #13 0x32baf26 in void llvm::function_ref<void (mlir::Operation*)>::callback_fn<std::enable_if<(!(llvm::is_one_of<circt::hw::HWModuleLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, circt::hw::HWModuleLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&)::'lambda'(mlir::Operation*)>(long, mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #14 0x3b4d0a2 in llvm::function_ref<void (mlir::Operation*)>::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #15 0x3b4d0a2 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:70:5
    #16 0x3b4d008 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:65:9
    #17 0x32b7e8f in std::enable_if<(!(llvm::is_one_of<circt::hw::HWModuleLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, circt::hw::HWModuleLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:197:10
    #18 0x32b7e8f in std::enable_if<(llvm::function_traits<std::decay<circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0>::type>::num_args) == (1), void>::type mlir::Operation::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, void>(circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:575:12
    #19 0x32b7e8f in circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:54:11
    #20 0x32053db in circt::hw::InstanceGraph::InstanceGraph(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/HW/HWInstanceGraph.cpp:15:7
    #21 0x1f843c9 in mlir::detail::AnalysisModel<circt::hw::InstanceGraph>::AnalysisModel<mlir::ModuleOp&>(mlir::ModuleOp&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:119:9
    #22 0x1f843c9 in std::_MakeUniq<mlir::detail::AnalysisModel<circt::hw::InstanceGraph> >::__single_object std::make_unique<mlir::detail::AnalysisModel<circt::hw::InstanceGraph>, mlir::ModuleOp&>(mlir::ModuleOp&) /nix/store/kiwdwd6zw4svi9jlr95yg1p5pgpjxn1v-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:962:34
    #23 0x1f843c9 in auto mlir::detail::AnalysisMap::constructAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp, (void*)0>(mlir::AnalysisManager&, mlir::ModuleOp) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:232:12
    #24 0x1f843c9 in circt::hw::InstanceGraph& mlir::detail::AnalysisMap::getAnalysisImpl<circt::hw::InstanceGraph, mlir::ModuleOp>(mlir::PassInstrumentor*, mlir::ModuleOp, mlir::AnalysisManager&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:210:32
    #25 0x1f84103 in std::enable_if<(std::is_constructible<circt::hw::InstanceGraph, mlir::ModuleOp>::value) || (std::is_constructible<circt::hw::InstanceGraph, mlir::ModuleOp, mlir::AnalysisManager&>::value), circt::hw::InstanceGraph&>::type mlir::detail::AnalysisMap::getAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp>(mlir::PassInstrumentor*, mlir::AnalysisManager&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:166:12
    #26 0x1f84096 in circt::hw::InstanceGraph& mlir::AnalysisManager::getAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp>() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:325:27
    #27 0x1f83fdd in circt::hw::InstanceGraph& mlir::Pass::getAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp>() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/Pass.h:224:33
    #28 0x376fdb0 in circt::hw::InstanceGraph& mlir::OperationPass<mlir::ModuleOp>::getAnalysis<circt::hw::InstanceGraph>() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/Pass.h:372:18
    #29 0x376fdb0 in (anonymous namespace)::SVExtractTestCodeImplPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:610:25
    #30 0x54bd7e9 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:469:11
    #31 0x54bea35 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:533:16
    #32 0x54c34e9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:836:10
    #33 0x54c3242 in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:816:60
    #34 0x40f6862 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17
    #35 0x40f5fd1 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12
    #36 0x40f5fd1 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12
    #37 0x40f5fd1 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12
    #38 0x414e1f6 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12
    #39 0x414df42 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16
    #40 0x414d67b in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1872:5
    #41 0x414d67b in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1890:3
    #42 0x414d67b in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3
    #43 0x40f3e4f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10
    #44 0x40f4123 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:205:10
    #45 0x40f4972 in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:298:14
    #46 0x1d660b5 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:64:23
    #47 0x7f28279fb236 in __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29236) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)
    #48 0x7fffed23a110  ([stack]+0x20110)

SUMMARY: AddressSanitizer: heap-use-after-free /home/will/src/sifive/circt/include/circt/Dialect/HW/InstanceGraphBase.h:126:26 in circt::hw::InstanceGraphNode::UseIterator::operator++()
Shadow bytes around the buggy address:
  0x0c0c7fffa190: fa fa fa fa 00 00 00 00 00 00 00 00 fa fa fa fa
  0x0c0c7fffa1a0: 00 00 00 00 00 00 00 00 fa fa fa fa 00 00 00 00
  0x0c0c7fffa1b0: 00 00 00 00 fa fa fa fa 00 00 00 00 00 00 00 fa
  0x0c0c7fffa1c0: fa fa fa fa 00 00 00 00 00 00 00 fa fa fa fa fa
  0x0c0c7fffa1d0: 00 00 00 00 00 00 00 fa fa fa fa fa fd fd fd fd
=>0x0c0c7fffa1e0: fd fd[fd]fd fa fa fa fa 00 00 00 00 00 00 00 00
  0x0c0c7fffa1f0: fa fa fa fa 00 00 00 00 00 00 00 00 fa fa fa fa
  0x0c0c7fffa200: 00 00 00 00 00 00 00 00 fa fa fa fa 00 00 00 00
  0x0c0c7fffa210: 00 00 00 00 fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c0c7fffa220: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c0c7fffa230: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==1579121==ABORTING",,,,,,,,,
3970,[Handshake] Parsing external function with no SSA values crashes.,2022-09-22T08:13:24Z,closed,"bug, Handshake","The following is an external `handshake.func` that causes the parser to crash.

```
  handshake.func private @foo(i32, i32, none, ...) -> (i32, none) attributes {argNames = [], resNames = []}
```

It seems that this falls apart when modifying SSA value names.

Furthermore, the parser would try to parse a region, even when it isn't present.","handshake.func private @foo(i32, i32, none, ...) -> (i32, none) attributes {argNames = [], resNames = []}",,,,,,,,,
3968,[FIRRTL] LowerTypes can Violate New Port Uniqueness Checks,2022-09-22T03:11:30Z,closed,"bug, FIRRTL","Consider the following circuit:

```scala
circuit Bar:
  module Bar:
    input a: UInt<1>[1]
    output a_0: UInt<1>

    a_0 <= a[0]
```

When compile with `firtool`, this will currently crash due to changes added in https://github.com/llvm/circt/pull/3891:
```
# firtool Bar.fir
Bar.fir:2:10: error: 'firrtl.module' op port names should be unique
  module Bar:
         ^
Bar.fir:2:10: note: see current operation: 
""firrtl.module""() ({
^bb0(%arg0: !firrtl.uint<1>, %arg1: !firrtl.uint<1>):
  ""firrtl.strictconnect""(%arg1, %arg0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
}) {annotations = [], portAnnotations = [[], []], portDirections = -2 : i2, portNames = [""a_0"", ""a_0""], portSyms = [], portTypes = [!firrtl.uint<1>, !firrtl.uint<1>], sym_name = ""Bar""} : () -> ()
```

Previously, `firtool` would produce some not-so-great names:

```verilog
module Bar(
  input  a_0,
  output a_0_0);

  assign a_0_0 = a_0;
endmodule
```

The SFC produces subjectively better names:

```verilog
module Bar(
  input   a__0,
  output  a_0
);
  assign a_0 = a__0;
endmodule
```

The SFC is approximating (though not exactly in my understanding) the definition of _prefix uniqueness_ in the FIRRTL spec. It is not necessary that we implement this, just: (1) that this doesn't crash and (2) that we produce some decent names here.","circuit Bar:
  module Bar:
    input a: UInt<1>[1]
    output a_0: UInt<1>

    a_0 <= a[0]","# firtool Bar.fir
Bar.fir:2:10: error: 'firrtl.module' op port names should be unique
  module Bar:
         ^
Bar.fir:2:10: note: see current operation: 
""firrtl.module""() ({
^bb0(%arg0: !firrtl.uint<1>, %arg1: !firrtl.uint<1>):
  ""firrtl.strictconnect""(%arg1, %arg0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
}) {annotations = [], portAnnotations = [[], []], portDirections = -2 : i2, portNames = [""a_0"", ""a_0""], portSyms = [], portTypes = [!firrtl.uint<1>, !firrtl.uint<1>], sym_name = ""Bar""} : () -> ()","module Bar(
  input  a_0,
  output a_0_0);

  assign a_0_0 = a_0;
endmodule","module Bar(
  input   a__0,
  output  a_0
);
  assign a_0 = a__0;
endmodule",,,,,,
3818,[StandardToHandshake] Loop task pipelining drops threads,2022-09-03T09:27:11Z,closed,"bug, Handshake","While writing additional tests for the `std-to-handshake` pass, I uncovered an issue related to loop task pipelining. 
The test defined [here](https://github.com/llvm/circt/tree/dinistro/more-task-pipeline-tests/integration_test/Dialect/Handshake/multiple_loops) breaks down as it does not emit all results. 
Independent of the input sequence, the 6th thread is always dropped. Note that his only happens for the buffer strategies `all` and `allFIFO`.

Either this is caused by a faulty test driver or there is indeed a deeper issue in the loop protection strategy. 

CC @mortbopet ",,,,,,,,,,
3810,[SystemC] SCModuleOp::getPortsOfDirection(direction) only returns first occurence,2022-09-02T14:36:30Z,open,"bug, SystemC","Above mentioned member function seems to only return the first port of the given direction for some reason.
There is no regression test with more than one output port, thus at least one should be added.
Observed in the `hw.output` lowering in HWToSystemC at 9384dccab8692086c21a4166c5e5181623695d91",,,,,,,,,,
3784,WireDFT: Crashes on DFT enable outside of DUT,2022-08-26T14:53:56Z,closed,"bug, FIRRTL","Test case:
```
circuit DFT: %[[
  {
    ""class"":""sifive.enterprise.firrtl.DFTTestModeEnableAnnotation"",
    ""target"":""DFT.DFT.psd_test_clock_enable""
  },
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""DFT.DUT""
  }
]]

  extmodule EICG_wrapper :
    input in : Clock
    input test_en : UInt<1>
    input en : UInt<1>
    output out : Clock
    defname = EICG_wrapper

  module DUT:
    inst eicg of EICG_wrapper
    eicg.in is invalid
    eicg.test_en is invalid
    eicg.en is invalid

  module DFT:
    input psd_test_clock_enable : UInt<1>
    inst d of DUT
```

Crash:

```
firtool: /home/will/src/sifive/circt/include/circt/Dialect/HW/InstanceGraphBase.h:121: circt::hw::InstanceGraphNode::UseIterator &circt::hw::InstanceGraphNode::UseIterator::operator++(): Assertion `current && ""incrementing past end""' failed.
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool /home/will/cur/debug/firrtl/test.fir
 #0 0x00000000005ed7e6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:569:13
 #1 0x00000000005ebc75 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:104:18
 #2 0x00000000005edb7f SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007fe646c950e0 __restore_rt (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x3d0e0)
 #4 0x00007fe646cdfc1f __pthread_kill_implementation (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x87c1f)
 #5 0x00007fe646c95042 gsignal (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x3d042)
 #6 0x00007fe646c8049c abort (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x2849c)
 #7 0x00007fe646c803d5 _nl_load_domain.cold.0 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x283d5)
 #8 0x00007fe646c8e062 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x36062)
 #9 0x00000000007acaaa llvm::SmallVectorTemplateCommon<lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement, void>::back() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:298:5
#10 0x00000000007acaaa lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement& llvm::SmallVectorTemplateBase<lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement, true>::growAndEmplaceBack<circt::hw::InstanceGraphNode*>(circt::hw::InstanceGraphNode*&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:545:18
#11 0x00000000007acaaa lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement& llvm::SmallVectorImpl<lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement>::emplace_back<circt::hw::InstanceGraphNode*>(circt::hw::InstanceGraphNode*&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:927:20
#12 0x00000000007acaaa lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/WireDFT.cpp:89:11
#13 0x00000000007acaaa (anonymous namespace)::WireDFTPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/WireDFT.cpp:205:15
#14 0x0000000000c79020 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11
#15 0x0000000000c79677 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35
#16 0x0000000000c79677 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#17 0x0000000000c79677 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#18 0x0000000000c79677 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#19 0x0000000000c7acfd std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/kiwdwd6zw4svi9jlr95yg1p5pgpjxn1v-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1046:25
#20 0x0000000000c7acfd mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5
#21 0x0000000000c7acfd mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18
#22 0x0000000000c7acfd mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#23 0x0000000000c7acfd mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14
#24 0x0000000000c7905e mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5
#25 0x0000000000c7905e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14
#26 0x0000000000c7b881 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35
#27 0x0000000000c7b881 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#28 0x0000000000c7b881 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#29 0x0000000000c7b881 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#30 0x0000000000c7b881 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:837:10
#31 0x0000000000c7b881 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:817:60
#32 0x00000000005371d8 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35
#33 0x00000000005371d8 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#34 0x00000000005371d8 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#35 0x00000000005371d8 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:696:7
#36 0x0000000000535708 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:794:12
#37 0x00000000005352ea processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:810:12
#38 0x00000000005352ea executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:892:14
#39 0x0000000000534f05 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35
#40 0x0000000000534f05 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#41 0x0000000000534f05 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#42 0x0000000000534f05 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:8
#43 0x00007fe646c81237 __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29237)
#44 0x00007fe646c812f5 __libc_start_main@GLIBC_2.2.5 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x292f5)
#45 0x0000000000534d41 _start /build/glibc-2.34/csu/../sysdeps/x86_64/start.S:118:0
```
","circuit DFT: %[[
  {
    ""class"":""sifive.enterprise.firrtl.DFTTestModeEnableAnnotation"",
    ""target"":""DFT.DFT.psd_test_clock_enable""
  },
  {
    ""class"":""sifive.enterprise.firrtl.MarkDUTAnnotation"",
    ""target"":""DFT.DUT""
  }
]]

  extmodule EICG_wrapper :
    input in : Clock
    input test_en : UInt<1>
    input en : UInt<1>
    output out : Clock
    defname = EICG_wrapper

  module DUT:
    inst eicg of EICG_wrapper
    eicg.in is invalid
    eicg.test_en is invalid
    eicg.en is invalid

  module DFT:
    input psd_test_clock_enable : UInt<1>
    inst d of DUT","firtool: /home/will/src/sifive/circt/include/circt/Dialect/HW/InstanceGraphBase.h:121: circt::hw::InstanceGraphNode::UseIterator &circt::hw::InstanceGraphNode::UseIterator::operator++(): Assertion `current && ""incrementing past end""' failed.
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: ./build/bin/firtool /home/will/cur/debug/firrtl/test.fir
 #0 0x00000000005ed7e6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:569:13
 #1 0x00000000005ebc75 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:104:18
 #2 0x00000000005edb7f SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007fe646c950e0 __restore_rt (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x3d0e0)
 #4 0x00007fe646cdfc1f __pthread_kill_implementation (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x87c1f)
 #5 0x00007fe646c95042 gsignal (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x3d042)
 #6 0x00007fe646c8049c abort (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x2849c)
 #7 0x00007fe646c803d5 _nl_load_domain.cold.0 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x283d5)
 #8 0x00007fe646c8e062 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x36062)
 #9 0x00000000007acaaa llvm::SmallVectorTemplateCommon<lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement, void>::back() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:298:5
#10 0x00000000007acaaa lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement& llvm::SmallVectorTemplateBase<lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement, true>::growAndEmplaceBack<circt::hw::InstanceGraphNode*>(circt::hw::InstanceGraphNode*&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:545:18
#11 0x00000000007acaaa lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement& llvm::SmallVectorImpl<lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement>::emplace_back<circt::hw::InstanceGraphNode*>(circt::hw::InstanceGraphNode*&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:927:20
#12 0x00000000007acaaa lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/WireDFT.cpp:89:11
#13 0x00000000007acaaa (anonymous namespace)::WireDFTPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/WireDFT.cpp:205:15
#14 0x0000000000c79020 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11
#15 0x0000000000c79677 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35
#16 0x0000000000c79677 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#17 0x0000000000c79677 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#18 0x0000000000c79677 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#19 0x0000000000c7acfd std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/kiwdwd6zw4svi9jlr95yg1p5pgpjxn1v-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1046:25
#20 0x0000000000c7acfd mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5
#21 0x0000000000c7acfd mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18
#22 0x0000000000c7acfd mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10
#23 0x0000000000c7acfd mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14
#24 0x0000000000c7905e mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5
#25 0x0000000000c7905e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14
#26 0x0000000000c7b881 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35
#27 0x0000000000c7b881 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#28 0x0000000000c7b881 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#29 0x0000000000c7b881 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9
#30 0x0000000000c7b881 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:837:10
#31 0x0000000000c7b881 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:817:60
#32 0x00000000005371d8 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35
#33 0x00000000005371d8 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#34 0x00000000005371d8 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#35 0x00000000005371d8 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:696:7
#36 0x0000000000535708 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:794:12
#37 0x00000000005352ea processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:810:12
#38 0x00000000005352ea executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:892:14
#39 0x0000000000534f05 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35
#40 0x0000000000534f05 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33
#41 0x0000000000534f05 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58
#42 0x0000000000534f05 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:8
#43 0x00007fe646c81237 __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29237)
#44 0x00007fe646c812f5 __libc_start_main@GLIBC_2.2.5 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x292f5)
#45 0x0000000000534d41 _start /build/glibc-2.34/csu/../sysdeps/x86_64/start.S:118:0",,,,,,,,
3768,[HW] Enum aliasing in SV output,2022-08-24T09:25:15Z,open,"bug, HW","Currently, different enums with identical field names:
```mlir
  hw.type_scope @fsm_enum_typedecls {
    hw.typedecl @M2_state_t : !hw.enum<A, B>
    hw.typedecl @M1_state_t : !hw.enum<A, B>
  }
```

Will export as:
```sv
typedef enum {A, B} M2_state_t;
typedef enum {A, B} M1_state_t;
```
wherein enum values alias.

Enum values should be emitted with additional pre/suffixing of the enum type name to avoid this, e.g.:
```sv
typedef enum {M2_state_A, M2_state_B} M2_state_t;
typedef enum {M1_state_A, M1_state_B} M1_state_t;
```","hw.type_scope @fsm_enum_typedecls {
    hw.typedecl @M2_state_t : !hw.enum<A, B>
    hw.typedecl @M1_state_t : !hw.enum<A, B>
  }","typedef enum {A, B} M2_state_t;
typedef enum {A, B} M1_state_t;","typedef enum {M2_state_A, M2_state_B} M2_state_t;
typedef enum {M1_state_A, M1_state_B} M1_state_t;",,,,,,,
3651,[HWArith] ChainedCast canonicalization pattern is too permissive ,2022-08-03T13:11:04Z,closed,"bug, HWArith","The `ChainedCast` pattern, introduced in https://github.com/llvm/circt/pull/3647, can produce wrong and illegal results, i.e.:
```mlir
    %0 = hwarith.cast %a : (ui8) -> (si8)
    %1 = hwarith.cast %0 : (si8) -> (si10) // Sign-extension
```
is not equivalent with:
```mlir
    %0 = hwarith.cast %a : (ui8) -> (si10) // Zero-extension
```

also
```mlir
    %0 = hwarith.cast %a : (i8) -> (si8)
    %1 = hwarith.cast %0 : (si8) -> (si10) // Sign-extension
```
can not be combined to:
```mlir
    %0 = hwarith.cast %a : (i8) -> (si10)
```","%0 = hwarith.cast %a : (ui8) -> (si8)
    %1 = hwarith.cast %0 : (si8) -> (si10) // Sign-extension",%0 = hwarith.cast %a : (ui8) -> (si10) // Zero-extension,"%0 = hwarith.cast %a : (i8) -> (si8)
    %1 = hwarith.cast %0 : (si8) -> (si10) // Sign-extension",%0 = hwarith.cast %a : (i8) -> (si10),,,,,,
3607,[ExportVerilog] `hw.verilogName` collision on declaration ops,2022-07-26T13:41:36Z,closed,"bug, ExportVerilog","```mlir
hw.module @CollectNamesOrder(%in: i1) -> (out:i1) {
  %0 = sv.wire : !hw.inout<i1>
  %foo = sv.wire {hw.verilogName = ""_GEN""} : !hw.inout<i1>
  %1 = sv.read_inout %foo: !hw.inout<i1>
  hw.output %1: i1
}
```
The current output is:
```verilog
module CollectNamesOrder(       // bar.mlir:2:1
  input  in,
  output out);

  wire _GEN;    // bar.mlir:3:8
  wire _GEN_0;  // bar.mlir:4:10

  assign out = _GEN_0;  // bar.mlir:5:8, :6:3
endmodule

module {
  hw.module @CollectNamesOrder(%in: i1) -> (out: i1) {
    %0 = sv.wire  {hw.verilogName = ""_GEN""} : !hw.inout<i1>
    %foo = sv.wire  {hw.verilogName = ""_GEN""} : !hw.inout<i1>
    %1 = sv.read_inout %foo : !hw.inout<i1>
    hw.output %1 : i1
  }
}
```
`hw.verilogName` on `%foo` is ignored because the name `_GEN` is given to `%0`. 
We fixed the issue for the cases when temporary wires are introduced at ExportVerilog (https://github.com/llvm/circt/pull/3342) but it seems it is necessary to consider cases like above.","hw.module @CollectNamesOrder(%in: i1) -> (out:i1) {
  %0 = sv.wire : !hw.inout<i1>
  %foo = sv.wire {hw.verilogName = ""_GEN""} : !hw.inout<i1>
  %1 = sv.read_inout %foo: !hw.inout<i1>
  hw.output %1: i1
}","module CollectNamesOrder(       // bar.mlir:2:1
  input  in,
  output out);

  wire _GEN;    // bar.mlir:3:8
  wire _GEN_0;  // bar.mlir:4:10

  assign out = _GEN_0;  // bar.mlir:5:8, :6:3
endmodule

module {
  hw.module @CollectNamesOrder(%in: i1) -> (out: i1) {
    %0 = sv.wire  {hw.verilogName = ""_GEN""} : !hw.inout<i1>
    %foo = sv.wire  {hw.verilogName = ""_GEN""} : !hw.inout<i1>
    %1 = sv.read_inout %foo : !hw.inout<i1>
    hw.output %1 : i1
  }
}",,,,,,,,
3606,[PrepareForEmission] `reuseExistingInOut` should check ifdef,2022-07-26T12:57:55Z,closed,"bug, ExportVerilog","```mlir
hw.module @ReuseExistingInOut(%clock: i1, %a: i1) -> (out1: i1) {
    %0 = comb.or %a, %a : i1
    %mywire = sv.wire  : !hw.inout<i1>
    sv.ifdef  ""FOO"" {
      sv.assign %mywire, %0 : i1
    }
    hw.output %0 : i1
  }
```

The current output of `circt-opt -export-verilog` is:
```verilog
module ReuseExistingInOut(      // bar.mlir:4:1
  input  clock,
         a,
  output out1);

  wire mywire;  // bar.mlir:6:13

  `ifdef FOO    // bar.mlir:8:3
    assign mywire = a | a;      // bar.mlir:5:12, :9:5
  `endif
  assign out1 = mywire; // bar.mlir:6:13, :18:3
endmodule
```
It is incorrect to replace `%0` with `mywire` because assign to `mywire` is gated by ifdef. ","hw.module @ReuseExistingInOut(%clock: i1, %a: i1) -> (out1: i1) {
    %0 = comb.or %a, %a : i1
    %mywire = sv.wire  : !hw.inout<i1>
    sv.ifdef  ""FOO"" {
      sv.assign %mywire, %0 : i1
    }
    hw.output %0 : i1
  }","module ReuseExistingInOut(      // bar.mlir:4:1
  input  clock,
         a,
  output out1);

  wire mywire;  // bar.mlir:6:13

  `ifdef FOO    // bar.mlir:8:3
    assign mywire = a | a;      // bar.mlir:5:12, :9:5
  `endif
  assign out1 = mywire; // bar.mlir:6:13, :18:3
endmodule",,,,,,,,
3603,[ExportVerilog] `isExpressionEmittedInlineIntoProceduralDeclaration`  incorrectly inlines assignments,2022-07-26T10:17:43Z,closed,"bug, ExportVerilog","```mlir
hw.module @isEmittedBroken(%a:i4, %b:i1, %c:i1) {
  %0 = sv.reg : !hw.inout<i4>
  %1 = sv.reg : !hw.inout<i4>
  %2 = sv.reg : !hw.inout<i2>
  sv.always posedge %b {
   sv.bpassign %0, %a: i4
   sv.bpassign %1, %a: i4
   %3 = sv.read_inout %0: !hw.inout<i4>
   %4 = sv.read_inout %1: !hw.inout<i4>
   %add =comb.add %3, %4:i4
   %extract = comb.extract %add from 1 : (i4) -> i2
   sv.bpassign %2, %extract: i2
  }
}
```
Current output:
```verilog
module isEmittedBroken( // bar.mlir:1:1
  input [3:0] a,
  input       b,
              c);

  reg [3:0] _GEN;       // bar.mlir:2:8
  reg [3:0] _GEN_0;     // bar.mlir:3:8
  reg [1:0] _GEN_1;     // bar.mlir:4:8

  always @(posedge b) begin     // bar.mlir:5:3
    automatic logic [3:0] _GEN_2 = _GEN + _GEN_0;       // bar.mlir:8:9, :9:9, :10:10

    _GEN = a;   // bar.mlir:6:4
    _GEN_0 = a; // bar.mlir:7:4
    _GEN_1 = _GEN_2[2:1];       // bar.mlir:11:15, :12:4
  end // always @(posedge)
endmodule
```

`_GEN_2` is declared as ""automatic logic"" variable and initialized at the same time. This is because `isExpressionEmittedInlineIntoProceduralDeclaration` identifies inlining `_GEN + _GEN_0` to be safe but it is actually incorrect. ","hw.module @isEmittedBroken(%a:i4, %b:i1, %c:i1) {
  %0 = sv.reg : !hw.inout<i4>
  %1 = sv.reg : !hw.inout<i4>
  %2 = sv.reg : !hw.inout<i2>
  sv.always posedge %b {
   sv.bpassign %0, %a: i4
   sv.bpassign %1, %a: i4
   %3 = sv.read_inout %0: !hw.inout<i4>
   %4 = sv.read_inout %1: !hw.inout<i4>
   %add =comb.add %3, %4:i4
   %extract = comb.extract %add from 1 : (i4) -> i2
   sv.bpassign %2, %extract: i2
  }
}","module isEmittedBroken( // bar.mlir:1:1
  input [3:0] a,
  input       b,
              c);

  reg [3:0] _GEN;       // bar.mlir:2:8
  reg [3:0] _GEN_0;     // bar.mlir:3:8
  reg [1:0] _GEN_1;     // bar.mlir:4:8

  always @(posedge b) begin     // bar.mlir:5:3
    automatic logic [3:0] _GEN_2 = _GEN + _GEN_0;       // bar.mlir:8:9, :9:9, :10:10

    _GEN = a;   // bar.mlir:6:4
    _GEN_0 = a; // bar.mlir:7:4
    _GEN_1 = _GEN_2[2:1];       // bar.mlir:11:15, :12:4
  end // always @(posedge)
endmodule",,,,,,,,
3547,[PrepareForEmission] `shouldSpillWire` creates wires in procedural regions,2022-07-17T21:08:30Z,closed,"bug, ExportVerilog","```mlir
module attributes {circt.loweringOptions = ""maximumNumberOfTermsPerExpression=4""} {
  hw.module @Foo(%z: i10) -> () {
    %0 = sv.reg : !hw.inout<i1>
    %re = sv.reg : !hw.inout<i10>
    sv.initial {
      %x = sv.read_inout %re: !hw.inout<i10>
      sv.ifdef.procedural ""bar"" {
        %2 = comb.add %x, %x, %x, %x, %x : i10
        %3 = comb.icmp eq %2, %z: i10
        sv.passign %0, %3: i1
      }
    }
  
    hw.output
  }
}
```
With `circt-opt -export-verilog` we get the following error.
```
foo.mlir:9:12: error: sv.wire should be in a non-procedural region
      %2 = comb.add %x, %x, %x, %x, %x : i10
```

`%2` is spilled to a temporary wire because it violates `maximumNumberOfTermsPerExpression` but it is spilled to a procedural region in the initial block. 
 
","module attributes {circt.loweringOptions = ""maximumNumberOfTermsPerExpression=4""} {
  hw.module @Foo(%z: i10) -> () {
    %0 = sv.reg : !hw.inout<i1>
    %re = sv.reg : !hw.inout<i10>
    sv.initial {
      %x = sv.read_inout %re: !hw.inout<i10>
      sv.ifdef.procedural ""bar"" {
        %2 = comb.add %x, %x, %x, %x, %x : i10
        %3 = comb.icmp eq %2, %z: i10
        sv.passign %0, %3: i1
      }
    }
  
    hw.output
  }
}","foo.mlir:9:12: error: sv.wire should be in a non-procedural region
      %2 = comb.add %x, %x, %x, %x, %x : i10",,,,,,,,
3515,[firtool] -verbose-pass-executions prints wrong options for drop-names,2022-07-12T17:59:54Z,closed,bug,"Specifying various `-preserve-values=` options (default is 'none' presently) does change the option but not as expected:

```
$ ./bin/firtool ./test.fir -verbose-pass-executions -preserve-values=none |& grep -o ""drop-names{preserve-values=[^}]\+}""
drop-names{preserve-values=named}
drop-names{preserve-values=named}
drop-names{preserve-values=named}
drop-names{preserve-values=named}
```

none is default, and is reported as 'named' (shown above).  Here's what's printed for each of the supported values:


""none"" → ""named""
""named"" → ""none""
""all"" → ""none""

AFAICT the options are working properly, just printed/reported incorrectly.","$ ./bin/firtool ./test.fir -verbose-pass-executions -preserve-values=none |& grep -o ""drop-names{preserve-values=[^}]\+}""
drop-names{preserve-values=named}
drop-names{preserve-values=named}
drop-names{preserve-values=named}
drop-names{preserve-values=named}",,,,,,,,,
3495,[FIRRTL] GCT Taps and Dedup,2022-07-08T23:22:37Z,closed,"bug, FIRRTL","This is the Grand Central (GCT) Taps variant of #3494. GCT Taps does not work on a deduplicated design. We need to fix this with a better representation for XMRs that works with dedup. Dedup and annotations do not work if the annotations describe XMRs.

Consider:

```scala
circuit Top :
  module Bar :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  extmodule DataTap_1 :
    output _0 : UInt<1>
    defname = DataTap_1

  module Foo :
    input clock : Clock
    input reset : Reset

    inst bar of Bar
    bar.clock <= clock
    bar.reset <= reset
    wire w : UInt<1>
    inst DataTap_1 of DataTap_1
    DataTap_1._0 is invalid
    w <= DataTap_1._0

  module Bar_1 :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  extmodule DataTap_1_0 :
    output _0 : UInt<1>
    defname = DataTap_1

  module Foo_1 :
    input clock : Clock
    input reset : Reset

    inst bar of Bar_1
    bar.clock <= clock
    bar.reset <= reset
    wire w : UInt<1>
    inst DataTap_1 of DataTap_1_0
    DataTap_1._0 is invalid
    w <= DataTap_1._0

  module Top :
    input clock : Clock
    input reset : UInt<1>

    inst foo1 of Foo
    foo1.clock <= clock
    foo1.reset <= reset
    inst foo2 of Foo_1
    foo2.clock <= clock
    foo2.reset <= reset
```

```json
[
  {
    ""class"":""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"":""~Top|DataTap_1"",
    ""keys"":[
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/foo1:Foo/bar:Bar>w"",
        ""portName"":""~Top|DataTap_1>_0""
      }
    ]
  },
  {
    ""class"":""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"":""~Top|DataTap_1_0"",
    ""keys"":[
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/foo2:Foo_1/bar:Bar_1>w"",
        ""portName"":""~Top|DataTap_1_0>_0""
      }
    ]
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""builds/gct-tests/DedupTap/firrtl/gct"",
    ""filename"":""builds/gct-tests/DedupTap/firrtl/bindings.sv""
  },
  {
    ""class"":""sifive.enterprise.firrtl.TestBenchDirAnnotation"",
    ""dirname"":""builds/gct-tests/DedupTap/firrtl/verilog/testbench""
  }
]
```

Currently this will crash after GCT Taps (`firtool Foo.fir -annotation-file Foo.anno.json -dedup -firrtl-grand-central`):

```
firrtl/Top.fir:36:10: error: 'firrtl.hierpath' op instance path is incorrect. Expected module: ""DataTap_1_impl_1"" instead found: ""DataTap_1""
  module Foo_1 :
         ^
firrtl/Top.fir:36:10: note: see current operation: ""firrtl.hierpath""() {namepath = [#hw.innerNameRef<@Top::@foo2>, #hw.innerNameRef<@Foo::@DataTap_1>, @DataTap_1], sym_name = ""nla_4""} : () -> ()
firrtl/Top.fir:13:10: error: 'firrtl.hierpath' op instance path is incorrect. Expected module: ""DataTap_1_impl_1"" instead found: ""DataTap_1""
  module Foo :
         ^
firrtl/Top.fir:13:10: note: see current operation: ""firrtl.hierpath""() {namepath = [#hw.innerNameRef<@Top::@foo1>, #hw.innerNameRef<@Foo::@DataTap_1>, @DataTap_1], sym_name = ""nla_3""} : () -> ()
```","circuit Top :
  module Bar :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  extmodule DataTap_1 :
    output _0 : UInt<1>
    defname = DataTap_1

  module Foo :
    input clock : Clock
    input reset : Reset

    inst bar of Bar
    bar.clock <= clock
    bar.reset <= reset
    wire w : UInt<1>
    inst DataTap_1 of DataTap_1
    DataTap_1._0 is invalid
    w <= DataTap_1._0

  module Bar_1 :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  extmodule DataTap_1_0 :
    output _0 : UInt<1>
    defname = DataTap_1

  module Foo_1 :
    input clock : Clock
    input reset : Reset

    inst bar of Bar_1
    bar.clock <= clock
    bar.reset <= reset
    wire w : UInt<1>
    inst DataTap_1 of DataTap_1_0
    DataTap_1._0 is invalid
    w <= DataTap_1._0

  module Top :
    input clock : Clock
    input reset : UInt<1>

    inst foo1 of Foo
    foo1.clock <= clock
    foo1.reset <= reset
    inst foo2 of Foo_1
    foo2.clock <= clock
    foo2.reset <= reset","[
  {
    ""class"":""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"":""~Top|DataTap_1"",
    ""keys"":[
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/foo1:Foo/bar:Bar>w"",
        ""portName"":""~Top|DataTap_1>_0""
      }
    ]
  },
  {
    ""class"":""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"":""~Top|DataTap_1_0"",
    ""keys"":[
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top/foo2:Foo_1/bar:Bar_1>w"",
        ""portName"":""~Top|DataTap_1_0>_0""
      }
    ]
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""builds/gct-tests/DedupTap/firrtl/gct"",
    ""filename"":""builds/gct-tests/DedupTap/firrtl/bindings.sv""
  },
  {
    ""class"":""sifive.enterprise.firrtl.TestBenchDirAnnotation"",
    ""dirname"":""builds/gct-tests/DedupTap/firrtl/verilog/testbench""
  }
]","firrtl/Top.fir:36:10: error: 'firrtl.hierpath' op instance path is incorrect. Expected module: ""DataTap_1_impl_1"" instead found: ""DataTap_1""
  module Foo_1 :
         ^
firrtl/Top.fir:36:10: note: see current operation: ""firrtl.hierpath""() {namepath = [#hw.innerNameRef<@Top::@foo2>, #hw.innerNameRef<@Foo::@DataTap_1>, @DataTap_1], sym_name = ""nla_4""} : () -> ()
firrtl/Top.fir:13:10: error: 'firrtl.hierpath' op instance path is incorrect. Expected module: ""DataTap_1_impl_1"" instead found: ""DataTap_1""
  module Foo :
         ^
firrtl/Top.fir:13:10: note: see current operation: ""firrtl.hierpath""() {namepath = [#hw.innerNameRef<@Top::@foo1>, #hw.innerNameRef<@Foo::@DataTap_1>, @DataTap_1], sym_name = ""nla_3""} : () -> ()",,,,,,,
3494,[FIRRTL] GCT Views and Dedup,2022-07-08T23:19:29Z,open,"bug, FIRRTL","Grand Central (GCT) Views do not currently work when combined with FIRRTL's deduplication pass. Consider the following circuit and annotation file. `Top` instantiates `Foo` and `Foo_1`. Each of those, respectively, instantiate `Bar` and `Bar_1`. Each `Foo*` has a view of something inside each `Bar*`:

```scala
circuit Top :
  module Bar :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  module MyView_companion :

    skip

  module Foo :
    input clock : Clock
    input reset : Reset

    inst bar of Bar
    bar.clock <= clock
    bar.reset <= reset
    inst MyView_companion of MyView_companion

  module Bar_1 :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  module MyView_companion_0 :

    skip

  module Foo_1 :
    input clock : Clock
    input reset : Reset

    inst bar of Bar_1
    bar.clock <= clock
    bar.reset <= reset
    inst MyView_companion_0 of MyView_companion_0

  module Top :
    input clock : Clock
    input reset : UInt<1>

    inst foo1 of Foo
    foo1.clock <= clock
    foo1.reset <= reset
    inst foo2 of Foo_1
    foo2.clock <= clock
    foo2.reset <= reset
```

```json
[
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~Top|MyView_companion"",
    ""parent"": ""~Top|Foo"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""w"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""Top"",
              ""module"": ""Top"",
              ""path"": [
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""foo1""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Foo""
                  }
                },
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""bar""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Bar""
                  }
                }
              ],
              ""ref"": ""w"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~Top|MyView_companion_0"",
    ""parent"": ""~Top|Foo_1"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""w"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""Top"",
              ""module"": ""Top"",
              ""path"": [
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""foo2""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Foo_1""
                  }
                },
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""bar""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Bar_1""
                  }
                }
              ],
              ""ref"": ""w"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  }
]
```

If you run this with `firtool Foo.fir -annotation-file Foo.anno.json -dedup -firrtl-grand-central` you get an expected error. The GCT Views pass is asserting that the `NoDedupAnnotation` behavior exists:

```
firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once
  module Foo :
         ^
firrtl/Top.fir:13:10: note: see current operation: ""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):
  %0:2 = ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@bar"">, moduleName = @Bar, name = ""bar"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""]} : () -> (!firrtl.clock, !firrtl.uint<1>)
  ""firrtl.strictconnect""(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()
  ""firrtl.strictconnect""(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@MyView_companion"">, moduleName = @MyView_companion, name = ""MyView_companion"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()
}) {annotations = [{circt.nonlocal = @nla_3, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 2 : i64, name = ""MyView"", type = ""parent""}, {circt.nonlocal = @nla_4, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 0 : i64, name = ""MyView"", type = ""parent""}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""], portSyms = ["""", """"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = ""Foo"", sym_visibility = ""private""} : () -> ()
firrtl/Top.fir:49:5: note: parent is instantiated here
    inst foo2 of Foo_1
    ^
firrtl/Top.fir:46:5: note: parent is instantiated here
    inst foo1 of Foo
    ^
firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once
  module Foo :
         ^
firrtl/Top.fir:13:10: note: see current operation: ""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):
  %0:2 = ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@bar"">, moduleName = @Bar, name = ""bar"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""]} : () -> (!firrtl.clock, !firrtl.uint<1>)
  ""firrtl.strictconnect""(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()
  ""firrtl.strictconnect""(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@MyView_companion"">, moduleName = @MyView_companion, name = ""MyView_companion"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()
}) {annotations = [{circt.nonlocal = @nla_3, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 2 : i64, name = ""MyView"", type = ""parent""}, {circt.nonlocal = @nla_4, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 0 : i64, name = ""MyView"", type = ""parent""}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""], portSyms = ["""", """"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = ""Foo"", sym_visibility = ""private""} : () -> ()
firrtl/Top.fir:49:5: note: parent is instantiated here
    inst foo2 of Foo_1
    ^
firrtl/Top.fir:46:5: note: parent is instantiated here
    inst foo1 of Foo
    ^
firrtl/Top.fir:1:1: error: 'firrtl.circuit' op contains a 'companion' with id '2', but does not contain a GrandCentral 'parent' with the same id
circuit Top :
^
```

If you run this without dedup (or with a `NoDedupAnnotation`) everything expectedly works. The fundamental problem is that GCT Views are encoding an XMR using annotations. After Dedup runs, it rightly keeps both of these annotations around. However, now you have a multiply instantiated parent module that is supposed to describe _two_ XMRs. However, these XMRs ""deduplicate"" to a single XMR.

There are multiple approaches to fix this:

1. Modify the GCT Views pass to recognize this pattern and generate a ""minimal"" XMR that combines all the deduplicated XMRs.
2. Special case certain annotations in dedup to also deduplicate.
3. Change `LowerAnnotations` to represent XMRs as ""fake ports"" in the design rooted at the lowest-common ancestor necessary to make the connection. Then dedup works correctly.

(1) is janky, but expedient. (2) is extremely janky. (3) is the only reasonable solution here.","circuit Top :
  module Bar :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  module MyView_companion :

    skip

  module Foo :
    input clock : Clock
    input reset : Reset

    inst bar of Bar
    bar.clock <= clock
    bar.reset <= reset
    inst MyView_companion of MyView_companion

  module Bar_1 :
    input clock : Clock
    input reset : Reset

    wire w : UInt<1>
    w <= UInt<1>(""h0"")

  module MyView_companion_0 :

    skip

  module Foo_1 :
    input clock : Clock
    input reset : Reset

    inst bar of Bar_1
    bar.clock <= clock
    bar.reset <= reset
    inst MyView_companion_0 of MyView_companion_0

  module Top :
    input clock : Clock
    input reset : UInt<1>

    inst foo1 of Foo
    foo1.clock <= clock
    foo1.reset <= reset
    inst foo2 of Foo_1
    foo2.clock <= clock
    foo2.reset <= reset","[
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~Top|MyView_companion"",
    ""parent"": ""~Top|Foo"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""w"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""Top"",
              ""module"": ""Top"",
              ""path"": [
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""foo1""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Foo""
                  }
                },
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""bar""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Bar""
                  }
                }
              ],
              ""ref"": ""w"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  },
  {
    ""class"": ""sifive.enterprise.grandcentral.ViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~Top|MyView_companion_0"",
    ""parent"": ""~Top|Foo_1"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""w"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""ref"": {
              ""circuit"": ""Top"",
              ""module"": ""Top"",
              ""path"": [
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""foo2""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Foo_1""
                  }
                },
                {
                  ""_1"": {
                    ""class"": ""firrtl.annotations.TargetToken$Instance"",
                    ""value"": ""bar""
                  },
                  ""_2"": {
                    ""class"": ""firrtl.annotations.TargetToken$OfModule"",
                    ""value"": ""Bar_1""
                  }
                }
              ],
              ""ref"": ""w"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  }
]","firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once
  module Foo :
         ^
firrtl/Top.fir:13:10: note: see current operation: ""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):
  %0:2 = ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@bar"">, moduleName = @Bar, name = ""bar"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""]} : () -> (!firrtl.clock, !firrtl.uint<1>)
  ""firrtl.strictconnect""(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()
  ""firrtl.strictconnect""(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@MyView_companion"">, moduleName = @MyView_companion, name = ""MyView_companion"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()
}) {annotations = [{circt.nonlocal = @nla_3, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 2 : i64, name = ""MyView"", type = ""parent""}, {circt.nonlocal = @nla_4, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 0 : i64, name = ""MyView"", type = ""parent""}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""], portSyms = ["""", """"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = ""Foo"", sym_visibility = ""private""} : () -> ()
firrtl/Top.fir:49:5: note: parent is instantiated here
    inst foo2 of Foo_1
    ^
firrtl/Top.fir:46:5: note: parent is instantiated here
    inst foo1 of Foo
    ^
firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once
  module Foo :
         ^
firrtl/Top.fir:13:10: note: see current operation: ""firrtl.module""() ({
^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):
  %0:2 = ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@bar"">, moduleName = @Bar, name = ""bar"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""]} : () -> (!firrtl.clock, !firrtl.uint<1>)
  ""firrtl.strictconnect""(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()
  ""firrtl.strictconnect""(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
  ""firrtl.instance""() {annotations = [], inner_sym = #firrtl<""innerSym@MyView_companion"">, moduleName = @MyView_companion, name = ""MyView_companion"", nameKind = #firrtl<""name_kind droppable_name"">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()
}) {annotations = [{circt.nonlocal = @nla_3, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 2 : i64, name = ""MyView"", type = ""parent""}, {circt.nonlocal = @nla_4, class = ""sifive.enterprise.grandcentral.ViewAnnotation.parent"", id = 0 : i64, name = ""MyView"", type = ""parent""}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [""clock"", ""reset""], portSyms = ["""", """"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = ""Foo"", sym_visibility = ""private""} : () -> ()
firrtl/Top.fir:49:5: note: parent is instantiated here
    inst foo2 of Foo_1
    ^
firrtl/Top.fir:46:5: note: parent is instantiated here
    inst foo1 of Foo
    ^
firrtl/Top.fir:1:1: error: 'firrtl.circuit' op contains a 'companion' with id '2', but does not contain a GrandCentral 'parent' with the same id
circuit Top :
^",,,,,,,
3460,[FIRRTL] Grand Central Views Zero Width Bug,2022-07-01T05:46:19Z,closed,"bug, good first issue, FIRRTL","GCT Views with zero width components is also busted similarly to #3458.

Consider:

```scala
circuit ZeroWidth : %[[
  {
    ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~ZeroWidth|MyView_companion"",
    ""parent"": ""~ZeroWidth|ZeroWidth"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""ground"",
          ""description"": ""a ground type port"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""refBetter"": ""~ZeroWidth|ZeroWidth>w"",
            ""ref"": {
              ""circuit"": ""ZeroWidth"",
              ""module"": ""ZeroWidth"",
              ""path"": [],
              ""ref"": ""w"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  }
]]
  module MyView_companion :

  module ZeroWidth :

    wire w : UInt<0>
    w is invalid
    inst MyView_companion of MyView_companion
```

Running this through Grand Central will currently not do the right thing. This should not emit an XMR and do something with the zero-width port. Currently ExportVerilog will generate a 1-bit logic with an inline comment. (This should probably be changed, but is different from this issue as we still don't want the XMR.)","circuit ZeroWidth : %[[
  {
    ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"": ""MyView"",
    ""companion"": ""~ZeroWidth|MyView_companion"",
    ""parent"": ""~ZeroWidth|ZeroWidth"",
    ""view"": {
      ""class"": ""sifive.enterprise.grandcentral.AugmentedBundleType"",
      ""defName"": ""MyInterface"",
      ""elements"": [
        {
          ""name"": ""ground"",
          ""description"": ""a ground type port"",
          ""tpe"": {
            ""class"": ""sifive.enterprise.grandcentral.AugmentedGroundType"",
            ""refBetter"": ""~ZeroWidth|ZeroWidth>w"",
            ""ref"": {
              ""circuit"": ""ZeroWidth"",
              ""module"": ""ZeroWidth"",
              ""path"": [],
              ""ref"": ""w"",
              ""component"": []
            },
            ""tpe"": {
              ""class"": ""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$""
            }
          }
        }
      ]
    }
  }
]]
  module MyView_companion :

  module ZeroWidth :

    wire w : UInt<0>
    w is invalid
    inst MyView_companion of MyView_companion",,,,,,,,,
3458,[FIRRTL] Zero Width GCT Taps Crashes in LowerToHW,2022-06-30T23:02:33Z,closed,"bug, good first issue, FIRRTL","The following can produce a crash:

```scala
circuit Top : %[[
  {
    ""class"":""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"":""~Top|DataTap"",
    ""keys"":[
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top>w"",
        ""portName"":""~Top|DataTap>_0""
      }
    ]
  }
]]
  extmodule DataTap:
    output _0: UInt<0>

  module Top:
    wire w: UInt<0>
    w is invalid
    inst tap of DataTap
```

`firtool Foo.fir -firrtl-grand-central`:
```
Assertion failed: ((srcWidth != 0) && ""Lowering produced value for zero width source""), function setLowering, file LowerToHW.cpp, line 2043.
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x000000010ebea18d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x000000010ebea70b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x000000010ebe83f6 llvm::sys::RunSignalHandlers() + 134
3  firtool                  0x000000010ebec35f SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff81a838dfd _sigtramp + 29
5  libsystem_platform.dylib 0x0000000000000001 _sigtramp + 18446603370136105505
6  libsystem_c.dylib        0x00007ff81a76ed24 abort + 123
7  libsystem_c.dylib        0x00007ff81a76e0cb err + 0
8  firtool                  0x000000010ed22f8b (anonymous namespace)::FIRRTLLowering::setLowering(mlir::Value, mlir::Value) + 379
9  firtool                  0x000000010ed2575c (anonymous namespace)::FIRRTLLowering::setPossiblyFoldedLowering(mlir::Value, mlir::Value) + 332
10 firtool                  0x000000010ed4705d mlir::LogicalResult (anonymous namespace)::FIRRTLLowering::setLoweringTo<circt::sv::VerbatimExprOp, mlir::Type, mlir::StringAttr, llvm::SmallVector<mlir::Value, 4u>, mlir::ArrayAttr>(mlir::Operation*, mlir::Type, mlir::StringAttr, llvm::SmallVector<mlir::Value, 4u>, mlir::ArrayAttr) + 157
11 firtool                  0x000000010ed46f0d (anonymous namespace)::FIRRTLLowering::visitExpr(circt::firrtl::VerbatimExprOp) + 733
12 firtool                  0x000000010ed46c1b mlir::LogicalResult circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::VerbatimExprOp>(auto) const + 43
13 firtool                  0x000000010ed46b9a llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::firrtl::VerbatimExprOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&) + 122
14 firtool                  0x000000010ed22add circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*) + 2461
15 firtool                  0x000000010ed21b9d circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchVisitor(mlir::Operation*) + 29
16 firtool                  0x000000010ed1d794 (anonymous namespace)::FIRRTLLowering::run() + 308
17 firtool                  0x000000010ed1a9b2 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleOperations(circt::hw::HWModuleOp, (anonymous namespace)::CircuitLoweringState&) + 98
18 firtool                  0x000000010ed19efb (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) + 2155
19 firtool                  0x000000010ed194eb auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9::operator()<unsigned long>(unsigned long) const + 75
20 firtool                  0x000000010edbb3d9 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()::operator()() const + 169
21 firtool                  0x000000010edbb325 decltype(static_cast<llvm::detail::SafeIntIterator<unsigned long, false>>(fp)()) std::__1::__invoke<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()&>(llvm::detail::SafeIntIterator<unsigned long, false>&&) + 21
22 firtool                  0x000000010edbb2dd void std::__1::__invoke_void_return_wrapper<void, true>::__call<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()&>(mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()&) + 29
23 firtool                  0x000000010edbb2ad std::__1::__function::__alloc_func<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()>, void ()>::operator()() + 29
24 firtool                  0x000000010edba2f9 std::__1::__function::__func<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()>, void ()>::operator()() + 25
25 firtool                  0x000000010fb6c852 std::__1::__function::__value_func<void ()>::operator()() const + 50
26 firtool                  0x000000010fb6c815 std::__1::function<void ()>::operator()() const + 21
27 firtool                  0x000000010fb6c7dd llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()::operator()() const + 29
28 firtool                  0x000000010fb6c7a5 decltype(static_cast<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(fp)()) std::__1::__invoke<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 21
29 firtool                  0x000000010fb6c75d void std::__1::__invoke_void_return_wrapper<void, true>::__call<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 29
30 firtool                  0x000000010fb6c72d std::__1::__function::__alloc_func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 29
31 firtool                  0x000000010fb6b519 std::__1::__function::__func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 25
32 firtool                  0x000000010fb6c852 std::__1::__function::__value_func<void ()>::operator()() const + 50
33 firtool                  0x000000010fb6c815 std::__1::function<void ()>::operator()() const + 21
34 firtool                  0x000000010eb22c42 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) + 546
35 firtool                  0x000000010eb261d3 llvm::ThreadPool::grow(int)::$_0::operator()() const + 51
36 firtool                  0x000000010eb26165 void llvm::thread::Apply<llvm::ThreadPool::grow(int)::$_0>(std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::__1::integer_sequence<unsigned long>) + 37
37 firtool                  0x000000010eb26123 void llvm::thread::GenericThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 51
38 firtool                  0x000000010eb25e55 void* llvm::thread::ThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 21
39 libsystem_pthread.dylib  0x00007ff81a8234e1 _pthread_start + 125
40 libsystem_pthread.dylib  0x00007ff81a81ef6b thread_start + 15
zsh: abort      firtool firrtl/Top.fir -firrtl-grand-central
```","circuit Top : %[[
  {
    ""class"":""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"":""~Top|DataTap"",
    ""keys"":[
      {
        ""class"":""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"":""~Top|Top>w"",
        ""portName"":""~Top|DataTap>_0""
      }
    ]
  }
]]
  extmodule DataTap:
    output _0: UInt<0>

  module Top:
    wire w: UInt<0>
    w is invalid
    inst tap of DataTap","Assertion failed: ((srcWidth != 0) && ""Lowering produced value for zero width source""), function setLowering, file LowerToHW.cpp, line 2043.
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x000000010ebea18d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x000000010ebea70b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x000000010ebe83f6 llvm::sys::RunSignalHandlers() + 134
3  firtool                  0x000000010ebec35f SignalHandler(int) + 223
4  libsystem_platform.dylib 0x00007ff81a838dfd _sigtramp + 29
5  libsystem_platform.dylib 0x0000000000000001 _sigtramp + 18446603370136105505
6  libsystem_c.dylib        0x00007ff81a76ed24 abort + 123
7  libsystem_c.dylib        0x00007ff81a76e0cb err + 0
8  firtool                  0x000000010ed22f8b (anonymous namespace)::FIRRTLLowering::setLowering(mlir::Value, mlir::Value) + 379
9  firtool                  0x000000010ed2575c (anonymous namespace)::FIRRTLLowering::setPossiblyFoldedLowering(mlir::Value, mlir::Value) + 332
10 firtool                  0x000000010ed4705d mlir::LogicalResult (anonymous namespace)::FIRRTLLowering::setLoweringTo<circt::sv::VerbatimExprOp, mlir::Type, mlir::StringAttr, llvm::SmallVector<mlir::Value, 4u>, mlir::ArrayAttr>(mlir::Operation*, mlir::Type, mlir::StringAttr, llvm::SmallVector<mlir::Value, 4u>, mlir::ArrayAttr) + 157
11 firtool                  0x000000010ed46f0d (anonymous namespace)::FIRRTLLowering::visitExpr(circt::firrtl::VerbatimExprOp) + 733
12 firtool                  0x000000010ed46c1b mlir::LogicalResult circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::VerbatimExprOp>(auto) const + 43
13 firtool                  0x000000010ed46b9a llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::firrtl::VerbatimExprOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&) + 122
14 firtool                  0x000000010ed22add circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*) + 2461
15 firtool                  0x000000010ed21b9d circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchVisitor(mlir::Operation*) + 29
16 firtool                  0x000000010ed1d794 (anonymous namespace)::FIRRTLLowering::run() + 308
17 firtool                  0x000000010ed1a9b2 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleOperations(circt::hw::HWModuleOp, (anonymous namespace)::CircuitLoweringState&) + 98
18 firtool                  0x000000010ed19efb (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) + 2155
19 firtool                  0x000000010ed194eb auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9::operator()<unsigned long>(unsigned long) const + 75
20 firtool                  0x000000010edbb3d9 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()::operator()() const + 169
21 firtool                  0x000000010edbb325 decltype(static_cast<llvm::detail::SafeIntIterator<unsigned long, false>>(fp)()) std::__1::__invoke<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()&>(llvm::detail::SafeIntIterator<unsigned long, false>&&) + 21
22 firtool                  0x000000010edbb2dd void std::__1::__invoke_void_return_wrapper<void, true>::__call<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()&>(mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()&) + 29
23 firtool                  0x000000010edbb2ad std::__1::__function::__alloc_func<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()>, void ()>::operator()() + 29
24 firtool                  0x000000010edba2f9 std::__1::__function::__func<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()>, void ()>::operator()() + 25
25 firtool                  0x000000010fb6c852 std::__1::__function::__value_func<void ()>::operator()() const + 50
26 firtool                  0x000000010fb6c815 std::__1::function<void ()>::operator()() const + 21
27 firtool                  0x000000010fb6c7dd llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()::operator()() const + 29
28 firtool                  0x000000010fb6c7a5 decltype(static_cast<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(fp)()) std::__1::__invoke<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 21
29 firtool                  0x000000010fb6c75d void std::__1::__invoke_void_return_wrapper<void, true>::__call<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 29
30 firtool                  0x000000010fb6c72d std::__1::__function::__alloc_func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 29
31 firtool                  0x000000010fb6b519 std::__1::__function::__func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 25
32 firtool                  0x000000010fb6c852 std::__1::__function::__value_func<void ()>::operator()() const + 50
33 firtool                  0x000000010fb6c815 std::__1::function<void ()>::operator()() const + 21
34 firtool                  0x000000010eb22c42 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) + 546
35 firtool                  0x000000010eb261d3 llvm::ThreadPool::grow(int)::$_0::operator()() const + 51
36 firtool                  0x000000010eb26165 void llvm::thread::Apply<llvm::ThreadPool::grow(int)::$_0>(std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::__1::integer_sequence<unsigned long>) + 37
37 firtool                  0x000000010eb26123 void llvm::thread::GenericThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 51
38 firtool                  0x000000010eb25e55 void* llvm::thread::ThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 21
39 libsystem_pthread.dylib  0x00007ff81a8234e1 _pthread_start + 125
40 libsystem_pthread.dylib  0x00007ff81a81ef6b thread_start + 15
zsh: abort      firtool firrtl/Top.fir -firrtl-grand-central",,,,,,,,
3454,[ExportVerilog] Initial statement needs begin/end for single declaration,2022-06-30T11:00:07Z,open,"bug, ExportVerilog","Input:
```mlir
hw.module private @Foo() -> (){
    sv.initial {
      %param_x = sv.localparam : i42 { value = 11: i42 }
    }
}
```
`$ circt-opt -export-verilog` produces:
```verilog
module Foo();
  initial     
    localparam [41:0] param_x = 42'd11; 

endmodule
```

At least Verilator and Yosys produce a syntax error. When I added ""begin"" and ""end"" around initial statement, it parses.  
```verilog
  initial begin 
    localparam [41:0] param_x = 42'd11;
  end
```","hw.module private @Foo() -> (){
    sv.initial {
      %param_x = sv.localparam : i42 { value = 11: i42 }
    }
}","module Foo();
  initial     
    localparam [41:0] param_x = 42'd11; 

endmodule","initial begin 
    localparam [41:0] param_x = 42'd11;
  end",,,,,,,
3419,[FIRRTL] LowerTypes is Dropping Some `circt.fieldID` Annotations,2022-06-26T19:53:26Z,closed,"bug, FIRRTL","Annotations targeting fields from the LowerAnnotations `circt.fieldID` member are getting dropped during `LowerTypes` whereas annotations that use the older `#firrtl.subAnno` generated by the parser work fine.

Consider the following:

```mlir
firrtl.circuit ""Foo""  {
  firrtl.module @Foo() {
    %a = firrtl.wire interesting_name  {annotations = [
      #firrtl.subAnno<fieldID = 2, {class = ""circt.test2""}>, 
      {circt.fieldID = 2 : i32, class = ""circt.test""}]
    } : !firrtl.bundle<b: uint<1>, c: vector<uint<1>, 1>>
  }
}
```

After `LowerTypes` (`circt-opt -firrtl-lower-types`) this looks like:
```mlir
firrtl.circuit ""Foo""  {
  firrtl.module @Foo() {
    %a_b = firrtl.wire interesting_name  : !firrtl.uint<1>
    %a_c_0 = firrtl.wire interesting_name  {annotations = [{class = ""circt.test2""}]} : !firrtl.uint<1>
  }
}
```

This bug is likely unreachable/not concerning due to a combination of limited use of `LowerAnnotations` right now (this is only used for GCT View and Taps, those generate annotations on aggregates, and any downstream consumer of Views/Taps will error if these get deleted). However, this should be fixed as we migrate more annotations over. E.g., I noticed this because GCT signal driving _does_ want to target aggregates and I noticed the annotations getting deleted as I migrated them on my branch.","firrtl.circuit ""Foo""  {
  firrtl.module @Foo() {
    %a = firrtl.wire interesting_name  {annotations = [
      #firrtl.subAnno<fieldID = 2, {class = ""circt.test2""}>, 
      {circt.fieldID = 2 : i32, class = ""circt.test""}]
    } : !firrtl.bundle<b: uint<1>, c: vector<uint<1>, 1>>
  }
}","firrtl.circuit ""Foo""  {
  firrtl.module @Foo() {
    %a_b = firrtl.wire interesting_name  : !firrtl.uint<1>
    %a_c_0 = firrtl.wire interesting_name  {annotations = [{class = ""circt.test2""}]} : !firrtl.uint<1>
  }
}",,,,,,,,
3417,[FIRRTL] Unused 0-bit firrtl.invalidvalue remains after LowerToHW,2022-06-24T12:29:18Z,closed,"bug, FIRRTL","Input:
```mlir
firrtl.circuit ""Foo""  {
  firrtl.module @Foo() {
    %invalid_ui0 = firrtl.invalidvalue : !firrtl.uint<0>
  }
}
```
Output of `circt-opt -lower-firrtl-to-hw` contains `firrtl.invalidvalue` for some reason.
```
  hw.module @Foo() {
    %invalid_ui0 = firrtl.invalidvalue : !firrtl.uint<0>
    hw.output
  }
```","firrtl.circuit ""Foo""  {
  firrtl.module @Foo() {
    %invalid_ui0 = firrtl.invalidvalue : !firrtl.uint<0>
  }
}","hw.module @Foo() {
    %invalid_ui0 = firrtl.invalidvalue : !firrtl.uint<0>
    hw.output
  }",,,,,,,,
3388,[ExportVerilog] Weird wire/assign statement indent,2022-06-21T12:22:06Z,closed,"bug, ExportVerilog","I haven't reduced yet but I have often seen indent around wire/assign broken.  For example, in  `DivSqrtRecF64_mulAddZ31` module in [FPU.fir](https://github.com/circt/perf/blob/trunk/regress/FPU.fir) compiled with `firtool -drop-names`, there is code like this:
```verilog
      wire _T_275 = valid_PA & valid_leaving_PA;        // DivSqrtRecF64_mulAddZ31.scala:233:55, :283:28
  assign _T_278 = ~valid_PA | valid_leaving_PA; // DivSqrtRecF64_mulAddZ31.scala:233:55, :235:36, :284:28
      wire _T_298 = specialCodeB_PB[2:1] != 2'h3;       // DivSqrtRecF64_mulAddZ31.scala:97:30, :212:46, :293:24, :298:25, :311:{41,48}
```
","wire _T_275 = valid_PA & valid_leaving_PA;        // DivSqrtRecF64_mulAddZ31.scala:233:55, :283:28
  assign _T_278 = ~valid_PA | valid_leaving_PA; // DivSqrtRecF64_mulAddZ31.scala:233:55, :235:36, :284:28
      wire _T_298 = specialCodeB_PB[2:1] != 2'h3;       // DivSqrtRecF64_mulAddZ31.scala:97:30, :212:46, :293:24, :298:25, :311:{41,48}",,,,,,,,,
3334,[FIRRTL] New NLA Support in ModuleInliner ,2022-06-12T20:19:37Z,closed,"bug, FIRRTL","FIRRTL's Module Inliner definitely does not work with the new-style NLA paths. The problem is that [the NLA is marked dead if it ends in a module](https://github.com/llvm/circt/blob/c266174ef9410ff345a31a2af289f1d70d5d6147/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp#L325). Instead, the NLA is still alive so long as it has uses within the module.

Consider:

```mlir
firrtl.circuit ""Top"" {
  firrtl.hierpath @path_component_old [@Top::@foo, @Foo::@bar1, @Bar::@b]
  firrtl.hierpath @path_component_new [@Top::@foo, @Foo::@bar1, @Bar]
  firrtl.module private @Bar() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
    %b = firrtl.wire sym @b {annotations = [
      {circt.nonlocal = @path_component_old, ""path_component_old""},
      {circt.nonlocal = @path_component_new, ""path_component_new""}
    ]} : !firrtl.uint<1>
  }
  firrtl.module private @Foo() {
    firrtl.instance bar1 sym @bar1 @Bar()
    firrtl.instance bar2 sym @bar2 @Bar()
  }
  firrtl.module @Top() {
    firrtl.instance foo sym @foo @Foo()
  }
}
```

This currently drops `@path_component_new` because it gets marked dead when `@Bar` is inlined:

```
# circt-opt Bar.mlir -firrtl-inliner -debug-only=firrtl-inliner
===- Running Module Inliner Pass --------------------------------------------===
NLA modifications:
  - orig:           firrtl.hierpath @path_component_old [@Top::@foo, @Foo::@bar1, @Bar::@b]
    new:            firrtl.nla @path_component_old [#hw.innerNameRef<@Top::@foo>, #hw.innerNameRef<@Foo::@b>]
    dead:           0
    isDead:         0
    isLocal:        0
    inlinedSymbols: [3]
    flattenPoint:   -1
    renames:
  - orig:           firrtl.hierpath @path_component_new [@Top::@foo, @Foo::@bar1, @Bar]
    new:            
    dead:           1
    isDead:         1
    isLocal:        0
    inlinedSymbols: [3]
    flattenPoint:   -1
    renames:
===--------------------------------------------------------------------------===
module {
  firrtl.circuit ""Top""  {
    firrtl.hierpath @path_component_old [@Top::@foo, @Foo::@b]
    firrtl.module private @Foo() {
      %bar1_b = firrtl.wire sym @b   {annotations = [{circt.nonlocal = @path_component_old, path_component_old}]} : !firrtl.uint<1>
      %bar2_b = firrtl.wire sym @b_0   : !firrtl.uint<1>
    }
    firrtl.module @Top() {
      firrtl.instance foo sym @foo  @Foo()
    }
  }
}
```","firrtl.circuit ""Top"" {
  firrtl.hierpath @path_component_old [@Top::@foo, @Foo::@bar1, @Bar::@b]
  firrtl.hierpath @path_component_new [@Top::@foo, @Foo::@bar1, @Bar]
  firrtl.module private @Bar() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
    %b = firrtl.wire sym @b {annotations = [
      {circt.nonlocal = @path_component_old, ""path_component_old""},
      {circt.nonlocal = @path_component_new, ""path_component_new""}
    ]} : !firrtl.uint<1>
  }
  firrtl.module private @Foo() {
    firrtl.instance bar1 sym @bar1 @Bar()
    firrtl.instance bar2 sym @bar2 @Bar()
  }
  firrtl.module @Top() {
    firrtl.instance foo sym @foo @Foo()
  }
}","# circt-opt Bar.mlir -firrtl-inliner -debug-only=firrtl-inliner
===- Running Module Inliner Pass --------------------------------------------===
NLA modifications:
  - orig:           firrtl.hierpath @path_component_old [@Top::@foo, @Foo::@bar1, @Bar::@b]
    new:            firrtl.nla @path_component_old [#hw.innerNameRef<@Top::@foo>, #hw.innerNameRef<@Foo::@b>]
    dead:           0
    isDead:         0
    isLocal:        0
    inlinedSymbols: [3]
    flattenPoint:   -1
    renames:
  - orig:           firrtl.hierpath @path_component_new [@Top::@foo, @Foo::@bar1, @Bar]
    new:            
    dead:           1
    isDead:         1
    isLocal:        0
    inlinedSymbols: [3]
    flattenPoint:   -1
    renames:
===--------------------------------------------------------------------------===
module {
  firrtl.circuit ""Top""  {
    firrtl.hierpath @path_component_old [@Top::@foo, @Foo::@b]
    firrtl.module private @Foo() {
      %bar1_b = firrtl.wire sym @b   {annotations = [{circt.nonlocal = @path_component_old, path_component_old}]} : !firrtl.uint<1>
      %bar2_b = firrtl.wire sym @b_0   : !firrtl.uint<1>
    }
    firrtl.module @Top() {
      firrtl.instance foo sym @foo  @Foo()
    }
  }
}",,,,,,,,
3307,"ModuleInliner: Finish removing reliance on breadcrumbs, currently broken in some situations",2022-06-09T00:20:34Z,closed,"bug, FIRRTL","## Summary

Currently, the inliner can do the wrong thing in various scenarios due to expecting/relying on the presence of breadcrumbs.
This is not good, because we haven't created those breadcrumbs since before 1.0 .

Examples below involve HierPath's that use symbols that conflict after inlining.

## Example 1

For example, this input file causes an error:

```scala
circuit Inline : %[[
  {
    ""class"": ""firrtl.passes.InlineAnnotation"",
    ""target"": ""~Inline|Foo""
  },
  {
    ""class"":""testing"",
    ""target"":""~Inline|Inline/foo:Foo/bar:Bar>i""
  },
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Inline|Inline>bar""
  }
]]
  module Inline:
    input i: UInt<1>
    output o: UInt<1>

    inst foo of Foo
    wire bar: UInt<1>

    foo.i <- bar
    bar <- i
    o <- foo.o


  module Bar:
    input i: UInt
    output o: UInt

    o <- i

  module Foo:
    input i: UInt
    output o: UInt

    inst bar of Bar

    bar.i <- i
    o <- bar.o
```

Which produces the following error when running `firtool` on it (verifier after the inliner runs):

```console
<unknown>:0: error: 'firrtl.hierpath' op  module: ""Inline"" does not contain any instance with symbol: ""bar""
<unknown>:0: note: see current operation: ""firrtl.hierpath""() {namepath = [#hw.innerNameRef<@Inline::@bar>, #hw.innerNameRef<@Bar::@i>], sym_name = ""nla_1""} : () -> ()
```

## Example 2

As a variant of the above example, it's possible to cause the inliner to do the wrong thing but not have an error-- causing the annotation to have the wrong path:

```scala
circuit Inline : %[[
  {
    ""class"": ""firrtl.passes.InlineAnnotation"",
    ""target"": ""~Inline|Foo""
  },
  {
    ""class"":""test_1"",
    ""target"":""~Inline|Inline/foo:Foo/bar:Bar>i""
  },
  {
    ""class"":""test_2"",
    ""target"":""~Inline|Inline/bar:Bar>i""
  }
]]
  module Inline:
    input i: UInt<1>
    output o: UInt<1>

    inst foo of Foo
    inst bar of Bar

    foo.i <- bar.i
    bar.i <- i
    o <- foo.o


  module Bar:
    input i: UInt
    output o: UInt

    o <- i

  module Foo:
    input i: UInt
    output o: UInt

    inst bar of Bar

    bar.i <- i
    o <- bar.o
```

Here's the MLIR before/after Inliner runs:

**Before**:
```mlir
firrtl.circuit ""Inline""  {
  firrtl.hierpath @nla_2 [@Inline::@bar, @Bar::@i]
  firrtl.hierpath @nla_1 [@Inline::@foo, @Foo::@bar, @Bar::@i]
  firrtl.module @Inline(in %i: !firrtl.uint<1>, out %o: !firrtl.uint<1>) {
    %foo_i, %foo_o = firrtl.instance foo sym @foo  @Foo(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)
    %bar_i, %bar_o = firrtl.instance bar sym @bar  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)
    firrtl.strictconnect %foo_i, %bar_i : !firrtl.uint<1>
    firrtl.strictconnect %bar_i, %i : !firrtl.uint<1>
    firrtl.strictconnect %o, %foo_o : !firrtl.uint<1>
  }
  firrtl.module private @Bar(in %i: !firrtl.uint<1> sym @i [{circt.nonlocal = @nla_1, class = ""test_1""}, {circt.nonlocal = @nla_2, class = ""test_2""}], out %o: !firrtl.uint<1>) {
    firrtl.strictconnect %o, %i : !firrtl.uint<1>
  }
  firrtl.module private @Foo(in %i: !firrtl.uint<1>, out %o: !firrtl.uint<1>) attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
    %bar_i, %bar_o = firrtl.instance bar sym @bar  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)
    firrtl.strictconnect %bar_i, %i : !firrtl.uint<1>
    firrtl.strictconnect %o, %bar_o : !firrtl.uint<1>
  }
}
```

**After**:
```mlir
firrtl.circuit ""Inline""  {
  firrtl.hierpath @nla_2 [@Inline::@bar, @Bar::@i]
  firrtl.hierpath @nla_1 [@Inline::@bar, @Bar::@i]
  firrtl.module @Inline(in %i: !firrtl.uint<1>, out %o: !firrtl.uint<1>) {
    %foo_i = firrtl.wire  : !firrtl.uint<1>
    %foo_o = firrtl.wire  : !firrtl.uint<1>
    %foo_bar_i, %foo_bar_o = firrtl.instance foo_bar sym @bar_0  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)
    firrtl.strictconnect %foo_bar_i, %foo_i : !firrtl.uint<1>
    firrtl.strictconnect %foo_o, %foo_bar_o : !firrtl.uint<1>
    %bar_i, %bar_o = firrtl.instance bar sym @bar  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)
    firrtl.strictconnect %foo_i, %bar_i : !firrtl.uint<1>
    firrtl.strictconnect %bar_i, %i : !firrtl.uint<1>
    firrtl.strictconnect %o, %foo_o : !firrtl.uint<1>
  }
  firrtl.module private @Bar(in %i: !firrtl.uint<1> sym @i [{circt.nonlocal = @nla_1, class = ""test_1""}, {circt.nonlocal = @nla_2, class = ""test_2""}], out %o: !firrtl.uint<1>) {
    firrtl.strictconnect %o, %i : !firrtl.uint<1>
  }
}
```

Notice how after inlining, `nla_1` and `nla_2` are the same path, instead of `nla_1` going via `bar_0`.

## Notes

This issue can be observed after updating the inliner test to not have the breadcrumbs (1771b1eb687a6a3ed255d3a34b724ff02791b98c for example, although that test will still fail after fixing this in the FileCheck portion because I haven't finished updating it to also not /look/ for updated breadcrumbs).  Finishing removing breadcrumbs from the tests is probably a good idea (to root out this sort of issue elsewhere), but the Inliner test seems to have most of the breadcrumbs-in-test-code presently.

When fixing this, check for other things that might be wrong (hopefully nothing not covered by above examples(!) and tests, but for example dropping NLA's that seem unused or mishandling local/non-local).

Updating the Inliner for the new+improved HierPath style for NLA's may be blocked by this (at least being confident the result works).","circuit Inline : %[[
  {
    ""class"": ""firrtl.passes.InlineAnnotation"",
    ""target"": ""~Inline|Foo""
  },
  {
    ""class"":""testing"",
    ""target"":""~Inline|Inline/foo:Foo/bar:Bar>i""
  },
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Inline|Inline>bar""
  }
]]
  module Inline:
    input i: UInt<1>
    output o: UInt<1>

    inst foo of Foo
    wire bar: UInt<1>

    foo.i <- bar
    bar <- i
    o <- foo.o


  module Bar:
    input i: UInt
    output o: UInt

    o <- i

  module Foo:
    input i: UInt
    output o: UInt

    inst bar of Bar

    bar.i <- i
    o <- bar.o","<unknown>:0: error: 'firrtl.hierpath' op  module: ""Inline"" does not contain any instance with symbol: ""bar""
<unknown>:0: note: see current operation: ""firrtl.hierpath""() {namepath = [#hw.innerNameRef<@Inline::@bar>, #hw.innerNameRef<@Bar::@i>], sym_name = ""nla_1""} : () -> ()","circuit Inline : %[[
  {
    ""class"": ""firrtl.passes.InlineAnnotation"",
    ""target"": ""~Inline|Foo""
  },
  {
    ""class"":""test_1"",
    ""target"":""~Inline|Inline/foo:Foo/bar:Bar>i""
  },
  {
    ""class"":""test_2"",
    ""target"":""~Inline|Inline/bar:Bar>i""
  }
]]
  module Inline:
    input i: UInt<1>
    output o: UInt<1>

    inst foo of Foo
    inst bar of Bar

    foo.i <- bar.i
    bar.i <- i
    o <- foo.o


  module Bar:
    input i: UInt
    output o: UInt

    o <- i

  module Foo:
    input i: UInt
    output o: UInt

    inst bar of Bar

    bar.i <- i
    o <- bar.o","firrtl.circuit ""Inline""  {
  firrtl.hierpath @nla_2 [@Inline::@bar, @Bar::@i]
  firrtl.hierpath @nla_1 [@Inline::@foo, @Foo::@bar, @Bar::@i]
  firrtl.module @Inline(in %i: !firrtl.uint<1>, out %o: !firrtl.uint<1>) {
    %foo_i, %foo_o = firrtl.instance foo sym @foo  @Foo(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)
    %bar_i, %bar_o = firrtl.instance bar sym @bar  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)
    firrtl.strictconnect %foo_i, %bar_i : !firrtl.uint<1>
    firrtl.strictconnect %bar_i, %i : !firrtl.uint<1>
    firrtl.strictconnect %o, %foo_o : !firrtl.uint<1>
  }
  firrtl.module private @Bar(in %i: !firrtl.uint<1> sym @i [{circt.nonlocal = @nla_1, class = ""test_1""}, {circt.nonlocal = @nla_2, class = ""test_2""}], out %o: !firrtl.uint<1>) {
    firrtl.strictconnect %o, %i : !firrtl.uint<1>
  }
  firrtl.module private @Foo(in %i: !firrtl.uint<1>, out %o: !firrtl.uint<1>) attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
    %bar_i, %bar_o = firrtl.instance bar sym @bar  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)
    firrtl.strictconnect %bar_i, %i : !firrtl.uint<1>
    firrtl.strictconnect %o, %bar_o : !firrtl.uint<1>
  }
}","firrtl.circuit ""Inline""  {
  firrtl.hierpath @nla_2 [@Inline::@bar, @Bar::@i]
  firrtl.hierpath @nla_1 [@Inline::@bar, @Bar::@i]
  firrtl.module @Inline(in %i: !firrtl.uint<1>, out %o: !firrtl.uint<1>) {
    %foo_i = firrtl.wire  : !firrtl.uint<1>
    %foo_o = firrtl.wire  : !firrtl.uint<1>
    %foo_bar_i, %foo_bar_o = firrtl.instance foo_bar sym @bar_0  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)
    firrtl.strictconnect %foo_bar_i, %foo_i : !firrtl.uint<1>
    firrtl.strictconnect %foo_o, %foo_bar_o : !firrtl.uint<1>
    %bar_i, %bar_o = firrtl.instance bar sym @bar  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)
    firrtl.strictconnect %foo_i, %bar_i : !firrtl.uint<1>
    firrtl.strictconnect %bar_i, %i : !firrtl.uint<1>
    firrtl.strictconnect %o, %foo_o : !firrtl.uint<1>
  }
  firrtl.module private @Bar(in %i: !firrtl.uint<1> sym @i [{circt.nonlocal = @nla_1, class = ""test_1""}, {circt.nonlocal = @nla_2, class = ""test_2""}], out %o: !firrtl.uint<1>) {
    firrtl.strictconnect %o, %i : !firrtl.uint<1>
  }
}",,,,,
3268,[StandardToHandshake] Passing `memref` to a function will still use `memref.alloc` ,2022-06-03T11:12:50Z,open,"bug, Handshake","Passing the following code to `--lower-std-to-handshake` produces a weird output.

```mlir
func.func @external_mem(%mem : memref<4xi32>) {
  return
}

func.func @normal_mem() {
  %mem = memref.alloc() : memref<4xi32>
  func.call @external_mem(%mem) : (memref<4xi32>) -> ()
  return
}
```

Output:

```mlir
handshake.func @external_mem(%arg0: memref<4xi32>, %arg1: none, ...) -> none attributes {argNames = [""in0"", ""inCtrl""], resNames = [""outCtrl""]} {
  extmemory[ld = 0, st = 0] (%arg0 : memref<4xi32>) () {id = 0 : i32} : () -> ()
  return %arg1 : none
 }
handshake.func @normal_mem(%arg0: none, ...) -> none attributes {argNames = [""inCtrl""], resNames = [""outCtrl""]} {
  %0:2 = fork [2] %arg0 : none
  %1 = memref.alloc() : memref<4xi32>
  %2 = instance @external_mem(%1, %0#0) : (memref<4xi32>, none) -> none
  sink %2 : none
  return %0#1 : none
}
```

As you can see, a `memref.alloc()` remains, which is not expected and thus breaks further transformations. 

I would expect that a correct lowering would construct a `MemoryOp` in the `@normal_mem` function. How this exactly interacts with the external memory op is not clear to me, as this will cause cross function dependencies depending on the amount of memory operations in `@external_mem`.","func.func @external_mem(%mem : memref<4xi32>) {
  return
}

func.func @normal_mem() {
  %mem = memref.alloc() : memref<4xi32>
  func.call @external_mem(%mem) : (memref<4xi32>) -> ()
  return
}","handshake.func @external_mem(%arg0: memref<4xi32>, %arg1: none, ...) -> none attributes {argNames = [""in0"", ""inCtrl""], resNames = [""outCtrl""]} {
  extmemory[ld = 0, st = 0] (%arg0 : memref<4xi32>) () {id = 0 : i32} : () -> ()
  return %arg1 : none
 }
handshake.func @normal_mem(%arg0: none, ...) -> none attributes {argNames = [""inCtrl""], resNames = [""outCtrl""]} {
  %0:2 = fork [2] %arg0 : none
  %1 = memref.alloc() : memref<4xi32>
  %2 = instance @external_mem(%1, %0#0) : (memref<4xi32>, none) -> none
  sink %2 : none
  return %0#1 : none
}",,,,,,,,
3261,[FIRRTL] Lower Types Not Lowering Annotation-less Symbols,2022-06-02T20:14:26Z,closed,"bug, FIRRTL","Consider:

```mlir
firrtl.circuit ""Foo"" {
  firrtl.hierpath @nla_a [@Foo::@bar, @Bar::@a]
  firrtl.module @Bar() {
    %a = firrtl.wire sym @a : !firrtl.bundle<a: uint<1>>
  }
  firrtl.module @Foo() {
    firrtl.instance bar sym @bar @Bar()
  }
}
```

This is currently being lowered, by `LowerTypes`, to:
```mlir
firrtl.circuit ""Foo"" {
  firrtl.hierpath @nla_a [@Foo::@bar, @Bar::@a]
  firrtl.module @Bar() {
    %a_a = firrtl.wire sym @a_a : !firrtl.uint<1>
  }
  firrtl.module @Foo() {
    firrtl.instance bar sym @bar @Bar()
  }
}
```

This then trips hierarchical path verification because the `@a` symbol was not updated to `@a_a`. The logic inside `LowerTypes` is only lowering symbols that participate in an annotation which isn't correct.","firrtl.circuit ""Foo"" {
  firrtl.hierpath @nla_a [@Foo::@bar, @Bar::@a]
  firrtl.module @Bar() {
    %a = firrtl.wire sym @a : !firrtl.bundle<a: uint<1>>
  }
  firrtl.module @Foo() {
    firrtl.instance bar sym @bar @Bar()
  }
}","firrtl.circuit ""Foo"" {
  firrtl.hierpath @nla_a [@Foo::@bar, @Bar::@a]
  firrtl.module @Bar() {
    %a_a = firrtl.wire sym @a_a : !firrtl.uint<1>
  }
  firrtl.module @Foo() {
    firrtl.instance bar sym @bar @Bar()
  }
}",,,,,,,,
3257,[StandardToHandshake] External memory lowering produces code with multiple uses. ,2022-06-02T12:30:25Z,closed,"bug, Handshake","Lowering the following IR with `--lowert-std-to-handshake` produces invalid code.

```mlir
func.func @sub(%mem : memref<1xi32>) {
  %i = arith.constant 0 : index
  %val = memref.load %mem[%i] : memref<1xi32>
  return
}
```

Output:

```mlir
  handshake.func @foo(%arg0: memref<1xi32>, %arg1: none, ...) -> none attributes {argNames = [""in0"", ""inCtrl""], resNames = [""outCtrl""]} {
    %0:2 = extmemory[ld = 1, st = 0] (%arg0 : memref<1xi32>) (%addressResults) {id = 0 : i32} : (index) -> (i32, none)
    sink %arg0 : memref<1xi32>
    %1:2 = fork [2] %arg1 : none
    %2:2 = fork [2] %1#1 : none
    %3 = join %2#1, %0#1 : none
    %4 = constant %2#0 {value = 0 : index} : index
    %dataResult, %addressResults = load [%4] %0#0, %1#0 : index, i32
    sink %dataResult : i32
    return %3 : none
  }
```

As you can see, the memref argument `%arg0` has multiple uses which is not allowed in handshake. 

Furthermore, the documentation mentions that an interface for all loads and stores should be added, which is not the case:

> An ExternalMemoryOp represents a wrapper around a memref input to a handshake function. The semantics of the load/store operands are identical to what is decribed for MemoryOp. The only difference is that the first operand to this operand is a memref value. Upon lowering to FIRRTL, a handshake interface will be created in the top-level component for each load- and store which connected to this memory.

Was this just no implemented fully? 

Partially related to #3256 ","func.func @sub(%mem : memref<1xi32>) {
  %i = arith.constant 0 : index
  %val = memref.load %mem[%i] : memref<1xi32>
  return
}","handshake.func @foo(%arg0: memref<1xi32>, %arg1: none, ...) -> none attributes {argNames = [""in0"", ""inCtrl""], resNames = [""outCtrl""]} {
    %0:2 = extmemory[ld = 1, st = 0] (%arg0 : memref<1xi32>) (%addressResults) {id = 0 : i32} : (index) -> (i32, none)
    sink %arg0 : memref<1xi32>
    %1:2 = fork [2] %arg1 : none
    %2:2 = fork [2] %1#1 : none
    %3 = join %2#1, %0#1 : none
    %4 = constant %2#0 {value = 0 : index} : index
    %dataResult, %addressResults = load [%4] %0#0, %1#0 : index, i32
    sink %dataResult : i32
    return %3 : none
  }",,,,,,,,
3256,[StandardToHandshake] Handing unused external memory. ,2022-06-02T11:54:04Z,closed,"bug, Handshake","The following IR causes the `--convert-std-to-handshake` pass to produce a segfault.

```mlir
module {
  func.func @foo(%mem : memref<1xi32>) {
    return
  }
}
```

The cause is `https://github.com/llvm/circt/blob/main/lib/Conversion/StandardToHandshake/StandardToHandshake.cpp#L1457` because there is no such thing as a ""defining op"".

This can obviously be circumvented by checking if it's a `BlockArgument` and then continuing the loop. While the fix stops the pass from crashing and thus produces the following, the conversion to FIRRTL crashes afterwards.

```mlir
handshake.func @foo(%arg0: memref<1xi32>, %arg1: none, ...) -> none attributes {argNames = [""in0"", ""inCtrl""], resNames = [""outCtrl""]} {
  sink %arg0 : memref<1xi32>
  return %arg1 : none
}

```

`HandshakeToFIRRTL` assumes that each memref which is passed to a function is feed into a `extmemory` operation, which is not the case here. 
How should I fix that? By introducing an extra check that will ignore this case when then `memref` is directly pushed into a sink?","module {
  func.func @foo(%mem : memref<1xi32>) {
    return
  }
}","handshake.func @foo(%arg0: memref<1xi32>, %arg1: none, ...) -> none attributes {argNames = [""in0"", ""inCtrl""], resNames = [""outCtrl""]} {
  sink %arg0 : memref<1xi32>
  return %arg1 : none
}",,,,,,,,
3240,[FIRRTL] Grand Central Views/Taps Should Not Block Deduplication,2022-05-29T05:27:10Z,open,"bug, FIRRTL","The dead wire taps added to GCT Views and Data Taps are causing problems with deduplication. Specifically, the dead wire taps can block deduplication because they are IR operations. A GCT view or tap should not block deduplication.

## Example

Consider the following circuit.  In this, there are two submodules and _only one_ is tapped via a Grand Central View on wire `_w`:

```scala
circuit Top :
  module Submodule :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>
    output out : UInt<1>

    wire _w : UInt<1> 
    _w <= in 
    out <= _w 

  module Submodule_1 :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>
    output out : UInt<1>

    wire _w : UInt<1> 
    _w <= in 
    out <= _w 

  module MyView_companion :

    wire _WIRE : UInt<1>
    _WIRE <= UInt<1>(""h0"")

  module Top :
    input clock : Clock
    input reset : UInt<1>
    input in : UInt<1>
    output out : UInt<1>

    inst sub1 of Submodule 
    sub1.clock <= clock
    sub1.reset <= reset
    inst sub2 of Submodule_1 
    sub2.clock <= clock
    sub2.reset <= reset
    sub1.in <= in 
    sub2.in <= in 
    node _out_T = xor(sub1.out, sub2.out) 
    out <= _out_T 
    inst MyView_companion of MyView_companion 
```

The corresponding annotation file is:
```json
[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|MyView_companion>_WIRE""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"":""MyView"",
    ""companion"":""~Top|MyView_companion"",
    ""parent"":""~Top|Top"",
    ""view"":""{\""class\"":\""sifive.enterprise.grandcentral.AugmentedBundleType\"",\""defName\"":\""MyInterface\"",\""elements\"":[{\""name\"":\""tap1\"",\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.AugmentedGroundType\"",\""ref\"":{\""circuit\"":\""Top\"",\""module\"":\""Top\"",\""path\"":[{\""_1\"":{\""class\"":\""firrtl.annotations.TargetToken$Instance\"",\""value\"":\""sub1\""},\""_2\"":{\""class\"":\""firrtl.annotations.TargetToken$OfModule\"",\""value\"":\""Submodule\""}}],\""ref\"":\""_w\"",\""component\"":[]},\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\""}}}]}""
  },
  {
    ""class"":""firrtl.transforms.NoDedupAnnotation"",
    ""target"":""~Top|MyView_companion""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""builds/gct-tests/DedupOneTap/firrtl/gct"",
    ""filename"":""builds/gct-tests/DedupOneTap/firrtl/bindings.sv""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation"",
    ""filename"":""builds/gct-tests/DedupOneTap/firrtl/gct/gct.yaml""
  },
  {
    ""class"":""firrtl.stage.RunFirrtlTransformAnnotation"",
    ""transform"":""sifive.enterprise.grandcentral.GrandCentralTransform""
  },
  {
    ""class"":""firrtl.stage.RunFirrtlTransformAnnotation"",
    ""transform"":""sifive.enterprise.firrtl.ExtractTestCodeTransform""
  }
]
```

When compiled, this currently produces two copies of the submodule due to the `_gctTap` which causes them to differ.

The output Verilog currently is:

```verilog
module Submodule(
  input  in,
  output out);

  wire _gctTap;

  assign _gctTap = in;
  assign out = in;
endmodule

module Submodule_1(
  input  in,
  output out);

  assign out = in;
endmodule

module Top(
  input  clock,
         reset,
         in,
  output out);

  wire _sub2_out;
  wire _sub1_out;

  // This interface is elsewhere emitted as a bind statement.
  // MyInterface MyView();
  Submodule sub1 (
    .in  (in),
    .out (_sub1_out)
  );
  Submodule_1 sub2 (
    .in  (in),
    .out (_sub2_out)
  );
  /* This instance is elsewhere emitted as a bind statement.
    MyView_companion MyView_companion ();
  */
  assign out = _sub1_out ^ _sub2_out;
endmodule
```","circuit Top :
  module Submodule :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>
    output out : UInt<1>

    wire _w : UInt<1> 
    _w <= in 
    out <= _w 

  module Submodule_1 :
    input clock : Clock
    input reset : Reset
    input in : UInt<1>
    output out : UInt<1>

    wire _w : UInt<1> 
    _w <= in 
    out <= _w 

  module MyView_companion :

    wire _WIRE : UInt<1>
    _WIRE <= UInt<1>(""h0"")

  module Top :
    input clock : Clock
    input reset : UInt<1>
    input in : UInt<1>
    output out : UInt<1>

    inst sub1 of Submodule 
    sub1.clock <= clock
    sub1.reset <= reset
    inst sub2 of Submodule_1 
    sub2.clock <= clock
    sub2.reset <= reset
    sub1.in <= in 
    sub2.in <= in 
    node _out_T = xor(sub1.out, sub2.out) 
    out <= _out_T 
    inst MyView_companion of MyView_companion","[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|MyView_companion>_WIRE""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation"",
    ""name"":""MyView"",
    ""companion"":""~Top|MyView_companion"",
    ""parent"":""~Top|Top"",
    ""view"":""{\""class\"":\""sifive.enterprise.grandcentral.AugmentedBundleType\"",\""defName\"":\""MyInterface\"",\""elements\"":[{\""name\"":\""tap1\"",\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.AugmentedGroundType\"",\""ref\"":{\""circuit\"":\""Top\"",\""module\"":\""Top\"",\""path\"":[{\""_1\"":{\""class\"":\""firrtl.annotations.TargetToken$Instance\"",\""value\"":\""sub1\""},\""_2\"":{\""class\"":\""firrtl.annotations.TargetToken$OfModule\"",\""value\"":\""Submodule\""}}],\""ref\"":\""_w\"",\""component\"":[]},\""tpe\"":{\""class\"":\""sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\""}}}]}""
  },
  {
    ""class"":""firrtl.transforms.NoDedupAnnotation"",
    ""target"":""~Top|MyView_companion""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""builds/gct-tests/DedupOneTap/firrtl/gct"",
    ""filename"":""builds/gct-tests/DedupOneTap/firrtl/bindings.sv""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation"",
    ""filename"":""builds/gct-tests/DedupOneTap/firrtl/gct/gct.yaml""
  },
  {
    ""class"":""firrtl.stage.RunFirrtlTransformAnnotation"",
    ""transform"":""sifive.enterprise.grandcentral.GrandCentralTransform""
  },
  {
    ""class"":""firrtl.stage.RunFirrtlTransformAnnotation"",
    ""transform"":""sifive.enterprise.firrtl.ExtractTestCodeTransform""
  }
]","module Submodule(
  input  in,
  output out);

  wire _gctTap;

  assign _gctTap = in;
  assign out = in;
endmodule

module Submodule_1(
  input  in,
  output out);

  assign out = in;
endmodule

module Top(
  input  clock,
         reset,
         in,
  output out);

  wire _sub2_out;
  wire _sub1_out;

  // This interface is elsewhere emitted as a bind statement.
  // MyInterface MyView();
  Submodule sub1 (
    .in  (in),
    .out (_sub1_out)
  );
  Submodule_1 sub2 (
    .in  (in),
    .out (_sub2_out)
  );
  /* This instance is elsewhere emitted as a bind statement.
    MyView_companion MyView_companion ();
  */
  assign out = _sub1_out ^ _sub2_out;
endmodule",,,,,,,
3112,[StaticLogicToCalyx] Unused group in execution schedule.,2022-05-12T05:18:32Z,closed,"bug, Calyx","```mlir
// test.mlir
func.func @func(%A: memref<4xi32>, %B: memref<4xi32>, %R: memref<4xi32>) {
  affine.for %i = 0 to 4 {
    %5 = affine.load %A[%i] : memref<4xi32>
    %6 = affine.load %B[%i] : memref<4xi32>
    %7 = arith.muli %5, %6 : i32
    affine.store %7, %R[%i] : memref<4xi32>
  }
  return
}
```

```
 ./build/bin/circt-opt -convert-affine-to-staticlogic test.mlir | ./build/bin/circt-opt --lower-scf-to-calyx
```

```mlir
module {
  func.func @func(%arg0: memref<4xi32>, %arg1: memref<4xi32>, %arg2: memref<4xi32>) {
    %c0 = arith.constant 0 : index
    %c4 = arith.constant 4 : index
    %c1 = arith.constant 1 : index
    staticlogic.pipeline.while II =  1 trip_count =  4 iter_args(%arg3 = %c0) : (index) -> () {
      %0 = arith.cmpi ult, %arg3, %c4 : index
      staticlogic.pipeline.register %0 : i1
    } do {
      %0:3 = staticlogic.pipeline.stage start = 0 {
        %2 = memref.load %arg0[%arg3] : memref<4xi32>
        %3 = memref.load %arg1[%arg3] : memref<4xi32>
        %4 = arith.addi %arg3, %c1 : index
        staticlogic.pipeline.register %2, %3, %4 : i32, i32, index
      } : i32, i32, index
      %1 = staticlogic.pipeline.stage start = 1 {
        %2 = arith.muli %0#0, %0#1 : i32
        staticlogic.pipeline.register %2 : i32
      } : i32
      staticlogic.pipeline.stage start = 4 {
        memref.store %1, %arg2[%arg3] : memref<4xi32>
        staticlogic.pipeline.register 
      }
      staticlogic.pipeline.terminator iter_args(%0#2), results() : (index) -> ()
    }
    return
  }
}
```

```mlir
""builtin.module""() ({
  ""calyx.program""() ({
    ""calyx.component""() ({
    ^bb0(%arg0: i32, %arg1: i1, %arg2: i32, %arg3: i1, %arg4: i32, %arg5: i1, %arg6: i1, %arg7: i1, %arg8: i1, %arg9: i32, %arg10: i2, %arg11: i1, %arg12: i32, %arg13: i2, %arg14: i1, %arg15: i32, %arg16: i2, %arg17: i1, %arg18: i1):
      %0 = ""hw.constant""() {value = 1 : i32} : () -> i32
      %1 = ""hw.constant""() {value = 4 : i32} : () -> i32
      %2 = ""hw.constant""() {value = 0 : i32} : () -> i32
      %3 = ""hw.constant""() {value = true} : () -> i1
      %4:2 = ""calyx.std_slice""() {sym_name = ""std_slice_2""} : () -> (i32, i2)
      %5:2 = ""calyx.std_slice""() {sym_name = ""std_slice_1""} : () -> (i32, i2)
      %6:2 = ""calyx.std_slice""() {sym_name = ""std_slice_0""} : () -> (i32, i2)
      %7:7 = ""calyx.std_mult_pipe""() {sym_name = ""std_mult_pipe_0""} : () -> (i1, i1, i1, i32, i32, i32, i1)
      %8:3 = ""calyx.std_add""() {sym_name = ""std_add_0""} : () -> (i32, i32, i32)
      %9:3 = ""calyx.std_lt""() {sym_name = ""std_lt_0""} : () -> (i32, i32, i1)
      %10:6 = ""calyx.register""() {sym_name = ""stage_1_register_0_reg""} : () -> (i32, i1, i1, i1, i32, i1)
      %11:6 = ""calyx.register""() {sym_name = ""stage_0_register_1_reg""} : () -> (i32, i1, i1, i1, i32, i1)
      %12:6 = ""calyx.register""() {sym_name = ""stage_0_register_0_reg""} : () -> (i32, i1, i1, i1, i32, i1)
      %13:6 = ""calyx.register""() {sym_name = ""while_0_arg0_reg""} : () -> (i32, i1, i1, i1, i32, i1)
      ""calyx.wires""() ({
        ""calyx.group""() ({
          ""calyx.assign""(%13#0, %2) : (i32, i32) -> ()
          ""calyx.assign""(%13#1, %3) : (i1, i1) -> ()
          ""calyx.group_done""(%13#5) : (i1) -> ()
        }) {sym_name = ""assign_while_0_init_0""} : () -> ()
        ""calyx.comb_group""() ({
          ""calyx.assign""(%9#0, %13#4) : (i32, i32) -> ()
          ""calyx.assign""(%9#1, %1) : (i32, i32) -> ()
        }) {sym_name = ""bb0_0""} : () -> ()
        ""calyx.group""() ({
          ""calyx.assign""(%4#0, %13#4) : (i32, i32) -> ()
          ""calyx.assign""(%arg10, %4#1) : (i2, i2) -> ()
          ""calyx.assign""(%12#0, %arg0) : (i32, i32) -> ()
          ""calyx.assign""(%12#1, %3) : (i1, i1) -> ()
          ""calyx.group_done""(%12#5) : (i1) -> ()
        }) {sym_name = ""bb0_1""} : () -> ()
        ""calyx.group""() ({
          ""calyx.assign""(%5#0, %13#4) : (i32, i32) -> ()
          ""calyx.assign""(%arg13, %5#1) : (i2, i2) -> ()
          ""calyx.assign""(%11#0, %arg2) : (i32, i32) -> ()
          ""calyx.assign""(%11#1, %3) : (i1, i1) -> ()
          ""calyx.group_done""(%11#5) : (i1) -> ()
        }) {sym_name = ""bb0_2""} : () -> ()
        ""calyx.group""() ({
          ""calyx.assign""(%8#0, %13#4) : (i32, i32) -> ()
          ""calyx.assign""(%8#1, %0) : (i32, i32) -> ()
          ""calyx.assign""(%13#0, %8#2) : (i32, i32) -> ()
          ""calyx.assign""(%13#1, %3) : (i1, i1) -> ()
          ""calyx.group_done""(%13#5) : (i1) -> ()
        }) {sym_name = ""bb0_3""} : () -> ()
        ""calyx.group""() ({
          ""calyx.assign""(%7#3, %12#4) : (i32, i32) -> ()
          ""calyx.assign""(%7#4, %11#4) : (i32, i32) -> ()
          ""calyx.assign""(%10#0, %7#5) : (i32, i32) -> ()
          ""calyx.assign""(%10#1, %7#6) : (i1, i1) -> ()
          ""calyx.assign""(%7#2, %3) : (i1, i1) -> ()
          ""calyx.group_done""(%10#5) : (i1) -> ()
        }) {sym_name = ""bb0_4""} : () -> ()
        ""calyx.group""() ({
          ""calyx.assign""(%6#0, %13#4) : (i32, i32) -> ()
          ""calyx.assign""(%arg16, %6#1) : (i2, i2) -> ()
          ""calyx.assign""(%arg15, %10#4) : (i32, i32) -> ()
          ""calyx.assign""(%arg17, %3) : (i1, i1) -> ()
          ""calyx.group_done""(%arg5) : (i1) -> ()
        }) {sym_name = ""bb0_5""} : () -> ()
      }) : () -> ()
      ""calyx.control""() ({
        ""calyx.seq""() ({
          ""calyx.par""() ({./bin/circt-opt --lower-scf-to-calyx
            ""calyx.enable""() {groupName = @assign_while_0_init_0} : () -> ()
          }) : () -> ()
          ""calyx.par""() ({
            ""calyx.enable""() {groupName = @bb0_1} : () -> ()
            ""calyx.enable""() {groupName = @bb0_2} : () -> ()
            ""calyx.enable""() {groupName = @bb0_3} : () -> ()
          }) : () -> ()
          ""calyx.par""() ({
            ""calyx.enable""() {groupName = @bb0_1} : () -> ()
            ""calyx.enable""() {groupName = @bb0_2} : () -> ()
            ""calyx.enable""() {groupName = @bb0_3} : () -> ()
            ""calyx.enable""() {groupName = @bb0_4} : () -> ()
          }) : () -> ()
          ""calyx.while""(%9#2) ({
            ""calyx.par""() ({
              ""calyx.enable""() {groupName = @bb0_1} : () -> ()
              ""calyx.enable""() {groupName = @bb0_2} : () -> ()
              ""calyx.enable""() {groupName = @bb0_3} : () -> ()
              ""calyx.enable""() {groupName = @bb0_4} : () -> ()
            }) : () -> ()
          }) {bound = 2 : i64, groupName = @bb0_0} : (i1) -> ()
          ""calyx.par""() ({
            ""calyx.enable""() {groupName = @bb0_4} : () -> ()
          }) : () -> ()
        }) : () -> ()
      }) : () -> ()
    }) {function_type = (i32, i1, i32, i1, i32, i1, i1, i1, i1, i32, i2, i1, i32, i2, i1, i32, i2, i1, i1) -> (), portAttributes = [{mem = {id = 0 : i32, tag = ""read_data""}}, {mem = {id = 0 : i32, tag = ""done""}}, {mem = {id = 1 : i32, tag = ""read_data""}}, {mem = {id = 1 : i32, tag = ""done""}}, {mem = {id = 2 : i32, tag = ""read_data""}}, {mem = {id = 2 : i32, tag = ""done""}}, {clk}, {reset}, {go}, {mem = {id = 0 : i32, tag = ""write_data""}}, {mem = {addr_idx = 0 : i32, id = 0 : i32, tag = ""addr""}}, {mem = {id = 0 : i32, tag = ""write_en""}}, {mem = {id = 1 : i32, tag = ""write_data""}}, {mem = {addr_idx = 0 : i32, id = 1 : i32, tag = ""addr""}}, {mem = {id = 1 : i32, tag = ""write_en""}}, {mem = {id = 2 : i32, tag = ""write_data""}}, {mem = {addr_idx = 0 : i32, id = 2 : i32, tag = ""addr""}}, {mem = {id = 2 : i32, tag = ""write_en""}}, {done}], portDirections = -512 : i19, portNames = [""ext_mem0_read_data"", ""ext_mem0_done"", ""ext_mem1_read_data"", ""ext_mem1_done"", ""ext_mem2_read_data"", ""ext_mem2_done"", ""clk"", ""reset"", ""go"", ""ext_mem0_write_data"", ""ext_mem0_addr0"", ""ext_mem0_write_en"", ""ext_mem1_write_data"", ""ext_mem1_addr0"", ""ext_mem1_write_en"", ""ext_mem2_write_data"", ""ext_mem2_addr0"", ""ext_mem2_write_en"", ""done""], sym_name = ""func"", toplevel} : () -> ()
  }) {entryPointName = ""func""} : () -> ()
}) : () -> ()
```

```
<stdin>:21:9: error: 'calyx.group' op with name: ""bb0_5"" is unused in the control execution schedule
        memref.store %1, %arg2[%arg3] : memref<4xi32>
```","// test.mlir
func.func @func(%A: memref<4xi32>, %B: memref<4xi32>, %R: memref<4xi32>) {
  affine.for %i = 0 to 4 {
    %5 = affine.load %A[%i] : memref<4xi32>
    %6 = affine.load %B[%i] : memref<4xi32>
    %7 = arith.muli %5, %6 : i32
    affine.store %7, %R[%i] : memref<4xi32>
  }
  return
}",./build/bin/circt-opt -convert-affine-to-staticlogic test.mlir | ./build/bin/circt-opt --lower-scf-to-calyx,"module {
  func.func @func(%arg0: memref<4xi32>, %arg1: memref<4xi32>, %arg2: memref<4xi32>) {
    %c0 = arith.constant 0 : index
    %c4 = arith.constant 4 : index
    %c1 = arith.constant 1 : index
    staticlogic.pipeline.while II =  1 trip_count =  4 iter_args(%arg3 = %c0) : (index) -> () {
      %0 = arith.cmpi ult, %arg3, %c4 : index
      staticlogic.pipeline.register %0 : i1
    } do {
      %0:3 = staticlogic.pipeline.stage start = 0 {
        %2 = memref.load %arg0[%arg3] : memref<4xi32>
        %3 = memref.load %arg1[%arg3] : memref<4xi32>
        %4 = arith.addi %arg3, %c1 : index
        staticlogic.pipeline.register %2, %3, %4 : i32, i32, index
      } : i32, i32, index
      %1 = staticlogic.pipeline.stage start = 1 {
        %2 = arith.muli %0#0, %0#1 : i32
        staticlogic.pipeline.register %2 : i32
      } : i32
      staticlogic.pipeline.stage start = 4 {
        memref.store %1, %arg2[%arg3] : memref<4xi32>
        staticlogic.pipeline.register 
      }
      staticlogic.pipeline.terminator iter_args(%0#2), results() : (index) -> ()
    }
    return
  }
}","""builtin.module""() ({
  ""calyx.program""() ({
    ""calyx.component""() ({
    ^bb0(%arg0: i32, %arg1: i1, %arg2: i32, %arg3: i1, %arg4: i32, %arg5: i1, %arg6: i1, %arg7: i1, %arg8: i1, %arg9: i32, %arg10: i2, %arg11: i1, %arg12: i32, %arg13: i2, %arg14: i1, %arg15: i32, %arg16: i2, %arg17: i1, %arg18: i1):
      %0 = ""hw.constant""() {value = 1 : i32} : () -> i32
      %1 = ""hw.constant""() {value = 4 : i32} : () -> i32
      %2 = ""hw.constant""() {value = 0 : i32} : () -> i32
      %3 = ""hw.constant""() {value = true} : () -> i1
      %4:2 = ""calyx.std_slice""() {sym_name = ""std_slice_2""} : () -> (i32, i2)
      %5:2 = ""calyx.std_slice""() {sym_name = ""std_slice_1""} : () -> (i32, i2)
      %6:2 = ""calyx.std_slice""() {sym_name = ""std_slice_0""} : () -> (i32, i2)
      %7:7 = ""calyx.std_mult_pipe""() {sym_name = ""std_mult_pipe_0""} : () -> (i1, i1, i1, i32, i32, i32, i1)
      %8:3 = ""calyx.std_add""() {sym_name = ""std_add_0""} : () -> (i32, i32, i32)
      %9:3 = ""calyx.std_lt""() {sym_name = ""std_lt_0""} : () -> (i32, i32, i1)
      %10:6 = ""calyx.register""() {sym_name = ""stage_1_register_0_reg""} : () -> (i32, i1, i1, i1, i32, i1)
      %11:6 = ""calyx.register""() {sym_name = ""stage_0_register_1_reg""} : () -> (i32, i1, i1, i1, i32, i1)
      %12:6 = ""calyx.register""() {sym_name = ""stage_0_register_0_reg""} : () -> (i32, i1, i1, i1, i32, i1)
      %13:6 = ""calyx.register""() {sym_name = ""while_0_arg0_reg""} : () -> (i32, i1, i1, i1, i32, i1)
      ""calyx.wires""() ({
        ""calyx.group""() ({
          ""calyx.assign""(%13#0, %2) : (i32, i32) -> ()
          ""calyx.assign""(%13#1, %3) : (i1, i1) -> ()
          ""calyx.group_done""(%13#5) : (i1) -> ()
        }) {sym_name = ""assign_while_0_init_0""} : () -> ()
        ""calyx.comb_group""() ({
          ""calyx.assign""(%9#0, %13#4) : (i32, i32) -> ()
          ""calyx.assign""(%9#1, %1) : (i32, i32) -> ()
        }) {sym_name = ""bb0_0""} : () -> ()
        ""calyx.group""() ({
          ""calyx.assign""(%4#0, %13#4) : (i32, i32) -> ()
          ""calyx.assign""(%arg10, %4#1) : (i2, i2) -> ()
          ""calyx.assign""(%12#0, %arg0) : (i32, i32) -> ()
          ""calyx.assign""(%12#1, %3) : (i1, i1) -> ()
          ""calyx.group_done""(%12#5) : (i1) -> ()
        }) {sym_name = ""bb0_1""} : () -> ()
        ""calyx.group""() ({
          ""calyx.assign""(%5#0, %13#4) : (i32, i32) -> ()
          ""calyx.assign""(%arg13, %5#1) : (i2, i2) -> ()
          ""calyx.assign""(%11#0, %arg2) : (i32, i32) -> ()
          ""calyx.assign""(%11#1, %3) : (i1, i1) -> ()
          ""calyx.group_done""(%11#5) : (i1) -> ()
        }) {sym_name = ""bb0_2""} : () -> ()
        ""calyx.group""() ({
          ""calyx.assign""(%8#0, %13#4) : (i32, i32) -> ()
          ""calyx.assign""(%8#1, %0) : (i32, i32) -> ()
          ""calyx.assign""(%13#0, %8#2) : (i32, i32) -> ()
          ""calyx.assign""(%13#1, %3) : (i1, i1) -> ()
          ""calyx.group_done""(%13#5) : (i1) -> ()
        }) {sym_name = ""bb0_3""} : () -> ()
        ""calyx.group""() ({
          ""calyx.assign""(%7#3, %12#4) : (i32, i32) -> ()
          ""calyx.assign""(%7#4, %11#4) : (i32, i32) -> ()
          ""calyx.assign""(%10#0, %7#5) : (i32, i32) -> ()
          ""calyx.assign""(%10#1, %7#6) : (i1, i1) -> ()
          ""calyx.assign""(%7#2, %3) : (i1, i1) -> ()
          ""calyx.group_done""(%10#5) : (i1) -> ()
        }) {sym_name = ""bb0_4""} : () -> ()
        ""calyx.group""() ({
          ""calyx.assign""(%6#0, %13#4) : (i32, i32) -> ()
          ""calyx.assign""(%arg16, %6#1) : (i2, i2) -> ()
          ""calyx.assign""(%arg15, %10#4) : (i32, i32) -> ()
          ""calyx.assign""(%arg17, %3) : (i1, i1) -> ()
          ""calyx.group_done""(%arg5) : (i1) -> ()
        }) {sym_name = ""bb0_5""} : () -> ()
      }) : () -> ()
      ""calyx.control""() ({
        ""calyx.seq""() ({
          ""calyx.par""() ({./bin/circt-opt --lower-scf-to-calyx
            ""calyx.enable""() {groupName = @assign_while_0_init_0} : () -> ()
          }) : () -> ()
          ""calyx.par""() ({
            ""calyx.enable""() {groupName = @bb0_1} : () -> ()
            ""calyx.enable""() {groupName = @bb0_2} : () -> ()
            ""calyx.enable""() {groupName = @bb0_3} : () -> ()
          }) : () -> ()
          ""calyx.par""() ({
            ""calyx.enable""() {groupName = @bb0_1} : () -> ()
            ""calyx.enable""() {groupName = @bb0_2} : () -> ()
            ""calyx.enable""() {groupName = @bb0_3} : () -> ()
            ""calyx.enable""() {groupName = @bb0_4} : () -> ()
          }) : () -> ()
          ""calyx.while""(%9#2) ({
            ""calyx.par""() ({
              ""calyx.enable""() {groupName = @bb0_1} : () -> ()
              ""calyx.enable""() {groupName = @bb0_2} : () -> ()
              ""calyx.enable""() {groupName = @bb0_3} : () -> ()
              ""calyx.enable""() {groupName = @bb0_4} : () -> ()
            }) : () -> ()
          }) {bound = 2 : i64, groupName = @bb0_0} : (i1) -> ()
          ""calyx.par""() ({
            ""calyx.enable""() {groupName = @bb0_4} : () -> ()
          }) : () -> ()
        }) : () -> ()
      }) : () -> ()
    }) {function_type = (i32, i1, i32, i1, i32, i1, i1, i1, i1, i32, i2, i1, i32, i2, i1, i32, i2, i1, i1) -> (), portAttributes = [{mem = {id = 0 : i32, tag = ""read_data""}}, {mem = {id = 0 : i32, tag = ""done""}}, {mem = {id = 1 : i32, tag = ""read_data""}}, {mem = {id = 1 : i32, tag = ""done""}}, {mem = {id = 2 : i32, tag = ""read_data""}}, {mem = {id = 2 : i32, tag = ""done""}}, {clk}, {reset}, {go}, {mem = {id = 0 : i32, tag = ""write_data""}}, {mem = {addr_idx = 0 : i32, id = 0 : i32, tag = ""addr""}}, {mem = {id = 0 : i32, tag = ""write_en""}}, {mem = {id = 1 : i32, tag = ""write_data""}}, {mem = {addr_idx = 0 : i32, id = 1 : i32, tag = ""addr""}}, {mem = {id = 1 : i32, tag = ""write_en""}}, {mem = {id = 2 : i32, tag = ""write_data""}}, {mem = {addr_idx = 0 : i32, id = 2 : i32, tag = ""addr""}}, {mem = {id = 2 : i32, tag = ""write_en""}}, {done}], portDirections = -512 : i19, portNames = [""ext_mem0_read_data"", ""ext_mem0_done"", ""ext_mem1_read_data"", ""ext_mem1_done"", ""ext_mem2_read_data"", ""ext_mem2_done"", ""clk"", ""reset"", ""go"", ""ext_mem0_write_data"", ""ext_mem0_addr0"", ""ext_mem0_write_en"", ""ext_mem1_write_data"", ""ext_mem1_addr0"", ""ext_mem1_write_en"", ""ext_mem2_write_data"", ""ext_mem2_addr0"", ""ext_mem2_write_en"", ""done""], sym_name = ""func"", toplevel} : () -> ()
  }) {entryPointName = ""func""} : () -> ()
}) : () -> ()","<stdin>:21:9: error: 'calyx.group' op with name: ""bb0_5"" is unused in the control execution schedule
        memref.store %1, %arg2[%arg3] : memref<4xi32>",,,,,
3111," lower-scf-to-calyx => valueGroupAssigns.end() && ""No group evaluating value!""' failed",2022-05-12T02:21:20Z,closed,"bug, Calyx","When lowering lower-scf-to-calyx I'm getting:

circt-opt --allow-unregistered-dialect --lower-scf-to-calyx  -o=test_memory_3_calyx.mlir  test_memory_3_staticlogic.mlir

circt-opt: /mnt/scratch/tools/github/circt/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp:331: TGroupOp circt::ComponentLoweringState::getEvaluatingGroup(mlir::Value) [with TGroupOp = circt::calyx::GroupInterface]: Assertion `it != valueGroupAssigns.end() && ""No group evaluating value!""' failed.
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.      Program arguments: /mnt/scratch/tools/github/circt/build/bin/circt-opt --allow-unregistered-dialect --lower-scf-to-calyx -o=polygeist_circt_calyx/test_memory_3_calyx.mlir polygeist_circt_calyx/test_memory_3_staticlogic.mlir
 #0 0x00007fa78919b405 PrintStackTraceSignalHandler(void*) Signals.cpp:0:0
 #1 0x00007fa789198a84 SignalHandler(int) Signals.cpp:0:0
 #2 0x00007fa788a07520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)
 #3 0x00007fa788a5ba7c __pthread_kill_implementation ./nptl/./nptl/pthread_kill.c:44:76
 #4 0x00007fa788a5ba7c __pthread_kill_internal ./nptl/./nptl/pthread_kill.c:78:10
 #5 0x00007fa788a5ba7c pthread_kill ./nptl/./nptl/pthread_kill.c:89:10
 #6 0x00007fa788a07476 gsignal ./signal/../sysdeps/posix/raise.c:27:6
 #7 0x00007fa7889ed7f3 abort ./stdlib/./stdlib/abort.c:81:7
 #8 0x00007fa7889ed71b _nl_load_domain ./intl/./intl/loadmsgcat.c:1177:9
 #9 0x00007fa7889fee96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)
#10 0x00005652a5a0561f circt::BuildPipelineGroups::buildStageGroups(circt::staticlogic::PipelineWhileOp, circt::staticlogic::PipelineStageOp, mlir::Patte
[test_memory_3.zip](https://github.com/llvm/circt/files/8674539/test_memory_3.zip)
rnRewriter&) const (/mnt/scratch/tools/github/circt/build/bin/circt-opt+0x5d461f)
#11 0x00005652a5a05de5 circt::BuildPipelineGroups::PartiallyLowerFuncToComp(mlir::func::FuncOp, mlir::PatternRewriter&) const (/mnt/scratch/tools/github/circt/build/bin/circt-opt+0x5d4de5)
#12 0x00005652a59e845e circt::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const (/mnt/scratch/tools/github/circt/build/bin/circt-opt+0x5b745e)
#13 0x00007fa78949df6d mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIRRewrite.so.15git+0x4ff6d)
#14 0x00007fa7895086a1 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) (.constprop.0) GreedyPatternRewriteDriver.cpp:0:0
#15 0x00007fa78950a7b3 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIRTransformUtils.so.15git+0x607b3)
#16 0x00005652a59eb151 circt::SCFToCalyxPass::runOnOperation() (/mnt/scratch/tools/github/circt/build/bin/circt-opt+0x5ba151)
#17 0x00007fa78942b19a mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIRPass.so.15git+0x2c19a)
#18 0x00007fa78942b8c0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIRPass.so.15git+0x2c8c0)
#19 0x00007fa78942cbe4 mlir::PassManager::run(mlir::Operation*) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIRPass.so.15git+0x2dbe4)
#20 0x00007fa78a23215d performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>) (.constprop.0) MlirOptMain.cpp:0:0
#21 0x00007fa78a2324c1 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) MlirOptMain.cpp:0:0
#22 0x00007fa78a232970 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIROptLib.so.15git+0x7970)
#23 0x00007fa78a234742 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIROptLib.so.15git+0x9742)
#24 0x00005652a547ca3c main (/mnt/scratch/tools/github/circt/build/bin/circt-opt+0x4ba3c)
#25 0x00007fa7889eed90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16
#26 0x00007fa7889eee40 call_init ./csu/../csu/libc-start.c:128:20
#27 0x00007fa7889eee40 __libc_start_main ./csu/../csu/libc-start.c:379:5
#28 0x00005652a547cd75 _start (/mnt/scratch/tools/github/circt/build/bin/circt-opt+0x4bd75)
",,,,,,,,,,
3105,[FIRRTL] ExtractInstances wrapper module name is not prefixed,2022-05-11T14:49:40Z,open,"bug, FIRRTL","The optional wrapper modules that `ExtractInstances` can generate (e.g. through the `group` field in `ExtractSeqMemsFileAnnotation`) do not get prefixed by `PrefixModules`. See `test/Dialect/FIRRTL/SFCTests/ExtractSeqMems/Compose.fir` for an example.

Doing the prefixing is not that simple, since ideally we would want prefixing to run before extraction. But extraction creates `sv.verbatim` ops with symbol references to modules which prefixing will invalidate. Alternatively one could go the route of GrandCentral views which also runs after prefixing, but where prefixing updates the annotations relevant for GCT views to contain the prefix. This is challenging for extraction though, since instances to be extracted are not all explicitly annotated, and whether or not a prefix has to be added to the wrapper module also depends on whether the location of the wrapper module is inside the area of effect of a prefix annotation.

Ideally we would make `PrefixInstances` update symbols appropriately (#3104) and make `sv.verbatim` robust under hierarchy modification. That would disentangle the ordering requirements of the passes and we could run extraction before prefixing.",,,,,,,,,,
3104,[FIRRTL] PrefixModules does not update symbols in sv.verbatim ops,2022-05-11T14:42:23Z,open,"bug, FIRRTL","The `PrefixModules` pass does not update uses of the old module symbol names to the renamed version. Occurs if a pass runs before prefixing that already generates verbatim nodes refering to modules through symbol placeholders (as we commonly do in metadata emission).

Getting this right might actually be harder than it looks at first glance, especially if modules have to be duplicated to account for instance-specific prefixing.",,,,,,,,,,
3097,[FIRRTL][CreateSiFiveMetadata] Should use symbol references in exported metadata,2022-05-11T03:41:17Z,closed,"bug, FIRRTL","The ForceNames annotation changes the name of modules after the creation of the verbatim ops, so we should be using symbol references to get the correct module names.

(this is just a tracking issue for a PR that is already open)",,,,,,,,,,
3093,[FIRRTL] Extract memory instances,2022-05-10T18:03:25Z,closed,"bug, FIRRTL","Extend the `ExtractInstances` pass such that it marks instances of the new `FMemModuleOp` as to be extracted. This then allows the pass to cover the functionality of the original `ExtractSeqMems` pass on the Scala side of things.

Fixes #3092.",,,,,,,,,,
3091,[FIRRTL] Uniquify extracted instance symbols,2022-05-10T16:48:45Z,closed,"bug, FIRRTL","Fix an issue in the `ExtractInstances` pass where certain diamond-shaped instantiation arrangements can lead to instances with identical symbol after extraction.

With this change, the pass uses `ModuleNamespace::newName` to ensure the instance symbol is unique within the module it is being extracted to. Fixing this also requires fixing an issue where a black box in a multiply instantiated parent would not properly filter its non-local annotations to only contain the ones that go through the parent instance it was pulled out of.

Fixes #3089.",,,,,,,,,,
3090,[FIRRTL] ExtractInstances duplicates NLAs without assigning new names,2022-05-10T14:52:23Z,open,"bug, FIRRTL","The following caveat is a problem: https://github.com/llvm/circt/blob/a9bdc67cf5bd9493b402c1ee18dca1f6c9766e28/lib/Dialect/FIRRTL/Transforms/ExtractInstances.cpp#L601-L620

In a nutshell: There are cases where `ExtractInstances` has to create multiple copies of an NLA during extraction, and currently it does not pick new names for those NLAs. Doing so is a bit cumbersome since the pass has to visit all instances along the NLA path and insert trackers for the newly-created NLAs there as well.

The case where this happens requires:
- An instance to be extracted that is nested somewhere within a multiply-instantiated module
- An NLA on that instance that is rooted at the multiply-instantiated module",,,,,,,,,,
3089,[FIRRTL] Conflicting extracted instance symbols in diamond-shaped instance graph,2022-05-10T14:48:22Z,closed,"bug, FIRRTL","The `ExtractInstances` pass can create situations where the top-level module ends up having multiple instances with the same symbol if the following conditions are met:
- Extracted instances are within a multiply-instantiated module
- Instances had a `inner_sym` already before extraction (e.g., because they were part of an NLA)

The pass should make sure that extracted instance symbols are uniquified, potentially updating the relevant NLAs.",,,,,,,,,,
3033,[FIRRTL] Dedup Should Work in Circuit Order,2022-05-03T22:37:08Z,open,"bug, FIRRTL","CIRCT deviates from the SFC because it is doing deduplication based on the instantiation order).  Instead, deduplication should use circuit order (declaration order).

Consider the following:

```scala
circuit Bar:
  module X:
    input a: UInt<1>
    output b: UInt<1>

    b <= not(a)
  module Y:
    input a: UInt<1>
    output b: UInt<1>

    b <= not(a)
  module Bar:
    input a: UInt<1>
    output b: UInt<1>

    inst y of Y
    inst x of X

    x.a <= a
    y.a <= a
    b <= xor(x.b, y.b)
```

This circuit, `Bar`, instantiates two modules that will deduplicate, `X` and `Y`. Module `Y` is instantiated before module `X`. However, `Y` should deduplicate into `X` because `X` is declared first.

Currently CIRCT produces (`firtool Bar.fir -dedup -strip-debug-info`):

```verilog
module Y(
  input  a,
  output b);

  assign b = ~a;
endmodule

module Bar(
  input  a,
  output b);

  wire _x_b;
  wire _y_b;

  Y y (
    .a (a),
    .b (_y_b)
  );
  Y x (
    .a (a),
    .b (_x_b)
  );
  assign b = _x_b ^ _y_b;
endmodule
```

SFC produces (`firrtl -i Bar.fir`):

```verilog
module X(
  input   a,
  output  b
);
  assign b = ~a;
endmodule
module Bar(
  input   a,
  output  b
);
  wire  y_a;
  wire  y_b;
  wire  x_a;
  wire  x_b;
  X y (
    .a(y_a),
    .b(y_b)
  );
  X x (
    .a(x_a),
    .b(x_b)
  );
  assign b = x_b ^ y_b;
  assign y_a = a;
  assign x_a = a;
endmodule
```","circuit Bar:
  module X:
    input a: UInt<1>
    output b: UInt<1>

    b <= not(a)
  module Y:
    input a: UInt<1>
    output b: UInt<1>

    b <= not(a)
  module Bar:
    input a: UInt<1>
    output b: UInt<1>

    inst y of Y
    inst x of X

    x.a <= a
    y.a <= a
    b <= xor(x.b, y.b)","module Y(
  input  a,
  output b);

  assign b = ~a;
endmodule

module Bar(
  input  a,
  output b);

  wire _x_b;
  wire _y_b;

  Y y (
    .a (a),
    .b (_y_b)
  );
  Y x (
    .a (a),
    .b (_x_b)
  );
  assign b = _x_b ^ _y_b;
endmodule","module X(
  input   a,
  output  b
);
  assign b = ~a;
endmodule
module Bar(
  input   a,
  output  b
);
  wire  y_a;
  wire  y_b;
  wire  x_a;
  wire  x_b;
  X y (
    .a(y_a),
    .b(y_b)
  );
  X x (
    .a(x_a),
    .b(x_b)
  );
  assign b = x_b ^ y_b;
  assign y_a = a;
  assign x_a = a;
endmodule",,,,,,,
2888,[FIRRTL] Don't Dedup Modules with Different NestedPrefixModulesAnnotation,2022-04-13T04:49:07Z,open,bug,"`NestedPrefixModulesAnnotation` with different prefixes should not deduplicate. This can be interpreted one of two ways, either of which should have the same effect:

1. `NestedPrefixModulesAnnotation` should block deduplication.
2. The `PrefixModules` pass should duplicate modules which have different prefixes.

SiFive's extensions to the SFC are implementing this using strategy (2).

An end-to-end test case that should work is the following:

```scala
circuit Foo: %[[
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""prefix"":""prefix1_"",
    ""inclusive"":true,
    ""target"":""~Foo|Bar""
  },
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""prefix"":""prefix2_"",
    ""inclusive"":true,
    ""target"":""~Foo|Baz""
  }
]]
  module Bar:
  module Baz:
  module Foo:
    inst bar of Bar
    inst baz of Baz
```

Currently, this produces (`firtool -dedup -strip-debug-info`):

```verilog
module prefix2_Bar();
endmodule

module Foo();
  prefix2_Bar bar ();
  prefix2_Bar baz ();
endmodule
```

This should produce:
```verilog
module prefix1_Bar();
endmodule

module prefix2_Baz();
endmodule

module Foo();
  prefix1_Bar bar ();
  prefix2_Baz baz ();
endmodule
```

There may also be an interaction here with memories where memories should not deduplicate if they have different prefixes.  This may be a little funky because it has interactions with the memory generator schema which may not respect prefixing.","circuit Foo: %[[
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""prefix"":""prefix1_"",
    ""inclusive"":true,
    ""target"":""~Foo|Bar""
  },
  {
    ""class"":""sifive.enterprise.firrtl.NestedPrefixModulesAnnotation"",
    ""prefix"":""prefix2_"",
    ""inclusive"":true,
    ""target"":""~Foo|Baz""
  }
]]
  module Bar:
  module Baz:
  module Foo:
    inst bar of Bar
    inst baz of Baz","module prefix2_Bar();
endmodule

module Foo();
  prefix2_Bar bar ();
  prefix2_Bar baz ();
endmodule","module prefix1_Bar();
endmodule

module prefix2_Baz();
endmodule

module Foo();
  prefix1_Bar bar ();
  prefix2_Baz baz ();
endmodule",,,,,,,
2859,[HWMemSimImpl] Fix randomization of wide memories,2022-04-07T08:56:54Z,closed,"bug, FIRRTL","The `HWMemSimImpl` pass currently generates SystemVerilog that some tools cannot parse properly in cases where the memory data width is not a multiple of the random value bit width (32). In those cases the randomization produces:

    reg [33:0] _RANDOM;
    _RANDOM = {{`RANDOM}[1:0], {`RANDOM}};

Some tools do not recognize ``` {`RANDOM}[1:0] ``` as a primary expression and mistake it for being part of the concatenation, only to then complain that this isn't proper concatenation syntax.

This commit changes the randomization code to put the part-select after the overall concatenation, in the hope that most tools will have an easier time identifying `{...}[1:0]` as a primary expression if it appears as the right-hand side of an assignment. This now produces:

    reg [33:0] _RANDOM;
    _RANDOM = {{`RANDOM}, {`RANDOM}}[33:0];",{`RANDOM}[1:0],,,,,,,,,
2858,[InferResets] Fix inference for zero-length vectors,2022-04-07T06:06:57Z,closed,"bug, FIRRTL","When tracing resets through the design, the `InferResets` pass always uses the ID of the first vector element if it encounters a vector type. This is done to ensure that connections to an element of a vector affects the type inference of all the other elements too, since the pass can only pick a single reset type for the entire vector instead of individual types for each vector element.

This is problematic since it assumes that all vectors have at least one element, which may not be the case in practice. If such a vector is encountered, the field IDs get out of sync in weird ways if the vector is embedded in a bundle: when the bundle is asked to resolve a field ID to one of its fields, it treats the zero-length vector as actually having zero elements, such that forcibly asking for the first, non-existent element of that vector spills over into the next bundle field.

This commit changes the handling of vectors by always using the vector's self-referential field ID (i.e., the ID 0) to capture connections during reset tracing. Later in type updating, vectors correspondingly assume that a field ID 0 means that the vector element type is to be updated. This is not generally how field refs are supposed to work, but since the ID abuse is limited to this file we should be fine.

Fixes #2857.",,,,,,,,,,
2807,[FIRRTL] Infer type of mux with aggregate operands,2022-03-25T15:24:00Z,closed,"bug, FIRRTL","Extend the type inference for the `MuxPrimOp` to also support operands with aggregate types. The multiplexer is expected to return a widthless type when the two operands are of an integer type but with unknown widths, and the larger of the two otherwise (e.g., `UInt` for `UInt, UInt<42>`). This inference only occurred for ground types and did not recurse into vectors and bundles. This commit changes the type inference to perform a pairwise inference on the leaves of arbitrarily nested aggregates.

Fixes #2806.",,,,,,,,,,
2806,[FIRRTL] Mux Result Type Inference Asserting Out,2022-03-25T06:15:46Z,closed,"bug, FIRRTL","Consider the following circuit:
```scala
circuit Foo :
  module Foo :
    input a: UInt<1>[1]
    input b: UInt<32>[1]
    input sel: UInt<1>
    output c: UInt[1]

    c <= mux(sel, a, b)
```

This will currently cause MFC to error out with (`firtool Foo.fir`):
```
# firtool Foo.fir --verbose-pass-executions
Foo.fir:8:10: error: unknown types to mux
    c <= mux(sel, a, b)
         ^
```

The SFC will, however, compile this to:
```verilog
module Foo(
  input         a_0,
  input  [31:0] b_0,
  input         sel,
  output [31:0] c_0
);
  assign c_0 = sel ? {{31'd0}, a_0} : b_0;
endmodule
```

I'm currently seeing a failure for an internal design where this error is produced after `InferResets` when using a specific annotation file.  However, I expect that a solution to the circuit above will fix the problem for the internal design.","circuit Foo :
  module Foo :
    input a: UInt<1>[1]
    input b: UInt<32>[1]
    input sel: UInt<1>
    output c: UInt[1]

    c <= mux(sel, a, b)","# firtool Foo.fir --verbose-pass-executions
Foo.fir:8:10: error: unknown types to mux
    c <= mux(sel, a, b)
         ^","module Foo(
  input         a_0,
  input  [31:0] b_0,
  input         sel,
  output [31:0] c_0
);
  assign c_0 = sel ? {{31'd0}, a_0} : b_0;
endmodule",,,,,,,
2779,[FIRRTL] IMCP Issue with Register Reset,2022-03-17T03:24:47Z,closed,"bug, FIRRTL","IMCP is choosing to optimize a register with an invalidated reset to the reset value. This is causing a divergence with the Scala FIRRTL Compiler (SFC).

Consider:

```scala
circuit Foo :
  module Foo :
    input clock: Clock
    output b: UInt<1>

    inst bar of Bar
    bar.clock <= clock
    bar.a is invalid
    b <= bar.b
    
  module Bar :
    input clock : Clock
    input a: UInt<1>
    output b: UInt<1>

    reg r : UInt<1>, clock with: (reset => (a, UInt<1>(1)))
    r is invalid

    b <= r
```

CIRCT produces:

```verilog
module Foo(	// Foo.fir:2:10
  input  clock,
  output b);

  Bar bar ();	// Foo.fir:6:5
  assign b = 1'h1;	// Foo.fir:2:10, :6:5
endmodule
```

SFC produces:
```verilog
module Foo(
  input   clock,
  output  b
);
  assign b = 1'h0;
endmodule
```","circuit Foo :
  module Foo :
    input clock: Clock
    output b: UInt<1>

    inst bar of Bar
    bar.clock <= clock
    bar.a is invalid
    b <= bar.b
    
  module Bar :
    input clock : Clock
    input a: UInt<1>
    output b: UInt<1>

    reg r : UInt<1>, clock with: (reset => (a, UInt<1>(1)))
    r is invalid

    b <= r","module Foo(	// Foo.fir:2:10
  input  clock,
  output b);

  Bar bar ();	// Foo.fir:6:5
  assign b = 1'h1;	// Foo.fir:2:10, :6:5
endmodule","module Foo(
  input   clock,
  output  b
);
  assign b = 1'h0;
endmodule",,,,,,,
2767,[FIRRTL] GCT Mem Taps + Dedup Producing Invalid XMRs,2022-03-15T02:07:20Z,closed,"bug, FIRRTL","There is a bug in FIRRTL Dialect's Grand Central Taps transform where memory taps of deduplicated modules can produce invalid XMRs.

Consider the following:

```scala
circuit Top : %[[
  {
    ""class"":""firrtl.transforms.NoDedupAnnotation"",
    ""target"":""~Top|MemTap_1""
  },
  {
    ""class"":""firrtl.transforms.NoDedupAnnotation"",
    ""target"":""~Top|MemTap_2""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.MemTapAnnotation"",
    ""taps"":[
      ""Top.MemTap_1.mem[0]""
    ],
    ""source"":""~Top|Submodule_1>bar""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.MemTapAnnotation"",
    ""taps"":[
      ""Top.MemTap_2.mem[0]""
    ],
    ""source"":""~Top|Submodule_2>bar""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""builds/gct-taps/Simple/firrtl/gct"",
    ""filename"":""builds/gct-taps/Simple/firrtl/bindings.sv""
  }
]]
  module Submodule_1 :
    input clock : Clock
    input reset : UInt<1>
    output out: UInt<1>

    cmem bar : UInt<1>[1]
    infer mport out_MPORT = bar[UInt<1>(""h0"")], clock
    out <= out_MPORT

  module Submodule_2 :
    input clock : Clock
    input reset : UInt<1>
    output out : UInt<1>

    cmem bar : UInt<1>[1]
    infer mport out_MPORT = bar[UInt<1>(""h0"")], clock
    out <= out_MPORT

  extmodule MemTap_1 :
    output mem : UInt<1>[1]
    defname = MemTap

  extmodule MemTap_2 :
    output mem : UInt<1>[1]
    defname = MemTap

  module DUT :
    input clock : Clock
    input reset : UInt<1>
    output out : UInt<1>

    inst submodule_1 of Submodule_1
    submodule_1.clock <= clock
    submodule_1.reset <= reset

    inst submodule_2 of Submodule_2
    submodule_2.clock <= clock
    submodule_2.reset <= reset

    out <= or(submodule_1.out, submodule_2.out)

    inst mem_tap_MemTap_1 of MemTap_1
    mem_tap_MemTap_1.mem is invalid

    inst mem_tap_MemTap_2 of MemTap_2
    mem_tap_MemTap_2.mem is invalid

  module Top :
    input clock : Clock
    input reset : UInt<1>
    output out : UInt<1>

    inst dut of DUT
    dut.clock <= clock
    dut.reset <= reset
    out <= dut.out
```

You can compile this with into an output directory `gct-memtap`:

```
firtool gct-taps/Simple/firrtl/Top.fir --firrtl-grand-central --split-verilog -o gct-memtap
```

This can then be checked with Verilator using:

```
verilator -lint-only -f gct-memtap/filelist.f -Igct-memtap
```

With dedup enabled, the XMRs for the memory taps are incorrect:

```
%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_2_impl_0.sv:4:22: Can't find definition of 'submodule_2' in dotted scope/variable: 'Top.submodule_2'
    4 |   assign mem_0 = Top.submodule_2.bar.Memory[0];  
      |                      ^~~~~~~~~~~
        ... Known scopes under 'Top': dut
%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_2_impl_0.sv:4:34: Can't find definition of 'bar' in dotted scope/variable: 'Top.bar'
    4 |   assign mem_0 = Top.submodule_2.bar.Memory[0];  
      |                                  ^~~
        ... Known scopes under 'Top': dut
%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_1_impl_0.sv:4:22: Can't find definition of 'submodule_1' in dotted scope/variable: 'Top.submodule_1'
    4 |   assign mem_0 = Top.submodule_1.bar.Memory[0];  
      |                      ^~~~~~~~~~~
        ... Known scopes under 'Top': dut
%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_1_impl_0.sv:4:34: Can't find definition of 'bar' in dotted scope/variable: 'Top.bar'
    4 |   assign mem_0 = Top.submodule_1.bar.Memory[0];  
      |                                  ^~~
        ... Known scopes under 'Top': dut
%Error: Exiting due to 4 error(s)
```

Specifically, an invalid XMR is:

```verilog
assign mem_0 = Top.submodule_1.bar.Memory[0];
```

The XMR should be:

```verilog
assign mem_0 = DUT.submodule_1.bar.Memory[0];
```","circuit Top : %[[
  {
    ""class"":""firrtl.transforms.NoDedupAnnotation"",
    ""target"":""~Top|MemTap_1""
  },
  {
    ""class"":""firrtl.transforms.NoDedupAnnotation"",
    ""target"":""~Top|MemTap_2""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.MemTapAnnotation"",
    ""taps"":[
      ""Top.MemTap_1.mem[0]""
    ],
    ""source"":""~Top|Submodule_1>bar""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.MemTapAnnotation"",
    ""taps"":[
      ""Top.MemTap_2.mem[0]""
    ],
    ""source"":""~Top|Submodule_2>bar""
  },
  {
    ""class"":""sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation"",
    ""directory"":""builds/gct-taps/Simple/firrtl/gct"",
    ""filename"":""builds/gct-taps/Simple/firrtl/bindings.sv""
  }
]]
  module Submodule_1 :
    input clock : Clock
    input reset : UInt<1>
    output out: UInt<1>

    cmem bar : UInt<1>[1]
    infer mport out_MPORT = bar[UInt<1>(""h0"")], clock
    out <= out_MPORT

  module Submodule_2 :
    input clock : Clock
    input reset : UInt<1>
    output out : UInt<1>

    cmem bar : UInt<1>[1]
    infer mport out_MPORT = bar[UInt<1>(""h0"")], clock
    out <= out_MPORT

  extmodule MemTap_1 :
    output mem : UInt<1>[1]
    defname = MemTap

  extmodule MemTap_2 :
    output mem : UInt<1>[1]
    defname = MemTap

  module DUT :
    input clock : Clock
    input reset : UInt<1>
    output out : UInt<1>

    inst submodule_1 of Submodule_1
    submodule_1.clock <= clock
    submodule_1.reset <= reset

    inst submodule_2 of Submodule_2
    submodule_2.clock <= clock
    submodule_2.reset <= reset

    out <= or(submodule_1.out, submodule_2.out)

    inst mem_tap_MemTap_1 of MemTap_1
    mem_tap_MemTap_1.mem is invalid

    inst mem_tap_MemTap_2 of MemTap_2
    mem_tap_MemTap_2.mem is invalid

  module Top :
    input clock : Clock
    input reset : UInt<1>
    output out : UInt<1>

    inst dut of DUT
    dut.clock <= clock
    dut.reset <= reset
    out <= dut.out",firtool gct-taps/Simple/firrtl/Top.fir --firrtl-grand-central --split-verilog -o gct-memtap,verilator -lint-only -f gct-memtap/filelist.f -Igct-memtap,"%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_2_impl_0.sv:4:22: Can't find definition of 'submodule_2' in dotted scope/variable: 'Top.submodule_2'
    4 |   assign mem_0 = Top.submodule_2.bar.Memory[0];  
      |                      ^~~~~~~~~~~
        ... Known scopes under 'Top': dut
%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_2_impl_0.sv:4:34: Can't find definition of 'bar' in dotted scope/variable: 'Top.bar'
    4 |   assign mem_0 = Top.submodule_2.bar.Memory[0];  
      |                                  ^~~
        ... Known scopes under 'Top': dut
%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_1_impl_0.sv:4:22: Can't find definition of 'submodule_1' in dotted scope/variable: 'Top.submodule_1'
    4 |   assign mem_0 = Top.submodule_1.bar.Memory[0];  
      |                      ^~~~~~~~~~~
        ... Known scopes under 'Top': dut
%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_1_impl_0.sv:4:34: Can't find definition of 'bar' in dotted scope/variable: 'Top.bar'
    4 |   assign mem_0 = Top.submodule_1.bar.Memory[0];  
      |                                  ^~~
        ... Known scopes under 'Top': dut
%Error: Exiting due to 4 error(s)",assign mem_0 = Top.submodule_1.bar.Memory[0];,assign mem_0 = DUT.submodule_1.bar.Memory[0];,,,,
2763,[FIRRTL][LowerTypes] Lower Types is Broken for Implicit Truncation,2022-03-14T15:44:18Z,closed,"bug, FIRRTL","CIRCT is currently incorrectly erroring out during `LowerTypes` for circuits that have bulk connects with implicit truncations.

Consider the following:

```scala
circuit Foo:
  module Foo:
    input a: {a: UInt<10>}
    output b: {a: UInt<9>}

    b <= a
```

This current produces:
```
# firtool Foo.fir
Foo.fir:6:7: error: destination width 9 is not greater than or equal to source width 10
    b <= a
      ^
Foo.fir:6:7: note: see current operation: ""firrtl.connect""(%arg1, %arg0) : (!firrtl.uint<9>, !firrtl.uint<10>) -> ()
```

With the SFC, this happily accepts it:
```
# firrtl -i Foo.fir && cat Foo.v
module Foo(
  input  [9:0] a_a,
  output [8:0] b_a
);
  assign b_a = a_a[8:0];
endmodule
```","circuit Foo:
  module Foo:
    input a: {a: UInt<10>}
    output b: {a: UInt<9>}

    b <= a","# firtool Foo.fir
Foo.fir:6:7: error: destination width 9 is not greater than or equal to source width 10
    b <= a
      ^
Foo.fir:6:7: note: see current operation: ""firrtl.connect""(%arg1, %arg0) : (!firrtl.uint<9>, !firrtl.uint<10>) -> ()","# firrtl -i Foo.fir && cat Foo.v
module Foo(
  input  [9:0] a_a,
  output [8:0] b_a
);
  assign b_a = a_a[8:0];
endmodule",,,,,,,
2719,[FIRRTL] Dedup accesses bundle type out-of-bounds element,2022-03-03T14:29:18Z,closed,"bug, FIRRTL","I stumbled across the following bug today when I tried to reduce a test case for a different problem. Basically, when running the `module-externalizer` reduction, which tries to replace as many `firrtl.module` with `firrtl.extmodule` ops as possible, the dedup pass would start to trigger an assertion in `BundleType::getElementType`. I suspect this is somehow related to handling of extmodules, since regular modules didn't trigger the crash.

Here's the reduced test case:
```mlir
firrtl.circuit ""Foo""  {
  firrtl.extmodule @Bar(
    in clock: !firrtl.clock, out io: !firrtl.bundle<a: clock>)
  firrtl.extmodule @Baz(
    in clock: !firrtl.clock, out io: !firrtl.bundle<a flip: uint<1>, b flip: uint<16>, c: uint<1>>)
  firrtl.module @Foo() {
    %invalid_ui16 = firrtl.invalidvalue : !firrtl.uint<16>
    %bar_clock, %bar_io = firrtl.instance bar @Bar(
      in clock: !firrtl.clock, out io: !firrtl.bundle<a: clock>)
    %baz_clock, %baz_io = firrtl.instance baz @Baz(
      in clock: !firrtl.clock, out io: !firrtl.bundle<a flip: uint<1>, b flip: uint<16>, c: uint<1>>)
    %0 = firrtl.subfield %baz_io(1)
      : (!firrtl.bundle<a flip: uint<1>, b flip: uint<16>, c: uint<1>>) -> !firrtl.uint<16>
    firrtl.strictconnect %0, %invalid_ui16 : !firrtl.uint<16>
  }
}
```
Running this through dedup produces the following on my machine:
```
# circt-opt --firrtl-dedup
circt-opt: FIRRTLTypes.cpp:843: circt::firrtl::FIRRTLType circt::firrtl::BundleType::getElementType(size_t):
Assertion `index < getNumElements() && ""index must be less than number of fields in bundle""' failed.
[...]
Deduper::fixupReferences(mlir::Value, mlir::Type) Dedup.cpp:387:59
Deduper::fixupReferences(circt::firrtl::FModuleLike, mlir::Operation*) Dedup.cpp:449:25
Deduper::dedup(circt::firrtl::FModuleLike, circt::firrtl::FModuleLike) Dedup.cpp:233:3
```","firrtl.circuit ""Foo""  {
  firrtl.extmodule @Bar(
    in clock: !firrtl.clock, out io: !firrtl.bundle<a: clock>)
  firrtl.extmodule @Baz(
    in clock: !firrtl.clock, out io: !firrtl.bundle<a flip: uint<1>, b flip: uint<16>, c: uint<1>>)
  firrtl.module @Foo() {
    %invalid_ui16 = firrtl.invalidvalue : !firrtl.uint<16>
    %bar_clock, %bar_io = firrtl.instance bar @Bar(
      in clock: !firrtl.clock, out io: !firrtl.bundle<a: clock>)
    %baz_clock, %baz_io = firrtl.instance baz @Baz(
      in clock: !firrtl.clock, out io: !firrtl.bundle<a flip: uint<1>, b flip: uint<16>, c: uint<1>>)
    %0 = firrtl.subfield %baz_io(1)
      : (!firrtl.bundle<a flip: uint<1>, b flip: uint<16>, c: uint<1>>) -> !firrtl.uint<16>
    firrtl.strictconnect %0, %invalid_ui16 : !firrtl.uint<16>
  }
}","# circt-opt --firrtl-dedup
circt-opt: FIRRTLTypes.cpp:843: circt::firrtl::FIRRTLType circt::firrtl::BundleType::getElementType(size_t):
Assertion `index < getNumElements() && ""index must be less than number of fields in bundle""' failed.
[...]
Deduper::fixupReferences(mlir::Value, mlir::Type) Dedup.cpp:387:59
Deduper::fixupReferences(circt::firrtl::FModuleLike, mlir::Operation*) Dedup.cpp:449:25
Deduper::dedup(circt::firrtl::FModuleLike, circt::firrtl::FModuleLike) Dedup.cpp:233:3",,,,,,,,
2718,[firtool] Preserve Val Names Broken for Analog,2022-03-02T23:42:19Z,closed,"bug, FIRRTL","Chisel `val` name preservation, introduced in https://github.com/llvm/circt/pull/2676, has a bug where this will cause verification failures if there are analog types inside aggregates. 

Consider:
```scala
circuit Foo :
  module Foo :
    input a: {flip a: UInt<1>, b: Analog<1>}
    output b: {flip a: UInt<1>, b: Analog<1>}

    wire w: {flip a: UInt<1>, b: Analog<1>}
    w.a <= a.a

    b.a <= w.a
    attach(a.b, w.b, b.b)
```

With `firtool Foo.fir` the verifier errors out:
```
# firtool Foo.fir
./test.fir:6:5: error: analog types may not be connected
    wire w: {flip a: UInt<1>, b: Analog<1>}
    ^
./test.fir:6:5: note: see current operation: ""firrtl.connect""(%7, %4) : (!firrtl.bundle<a: uint<1>, b: analog<1>>, !firrtl.bundle<a flip: uint<1>, b: analog<1>>) -> ()
```

If the wire's type is not passive (it has flips), then it needs to be a wire and then it will try to bulk connect the wire, and you can't connect analog. The parser should be modified to use `attach` for leaves that are analog.","circuit Foo :
  module Foo :
    input a: {flip a: UInt<1>, b: Analog<1>}
    output b: {flip a: UInt<1>, b: Analog<1>}

    wire w: {flip a: UInt<1>, b: Analog<1>}
    w.a <= a.a

    b.a <= w.a
    attach(a.b, w.b, b.b)","# firtool Foo.fir
./test.fir:6:5: error: analog types may not be connected
    wire w: {flip a: UInt<1>, b: Analog<1>}
    ^
./test.fir:6:5: note: see current operation: ""firrtl.connect""(%7, %4) : (!firrtl.bundle<a: uint<1>, b: analog<1>>, !firrtl.bundle<a flip: uint<1>, b: analog<1>>) -> ()",,,,,,,,
2713,[FIRRTL] Dedup makes port NLAs point at the module,2022-03-02T16:27:00Z,closed,"bug, FIRRTL","Under certain circumstances, the deduplication pass changes NLAs pointing to a module port and makes them point at the surrounding module instead. After some `circt-reduce` and manual cleanup:
```mlir
firrtl.circuit ""Foo""  {
  firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b1>, #hw.innerNameRef<@Bar_43::@out>]
  firrtl.extmodule @Bar_42(out out: !firrtl.clock)
  firrtl.extmodule @Bar_43(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_1}])
  firrtl.module @Foo() {
    %b0_out = firrtl.instance b0 @Bar_42(out out: !firrtl.clock)
    %b1_out = firrtl.instance b1 sym @b1 
      {annotations = [{circt.nonlocal = @nla_1, class = ""circt.nonlocal""}]} @Bar_43(out out: !firrtl.clock)
  }
  // NLAs after `circt-opt --firrtl-dedup`:
  // firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b1>, @Bar_42]
}
```
Note how the last path segment of `@nla_1` changes from `#hw.innerNameRef<@Bar_43::@out>` to `@Bar_43`.

The behaviour seems to be limited to NLAs on modules that were dropped in favor of another, identical module. The following just defines three redundant modules with NLAs, and all but the first see this behaviour:
```mlir
firrtl.circuit ""Foo""  {
  firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b0>, #hw.innerNameRef<@Bar_42::@out>]
  firrtl.nla @nla_2 [#hw.innerNameRef<@Foo::@b1>, #hw.innerNameRef<@Bar_43::@out>]
  firrtl.nla @nla_3 [#hw.innerNameRef<@Foo::@b2>, #hw.innerNameRef<@Bar_44::@out>]
  firrtl.extmodule @Bar_42(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_1}])
  firrtl.extmodule @Bar_43(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_2}])
  firrtl.extmodule @Bar_44(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_3}])
  firrtl.module @Foo() {
    %b0_out = firrtl.instance b0 sym @b0
      {annotations = [{circt.nonlocal = @nla_1, class = ""circt.nonlocal""}]} @Bar_42(out out: !firrtl.clock)
    %b1_out = firrtl.instance b1 sym @b1
      {annotations = [{circt.nonlocal = @nla_2, class = ""circt.nonlocal""}]} @Bar_43(out out: !firrtl.clock)
    %b2_out = firrtl.instance b2 sym @b2
      {annotations = [{circt.nonlocal = @nla_3, class = ""circt.nonlocal""}]} @Bar_44(out out: !firrtl.clock)
  }
  // NLAs after `circt-opt --firrtl-dedup`:
  // firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b0>, #hw.innerNameRef<@Bar_42::@out>]
  // firrtl.nla @nla_2 [#hw.innerNameRef<@Foo::@b1>, @Bar_42]
  // firrtl.nla @nla_3 [#hw.innerNameRef<@Foo::@b2>, @Bar_42]
}
```","firrtl.circuit ""Foo""  {
  firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b1>, #hw.innerNameRef<@Bar_43::@out>]
  firrtl.extmodule @Bar_42(out out: !firrtl.clock)
  firrtl.extmodule @Bar_43(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_1}])
  firrtl.module @Foo() {
    %b0_out = firrtl.instance b0 @Bar_42(out out: !firrtl.clock)
    %b1_out = firrtl.instance b1 sym @b1 
      {annotations = [{circt.nonlocal = @nla_1, class = ""circt.nonlocal""}]} @Bar_43(out out: !firrtl.clock)
  }
  // NLAs after `circt-opt --firrtl-dedup`:
  // firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b1>, @Bar_42]
}","firrtl.circuit ""Foo""  {
  firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b0>, #hw.innerNameRef<@Bar_42::@out>]
  firrtl.nla @nla_2 [#hw.innerNameRef<@Foo::@b1>, #hw.innerNameRef<@Bar_43::@out>]
  firrtl.nla @nla_3 [#hw.innerNameRef<@Foo::@b2>, #hw.innerNameRef<@Bar_44::@out>]
  firrtl.extmodule @Bar_42(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_1}])
  firrtl.extmodule @Bar_43(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_2}])
  firrtl.extmodule @Bar_44(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_3}])
  firrtl.module @Foo() {
    %b0_out = firrtl.instance b0 sym @b0
      {annotations = [{circt.nonlocal = @nla_1, class = ""circt.nonlocal""}]} @Bar_42(out out: !firrtl.clock)
    %b1_out = firrtl.instance b1 sym @b1
      {annotations = [{circt.nonlocal = @nla_2, class = ""circt.nonlocal""}]} @Bar_43(out out: !firrtl.clock)
    %b2_out = firrtl.instance b2 sym @b2
      {annotations = [{circt.nonlocal = @nla_3, class = ""circt.nonlocal""}]} @Bar_44(out out: !firrtl.clock)
  }
  // NLAs after `circt-opt --firrtl-dedup`:
  // firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b0>, #hw.innerNameRef<@Bar_42::@out>]
  // firrtl.nla @nla_2 [#hw.innerNameRef<@Foo::@b1>, @Bar_42]
  // firrtl.nla @nla_3 [#hw.innerNameRef<@Foo::@b2>, @Bar_42]
}",,,,,,,,
2693,[FIRRTLToHW] Consider strictconnect for elimination,2022-02-25T16:18:07Z,closed,"bug, FIRRTL","The `LowerToHW` conversion uses the `tryEliminatingConnectsToValue` function to try and eliminate unnecessary connects to a value and replace all value uses with the connected value instead. This is used to avoid unnecessary `*.output` temporary wires when generating the `hw.output` lowering. That function only considers `ConnectOp` though, and any `StrictConnectOp` are left untouched. This commit extends the elimination to also consider `StrictConnectOp`, such that the lowered HW design contains fewer temporary wires.",,,,,,,,,,
2692,[FIRRTL] Honor NLAs in GCT data tap paths,2022-02-25T09:20:58Z,closed,"bug, FIRRTL","The Grand Central data/mem taps pass used guess which concrete instance of a wire or port a data/mem tap referred to, because the taps were local annotations (i.e., they did not mention a concrete instance that they applied to). Since we now *do* have support for non-local annotations, and passes like deduplication make ample use of them, the GCT pass should consider the additional path information provided by NLAs when generating the data tap wiring. This commit makes GCT leverage the path information in NLAs.

A concrete example would be a design with two instances:
```
module Top:
  inst foo of Foo
  inst bar of Foo
```
If the instance port `foo.a` is targeted as a reference data tap, the GCT pass would up until now consider `Top.foo.a` and `Top.bar.a` as possible paths to that port, essentially ignoring the concrete instance path provided by the NLA `foo.a` and instead finding all possible prefixes for `Foo.a` (note the reference to Foo the module, not foo the instance.) The pass would then pick among all possible prefixes the shortest one (or in case of a tie, the last shortest one), which in this case could lead to the data tap targeting `Top.bar.a`, instead of the specified `Top.foo.a`.

The solution is to actually consider the concrete NLA instance path if one is given, and use that to perform the tapping. Arguably, *all* GCT data taps should be local annotations, which would also allow us to get rid of a lot of hacky logic in the GCT pass. That requires upstream changes in Chisel first, though.

Fixes #2691.","module Top:
  inst foo of Foo
  inst bar of Foo",,,,,,,,,
2688,[FIRRTL] HW Attributes not Loaded?,2022-02-25T02:38:03Z,closed,"bug, FIRRTL","When running `circt-opt` with a lone pass that creates a `hw::InnerRefAttr` I can get MLIR to crash because the HW attributes aren't loaded.  (This is the same circuit as #2687, but with the bug in #2687 worked around by renaming `%0` to `%a`)

```mlir
firrtl.circuit ""Top""  {
  firrtl.module @Top() {
    %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
    %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)
  }
  firrtl.module @A(out %x: !firrtl.uint<1>) {
    %a = firrtl.wire  {annotations = [{class = ""hello""}]} : !firrtl.uint<1>
    %b = firrtl.node sym @b %a  : !firrtl.uint<1>
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %x, %a : !firrtl.uint<1>, !firrtl.uint<1>
  }
  firrtl.module @A_(out %x: !firrtl.uint<1>) {
    %a = firrtl.wire  : !firrtl.uint<1>
    %b = firrtl.node sym @b %a  : !firrtl.uint<1>
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %x, %a : !firrtl.uint<1>, !firrtl.uint<1>
  }
}
```

This then crashes when running `circt-opt --pass-pipeline='firrtl.circuit(firrtl-dedup)' dedup.mlir` with:

```
LLVM ERROR: can't create Attribute 'circt::hw::InnerRefAttr' because storage uniquer isn't initialized: the dialect was likely not loaded, or the attribute wasn't added with addAttributes<...>() in the Dialect::initialize() method.
```","firrtl.circuit ""Top""  {
  firrtl.module @Top() {
    %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
    %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)
  }
  firrtl.module @A(out %x: !firrtl.uint<1>) {
    %a = firrtl.wire  {annotations = [{class = ""hello""}]} : !firrtl.uint<1>
    %b = firrtl.node sym @b %a  : !firrtl.uint<1>
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %x, %a : !firrtl.uint<1>, !firrtl.uint<1>
  }
  firrtl.module @A_(out %x: !firrtl.uint<1>) {
    %a = firrtl.wire  : !firrtl.uint<1>
    %b = firrtl.node sym @b %a  : !firrtl.uint<1>
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %x, %a : !firrtl.uint<1>, !firrtl.uint<1>
  }
}","LLVM ERROR: can't create Attribute 'circt::hw::InnerRefAttr' because storage uniquer isn't initialized: the dialect was likely not loaded, or the attribute wasn't added with addAttributes<...>() in the Dialect::initialize() method.",,,,,,,,
2687,[FIRRTL] Dedup Creating Empty Symbols?,2022-02-25T02:34:39Z,closed,"bug, FIRRTL","I think FIRRTL's dedup can inadvertently create empty symbols (which then crash during printing).  Consider the following circuit where `%0` in `@A` and `@A_` are going to be deduped.  This results in an NLA that gets generated with, I think, the symbol `@""""` which will be empty:

```mlir
firrtl.circuit ""Top""  {
  firrtl.module @Top() {
    %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
    %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)
  }
  firrtl.module @A(out %x: !firrtl.uint<1>) {
    %0 = firrtl.wire  {annotations = [{class = ""hello""}]} : !firrtl.uint<1>
    %b = firrtl.node sym @b %0  : !firrtl.uint<1>
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %0, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %x, %0 : !firrtl.uint<1>, !firrtl.uint<1>
  }
  firrtl.module @A_(out %x: !firrtl.uint<1>) {
    %0 = firrtl.wire  : !firrtl.uint<1>
    %b = firrtl.node sym @b %0  : !firrtl.uint<1>
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %0, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %x, %0 : !firrtl.uint<1>, !firrtl.uint<1>
  }
}
```

The crash I'm seeing is:
```
# firtool dedup.mlir -ir-fir -dedup=1
module {
  firrtl.circuit ""Top""  {
    firrtl.nla @nla [#hw.innerNameRef<@Top::@a1>, Assertion failed: (!symbolRef.empty() && ""expected valid symbol reference""), function printSymbolReference, file AsmPrinter.cpp, line 1626.
```","firrtl.circuit ""Top""  {
  firrtl.module @Top() {
    %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
    %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)
  }
  firrtl.module @A(out %x: !firrtl.uint<1>) {
    %0 = firrtl.wire  {annotations = [{class = ""hello""}]} : !firrtl.uint<1>
    %b = firrtl.node sym @b %0  : !firrtl.uint<1>
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %0, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %x, %0 : !firrtl.uint<1>, !firrtl.uint<1>
  }
  firrtl.module @A_(out %x: !firrtl.uint<1>) {
    %0 = firrtl.wire  : !firrtl.uint<1>
    %b = firrtl.node sym @b %0  : !firrtl.uint<1>
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %0, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %x, %0 : !firrtl.uint<1>, !firrtl.uint<1>
  }
}","# firtool dedup.mlir -ir-fir -dedup=1
module {
  firrtl.circuit ""Top""  {
    firrtl.nla @nla [#hw.innerNameRef<@Top::@a1>, Assertion failed: (!symbolRef.empty() && ""expected valid symbol reference""), function printSymbolReference, file AsmPrinter.cpp, line 1626.",,,,,,,,
2665,[FIRParser] Flip assert predicate before applying modifiers,2022-02-21T15:38:40Z,closed,"bug, FIRRTL","When parsing printf-encoded assertions, the condition of the surrounding `when` has to be inverted in order to go from the fail-when-true polarity of the printf to the fail-when-false polarity of the assert. Predicate modifiers (currently just `trueOrIsX`) are formulated with respect to the assertion predicate, i.e., on the fail-when-false polarity. So a `trueOrIsX` modifier is supposed to add an additional pass case to the assertion if the condition is `X`. The parser currently applies predicate modifiers on the fail-when-true polarity, which is wrong. Move the predicate inversion upwards so it occurs before modifiers are applied.

Fixes #2653.",,,,,,,,,,
2588,[ExportVerilog] [PrepareForEmission] Invalid wire creation with disallowLocalVariables option,2022-02-06T06:55:48Z,closed,"bug, ExportVerilog","```mlir
// circt-opt -export-verilog %s
module attributes {circt.loweringOptions = ""disallowLocalVariables,verifLabels,emittedLineLength=240""} {
hw.module @Foo(%r: i1, %f: i1) -> (foo: i1) {
  %false = hw.constant false
  %reg = sv.reg sym @__reg__  : !hw.inout<i1>
  sv.initial {
    %3 = sv.read_inout %1 : !hw.inout<i1>
    %6 = comb.or %f, %3 : i1
    sv.if %3 {
      sv.passign %reg, %r : i1
    }
  }
  %0 = sv.read_inout %reg : !hw.inout<i1>
  %.io_writeVec.wire = sv.wire  : !hw.inout<array<1xi1>>
  %1 = sv.array_index_inout %.io_writeVec.wire[%false] : !hw.inout<array<1xi1>>, i1
  hw.output %0 : i1
}
}
```

```
<unknown>:0: error: invalid element for hw.inout type '!hw.inout<i1>'
circt-opt: ../llvm/llvm/../mlir/include/mlir/IR/StorageUniquerSupport.h:140: static ConcreteT mlir::detail::StorageUserBase<circt::hw::InOutType, mlir::Type, circt::hw::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get(mlir::MLIRContext *, Args...) [ConcreteT = circt::hw::InOutType, BaseT = mlir::Type, StorageT = circt::hw::detail::InOutTypeStorage, UniquerT = mlir::detail::TypeUniquer, Traits = <>, Args = <mlir::Type>]: Assertion `succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))' failed.
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ./bin/circt-opt -export-verilog ex.mlir
 #0 0x00000000005b2193 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/uenoku/dev/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:13
 #1 0x00000000005b02d0 llvm::sys::RunSignalHandlers() /home/uenoku/dev/circt/llvm/llvm/lib/Support/Signals.cpp:97:18
 #2 0x00000000005b27ca SignalHandler(int) /home/uenoku/dev/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #3 0x00007f4efc0901f0 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x141f0)
 #4 0x00007f4efbaeffbb raise ./signal/../sysdeps/unix/sysv/linux/raise.c:50:1
 #5 0x00007f4efbad5864 abort ./stdlib/abort.c:81:7
 #6 0x00007f4efbad5749 get_sysdep_segment_value ./intl/loadmsgcat.c:509:8
 #7 0x00007f4efbad5749 _nl_load_domain ./intl/loadmsgcat.c:970:34
 #8 0x00007f4efbae73d6 (/lib/x86_64-linux-gnu/libc.so.6+0x383d6)
 #9 0x00000000009bda70 mlir::detail::StorageUserBase<circt::hw::InOutType, mlir::Type, circt::hw::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::getImpl() const /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/StorageUniquerSupport.h:184:68
#10 0x00000000009bda70 circt::hw::InOutType::getElementType() const /home/uenoku/dev/circt/build/tools/circt/include/circt/Dialect/HW/HWTypes.cpp.inc:172:10
#11 0x0000000000a5a6c8 circt::sv::WireOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Type, mlir::StringAttr, mlir::StringAttr) /home/uenoku/dev/circt/lib/Dialect/SV/SVOps.cpp:1010:21
#12 0x00000000006bd41a circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type>(mlir::Location, mlir::Type&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Builders.h:431:16
#13 0x00000000006bbce7 lowerUsersToTemporaryWire(mlir::Operation&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/PrepareForEmission.cpp:229:28
#14 0x00000000006bbce7 circt::ExportVerilog::prepareHWModule(mlir::Block&, circt::LoweringOptions const&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/PrepareForEmission.cpp:541:7
#15 0x00000000006941ed mlir::LogicalResult mlir::failableParallelForEach<circt::hw::HWModuleOp*, void mlir::parallelForEach<circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71>(mlir::MLIRContext*, circt::hw::HWModuleOp*, circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&)::'lambda'(circt::hw::HWModuleOp*&&)>(mlir::MLIRContext*, circt::hw::HWModuleOp*, circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Threading.h:48:26
#16 0x00000000006941ed void mlir::parallelForEach<circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71>(mlir::MLIRContext*, circt::hw::HWModuleOp*, circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Threading.h:124:9
#17 0x00000000006941ed void mlir::parallelForEach<llvm::SmallVector<circt::hw::HWModuleOp, 6u>&, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71>(mlir::MLIRContext*, llvm::SmallVector<circt::hw::HWModuleOp, 6u>&, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Threading.h:136:3
#18 0x00000000006941ed prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:4370:3
```

Seems prepareForEmission tries to create temporary wires for inout operations with out-of-order uses.","// circt-opt -export-verilog %s
module attributes {circt.loweringOptions = ""disallowLocalVariables,verifLabels,emittedLineLength=240""} {
hw.module @Foo(%r: i1, %f: i1) -> (foo: i1) {
  %false = hw.constant false
  %reg = sv.reg sym @__reg__  : !hw.inout<i1>
  sv.initial {
    %3 = sv.read_inout %1 : !hw.inout<i1>
    %6 = comb.or %f, %3 : i1
    sv.if %3 {
      sv.passign %reg, %r : i1
    }
  }
  %0 = sv.read_inout %reg : !hw.inout<i1>
  %.io_writeVec.wire = sv.wire  : !hw.inout<array<1xi1>>
  %1 = sv.array_index_inout %.io_writeVec.wire[%false] : !hw.inout<array<1xi1>>, i1
  hw.output %0 : i1
}
}","<unknown>:0: error: invalid element for hw.inout type '!hw.inout<i1>'
circt-opt: ../llvm/llvm/../mlir/include/mlir/IR/StorageUniquerSupport.h:140: static ConcreteT mlir::detail::StorageUserBase<circt::hw::InOutType, mlir::Type, circt::hw::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get(mlir::MLIRContext *, Args...) [ConcreteT = circt::hw::InOutType, BaseT = mlir::Type, StorageT = circt::hw::detail::InOutTypeStorage, UniquerT = mlir::detail::TypeUniquer, Traits = <>, Args = <mlir::Type>]: Assertion `succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))' failed.
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ./bin/circt-opt -export-verilog ex.mlir
 #0 0x00000000005b2193 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/uenoku/dev/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:13
 #1 0x00000000005b02d0 llvm::sys::RunSignalHandlers() /home/uenoku/dev/circt/llvm/llvm/lib/Support/Signals.cpp:97:18
 #2 0x00000000005b27ca SignalHandler(int) /home/uenoku/dev/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #3 0x00007f4efc0901f0 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x141f0)
 #4 0x00007f4efbaeffbb raise ./signal/../sysdeps/unix/sysv/linux/raise.c:50:1
 #5 0x00007f4efbad5864 abort ./stdlib/abort.c:81:7
 #6 0x00007f4efbad5749 get_sysdep_segment_value ./intl/loadmsgcat.c:509:8
 #7 0x00007f4efbad5749 _nl_load_domain ./intl/loadmsgcat.c:970:34
 #8 0x00007f4efbae73d6 (/lib/x86_64-linux-gnu/libc.so.6+0x383d6)
 #9 0x00000000009bda70 mlir::detail::StorageUserBase<circt::hw::InOutType, mlir::Type, circt::hw::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::getImpl() const /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/StorageUniquerSupport.h:184:68
#10 0x00000000009bda70 circt::hw::InOutType::getElementType() const /home/uenoku/dev/circt/build/tools/circt/include/circt/Dialect/HW/HWTypes.cpp.inc:172:10
#11 0x0000000000a5a6c8 circt::sv::WireOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Type, mlir::StringAttr, mlir::StringAttr) /home/uenoku/dev/circt/lib/Dialect/SV/SVOps.cpp:1010:21
#12 0x00000000006bd41a circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type>(mlir::Location, mlir::Type&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Builders.h:431:16
#13 0x00000000006bbce7 lowerUsersToTemporaryWire(mlir::Operation&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/PrepareForEmission.cpp:229:28
#14 0x00000000006bbce7 circt::ExportVerilog::prepareHWModule(mlir::Block&, circt::LoweringOptions const&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/PrepareForEmission.cpp:541:7
#15 0x00000000006941ed mlir::LogicalResult mlir::failableParallelForEach<circt::hw::HWModuleOp*, void mlir::parallelForEach<circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71>(mlir::MLIRContext*, circt::hw::HWModuleOp*, circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&)::'lambda'(circt::hw::HWModuleOp*&&)>(mlir::MLIRContext*, circt::hw::HWModuleOp*, circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Threading.h:48:26
#16 0x00000000006941ed void mlir::parallelForEach<circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71>(mlir::MLIRContext*, circt::hw::HWModuleOp*, circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Threading.h:124:9
#17 0x00000000006941ed void mlir::parallelForEach<llvm::SmallVector<circt::hw::HWModuleOp, 6u>&, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71>(mlir::MLIRContext*, llvm::SmallVector<circt::hw::HWModuleOp, 6u>&, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Threading.h:136:3
#18 0x00000000006941ed prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:4370:3",,,,,,,,
2572,[FIRRTL] names get underscores in output,2022-02-02T19:10:36Z,closed,bug,underscores prevent vcs from tracing things.  We shouldn't be adding underscores to user-specified names.,,,,,,,,,,
2570,[FIRRTL] Remove unused NLAs from OMIR,2022-02-02T17:41:51Z,closed,bug,"`EmitOMIR.cpp` was removing `circt.nonlocal` annotations but not deleting the `NonLocalAnchor` operations.
This commit adds the removed NLA reference to the list of NLAs that need to be removed.
The assumption here is that NLAs are not reused, that is there is only one client for each NLA.
Not adding any lit test to check for this, since the NLA verifier should error out if we miss to remove the op.",,,,,,,,,,
2561,[Handshake] Integration tests broken recently.,2022-02-01T18:02:06Z,closed,"bug, Handshake","@mortbopet we don't test these in CI (requires a commercial simulator), but the Handshake integration tests are currently broken, probably by 5fc6ef49b78883890efa1798693d42546294bea4. The failure I'm seeing is:

```
error: 'handshake.buffer' op result 0 has multiple uses.
```

Both tests fail in this way. Let me know if you can see offhand why this fails, or else I'll take a look at it.",error: 'handshake.buffer' op result 0 has multiple uses.,,,,,,,,,
2546,[FIRRTL] Missed Combinational Loop Detection,2022-02-01T01:13:04Z,closed,"bug, FIRRTL","The following circuit should trip combinational loop checking, but does not:

```scala
circuit Foo:
  module Foo:
    output b: UInt<1>

    b <= not(b)
```

This gets into HW dialect and crashes on malformed IR of a unary `xor`. 👀 

```
%0 = comb.xor %0 : i1
```

```
Assertion failed: (size > 1 && ""expected 2 or more operands""), function canonicalize, file CombFolds.cpp, line 1228.
Process 65409 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = hit program assert
    frame #4: 0x0000000100be2fe6 firtool`circt::comb::XorOp::canonicalize(op=XorOp @ 0x00007ff7bfefd388, rewriter=0x00007ff7bfefdcc0) at CombFolds.cpp:1228:3
   1225	LogicalResult XorOp::canonicalize(XorOp op, PatternRewriter &rewriter) {
   1226	  auto inputs = op.inputs();
   1227	  auto size = inputs.size();
-> 1228	  assert(size > 1 && ""expected 2 or more operands"");
   1229	
   1230	  // xor(..., x, x) -> xor (...) -- idempotent
   1231	  if (inputs[size - 1] == inputs[size - 2]) {
```

I expect the problem is the read of an output port is not being checked for combinational loops.","circuit Foo:
  module Foo:
    output b: UInt<1>

    b <= not(b)",%0 = comb.xor %0 : i1,"Assertion failed: (size > 1 && ""expected 2 or more operands""), function canonicalize, file CombFolds.cpp, line 1228.
Process 65409 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = hit program assert
    frame #4: 0x0000000100be2fe6 firtool`circt::comb::XorOp::canonicalize(op=XorOp @ 0x00007ff7bfefd388, rewriter=0x00007ff7bfefdcc0) at CombFolds.cpp:1228:3
   1225	LogicalResult XorOp::canonicalize(XorOp op, PatternRewriter &rewriter) {
   1226	  auto inputs = op.inputs();
   1227	  auto size = inputs.size();
-> 1228	  assert(size > 1 && ""expected 2 or more operands"");
   1229	
   1230	  // xor(..., x, x) -> xor (...) -- idempotent
   1231	  if (inputs[size - 1] == inputs[size - 2]) {",,,,,,,
2531,[FIRRTL] DontTouchAnnotation as Symbol and Deduplication,2022-01-27T21:03:37Z,open,"bug, FIRRTL","The modeling of `DontTouchAnnotation` as a symbol destroys some information that may be necessary for an SFC-exact implementation of deduplication.

Consider the following circuit. Modules `A` and `A_` are structurally equivalent and should deduplicate. `A` has a `DontTouchAnnotation` on a wire inside it. This is not supposed to block deduplication.

```scala
circuit Top : %[[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""Top.A.b""
  }
]]
  module Top :
    inst a1 of A
    inst a2 of A_
  module A :
    output x: UInt<1>
    wire b: UInt<1>
    b is invalid
    x <= b
  module A_ :
    output x: UInt<1>
    wire b: UInt<1>
    b is invalid
    x <= b
```

When we parse this in, this specific annotations becomes a symbol `@b`:

```mlir
module  {
  firrtl.circuit ""Top""   {
    firrtl.module @Top() {
      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
      %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)
    }
    firrtl.module @A(out %x: !firrtl.uint<1>) {
      %b = firrtl.wire sym @b  : !firrtl.uint<1>
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>
    }
    firrtl.module @A_(out %x: !firrtl.uint<1>) {
      %b = firrtl.wire  : !firrtl.uint<1>
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}
```

After deduplication, the circuit looks like with `@b` applied to the deduplicated wire. The effect of the annotation now applies to both wires:
```mlir
module  {
  firrtl.circuit ""Top""   {
    firrtl.module @Top() {
      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
      %a2_x = firrtl.instance a2  @A(out x: !firrtl.uint<1>)
    }
    firrtl.module @A(out %x: !firrtl.uint<1>) {
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      %b = firrtl.wire sym @b  : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}
```

In contrast, the SFC produces a non-local annotation targeting the original instance's wire:
```scala
circuit Top :
  module A :
    output x : UInt<1>

    wire b : UInt<1> @[dont-touch.scala 33:15]
    b is invalid @[dont-touch.scala 34:5]
    x <= b @[dont-touch.scala 36:5]

  module Top :

    inst a1 of A @[dont-touch.scala 47:18]
    inst a2 of A @[dont-touch.scala 48:18]
```
```json
[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top/a1:A>b""
  }
]
```

I don't have an opinion or evidence that this is problematic, yet. This is just reporting an SFC deviation.","circuit Top : %[[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""Top.A.b""
  }
]]
  module Top :
    inst a1 of A
    inst a2 of A_
  module A :
    output x: UInt<1>
    wire b: UInt<1>
    b is invalid
    x <= b
  module A_ :
    output x: UInt<1>
    wire b: UInt<1>
    b is invalid
    x <= b","module  {
  firrtl.circuit ""Top""   {
    firrtl.module @Top() {
      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
      %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)
    }
    firrtl.module @A(out %x: !firrtl.uint<1>) {
      %b = firrtl.wire sym @b  : !firrtl.uint<1>
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>
    }
    firrtl.module @A_(out %x: !firrtl.uint<1>) {
      %b = firrtl.wire  : !firrtl.uint<1>
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}","module  {
  firrtl.circuit ""Top""   {
    firrtl.module @Top() {
      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)
      %a2_x = firrtl.instance a2  @A(out x: !firrtl.uint<1>)
    }
    firrtl.module @A(out %x: !firrtl.uint<1>) {
      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
      %b = firrtl.wire sym @b  : !firrtl.uint<1>
      firrtl.connect %b, %invalid_ui1 {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %x, %b {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}","circuit Top :
  module A :
    output x : UInt<1>

    wire b : UInt<1> @[dont-touch.scala 33:15]
    b is invalid @[dont-touch.scala 34:5]
    x <= b @[dont-touch.scala 36:5]

  module Top :

    inst a1 of A @[dont-touch.scala 47:18]
    inst a2 of A @[dont-touch.scala 48:18]","[
  {
    ""class"":""firrtl.transforms.DontTouchAnnotation"",
    ""target"":""~Top|Top/a1:A>b""
  }
]",,,,,
2516,[FIRRTL] (mem) mismatch,2022-01-25T05:27:32Z,open,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 6243
circuit top_mod :
  module top_mod :
    input clock0: Clock
    input raddr: UInt<10>
    input waddr: UInt<10>
    input wdata: UInt<20>
    output tmp54: UInt<20>
    mem tmp53:
      data-type => UInt<20>
      depth => 10
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp53.r0.clk <= clock0
    tmp53.r0.en <= UInt(0)
    tmp53.r0.addr <= waddr
    tmp53.w0.clk <= clock0
    tmp53.w0.en <= UInt(1)
    tmp53.w0.addr <= raddr
    tmp53.w0.data <= wdata
    tmp53.w0.mask <= UInt(1)
    tmp54 <= tmp53.r0.data
```

Compiled with firtool --lower-to-hw --infer-widths --imconstprop --lowering-options=disallowPackedArrays,emittedLineLength=8192 --mlir-timing --verilog -o=$VFILE2 produces this Verilog:

```verilog
module tmp53_ext(	// a_top_mod.fir:9:5
  input  [3:0]  R0_addr,
  input         R0_en, R0_clk,
  input  [3:0]  W0_addr,
  input         W0_en, W0_clk,
  input  [19:0] W0_data,
  input         W0_mask,
  output [19:0] R0_data);

  reg [19:0] Memory[0:9];

  wire _T = W0_en & W0_mask;
  always @(posedge W0_clk) begin
    if (_T)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 20'bx;	// a_top_mod.fir:9:5
endmodule

module top_mod(	// a_top_mod.fir:3:10
  input         clock0,
  input  [9:0]  raddr, waddr,
  input  [19:0] wdata,
  output [19:0] tmp54);

  tmp53_ext tmp53 (	// a_top_mod.fir:9:5
    .R0_addr (waddr[3:0]),	// a_top_mod.fir:19:19
    .R0_en   (1'h0),	// a_top_mod.fir:18:20
    .R0_clk  (clock0),
    .W0_addr (raddr[3:0]),	// a_top_mod.fir:22:19
    .W0_en   (1'h1),	// a_top_mod.fir:21:20
    .W0_clk  (clock0),
    .W0_data (wdata),
    .W0_mask (1'h1),	// a_top_mod.fir:21:20
    .R0_data (tmp54)
  );
endmodule
```

Compiled with firrtl-1.5-SNAPSHOT produces this Verilog:

```verilog
module top_mod(
  input         clock0,
  input  [9:0]  raddr,
  input  [9:0]  waddr,
  input  [19:0] wdata,
  output [19:0] tmp54
);
`ifdef RANDOMIZE_GARBAGE_ASSIGN
  reg [31:0] _RAND_1;
`endif // RANDOMIZE_GARBAGE_ASSIGN
`ifdef RANDOMIZE_MEM_INIT
  reg [31:0] _RAND_0;
`endif // RANDOMIZE_MEM_INIT
  reg [19:0] tmp53 [0:9];
  wire  tmp53_r0_en;
  wire [3:0] tmp53_r0_addr;
  wire [19:0] tmp53_r0_data;
  wire [19:0] tmp53_w0_data;
  wire [3:0] tmp53_w0_addr;
  wire  tmp53_w0_mask;
  wire  tmp53_w0_en;
  assign tmp53_r0_en = 1'h0;
  assign tmp53_r0_addr = waddr[3:0];
  `ifndef RANDOMIZE_GARBAGE_ASSIGN
  assign tmp53_r0_data = tmp53[tmp53_r0_addr];
  `else
  assign tmp53_r0_data = tmp53_r0_addr >= 4'ha ? _RAND_1[19:0] : tmp53[tmp53_r0_addr];
  `endif // RANDOMIZE_GARBAGE_ASSIGN
  assign tmp53_w0_data = wdata;
  assign tmp53_w0_addr = raddr[3:0];
  assign tmp53_w0_mask = 1'h1;
  assign tmp53_w0_en = 1'h1;
  assign tmp54 = tmp53_r0_data;
  always @(posedge clock0) begin
    if (tmp53_w0_en & tmp53_w0_mask) begin
      tmp53[tmp53_w0_addr] <= tmp53_w0_data;
    end
  end
// Register and memory initialization
`ifdef RANDOMIZE_GARBAGE_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_INVALID_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_REG_INIT
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_MEM_INIT
`define RANDOMIZE
`endif
`ifndef RANDOM
`define RANDOM $random
`endif
`ifdef RANDOMIZE_MEM_INIT
  integer initvar;
`endif
`ifndef SYNTHESIS
`ifdef FIRRTL_BEFORE_INITIAL
`FIRRTL_BEFORE_INITIAL
`endif
initial begin
  `ifdef RANDOMIZE
    `ifdef INIT_RANDOM
      `INIT_RANDOM
    `endif
    `ifndef VERILATOR
      `ifdef RANDOMIZE_DELAY
        #`RANDOMIZE_DELAY begin end
      `else
        #0.002 begin end
      `endif
    `endif
`ifdef RANDOMIZE_GARBAGE_ASSIGN
  _RAND_1 = {1{`RANDOM}};
`endif // RANDOMIZE_GARBAGE_ASSIGN
`ifdef RANDOMIZE_MEM_INIT
  _RAND_0 = {1{`RANDOM}};
  for (initvar = 0; initvar < 10; initvar = initvar+1)
    tmp53[initvar] = _RAND_0[19:0];
`endif // RANDOMIZE_MEM_INIT
  `endif // RANDOMIZE
end // initial
`ifdef FIRRTL_AFTER_INITIAL
`FIRRTL_AFTER_INITIAL
`endif
`endif // SYNTHESIS
endmodule
```
`Yosys 0.13+15 (git sha1 bc027b2ca, clang 13.0.0 -fPIC -Os)` reports formal mismatch:

```
ERROR: Found 20 unproven $equiv cells in 'equiv_status -assert'.
```
","; seed: 6243
circuit top_mod :
  module top_mod :
    input clock0: Clock
    input raddr: UInt<10>
    input waddr: UInt<10>
    input wdata: UInt<20>
    output tmp54: UInt<20>
    mem tmp53:
      data-type => UInt<20>
      depth => 10
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp53.r0.clk <= clock0
    tmp53.r0.en <= UInt(0)
    tmp53.r0.addr <= waddr
    tmp53.w0.clk <= clock0
    tmp53.w0.en <= UInt(1)
    tmp53.w0.addr <= raddr
    tmp53.w0.data <= wdata
    tmp53.w0.mask <= UInt(1)
    tmp54 <= tmp53.r0.data","module tmp53_ext(	// a_top_mod.fir:9:5
  input  [3:0]  R0_addr,
  input         R0_en, R0_clk,
  input  [3:0]  W0_addr,
  input         W0_en, W0_clk,
  input  [19:0] W0_data,
  input         W0_mask,
  output [19:0] R0_data);

  reg [19:0] Memory[0:9];

  wire _T = W0_en & W0_mask;
  always @(posedge W0_clk) begin
    if (_T)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = R0_en ? Memory[R0_addr] : 20'bx;	// a_top_mod.fir:9:5
endmodule

module top_mod(	// a_top_mod.fir:3:10
  input         clock0,
  input  [9:0]  raddr, waddr,
  input  [19:0] wdata,
  output [19:0] tmp54);

  tmp53_ext tmp53 (	// a_top_mod.fir:9:5
    .R0_addr (waddr[3:0]),	// a_top_mod.fir:19:19
    .R0_en   (1'h0),	// a_top_mod.fir:18:20
    .R0_clk  (clock0),
    .W0_addr (raddr[3:0]),	// a_top_mod.fir:22:19
    .W0_en   (1'h1),	// a_top_mod.fir:21:20
    .W0_clk  (clock0),
    .W0_data (wdata),
    .W0_mask (1'h1),	// a_top_mod.fir:21:20
    .R0_data (tmp54)
  );
endmodule","module top_mod(
  input         clock0,
  input  [9:0]  raddr,
  input  [9:0]  waddr,
  input  [19:0] wdata,
  output [19:0] tmp54
);
`ifdef RANDOMIZE_GARBAGE_ASSIGN
  reg [31:0] _RAND_1;
`endif // RANDOMIZE_GARBAGE_ASSIGN
`ifdef RANDOMIZE_MEM_INIT
  reg [31:0] _RAND_0;
`endif // RANDOMIZE_MEM_INIT
  reg [19:0] tmp53 [0:9];
  wire  tmp53_r0_en;
  wire [3:0] tmp53_r0_addr;
  wire [19:0] tmp53_r0_data;
  wire [19:0] tmp53_w0_data;
  wire [3:0] tmp53_w0_addr;
  wire  tmp53_w0_mask;
  wire  tmp53_w0_en;
  assign tmp53_r0_en = 1'h0;
  assign tmp53_r0_addr = waddr[3:0];
  `ifndef RANDOMIZE_GARBAGE_ASSIGN
  assign tmp53_r0_data = tmp53[tmp53_r0_addr];
  `else
  assign tmp53_r0_data = tmp53_r0_addr >= 4'ha ? _RAND_1[19:0] : tmp53[tmp53_r0_addr];
  `endif // RANDOMIZE_GARBAGE_ASSIGN
  assign tmp53_w0_data = wdata;
  assign tmp53_w0_addr = raddr[3:0];
  assign tmp53_w0_mask = 1'h1;
  assign tmp53_w0_en = 1'h1;
  assign tmp54 = tmp53_r0_data;
  always @(posedge clock0) begin
    if (tmp53_w0_en & tmp53_w0_mask) begin
      tmp53[tmp53_w0_addr] <= tmp53_w0_data;
    end
  end
// Register and memory initialization
`ifdef RANDOMIZE_GARBAGE_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_INVALID_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_REG_INIT
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_MEM_INIT
`define RANDOMIZE
`endif
`ifndef RANDOM
`define RANDOM $random
`endif
`ifdef RANDOMIZE_MEM_INIT
  integer initvar;
`endif
`ifndef SYNTHESIS
`ifdef FIRRTL_BEFORE_INITIAL
`FIRRTL_BEFORE_INITIAL
`endif
initial begin
  `ifdef RANDOMIZE
    `ifdef INIT_RANDOM
      `INIT_RANDOM
    `endif
    `ifndef VERILATOR
      `ifdef RANDOMIZE_DELAY
        #`RANDOMIZE_DELAY begin end
      `else
        #0.002 begin end
      `endif
    `endif
`ifdef RANDOMIZE_GARBAGE_ASSIGN
  _RAND_1 = {1{`RANDOM}};
`endif // RANDOMIZE_GARBAGE_ASSIGN
`ifdef RANDOMIZE_MEM_INIT
  _RAND_0 = {1{`RANDOM}};
  for (initvar = 0; initvar < 10; initvar = initvar+1)
    tmp53[initvar] = _RAND_0[19:0];
`endif // RANDOMIZE_MEM_INIT
  `endif // RANDOMIZE
end // initial
`ifdef FIRRTL_AFTER_INITIAL
`FIRRTL_AFTER_INITIAL
`endif
`endif // SYNTHESIS
endmodule",ERROR: Found 20 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
2514,"[FIRRTL] (core dump) leq,SInt<0>",2022-01-24T23:38:13Z,closed,"bug, FIRRTL","Running following fir file

```python
; seed: 3339
circuit top_mod :
  module top_mod :
    input clock1: Clock
    input inp_a: {inp_c: SInt<0>, inp_f: {inp_g: {inp_j: SInt<0>}}, inp_h: {inp_k: UInt<15>}}
    reg tmp23: UInt, clock1
    tmp23 <= head(UInt<1>(""b1""), 0)
    node _tmp26 = leq(inp_a.inp_f.inp_g.inp_j, asSInt(tmp23))
```

with:

`firtool a_top_mod.fir --lowering-options=disallowPackedArrays,noAlwaysComb,disallowLocalVariables --verilog -o=a_top_mod.fir.mfc.v` 

I am getting this error:
```
firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:284: int llvm::APInt::compareSigned(const llvm::APInt&) const: Assertion `BitWidth == RHS.BitWidth && ""Bit widths must be same for comparison""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --verilog --lowering-options=disallowPackedArrays,noAlwaysComb,disallowLocalVariables -o=a_top_mod.fir.mfc.v
 #0 0x000000000045c441 PrintStackTraceSignalHandler(void*) Signals.cpp:0:0
 #1 0x0000000000459d0e SignalHandler(int) Signals.cpp:0:0
 #2 0x00007f3fc26d1420 __restore_rt (/lib64/libc.so.6+0x56420)
 #3 0x00007f3fc272124c __pthread_kill_implementation (/lib64/libc.so.6+0xa624c)
 #4 0x00007f3fc26d1356 gsignal (/lib64/libc.so.6+0x56356)
 #5 0x00007f3fc26ba7d3 abort (/lib64/libc.so.6+0x3f7d3)
 #6 0x00007f3fc26ba6eb _nl_load_domain.cold (/lib64/libc.so.6+0x3f6eb)
 #7 0x00007f3fc26c9946 (/lib64/libc.so.6+0x4e946)
 #8 0x000000000046733f llvm::APInt::compareSigned(llvm::APInt const&) const (../../llvm/circt/build/bin/firtool+0x46733f)
 #9 0x000000000075dc59 circt::firrtl::LEQPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) (../../llvm/circt/build/bin/firtool+0x75dc59)
#10 0x000000000073d2d3 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&>::CallImpl<std::enable_if<(llvm::disjunction<std::is_same<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp>, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::ZeroSuccessor<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::NOperands<2u>::Impl<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, circt::firrtl::SameOperandsIntTypeKind<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::InferTypeOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::MemoryEffectOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > > >::value) && (llvm::detail::detector<void, mlir::Op<circt::firrtl::LEQPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, circt::firrtl::SameOperandsIntTypeKind, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::has_single_result_fold, mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >::value_t::value), llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const> >::type mlir::Op<circt::firrtl::LEQPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, circt::firrtl::SameOperandsIntTypeKind, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::getFoldHookFnImpl<circt::firrtl::LEQPrimOp>()::'lambda'(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>(void*, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) (../../llvm/circt/build/bin/firtool+0x73d2d3)
#11 0x00000000006ec4ba mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) (../../llvm/circt/build/bin/firtool+0x6ec4ba)
#12 0x000000000086a519 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) (../../llvm/circt/build/bin/firtool+0x86a519)
#13 0x000000000086b8a3 mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) (../../llvm/circt/build/bin/firtool+0x86b8a3)
#14 0x00000000008562b9 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) (.constprop.0) GreedyPatternRewriteDriver.cpp:0:0
#15 0x000000000085842a mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) (../../llvm/circt/build/bin/firtool+0x85842a)
#16 0x0000000000908846 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x908846)
#17 0x0000000000908dd8 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x908dd8)
#18 0x00000000009072ce mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x9072ce)
#19 0x00000000009088cf mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x9088cf)
#20 0x0000000000908dd8 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x908dd8)
#21 0x00000000009072ce mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x9072ce)
#22 0x00000000009088cf mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x9088cf)
#23 0x0000000000908dd8 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x908dd8)
#24 0x000000000090a42b mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x90a42b)
#25 0x000000000040d8e1 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) firtool.cpp:0:0
#26 0x000000000040e874 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) firtool.cpp:0:0
#27 0x0000000000409aa1 main (../../llvm/circt/build/bin/firtool+0x409aa1)
#28 0x00007f3fc26bb5c0 __libc_start_call_main (/lib64/libc.so.6+0x405c0)
#29 0x00007f3fc26bb67c __libc_start_main@GLIBC_2.2.5 (/lib64/libc.so.6+0x4067c)
#30 0x0000000000409e25 _start /home/abuild/rpmbuild/BUILD/glibc-2.34/csu/../sysdeps/x86_64/start.S:118:0
```
","; seed: 3339
circuit top_mod :
  module top_mod :
    input clock1: Clock
    input inp_a: {inp_c: SInt<0>, inp_f: {inp_g: {inp_j: SInt<0>}}, inp_h: {inp_k: UInt<15>}}
    reg tmp23: UInt, clock1
    tmp23 <= head(UInt<1>(""b1""), 0)
    node _tmp26 = leq(inp_a.inp_f.inp_g.inp_j, asSInt(tmp23))","firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:284: int llvm::APInt::compareSigned(const llvm::APInt&) const: Assertion `BitWidth == RHS.BitWidth && ""Bit widths must be same for comparison""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --verilog --lowering-options=disallowPackedArrays,noAlwaysComb,disallowLocalVariables -o=a_top_mod.fir.mfc.v
 #0 0x000000000045c441 PrintStackTraceSignalHandler(void*) Signals.cpp:0:0
 #1 0x0000000000459d0e SignalHandler(int) Signals.cpp:0:0
 #2 0x00007f3fc26d1420 __restore_rt (/lib64/libc.so.6+0x56420)
 #3 0x00007f3fc272124c __pthread_kill_implementation (/lib64/libc.so.6+0xa624c)
 #4 0x00007f3fc26d1356 gsignal (/lib64/libc.so.6+0x56356)
 #5 0x00007f3fc26ba7d3 abort (/lib64/libc.so.6+0x3f7d3)
 #6 0x00007f3fc26ba6eb _nl_load_domain.cold (/lib64/libc.so.6+0x3f6eb)
 #7 0x00007f3fc26c9946 (/lib64/libc.so.6+0x4e946)
 #8 0x000000000046733f llvm::APInt::compareSigned(llvm::APInt const&) const (../../llvm/circt/build/bin/firtool+0x46733f)
 #9 0x000000000075dc59 circt::firrtl::LEQPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) (../../llvm/circt/build/bin/firtool+0x75dc59)
#10 0x000000000073d2d3 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&>::CallImpl<std::enable_if<(llvm::disjunction<std::is_same<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp>, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::ZeroSuccessor<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::NOperands<2u>::Impl<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, circt::firrtl::SameOperandsIntTypeKind<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::InferTypeOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::MemoryEffectOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > > >::value) && (llvm::detail::detector<void, mlir::Op<circt::firrtl::LEQPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, circt::firrtl::SameOperandsIntTypeKind, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::has_single_result_fold, mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >::value_t::value), llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const> >::type mlir::Op<circt::firrtl::LEQPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, circt::firrtl::SameOperandsIntTypeKind, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::getFoldHookFnImpl<circt::firrtl::LEQPrimOp>()::'lambda'(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>(void*, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) (../../llvm/circt/build/bin/firtool+0x73d2d3)
#11 0x00000000006ec4ba mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) (../../llvm/circt/build/bin/firtool+0x6ec4ba)
#12 0x000000000086a519 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) (../../llvm/circt/build/bin/firtool+0x86a519)
#13 0x000000000086b8a3 mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) (../../llvm/circt/build/bin/firtool+0x86b8a3)
#14 0x00000000008562b9 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) (.constprop.0) GreedyPatternRewriteDriver.cpp:0:0
#15 0x000000000085842a mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) (../../llvm/circt/build/bin/firtool+0x85842a)
#16 0x0000000000908846 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x908846)
#17 0x0000000000908dd8 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x908dd8)
#18 0x00000000009072ce mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x9072ce)
#19 0x00000000009088cf mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x9088cf)
#20 0x0000000000908dd8 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x908dd8)
#21 0x00000000009072ce mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x9072ce)
#22 0x00000000009088cf mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x9088cf)
#23 0x0000000000908dd8 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x908dd8)
#24 0x000000000090a42b mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x90a42b)
#25 0x000000000040d8e1 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) firtool.cpp:0:0
#26 0x000000000040e874 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) firtool.cpp:0:0
#27 0x0000000000409aa1 main (../../llvm/circt/build/bin/firtool+0x409aa1)
#28 0x00007f3fc26bb5c0 __libc_start_call_main (/lib64/libc.so.6+0x405c0)
#29 0x00007f3fc26bb67c __libc_start_main@GLIBC_2.2.5 (/lib64/libc.so.6+0x4067c)
#30 0x0000000000409e25 _start /home/abuild/rpmbuild/BUILD/glibc-2.34/csu/../sysdeps/x86_64/start.S:118:0",,,,,,,,
2504,[ExportVerilog] Incorrect verilog output for bitcast + zero width aggregate types,2022-01-23T22:10:34Z,open,"bug, ExportVerilog","We are emitting zero bit width array/struct as one bit element. This is problem when we use bitcast for them.

```mlir
hw.module @top(%source: i1) -> (b: !hw.struct<zero: !hw.array<1xi0>, c: i1>) {
    %cast = hw.bitcast %source: (i1) -> !hw.struct<zero: !hw.array<1xi0>, c: i1>
    hw.output %cast : !hw.struct<zero: !hw.array<1xi0>, c: i1>
 }
```

```sv
module top(	// out.mlir:2:3
  input                                                            source,
  output struct packed {logic [0:0]/*Zero Width*/ zero; logic c; } b);
 
  assign b = source;	// out.mlir:3:12, :4:5
endmodule
```
","hw.module @top(%source: i1) -> (b: !hw.struct<zero: !hw.array<1xi0>, c: i1>) {
    %cast = hw.bitcast %source: (i1) -> !hw.struct<zero: !hw.array<1xi0>, c: i1>
    hw.output %cast : !hw.struct<zero: !hw.array<1xi0>, c: i1>
 }","module top(	// out.mlir:2:3
  input                                                            source,
  output struct packed {logic [0:0]/*Zero Width*/ zero; logic c; } b);
 
  assign b = source;	// out.mlir:3:12, :4:5
endmodule",,,,,,,,
2491,[SCFToCalyx] Crash with external memories,2022-01-21T23:13:50Z,closed,"bug, Calyx","I'm trying to run the following program through SCFToCalyx:

```mlir
 func @main(%arg0 : memref<64xi32>, %arg1 : memref<64xi32>) -> i32 {
    %c0_i32 = arith.constant 0 : i32
    %c0 = arith.constant 0 : index
    %c64 = arith.constant 64 : index
    %c1 = arith.constant 1 : index
    %0:2 = scf.while (%arg2 = %c0, %arg3 = %c0_i32) : (index, i32) -> (index, i32) {
      %1 = arith.cmpi slt, %arg2, %c64 : index
      scf.condition(%1) %arg2, %arg3 : index, i32
    } do {
    ^bb0(%arg2: index, %arg3: i32):  // no predecessors
      %1 = arith.addi %arg2, %c1 : index
      %2 = memref.load %arg0[%arg2] : memref<64xi32>
      %3 = memref.load %arg1[%arg2] : memref<64xi32>
      %4 = arith.muli %2, %3 : i32
      %5 = arith.addi %arg3, %4 : i32
      scf.yield %1, %5 : index, i32
    }
    return %0#1 : i32
  }
```

Unfortunately, this seems to crash the pass, and worse, it silently just exits with a return code of 1. This appears to be related to the external memories; if I move the parameters to internal allocations, the pass succeeds:

```mlir
  func @main() -> i32 {
    %arg0 = memref.alloc() : memref<64xi32>
    %arg1 = memref.alloc() : memref<64xi32>
```

I haven't begun looking into this yet, but will mention here if I do.","func @main(%arg0 : memref<64xi32>, %arg1 : memref<64xi32>) -> i32 {
    %c0_i32 = arith.constant 0 : i32
    %c0 = arith.constant 0 : index
    %c64 = arith.constant 64 : index
    %c1 = arith.constant 1 : index
    %0:2 = scf.while (%arg2 = %c0, %arg3 = %c0_i32) : (index, i32) -> (index, i32) {
      %1 = arith.cmpi slt, %arg2, %c64 : index
      scf.condition(%1) %arg2, %arg3 : index, i32
    } do {
    ^bb0(%arg2: index, %arg3: i32):  // no predecessors
      %1 = arith.addi %arg2, %c1 : index
      %2 = memref.load %arg0[%arg2] : memref<64xi32>
      %3 = memref.load %arg1[%arg2] : memref<64xi32>
      %4 = arith.muli %2, %3 : i32
      %5 = arith.addi %arg3, %4 : i32
      scf.yield %1, %5 : index, i32
    }
    return %0#1 : i32
  }","func @main() -> i32 {
    %arg0 = memref.alloc() : memref<64xi32>
    %arg1 = memref.alloc() : memref<64xi32>",,,,,,,,
2464,[FIRRTL] FlattenAnnotation should be removed by ModuleInliner Pass,2022-01-15T06:47:32Z,closed,"bug, FIRRTL","The `ModuleInliner` pas isn't removing `FlattenAnnotation`s on flattened modules.  This isn't a problem, per se, as flattening is an idempotent operation.  However, it's good practice for passes to remove annotations that they consume.",,,,,,,,,,
2451,[FIRRTL] Module Inliner Needs to Unique Colliding Symbols,2022-01-13T05:52:23Z,closed,"bug, FIRRTL","FIRRTL Dialect's `ModuleInliner` pass can result in inner sym collisions.  Consider the following:

```mlir
firrtl.circuit ""Foo"" {
  firrtl.module @Bar() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
    %b = firrtl.wire sym @hello : !firrtl.uint<1>
  }
  firrtl.module @Foo() {
    firrtl.instance foo @Bar()
    %a = firrtl.wire sym @hello : !firrtl.uint<1>
  }
}
```

After running `circt-opt -pass-pipeline='firrtl.circuit(firrtl-inliner)' Bar.mlir`:

```mlir
firrtl.circuit ""Foo""   {
  firrtl.module @Foo() {
    %foo_b = firrtl.wire sym @hello  : !firrtl.uint<1>
    %a = firrtl.wire sym @hello  : !firrtl.uint<1>
  }
}
```

The `@hello` symbol should be renamed using a `firrtl::ModuleNamespace` (and any NLAs using it should be updated).

Note: I'm working on fixing NLAs generally in the `ModuleInliner` and I'd like to land that before fixing this.

Note: I'm in favor of keeping the symbol name unmodified if it doesn't collide as opposed to updating the symbol to reflect the inlining, e.g., `@foo_hello`.  (Doing this would _still_ require uniquing the symbol in the namespace even though it lowers the probability of a collision.)","firrtl.circuit ""Foo"" {
  firrtl.module @Bar() attributes {annotations = [{class = ""firrtl.passes.InlineAnnotation""}]} {
    %b = firrtl.wire sym @hello : !firrtl.uint<1>
  }
  firrtl.module @Foo() {
    firrtl.instance foo @Bar()
    %a = firrtl.wire sym @hello : !firrtl.uint<1>
  }
}","firrtl.circuit ""Foo""   {
  firrtl.module @Foo() {
    %foo_b = firrtl.wire sym @hello  : !firrtl.uint<1>
    %a = firrtl.wire sym @hello  : !firrtl.uint<1>
  }
}",,,,,,,,
2404,[ExportVerilog] Crash with disallowLocalVariables option,2021-12-28T17:27:11Z,closed,"bug, ExportVerilog","input:
```mlir
hw.module @Foo(%clock: i1) {
    %false = hw.constant false
    %c0_i16 = hw.constant 0 : i16
    %status_regs = sv.reg : !hw.inout<array<1xi32>>
    %0 = sv.array_index_inout %status_regs[%false] : !hw.inout<array<1xi32>>, i1
    %1 = sv.read_inout %0 : !hw.inout<i32>
    %2 = comb.extract %1 from 0 : (i32) -> i16
    %3 = comb.concat %c0_i16, %2 : i16, i16
    sv.always posedge %clock  {
       sv.passign %0, %3 : i32
    }
    hw.output
  }
```
```
./bin/firtool --lowering-options=disallowLocalVariables foo.mlir
```
causes the assertion failure:
```
./lib/Conversion/ExportVerilog/ExportVerilog.cpp:355: llvm::StringRef getVerilogDeclWord(mlir::Operation *, const circt::LoweringOptions &): Assertion `!options.disallowLocalVariables && ""automatic variables not allowed""' failed
```

(This is reduced by circt-reduce. Thank you @fabianschuiki for creating circt-reduce!)","hw.module @Foo(%clock: i1) {
    %false = hw.constant false
    %c0_i16 = hw.constant 0 : i16
    %status_regs = sv.reg : !hw.inout<array<1xi32>>
    %0 = sv.array_index_inout %status_regs[%false] : !hw.inout<array<1xi32>>, i1
    %1 = sv.read_inout %0 : !hw.inout<i32>
    %2 = comb.extract %1 from 0 : (i32) -> i16
    %3 = comb.concat %c0_i16, %2 : i16, i16
    sv.always posedge %clock  {
       sv.passign %0, %3 : i32
    }
    hw.output
  }",./bin/firtool --lowering-options=disallowLocalVariables foo.mlir,"./lib/Conversion/ExportVerilog/ExportVerilog.cpp:355: llvm::StringRef getVerilogDeclWord(mlir::Operation *, const circt::LoweringOptions &): Assertion `!options.disallowLocalVariables && ""automatic variables not allowed""' failed",,,,,,,
2357,[FIRRTL] Fix use-after-free of ops erased during assert parsing,2021-12-16T13:33:10Z,closed,"bug, FIRRTL","Fix an issue where the `foldWhenEncodedVerifOp` function would erase operations while the `LazyLocationListener` of the parser still has a pointer to them. This causes `endStatement` to try and assign locations to those operations, which for the erased operations is a use after free. This adjusts the `foldWhenEncodedVerifOp` function to only remove the operation but not immediately destroy it. This allows the listener to do its updates and properly clean up the removed operations once it's done.

Fixes #2355.",,,,,,,,,,
2346,[FIRRTL] Fix OMIR port widths not being hex values,2021-12-15T16:16:07Z,closed,"bug, FIRRTL","Fix an issue in the `EmitOMIR` pass, where the addition of port information would introduce additional `OMBigInt` values which were not properly formatted as hexadecimal values, but just as decimal ones. This updates the emission to make them hexadecimal as expected by other parts of the FIRRTL ecosystem.",,,,,,,,,,
2343,[LowerToHW] Invalid lowering of register assignments through subindex/subfield,2021-12-15T14:37:45Z,closed,bug,"```mlir
; firtool -verilog -lower-types=false
firrtl.module @AggregateRegAssign(in %clock: !firrtl.clock, in %value: !firrtl.uint<1>) {
      %reg = firrtl.reg %clock  : !firrtl.vector<uint<1>, 1>
      %0 = firrtl.subindex %reg[0] : !firrtl.vector<uint<1>, 1>
      firrtl.connect %0, %value : !firrtl.uint<1>, !firrtl.uint<1>
}
```
currently generates something like this: 
```sv
module AggregateRegAssign(      // foo.mlir:2:1
  input clock, value);

  reg [0:0] reg_0;      // foo.mlir:3:14
  assign reg_0[1'h0] = value;   // foo.mlir:3:14, :4:12, :5:7
endmodule
```
We have to put assignment into always statement. This is a bug of `FIRRTLLowering::visitStmt(ConnectOp)`.","; firtool -verilog -lower-types=false
firrtl.module @AggregateRegAssign(in %clock: !firrtl.clock, in %value: !firrtl.uint<1>) {
      %reg = firrtl.reg %clock  : !firrtl.vector<uint<1>, 1>
      %0 = firrtl.subindex %reg[0] : !firrtl.vector<uint<1>, 1>
      firrtl.connect %0, %value : !firrtl.uint<1>, !firrtl.uint<1>
}","module AggregateRegAssign(      // foo.mlir:2:1
  input clock, value);

  reg [0:0] reg_0;      // foo.mlir:3:14
  assign reg_0[1'h0] = value;   // foo.mlir:3:14, :4:12, :5:7
endmodule",,,,,,,,
2342,[ExportVerilog] Invalid emission of mux of aggregates + extract,2021-12-14T22:04:55Z,closed,"bug, ExportVerilog","```mlir
// circt-opt %s -export-verilog
hw.module @muxAggregate(%cond: i1, %a: !hw.struct<c: i1>, %b: !hw.struct<c: i1>) -> (out: i1) {
    %0 = comb.mux %cond, %a, %b : !hw.struct<c: i1>
    %1 = hw.struct_extract %0[""c""] : !hw.struct<c: i1>
    hw.output %1 : i1
}
```
will become
```sv
module muxAggregate(      // foo.mlir:2:3
  input                            cond,
  input  struct packed {logic c; } a, b,
  output                           out);

  assign out = (cond ? a : b).c;        // foo.mlir:3:12, :4:12, :5:5
endmodule
```
`(cond?a:b).c` causes a syntax error so we need to spill mux into a temporary wire. ","// circt-opt %s -export-verilog
hw.module @muxAggregate(%cond: i1, %a: !hw.struct<c: i1>, %b: !hw.struct<c: i1>) -> (out: i1) {
    %0 = comb.mux %cond, %a, %b : !hw.struct<c: i1>
    %1 = hw.struct_extract %0[""c""] : !hw.struct<c: i1>
    hw.output %1 : i1
}","module muxAggregate(      // foo.mlir:2:3
  input                            cond,
  input  struct packed {logic c; } a, b,
  output                           out);

  assign out = (cond ? a : b).c;        // foo.mlir:3:12, :4:12, :5:5
endmodule",,,,,,,,
2335,[ExportVerilog] Invalid automatic variable emission of struct type,2021-12-13T15:41:37Z,closed,"bug, ExportVerilog","```mlir
; circt-opt %s -export-verilog
hw.module @AggregateTemporay(%clock: i1, %foo: i1) {
  %temp = sv.reg  : !hw.inout<!hw.struct<b: i1>>
  sv.always posedge %clock  {
    %0 = hw.bitcast %foo : (i1) -> !hw.struct<b: i1>
    sv.passign %temp, %0 : !hw.struct<b: i1>
    sv.passign %temp, %0 : !hw.struct<b: i1>
  }
}
```
will generate something like this:
```sv
module AggregateTemporay(       // foo.mlir:1:1
  input clock, foo);

  struct packed {logic b; } temp;       // foo.mlir:2:11

  always @(posedge clock) begin // foo.mlir:5:3
    automatic logic struct packed {logic b; } _T = foo;       // foo.mlir:6:10

    temp <= _T; // foo.mlir:7:5
    temp <= _T; // foo.mlir:8:5
  end // always @(posedge)
endmodule
```
`automatic logic struct packed {logic b; } _T = foo;` is syntactically incorrect. 
We have to emit `automatic struct packed {logic b; } _T = foo; `. ","; circt-opt %s -export-verilog
hw.module @AggregateTemporay(%clock: i1, %foo: i1) {
  %temp = sv.reg  : !hw.inout<!hw.struct<b: i1>>
  sv.always posedge %clock  {
    %0 = hw.bitcast %foo : (i1) -> !hw.struct<b: i1>
    sv.passign %temp, %0 : !hw.struct<b: i1>
    sv.passign %temp, %0 : !hw.struct<b: i1>
  }
}","module AggregateTemporay(       // foo.mlir:1:1
  input clock, foo);

  struct packed {logic b; } temp;       // foo.mlir:2:11

  always @(posedge clock) begin // foo.mlir:5:3
    automatic logic struct packed {logic b; } _T = foo;       // foo.mlir:6:10

    temp <= _T; // foo.mlir:7:5
    temp <= _T; // foo.mlir:8:5
  end // always @(posedge)
endmodule",,,,,,,,
2327,[ExportVerilog] Verilog empty struct emission,2021-12-12T20:54:34Z,closed,"bug, ExportVerilog","```mlir
hw.module @EmptyStruct(%empty: !hw.struct<>) {
}
```
will generate
```verilog
module EmptyStruct(     // foo.mlir:1:1
  input struct packed {} empty);

endmodule
```
An empty `{}` causes syntax errors so we need to emit `/*Zero Width*/` instead. ","hw.module @EmptyStruct(%empty: !hw.struct<>) {
}","module EmptyStruct(     // foo.mlir:1:1
  input struct packed {} empty);

endmodule",,,,,,,,
2326,[ExportVerilog] Verilog reserved keywords in Struct Type field names,2021-12-12T20:45:06Z,closed,"bug, ExportVerilog","```mlir
; circt-opt -export-verilog %s
hw.module @ReservedKeyword(%rep: !hw.struct<repeat: i1>) {
}
```
will generate
```verilog
module ReservedKeyword( // foo.mlir:1:1
  input struct packed {logic repeat; } rep);

endmodule
```
This causes a syntax error because `repeat` is verilog keyword. We have to check field names are verilog keyward as well as variable names. ","; circt-opt -export-verilog %s
hw.module @ReservedKeyword(%rep: !hw.struct<repeat: i1>) {
}","module ReservedKeyword( // foo.mlir:1:1
  input struct packed {logic repeat; } rep);

endmodule",,,,,,,,
2316,[FIRRTL] Fix index overflows during subaccess lowering,2021-12-09T10:34:09Z,closed,"bug, FIRRTL","Fix an issue in `LowerTypes` around `SubaccessOp`s, where narrow index expressions could cause constant overflows. If the subaccess index had fewer bits than necessary to address all elements of the vector, the comparisons between that index and a constant generated for every element would see the constant overflow for all the elements beyond reach.

For example, using a 2-bit index `x` to access a 5-element vector `y` would generate comparisons as follows:

- `x == 0 : i2`
- `x == 1 : i2`
- `x == 2 : i2`
- `x == 3 : i2`
- `x == 0 : i2` (4 overflows in the 2-bit constant)

This fixes the issue by choosing the width of the constants according to `ceil(log2(vectorLength))`, which is guaranteed to always have enough bits to represent all vector indices. This makes the generated equality checks compare numbers of potentially different bit widths, which is fine in FIRRTL.

Fixes #2315.",,,,,,,,,,
2315,[FIRRTL] Subaccess into vector may overflow index expression,2021-12-09T10:10:09Z,closed,"bug, FIRRTL","A subaccess into a vector longer than what the index can address will cause constants to overflow during `LowerTypes`:
```
firrtl.circuit ""Foo"" {
  firrtl.module @Foo(
    in %x: !firrtl.vector<uint<10>, 5>,
    in %source: !firrtl.uint<2>,
    out %z: !firrtl.uint<10>
  ) {
    %0 = firrtl.subaccess %x[%source] : !firrtl.vector<uint<10>, 5>, !firrtl.uint<2>
    firrtl.connect %z, %0 : !firrtl.uint<10>, !firrtl.uint<10>
  }
}
```
will lower to
```
firrtl.circuit ""Foo""   {
  firrtl.module @Foo(
    in %x_0: !firrtl.uint<10>,
    in %x_1: !firrtl.uint<10>,
    in %x_2: !firrtl.uint<10>,
    in %x_3: !firrtl.uint<10>,
    in %x_4: !firrtl.uint<10>,
    in %source: !firrtl.uint<2>,
    out %z: !firrtl.uint<10>
  ) {
    %c1_ui2 = firrtl.constant 1 : !firrtl.uint<2>
    %c2_ui2 = firrtl.constant 2 : !firrtl.uint<2>
    %c3_ui2 = firrtl.constant 3 : !firrtl.uint<2>
    %c0_ui2 = firrtl.constant 0 : !firrtl.uint<2>  // <-- 4 being squeezed into the 2-bit index
    %0 = firrtl.eq %source, %c1_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>
    %1 = firrtl.mux(%0, %x_1, %x_0) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>
    %2 = firrtl.eq %source, %c2_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>
    %3 = firrtl.mux(%2, %x_2, %1) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>
    %4 = firrtl.eq %source, %c3_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>
    %5 = firrtl.mux(%4, %x_3, %3) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>
    %6 = firrtl.eq %source, %c0_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>
    %7 = firrtl.mux(%6, %x_4, %5) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>
    firrtl.connect %z, %7 : !firrtl.uint<10>, !firrtl.uint<10>
  }
}
```
This causes fun things during Verilog emission, like indexing an array `{x0, ..., x5}` with a 2-bit index expression `y` being lowered to `{x4, x5, x2, x3}[y]` (where the overflowing indices 4 and 5 get wrapped around and override the other values). Working on a fix.","firrtl.circuit ""Foo"" {
  firrtl.module @Foo(
    in %x: !firrtl.vector<uint<10>, 5>,
    in %source: !firrtl.uint<2>,
    out %z: !firrtl.uint<10>
  ) {
    %0 = firrtl.subaccess %x[%source] : !firrtl.vector<uint<10>, 5>, !firrtl.uint<2>
    firrtl.connect %z, %0 : !firrtl.uint<10>, !firrtl.uint<10>
  }
}","firrtl.circuit ""Foo""   {
  firrtl.module @Foo(
    in %x_0: !firrtl.uint<10>,
    in %x_1: !firrtl.uint<10>,
    in %x_2: !firrtl.uint<10>,
    in %x_3: !firrtl.uint<10>,
    in %x_4: !firrtl.uint<10>,
    in %source: !firrtl.uint<2>,
    out %z: !firrtl.uint<10>
  ) {
    %c1_ui2 = firrtl.constant 1 : !firrtl.uint<2>
    %c2_ui2 = firrtl.constant 2 : !firrtl.uint<2>
    %c3_ui2 = firrtl.constant 3 : !firrtl.uint<2>
    %c0_ui2 = firrtl.constant 0 : !firrtl.uint<2>  // <-- 4 being squeezed into the 2-bit index
    %0 = firrtl.eq %source, %c1_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>
    %1 = firrtl.mux(%0, %x_1, %x_0) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>
    %2 = firrtl.eq %source, %c2_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>
    %3 = firrtl.mux(%2, %x_2, %1) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>
    %4 = firrtl.eq %source, %c3_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>
    %5 = firrtl.mux(%4, %x_3, %3) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>
    %6 = firrtl.eq %source, %c0_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>
    %7 = firrtl.mux(%6, %x_4, %5) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>
    firrtl.connect %z, %7 : !firrtl.uint<10>, !firrtl.uint<10>
  }
}",,,,,,,,
2299,[FIRRTL] Parsing a `-1` Parameter Results in Too Few Bits,2021-12-06T21:07:20Z,closed,"bug, FIRRTL","When parsing external module parameters from FIRRTL text, negative numbers need to be expanded to a 32-bit value.  (Likely, all integer parameters should just be parsed as 32-bit values regardless of whether or not they can fit in a smaller-sized APSInt.)

As an example, the following input FIRRTL text:

```scala
circuit Foo:
  extmodule Bar:
    output a: UInt<1>
    parameter x = -1
  module Foo:
    output a: UInt<1>

    inst bar of Bar
    a <= bar.a
```

Is parsed into:
```mlir
firrtl.circuit ""Foo""   {
  firrtl.extmodule @Bar(out a: !firrtl.uint<1>) attributes {parameters = {x = -1 : i4}}
  firrtl.module @Foo(out %a: !firrtl.uint<1>) {
    %bar_a = firrtl.instance bar  @Bar(out a: !firrtl.uint<1>)
    firrtl.connect %a, %bar_a : !firrtl.uint<1>, !firrtl.uint<1>
  }
}
```

This results in the following Verilog:
```verilog
// external module Bar

module Foo(     // Foo.fir:5:10
  output a);

  Bar #(
    .x(15)
  ) bar (       // Foo.fir:8:5
    .a (a)
  );
endmodule
```

The SFC produces:
```verilog
module Foo(
  output  a
);
  wire  bar_a;
  Bar #(.x(-1)) bar (
    .a(bar_a)
  );
  assign a = bar_a;
endmodule
```","circuit Foo:
  extmodule Bar:
    output a: UInt<1>
    parameter x = -1
  module Foo:
    output a: UInt<1>

    inst bar of Bar
    a <= bar.a","firrtl.circuit ""Foo""   {
  firrtl.extmodule @Bar(out a: !firrtl.uint<1>) attributes {parameters = {x = -1 : i4}}
  firrtl.module @Foo(out %a: !firrtl.uint<1>) {
    %bar_a = firrtl.instance bar  @Bar(out a: !firrtl.uint<1>)
    firrtl.connect %a, %bar_a : !firrtl.uint<1>, !firrtl.uint<1>
  }
}","// external module Bar

module Foo(     // Foo.fir:5:10
  output a);

  Bar #(
    .x(15)
  ) bar (       // Foo.fir:8:5
    .a (a)
  );
endmodule","module Foo(
  output  a
);
  wire  bar_a;
  Bar #(.x(-1)) bar (
    .a(bar_a)
  );
  assign a = bar_a;
endmodule",,,,,,
2298,[LowerToHW] Define Behavior for Multiple Circuits,2021-12-06T19:11:08Z,open,"bug, FIRRTL, HW","Currently, if you compile multiple FIRRTL circuits, only one of them gets lowered. We need to define a behavior here for how this should work and what the resulting HW representation is. Consider the following:

```mlir
module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
  firrtl.circuit ""Bar""   {
    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}
```

This produces, after `LowerToHW`:
```mlir
module  {
  firrtl.circuit ""Bar""   {
    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
  hw.module @Foo(%a: i1) -> (b: i1) {
    hw.output %a : i1
  }
}
```

If allowed to continue after this, eventually `ExportVerilog` will print an error because it doesn't know how to handle a `firrtl.circuit`.

I can think of two behaviors here:

1. This should produce a flat list of modules.
2. (Likely what we need) This should lower each to two lists of modules in a `hw.namespace`-guarded region.","module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
  firrtl.circuit ""Bar""   {
    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
}","module  {
  firrtl.circuit ""Bar""   {
    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>
    }
  }
  hw.module @Foo(%a: i1) -> (b: i1) {
    hw.output %a : i1
  }
}",,,,,,,,
2289,[FIRRTL] Sub Folder Can't Use AsUInt Before Pad,2021-12-05T07:10:40Z,closed,"bug, FIRRTL","There's a bug in the sub folder added in #2251.  This inserts an `asUInt` before `canonicalizePrimOp` adds a `pad`.  The end result is that we wind up with zero-extension instead of sign-extension.

Consider:

```scala
circuit Bar :
  module Bar :
    input clock : Clock
    input reset : UInt<1>
    output out : UInt<5>

    reg r: UInt<1>, clock
    r <= r
    out <= sub(UInt<4>(0), dshl(UInt<1>(1), r))
```

After canonicalization, this is:

```mlir
firrtl.module @Bar(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, out %out: !firrtl.uint<5>) {
  %r = firrtl.reg %clock  : !firrtl.uint<2>
  firrtl.connect %r, %r : !firrtl.uint<2>, !firrtl.uint<2>
  %0 = firrtl.neg %r : (!firrtl.uint<2>) -> !firrtl.sint<3>
  %1 = firrtl.asUInt %0 : (!firrtl.sint<3>) -> !firrtl.uint<3>
  %2 = firrtl.pad %1, 5 : (!firrtl.uint<3>) -> !firrtl.uint<5>
  firrtl.connect %out, %2 : !firrtl.uint<5>, !firrtl.uint<5>
}
```

IMCP then collapses all this (as the register is invalid/zero) to produce the following Verilog:

```verilog
module Bar(output [4:0] out);
  assign out = 5'h7;
endmodule
```

This should be `5'h1f`.

The output produced by the SFC is the following which I think is `5'h1f` after the context determined widths happen, but I'm not sure...:
```verilog
module Bar(
  input        clock,
  input        reset,
  output [4:0] out
);
  assign out = 4'h0 - 4'h1;
endmodule
```","circuit Bar :
  module Bar :
    input clock : Clock
    input reset : UInt<1>
    output out : UInt<5>

    reg r: UInt<1>, clock
    r <= r
    out <= sub(UInt<4>(0), dshl(UInt<1>(1), r))","firrtl.module @Bar(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, out %out: !firrtl.uint<5>) {
  %r = firrtl.reg %clock  : !firrtl.uint<2>
  firrtl.connect %r, %r : !firrtl.uint<2>, !firrtl.uint<2>
  %0 = firrtl.neg %r : (!firrtl.uint<2>) -> !firrtl.sint<3>
  %1 = firrtl.asUInt %0 : (!firrtl.sint<3>) -> !firrtl.uint<3>
  %2 = firrtl.pad %1, 5 : (!firrtl.uint<3>) -> !firrtl.uint<5>
  firrtl.connect %out, %2 : !firrtl.uint<5>, !firrtl.uint<5>
}","module Bar(output [4:0] out);
  assign out = 5'h7;
endmodule","module Bar(
  input        clock,
  input        reset,
  output [4:0] out
);
  assign out = 4'h0 - 4'h1;
endmodule",,,,,,
2269,[LowerToHW] LowerToHW Can't Handle 0-width Constants,2021-12-01T17:47:35Z,closed,bug,"The following is crashing on an old assertion inside LowerToHW:

```mlir
firrtl.circuit ""top_mod""   {
  firrtl.module @top_mod(out %a: !firrtl.uint<0>) {
    %c0_ui0 = firrtl.constant 0 : !firrtl.uint<0>
    firrtl.connect %a, %c0_ui0 : !firrtl.uint<0>, !firrtl.uint<0>
  }
}
```

With the change in https://github.com/llvm/circt/pull/2268, this type of code can now be generated and we need to lower it.  Specifically, the above is reduced from the nightly performance regression `test1.fir` with #2268 applied.  The above code will then fail on `main` without #2268.","firrtl.circuit ""top_mod""   {
  firrtl.module @top_mod(out %a: !firrtl.uint<0>) {
    %c0_ui0 = firrtl.constant 0 : !firrtl.uint<0>
    firrtl.connect %a, %c0_ui0 : !firrtl.uint<0>, !firrtl.uint<0>
  }
}",,,,,,,,,
2256,"[ExportVerilog] Remove parallel assert, XFAIL, add comment",2021-11-30T09:22:00Z,closed,"bug, ExportVerilog","Remove the `isInParallelMode` flag and the corresponding assertion, which are no longer needed since the emission phase of `ExportVerilog` treats the IR as immutable, which allows for pretty straightforward parallelization. All mutation is limited to the preparation phase which lives in the separate `PrepareForEmission.cpp` file.

Also remove the XFAIL on one of the FIRRTL Grand Central integration tests, which used to trigger this assertion.

Add comments to the `ExportVerilog.cpp` and `PrepareForEmission.cpp` files explaining the separation into an IR-mutating preparation and IR-immutable emission phase.",,,,,,,,,,
2250,[CombFolds] Fix issue in icmp ult/ugt extract fold,2021-11-29T08:42:16Z,closed,"bug, FIRRTL","Fix an issue introduced in 3664712 where ult comparisons against a constant of the shape `0b111..111000..000` would be converted to an extract operation. The fold is based on the observation that in an icmp `x < cst`, where `cst` has this shape of a bunch of leading ones followed by all zeros, all values for `x` for which the comparison would return a 0 are the values that have all the upper bits set (those that are a one in the constant). Therefore the comparison is equivalent to checking if those upper bits are not all ones. The implementation in 3664712 erroneously checked the lower bits of the number.",,,,,,,,,,
2238,"[ExportVerilog] Fix bind emission, split into parallel/sequential phase",2021-11-25T07:43:54Z,closed,"bug, ExportVerilog","Emission of `sv.bind` requires to occur in a sequential piece of code. This is currently handled well in `emitOps` if parallelize is `true`, which is the case for single-file Verilog emission. But in split Verilog emission, `emitOps` itself is called in a parallel block, which breaks an implicit assumption in the code.

This change extends the split into parallel and sequential phases of emission, and makes them explicit at the unified/split Verilog emitter level by separating the `emitOps` function into an `emitOpsParallel` and a `emitOpsSequential`. These correspond to the first and second half of the original `emitOps`:

- `emitOpsParallel` performs opportunistic emission of operations. It tries to emit operations in parallel, if possible directly to the   output stream, or into a string buffer otherwise. It may leave operations unemitted.
- `emitOpsSequential` performs the final emission of operations. This includes emitting any string buffers produced by the parallel portion, and actually emitting any ops that were left over.

The split Verilog emitter now keeps a list of `SplitOutputFile`s in a vector, which is used to carry the necessary information from the parallel to the sequential emission phase. The emitter then performs emission in two phases: first calling the `emitParallel` function in a parallel block, and then calling the `emitSequential` function in a sequential block.

This fixes an assertion that triggers when trying to emit any design containing bind statements through the split Verilog emitter.",,,,,,,,,,
2207,[FIRRTL] Fix InferResets failing on zero-width registers,2021-11-18T17:32:12Z,closed,"bug, FIRRTL","In practice we have come across registers of width zero. The `InferResets` pass then tries to add an asynchronous reset to these, for which it has to come up with a zero value of that type. However, the `firrtl.constant` op cannot generate a value of width 0. This adds a workaround that keeps `ConstantOp` unchanged, but uses the `TailPrimOp` to chop off the only bit from a single-bit value.",,,,,,,,,,
2203,[FIRRTL] Cast Folders for Invalid,2021-11-18T00:04:16Z,closed,"bug, FIRRTL","Similar to #2197, there are other folds/canonicalizations that are missing that may result in registers hanging around.

Consider the following.  This is the same as #2197, but just with `asUInt` as opposed to `pad`:

```scala
circuit Foo:
  module Foo:
    input clock: Clock
    output a: UInt<1>

    wire x: SInt<1>
    x is invalid

    reg b: UInt<1>, clock
    b <= asUInt(x)
    a <= b
```

MFC produces a register:

```verilog
  always @(posedge clock)	// Foo.fir:10:7
    b <= 1'h0;	// Foo.fir:7:7, :10:7
  assign a = b;	// Foo.fir:2:10
```

SFC produces a constant output:

```verilog
  assign a = 1'h0;
```

However, this is just the tip of the iceberg.  I generated lots of tests of this same form and committed passing and failing test cases in https://github.com/llvm/circt/commit/4e21aebe0b26a4182ad95ef453ea4753618cf605.  When people look at fixing this, they should be able to move tests from the failing file to the passing file.","circuit Foo:
  module Foo:
    input clock: Clock
    output a: UInt<1>

    wire x: SInt<1>
    x is invalid

    reg b: UInt<1>, clock
    b <= asUInt(x)
    a <= b","always @(posedge clock)	// Foo.fir:10:7
    b <= 1'h0;	// Foo.fir:7:7, :10:7
  assign a = b;	// Foo.fir:2:10",assign a = 1'h0;,,,,,,,
2154,[ExportVerilog] Query global state to get the updated names,2021-11-11T21:34:00Z,closed,"bug, ExportVerilog","The commit https://github.com/llvm/circt/commit/fc7d917466db453d3e7a322194977519c4cb5a19, updated the name legalization to properly rename 
all declaration ops `(<WireOp, RegOp, LocalParamOp, InstanceOp>)`, and 
maintain them in the rename map in the global state. 
This means, the ops no longer have the updated names in the IR.

This commit fixes the `ExportVerilog` to query the global symbol table,
 for getting the name of any Declaration op.
This fixes an issue with the `bind` op printing the incorrect old names.


",,,,,,,,,,
2132,[FIRRTL] InferReset crash with Subaccess Index,2021-11-10T16:17:03Z,closed,"bug, FIRRTL","The following IR crashes with `circt-opt --pass-pipeline='firrtl.circuit(firrtl-infer-resets)'`

```mlir
firrtl.circuit ""Top"" {
  firrtl.module @Top(in %clock: !firrtl.clock, in %reset: !firrtl.asyncreset, in %init: !firrtl.uint<1>, in %in: !firrtl.uint<8>, in %extraReset: !firrtl.asyncreset ) attributes {
    portAnnotations = [[],[],[],[],[{class = ""firrtl.transforms.DontTouchAnnotation""}, {class = ""sifive.enterprise.firrtl.FullAsyncResetAnnotation""}]]} {
    %c1_ui8 = firrtl.constant 1 : !firrtl.uint<2>
    %arr = firrtl.wire : !firrtl.vector<uint<8>, 1>
    %reg6 = firrtl.regreset %clock, %init, %c1_ui8 : !firrtl.uint<1>, !firrtl.uint<2>, !firrtl.uint<2>
    %2 = firrtl.subaccess %arr[%reg6] : !firrtl.vector<uint<8>, 1>, !firrtl.uint<2>
    firrtl.connect %2, %in : !firrtl.uint<8>, !firrtl.uint<8>
                                                                                                                                                                                                                                              }
}
```

```
t1.mlir:6:13: error: subaccess requires vector operand, not '!firrtl.uint<2>' 
%reg6 = firrtl.regreset %clock, %init, %c1_ui8 : !firrtl.uint<1>, !firrtl.uint<2>, !firrtl.uint<2>
^  
LLVM ERROR: Failed to infer result type(s).           
```
Seems like `insertResetMux()` in `InferResets` doesn't handle the case when `resetValue` is not the input but `index` into `SubaccessOp` . ","firrtl.circuit ""Top"" {
  firrtl.module @Top(in %clock: !firrtl.clock, in %reset: !firrtl.asyncreset, in %init: !firrtl.uint<1>, in %in: !firrtl.uint<8>, in %extraReset: !firrtl.asyncreset ) attributes {
    portAnnotations = [[],[],[],[],[{class = ""firrtl.transforms.DontTouchAnnotation""}, {class = ""sifive.enterprise.firrtl.FullAsyncResetAnnotation""}]]} {
    %c1_ui8 = firrtl.constant 1 : !firrtl.uint<2>
    %arr = firrtl.wire : !firrtl.vector<uint<8>, 1>
    %reg6 = firrtl.regreset %clock, %init, %c1_ui8 : !firrtl.uint<1>, !firrtl.uint<2>, !firrtl.uint<2>
    %2 = firrtl.subaccess %arr[%reg6] : !firrtl.vector<uint<8>, 1>, !firrtl.uint<2>
    firrtl.connect %2, %in : !firrtl.uint<8>, !firrtl.uint<8>
                                                                                                                                                                                                                                              }
}","t1.mlir:6:13: error: subaccess requires vector operand, not '!firrtl.uint<2>' 
%reg6 = firrtl.regreset %clock, %init, %c1_ui8 : !firrtl.uint<1>, !firrtl.uint<2>, !firrtl.uint<2>
^  
LLVM ERROR: Failed to infer result type(s).",,,,,,,,
2126,[ExportVerilog] Parametric Verilog Widths Printing `w-1` as `w+MaxValue`,2021-11-10T04:28:49Z,closed,"bug, ExportVerilog","The following circuit:

```mlir
hw.module @Bar<w: i32 = 8>
  (%a: !hw.int<#hw.param.decl.ref<""w"">>) -> (b: !hw.int<#hw.param.decl.ref<""w"">>)  {
  hw.output %a : !hw.int<#hw.param.decl.ref<""w"">>
}
```

Is printing out as `w + 0xFFFFFFFF`:

```verilog
module Bar
  #(parameter w = 8) (
  input  [w + 4294967295:0] a,
  output [w + 4294967295:0] b);

  assign b = a;	
endmodule
```

This likes like a simple problem of `-1` not showing up as intended.","hw.module @Bar<w: i32 = 8>
  (%a: !hw.int<#hw.param.decl.ref<""w"">>) -> (b: !hw.int<#hw.param.decl.ref<""w"">>)  {
  hw.output %a : !hw.int<#hw.param.decl.ref<""w"">>
}","module Bar
  #(parameter w = 8) (
  input  [w + 4294967295:0] a,
  output [w + 4294967295:0] b);

  assign b = a;	
endmodule",,,,,,,,
2116,[ExportVerilog] Get legalized bind port names,2021-11-09T16:55:37Z,closed,"bug, ExportVerilog","The `emitBind` was using incorrect port names during `ExportVerilog`. 
Use `getPortVerilogName` to get the updated name. 
Fixes https://github.com/llvm/circt/issues/2084",,,,,,,,,,
2115,[ExportVerilog] Fix output port symbols not interpolating properly,2021-11-09T16:26:53Z,closed,"bug, ExportVerilog","Fix an issue in `ExportVerilog` where `hw.exportPort` symbols on output ports of a module would not be properly interpolated into `sv.verbatim` operations. This commit fixes the issue by adding the output ports to the symbol cache, and changing the interpolation of port symbols to rely on the `getPortVerilogName()` function of the `GlobalNameTable`. This has the benefit of beign consistent with the corresponding module (name collisions are resolved), and that no `BlockArgument` is required to get a hold of the output port name.",,,,,,,,,,
2109,[FIRRTL] Fix local wire/node resets not dominating inferred connections,2021-11-09T07:59:31Z,closed,"bug, FIRRTL","Fix an issue in `InferResets` where using a local wire or node as the async reset for the module could cause dominance issues when the wire was declared *after* some of things it would end up getting connected to. A typical example would be:

    %reg = firrtl.reg %clock
    %localReset = firrtl.wire /*FullAsyncResetAnnotation*/

In this case `InferResets` would decide to hook `%localReset` up to the register `%reg`, creating a dominance problem.

This commit changes the behavior of `InferResets` such that it moves the local reset declaration up to before the first thing it gets connected to, possibly converting a `NodeOp` to a `WireOp` if the node's input value blocks the move due to it not dominating the target site.

Thanks to @youngar for finding this issue!",,,,,,,,,,
2108,[SCFToCalyx] Incorrect assumptions for memory inlining.,2021-11-09T06:16:49Z,closed,"bug, Calyx","Currently, the SCFToCalyx pass assumes that if there is a single load from a given memory, then it can be ""inlined.""

This means a body with a read and write to the same memory will be inlined. This leads to two individual problems:

1. We probably shouldn't be reading and writing to the same memory within the same group.
2. Address ports are assigned twice; this is illegal.",,,,,,,,,,
2092,[ExportVerilog] Line Breaks in SV Verbatim not Commented,2021-11-07T18:30:09Z,closed,"bug, ExportVerilog","The following circuit, when run through Verilog export, results in illegal Verilog:

```mlir
firrtl.circuit ""Bar""   {
  firrtl.module @Foo(in %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: !firrtl.uint<1>, out %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: !firrtl.uint<1>) {
    firrtl.connect %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    , %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa : !firrtl.uint<1>, !firrtl.uint<1>
  }
  firrtl.module @Bar(in %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: !firrtl.uint<1>, out %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: !firrtl.uint<1>) {
    %foo_a, %foo_b = firrtl.instance foo {lowerToBind=true} @Foo(in aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: !firrtl.uint<1>, out bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: !firrtl.uint<1>)
    firrtl.connect %foo_a, %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb, %foo_b : !firrtl.uint<1>, !firrtl.uint<1>
  }
}
```

This produces (`firtool Bar.mlir -verilog`):

```verilog
module Foo(	// Bar.mlir:3:5
  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);

  assign bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb = 
                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;	// Bar.mlir:3:5
endmodule

module Bar(	// Bar.mlir:7:5
  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);

  // This instance is elsewhere emitted as a bind statement.
  // Foo foo (	// Bar.mlir:8:24
  //   .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (
                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),
  //   .bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)
  // );
endmodule
```

The problem appears to have been introduced in: 7d94f232

Previously, this would produce:

```verilog
module Foo(	// Bar.mlir:3:5
  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);

  assign bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;	// Bar.mlir:3:5
endmodule

module Bar(	// Bar.mlir:7:5
  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);

  // This instance is elsewhere emitted as a bind statement.
  // Foo foo (	// Bar.mlir:8:24
  //   .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),
  //   .bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)
  // );
endmodule
```","firrtl.circuit ""Bar""   {
  firrtl.module @Foo(in %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: !firrtl.uint<1>, out %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: !firrtl.uint<1>) {
    firrtl.connect %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    , %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa : !firrtl.uint<1>, !firrtl.uint<1>
  }
  firrtl.module @Bar(in %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: !firrtl.uint<1>, out %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: !firrtl.uint<1>) {
    %foo_a, %foo_b = firrtl.instance foo {lowerToBind=true} @Foo(in aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: !firrtl.uint<1>, out bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: !firrtl.uint<1>)
    firrtl.connect %foo_a, %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb, %foo_b : !firrtl.uint<1>, !firrtl.uint<1>
  }
}","module Foo(	// Bar.mlir:3:5
  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);

  assign bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb = 
                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;	// Bar.mlir:3:5
endmodule

module Bar(	// Bar.mlir:7:5
  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);

  // This instance is elsewhere emitted as a bind statement.
  // Foo foo (	// Bar.mlir:8:24
  //   .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (
                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),
  //   .bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)
  // );
endmodule","module Foo(	// Bar.mlir:3:5
  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);

  assign bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;	// Bar.mlir:3:5
endmodule

module Bar(	// Bar.mlir:7:5
  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,
  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);

  // This instance is elsewhere emitted as a bind statement.
  // Foo foo (	// Bar.mlir:8:24
  //   .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),
  //   .bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)
  // );
endmodule",,,,,,,
2089,[FIRRTL] Free of Unalloc'd Pointer during Assert Parsing,2021-11-06T19:30:27Z,closed,"bug, FIRRTL","The following circuit is causing a free of an unallocated pointer crash inside `FIRParserAsserts.cpp`:

```scala
circuit Foo:
  module Foo:
    input clock: Clock
    input reset: UInt<1>
    input a: UInt<1>

    when a :
      node b = eq(reset, UInt<1>(""h0""))
      when b :
        assert(clock, UInt<1>(""h1""), UInt<1>(""h1""), """") : assert_50
        node c = eq(UInt<1>(""h1""), UInt<1>(""h0""))
        when c :
          printf(clock, UInt<1>(""h1""), ""Assertion failed: [verif-library-assert]<extraction-summary>{\""predicateModifier\"":{\""type\"":\""noMod\""},\""format\"":{\""type\"":\""ifElseFatal\""},\""labelExts\"":[\""hello\""],\""baseMsg\"":\""Assertion failed (verification library): hello  @[hello.scala 1337:42]\""}</extraction-summary>\n    at world.scala:42 chisel3.assert(predicate, flag + exStr, msgArgs: _*)(sourceInfo, compileOptions)\n"") : printf_50
```

I'm seeing:
```
# lldb firtool -- issues/free-unalloc.fir 
(lldb) target create ""firtool""
Current executable set to 'firtool' (x86_64).
(lldb) settings set -- target.run-args  ""issues/free-unalloc.fir""
(lldb) r
Process 91940 launched: '/usr/bin/firtool' (x86_64)
firtool(91940,0x10499fe00) malloc: *** error for object 0x104d15c10: pointer being freed was not allocated
firtool(91940,0x10499fe00) malloc: *** set a breakpoint in malloc_error_break to debug
Process 91940 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGABRT
    frame #0: 0x00007fff204c092e libsystem_kernel.dylib`__pthread_kill + 10
libsystem_kernel.dylib`__pthread_kill:
->  0x7fff204c092e <+10>: jae    0x7fff204c0938            ; <+20>
    0x7fff204c0930 <+12>: movq   %rax, %rdi
    0x7fff204c0933 <+15>: jmp    0x7fff204baad9            ; cerror_nocancel
    0x7fff204c0938 <+20>: retq   
Target 0: (firtool) stopped.
(lldb) frame select 7
frame #7: 0x00000001002b5fdf firtool`circt::firrtl::foldWhenEncodedVerifOp(builder=0x00007ffeefbfca60, whenStmt=WhenOp @ 0x00007ffeefbfc058) at FIRParserAsserts.cpp:302:11
   299 	          });
   300 	    }
   301 	    for (auto op : opsToErase)
-> 302 	      op->erase();
   303 	  }
   304 	
   305 	  builder.setInsertionPointAfter(whenStmt);
```","circuit Foo:
  module Foo:
    input clock: Clock
    input reset: UInt<1>
    input a: UInt<1>

    when a :
      node b = eq(reset, UInt<1>(""h0""))
      when b :
        assert(clock, UInt<1>(""h1""), UInt<1>(""h1""), """") : assert_50
        node c = eq(UInt<1>(""h1""), UInt<1>(""h0""))
        when c :
          printf(clock, UInt<1>(""h1""), ""Assertion failed: [verif-library-assert]<extraction-summary>{\""predicateModifier\"":{\""type\"":\""noMod\""},\""format\"":{\""type\"":\""ifElseFatal\""},\""labelExts\"":[\""hello\""],\""baseMsg\"":\""Assertion failed (verification library): hello  @[hello.scala 1337:42]\""}</extraction-summary>\n    at world.scala:42 chisel3.assert(predicate, flag + exStr, msgArgs: _*)(sourceInfo, compileOptions)\n"") : printf_50","# lldb firtool -- issues/free-unalloc.fir 
(lldb) target create ""firtool""
Current executable set to 'firtool' (x86_64).
(lldb) settings set -- target.run-args  ""issues/free-unalloc.fir""
(lldb) r
Process 91940 launched: '/usr/bin/firtool' (x86_64)
firtool(91940,0x10499fe00) malloc: *** error for object 0x104d15c10: pointer being freed was not allocated
firtool(91940,0x10499fe00) malloc: *** set a breakpoint in malloc_error_break to debug
Process 91940 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGABRT
    frame #0: 0x00007fff204c092e libsystem_kernel.dylib`__pthread_kill + 10
libsystem_kernel.dylib`__pthread_kill:
->  0x7fff204c092e <+10>: jae    0x7fff204c0938            ; <+20>
    0x7fff204c0930 <+12>: movq   %rax, %rdi
    0x7fff204c0933 <+15>: jmp    0x7fff204baad9            ; cerror_nocancel
    0x7fff204c0938 <+20>: retq   
Target 0: (firtool) stopped.
(lldb) frame select 7
frame #7: 0x00000001002b5fdf firtool`circt::firrtl::foldWhenEncodedVerifOp(builder=0x00007ffeefbfca60, whenStmt=WhenOp @ 0x00007ffeefbfc058) at FIRParserAsserts.cpp:302:11
   299 	          });
   300 	    }
   301 	    for (auto op : opsToErase)
-> 302 	      op->erase();
   303 	  }
   304 	
   305 	  builder.setInsertionPointAfter(whenStmt);",,,,,,,,
2069,"[HW] [Windows] Assertion failed: !it->second.hasPort() && ""Module names should never be ports"", file C:\code\circt\include\circt/Dialect/HW/HWOps.h, line 187",2021-11-02T04:29:43Z,closed,"bug, HW","CIRCT on Windows is currently broken with `Assertion failed: !it->second.hasPort() && ""Module names should never be ports"", file C:\code\circt\include\circt/Dialect/HW/HWOps.h, line 187`. For instance:

```
FAIL: CIRCT :: Dialect/SV/prettify-verilog.mlir (121 of 300)
******************** TEST 'CIRCT :: Dialect/SV/prettify-verilog.mlir' FAILED ********************
Script:
--
: 'RUN: at line 1';   c:\code\circt_build\bin\circt-opt.exe -prettify-verilog C:\code\circt\test\Dialect\SV\prettify-verilog.mlir | c:\code\circt_build\bin\filecheck.exe C:\code\circt\test\Dialect\SV\prettify-verilog.mlir
: 'RUN: at line 2';   c:\code\circt_build\bin\circt-opt.exe -prettify-verilog C:\code\circt\test\Dialect\SV\prettify-verilog.mlir | c:\code\circt_build\bin\circt-opt.exe --export-verilog | c:\code\circt_build\bin\filecheck.exe C:\code\circt\test\Dialect\SV\prettify-verilog.mlir --check-prefix=VERILOG
--
Exit Code: 2

Command Output (stdout):
--
$ "":"" ""RUN: at line 1""
$ ""c:\code\circt_build\bin\circt-opt.exe"" ""-prettify-verilog"" ""C:\code\circt\test\Dialect\SV\prettify-verilog.mlir""
$ ""c:\code\circt_build\bin\filecheck.exe"" ""C:\code\circt\test\Dialect\SV\prettify-verilog.mlir""
$ "":"" ""RUN: at line 2""
$ ""c:\code\circt_build\bin\circt-opt.exe"" ""-prettify-verilog"" ""C:\code\circt\test\Dialect\SV\prettify-verilog.mlir""
$ ""c:\code\circt_build\bin\circt-opt.exe"" ""--export-verilog""
# command stderr:
Assertion failed: !it->second.hasPort() && ""Module names should never be ports"", file C:\code\circt\include\circt/Dialect/HW/HWOps.h, line 187
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
 #0 0x00007ff6331998cc HandleAbort C:\code\circt\llvm\llvm\lib\Support\Windows\Signals.inc:408:0
 #1 0x00007ffbbcf9bc31 (C:\WINDOWS\SYSTEM32\ucrtbased.dll+0x6bc31)
 #2 0x00007ffbbcf9d889 (C:\WINDOWS\SYSTEM32\ucrtbased.dll+0x6d889)
 #3 0x00007ffbbcfa30bf (C:\WINDOWS\SYSTEM32\ucrtbased.dll+0x730bf)
 #4 0x00007ffbbcfa1091 (C:\WINDOWS\SYSTEM32\ucrtbased.dll+0x71091)
 #5 0x00007ffbbcfa3a1f (C:\WINDOWS\SYSTEM32\ucrtbased.dll+0x73a1f)
 #6 0x00007ff63359db34 circt::hw::SymbolCache::getDefinition(class llvm::StringRef) const C:\code\circt\include\circt\Dialect\HW\HWOps.h:187:0
 #7 0x00007ff63359d9f0 circt::hw::SymbolCache::getDefinition(class mlir::FlatSymbolRefAttr) const C:\code\circt\include\circt\Dialect\HW\HWOps.h:197:0
 #8 0x00007ff633db9a99 circt::hw::InstanceOp::getReferencedModule(class circt::hw::SymbolCache const *) C:\code\circt\lib\Dialect\HW\HWOps.cpp:832:0
 #9 0x00007ff6335319ea `anonymous namespace'::StmtEmitter::visitStmt C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:3016:0
#10 0x00007ff6335508fd <lambda_67ecaea1f18c3f2c5781c752e8551e9e>::operator()<circt::hw::InstanceOp> C:\code\circt\include\circt\Dialect\HW\HWVisitors.h:84:0
#11 0x00007ff63355a605 llvm::TypeSwitch<mlir::Operation *,mlir::LogicalResult>::Case<circt::hw::InstanceOp,<lambda_67ecaea1f18c3f2c5781c752e8551e9e> &> C:\code\circt\llvm\llvm\include\llvm\ADT\TypeSwitch.h:121:0
#12 0x00007ff63355c83c llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation *,mlir::LogicalResult>,mlir::Operation *>::Case<circt::hw::OutputOp,circt::hw::InstanceOp,<lambda_67ecaea1f18c3f2c5781c752e8551e9e> > C:\code\circt\llvm\llvm\include\llvm\ADT\TypeSwitch.h:47:0
#13 0x00007ff63352e7cb circt::hw::StmtVisitor<`anonymous namespace'::StmtEmitter,mlir::LogicalResult>::dispatchStmtVisitor C:\code\circt\include\circt\Dialect\HW\HWVisitors.h:82:0
#14 0x00007ff63352ef03 `anonymous namespace'::StmtEmitter::emitStatement C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:3228:0
#15 0x00007ff63352f15e `anonymous namespace'::StmtEmitter::emitStatementBlock C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:3429:0
#16 0x00007ff633522d73 `anonymous namespace'::ModuleEmitter::emitHWModule C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:3775:0
#17 0x00007ff63354ffcc <lambda_5180d4edfd1d3e51638c180167ed63ea>::operator()<circt::hw::HWModuleOp> C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:4105:0
#18 0x00007ff633558f85 llvm::TypeSwitch<mlir::Operation *,void>::Case<circt::hw::HWModuleOp,<lambda_5180d4edfd1d3e51638c180167ed63ea> > C:\code\circt\llvm\llvm\include\llvm\ADT\TypeSwitch.h:170:0
#19 0x00007ff63353d386 emitOperation C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:4104:0
#20 0x00007ff63353d812 <lambda_a9ede889d1b3f22089910ed89a310f8b>::operator() C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:4171:0
#21 0x00007ff63354d1cf <lambda_7050d41f794d1e46a912ba0add2fdfba>::operator()<`anonymous namespace'::StringOrOpToEmit &> C:\code\circt\llvm\mlir\include\mlir\IR\Threading.h:125:0
#22 0x00007ff633540f5f <lambda_61ef71485879529b202dab933c69d60c>::operator() C:\code\circt\llvm\mlir\include\mlir\IR\Threading.h:65:0
#23 0x00007ff633577e74 std::invoke<<lambda_61ef71485879529b202dab933c69d60c> &> C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.29.30133\include\type_traits:1586:0
#24 0x00007ff633562a74 std::_Invoker_ret<void,1>::_Call<<lambda_61ef71485879529b202dab933c69d60c> &> C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.29.30133\include\functional:745:0
#25 0x00007ff6335413cb std::_Func_impl_no_alloc<<lambda_61ef71485879529b202dab933c69d60c>,void>::_Do_call C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.29.30133\include\functional:921:0
#26 0x00007ff6337bfb3f std::_Func_class<void>::operator()(void) const C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.29.30133\include\functional:969:0
#27 0x00007ff635317fd4 std::_Packaged_state<(void)>::_Call_immediate(void) C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.29.30133\include\future:604:0
#28 0x00007ff635317b50 std::packaged_task<(void)>::operator()(void) C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.29.30133\include\future:1399:0
#29 0x00007ff635314cda <lambda_363bb815a5743b94ed5a743b9a07bcb7>::operator() C:\code\circt\llvm\llvm\lib\Support\ThreadPool.cpp:56:0
#30 0x00007ff635315718 llvm::thread::Apply<<lambda_363bb815a5743b94ed5a743b9a07bcb7> > C:\code\circt\llvm\llvm\include\llvm\Support\thread.h:43:0
#31 0x00007ff635315787 llvm::thread::GenericThreadProxy<std::tuple<<lambda_363bb815a5743b94ed5a743b9a07bcb7> > > C:\code\circt\llvm\llvm\include\llvm\Support\thread.h:51:0
#32 0x00007ff6353157e4 llvm::thread::ThreadProxy<std::tuple<<lambda_363bb815a5743b94ed5a743b9a07bcb7> > > C:\code\circt\llvm\llvm\include\llvm\Support\thread.h:71:0
#33 0x00007ffbbcfa4c7c (C:\WINDOWS\SYSTEM32\ucrtbased.dll+0x74c7c)
#34 0x00007ffc2d1d54e0 (C:\WINDOWS\System32\KERNEL32.DLL+0x154e0)
#35 0x00007ffc2dce485b (C:\WINDOWS\SYSTEM32\ntdll.dll+0x485b)

error: command failed with exit status: 2147483651
$ ""c:\code\circt_build\bin\filecheck.exe"" ""C:\code\circt\test\Dialect\SV\prettify-verilog.mlir"" ""--check-prefix=VERILOG""
# command stderr:
FileCheck error: '<stdin>' is empty.
FileCheck command line:  c:\code\circt_build\bin\filecheck.exe C:\code\circt\test\Dialect\SV\prettify-verilog.mlir --check-prefix=VERILOG

error: command failed with exit status: 2

--
```

@darthscsi Since you touched this line 6 days ago, I'm assigning this to you. ","FAIL: CIRCT :: Dialect/SV/prettify-verilog.mlir (121 of 300)
******************** TEST 'CIRCT :: Dialect/SV/prettify-verilog.mlir' FAILED ********************
Script:
--
: 'RUN: at line 1';   c:\code\circt_build\bin\circt-opt.exe -prettify-verilog C:\code\circt\test\Dialect\SV\prettify-verilog.mlir | c:\code\circt_build\bin\filecheck.exe C:\code\circt\test\Dialect\SV\prettify-verilog.mlir
: 'RUN: at line 2';   c:\code\circt_build\bin\circt-opt.exe -prettify-verilog C:\code\circt\test\Dialect\SV\prettify-verilog.mlir | c:\code\circt_build\bin\circt-opt.exe --export-verilog | c:\code\circt_build\bin\filecheck.exe C:\code\circt\test\Dialect\SV\prettify-verilog.mlir --check-prefix=VERILOG
--
Exit Code: 2

Command Output (stdout):
--
$ "":"" ""RUN: at line 1""
$ ""c:\code\circt_build\bin\circt-opt.exe"" ""-prettify-verilog"" ""C:\code\circt\test\Dialect\SV\prettify-verilog.mlir""
$ ""c:\code\circt_build\bin\filecheck.exe"" ""C:\code\circt\test\Dialect\SV\prettify-verilog.mlir""
$ "":"" ""RUN: at line 2""
$ ""c:\code\circt_build\bin\circt-opt.exe"" ""-prettify-verilog"" ""C:\code\circt\test\Dialect\SV\prettify-verilog.mlir""
$ ""c:\code\circt_build\bin\circt-opt.exe"" ""--export-verilog""
# command stderr:
Assertion failed: !it->second.hasPort() && ""Module names should never be ports"", file C:\code\circt\include\circt/Dialect/HW/HWOps.h, line 187
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
 #0 0x00007ff6331998cc HandleAbort C:\code\circt\llvm\llvm\lib\Support\Windows\Signals.inc:408:0
 #1 0x00007ffbbcf9bc31 (C:\WINDOWS\SYSTEM32\ucrtbased.dll+0x6bc31)
 #2 0x00007ffbbcf9d889 (C:\WINDOWS\SYSTEM32\ucrtbased.dll+0x6d889)
 #3 0x00007ffbbcfa30bf (C:\WINDOWS\SYSTEM32\ucrtbased.dll+0x730bf)
 #4 0x00007ffbbcfa1091 (C:\WINDOWS\SYSTEM32\ucrtbased.dll+0x71091)
 #5 0x00007ffbbcfa3a1f (C:\WINDOWS\SYSTEM32\ucrtbased.dll+0x73a1f)
 #6 0x00007ff63359db34 circt::hw::SymbolCache::getDefinition(class llvm::StringRef) const C:\code\circt\include\circt\Dialect\HW\HWOps.h:187:0
 #7 0x00007ff63359d9f0 circt::hw::SymbolCache::getDefinition(class mlir::FlatSymbolRefAttr) const C:\code\circt\include\circt\Dialect\HW\HWOps.h:197:0
 #8 0x00007ff633db9a99 circt::hw::InstanceOp::getReferencedModule(class circt::hw::SymbolCache const *) C:\code\circt\lib\Dialect\HW\HWOps.cpp:832:0
 #9 0x00007ff6335319ea `anonymous namespace'::StmtEmitter::visitStmt C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:3016:0
#10 0x00007ff6335508fd <lambda_67ecaea1f18c3f2c5781c752e8551e9e>::operator()<circt::hw::InstanceOp> C:\code\circt\include\circt\Dialect\HW\HWVisitors.h:84:0
#11 0x00007ff63355a605 llvm::TypeSwitch<mlir::Operation *,mlir::LogicalResult>::Case<circt::hw::InstanceOp,<lambda_67ecaea1f18c3f2c5781c752e8551e9e> &> C:\code\circt\llvm\llvm\include\llvm\ADT\TypeSwitch.h:121:0
#12 0x00007ff63355c83c llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation *,mlir::LogicalResult>,mlir::Operation *>::Case<circt::hw::OutputOp,circt::hw::InstanceOp,<lambda_67ecaea1f18c3f2c5781c752e8551e9e> > C:\code\circt\llvm\llvm\include\llvm\ADT\TypeSwitch.h:47:0
#13 0x00007ff63352e7cb circt::hw::StmtVisitor<`anonymous namespace'::StmtEmitter,mlir::LogicalResult>::dispatchStmtVisitor C:\code\circt\include\circt\Dialect\HW\HWVisitors.h:82:0
#14 0x00007ff63352ef03 `anonymous namespace'::StmtEmitter::emitStatement C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:3228:0
#15 0x00007ff63352f15e `anonymous namespace'::StmtEmitter::emitStatementBlock C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:3429:0
#16 0x00007ff633522d73 `anonymous namespace'::ModuleEmitter::emitHWModule C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:3775:0
#17 0x00007ff63354ffcc <lambda_5180d4edfd1d3e51638c180167ed63ea>::operator()<circt::hw::HWModuleOp> C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:4105:0
#18 0x00007ff633558f85 llvm::TypeSwitch<mlir::Operation *,void>::Case<circt::hw::HWModuleOp,<lambda_5180d4edfd1d3e51638c180167ed63ea> > C:\code\circt\llvm\llvm\include\llvm\ADT\TypeSwitch.h:170:0
#19 0x00007ff63353d386 emitOperation C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:4104:0
#20 0x00007ff63353d812 <lambda_a9ede889d1b3f22089910ed89a310f8b>::operator() C:\code\circt\lib\Conversion\ExportVerilog\ExportVerilog.cpp:4171:0
#21 0x00007ff63354d1cf <lambda_7050d41f794d1e46a912ba0add2fdfba>::operator()<`anonymous namespace'::StringOrOpToEmit &> C:\code\circt\llvm\mlir\include\mlir\IR\Threading.h:125:0
#22 0x00007ff633540f5f <lambda_61ef71485879529b202dab933c69d60c>::operator() C:\code\circt\llvm\mlir\include\mlir\IR\Threading.h:65:0
#23 0x00007ff633577e74 std::invoke<<lambda_61ef71485879529b202dab933c69d60c> &> C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.29.30133\include\type_traits:1586:0
#24 0x00007ff633562a74 std::_Invoker_ret<void,1>::_Call<<lambda_61ef71485879529b202dab933c69d60c> &> C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.29.30133\include\functional:745:0
#25 0x00007ff6335413cb std::_Func_impl_no_alloc<<lambda_61ef71485879529b202dab933c69d60c>,void>::_Do_call C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.29.30133\include\functional:921:0
#26 0x00007ff6337bfb3f std::_Func_class<void>::operator()(void) const C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.29.30133\include\functional:969:0
#27 0x00007ff635317fd4 std::_Packaged_state<(void)>::_Call_immediate(void) C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.29.30133\include\future:604:0
#28 0x00007ff635317b50 std::packaged_task<(void)>::operator()(void) C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Tools\MSVC\14.29.30133\include\future:1399:0
#29 0x00007ff635314cda <lambda_363bb815a5743b94ed5a743b9a07bcb7>::operator() C:\code\circt\llvm\llvm\lib\Support\ThreadPool.cpp:56:0
#30 0x00007ff635315718 llvm::thread::Apply<<lambda_363bb815a5743b94ed5a743b9a07bcb7> > C:\code\circt\llvm\llvm\include\llvm\Support\thread.h:43:0
#31 0x00007ff635315787 llvm::thread::GenericThreadProxy<std::tuple<<lambda_363bb815a5743b94ed5a743b9a07bcb7> > > C:\code\circt\llvm\llvm\include\llvm\Support\thread.h:51:0
#32 0x00007ff6353157e4 llvm::thread::ThreadProxy<std::tuple<<lambda_363bb815a5743b94ed5a743b9a07bcb7> > > C:\code\circt\llvm\llvm\include\llvm\Support\thread.h:71:0
#33 0x00007ffbbcfa4c7c (C:\WINDOWS\SYSTEM32\ucrtbased.dll+0x74c7c)
#34 0x00007ffc2d1d54e0 (C:\WINDOWS\System32\KERNEL32.DLL+0x154e0)
#35 0x00007ffc2dce485b (C:\WINDOWS\SYSTEM32\ntdll.dll+0x485b)

error: command failed with exit status: 2147483651
$ ""c:\code\circt_build\bin\filecheck.exe"" ""C:\code\circt\test\Dialect\SV\prettify-verilog.mlir"" ""--check-prefix=VERILOG""
# command stderr:
FileCheck error: '<stdin>' is empty.
FileCheck command line:  c:\code\circt_build\bin\filecheck.exe C:\code\circt\test\Dialect\SV\prettify-verilog.mlir --check-prefix=VERILOG

error: command failed with exit status: 2

--",,,,,,,,,
2047,[FIRRTL] Make GCT data tap hierarchical names start at module,2021-10-28T08:02:09Z,closed,"bug, FIRRTL","Change how GCT data/memory taps are generated by always starting the hierarchical names with a module. This removes ambiguities where a local declaration `bar` could shadow an instance `bar` in a parent module, rendering the XMR `bar.x` invalid. Also, if a signal is tapped in the same module where the data taps module is instantiated, the resulting hierarchical name would just be `x`, which in SV is not a hierarchical name and causes no resolution against the `x` in the parent module we're interested in. Always inserting a module name prefix removes any such ambiguity, generates a hierarchical name in any case, and causes SV to properly look upwards in the instance graph until that parent module is found.",,,,,,,,,,
2041,[FIRRTL] Extend when-encoded assert pattern detection in parser,2021-10-27T09:08:09Z,closed,"bug, FIRRTL","Extend the FIR file parser's ability to detect when-encoded assertions. In recent Chisel versions, these have slightly changed to now be of the form:

    assert(clock, cond, enable, ""msg"")
    node T = eq(cond, UInt<1>(0))
    when T:
      printf(clock, enable, ""Assertion failed: msg"")

The previous implementation of the FIR parser only detects the following pattern:

    when not_cond:
      printf(clock, enable, ""Assertion failed: msg"")
      stop(clock, enable, 1)

This fixes issues SiFive has seen on FIRRTL emitted from never versions of Chisel. Originally found by @Ramlakshmi3733.",,,,,,,,,,
2039,[FIRRTL] Fix SRAM instance paths in OMIR,2021-10-26T14:57:19Z,closed,"bug, FIRRTL","Fix an issue in `EmitOMIR` where the instance paths of SRAMs would be incorrectly rendered as `OMMemberReferenceTarget` instead of the correct `OMMemberInstanceTarget`. This also includes figuring out the module name that the final SRAM is going to have, which in the case of a `firrtl.mem` is a bit tricky/fragile: the actual module name for the memory is only generated after lowering to the HW dialect, at which point the OMIR has long been emitted. This change ""predicts"" the name that the memory is going to have by querying `getFirMemoryName()`, which looks like it's going to be accurate in most cases we currently care about.

In the long run, we'll want better ways to encode this formulation of an instance path and ideally dealy it until `ExportVerilog` time.",,,,,,,,,,
2036,Analysis/scheduling-analysis.mlir failing on release builds,2021-10-25T23:48:19Z,closed,bug,"Analysis/scheduling-analysis.mlir is failing for me on release, but not debug builds on multiple machines.  This clearly isn't affecting everybody.
I am not seeing:
`arith.addi %arg2, %1 {dependence}`
but rather
`      %2 = arith.addi %arg2, %1 : i32`
in the output (for example).",,,,,,,,,,
2029,[FIRRTL] RemoveCHIRRTL Should Lower Unused Memories (or at least repsect DontTouch),2021-10-22T17:54:24Z,open,"bug, FIRRTL","If you have an unused behavior memory in FIRRTL, the SFC will lower this to a memory that has no ports. This is a candidate for later DCE, but won't be DCE'd if there is a don't touch annotation. 

In CIRCT, we are deleting behavioral memories which have no users, i.e., DCE'ing unused memories during RemoveCHIRRTL,  and not respecting a dont touch annotation that may exist.

I expect that this has no effect on ""sane"" designs and is consequently a low priority bug. For more info, I hit this when writing some test cases for Grand Central where I didn't want to hook up my memories. 😅 ",,,,,,,,,,
2027,[FIRRTL] Prefix Grand Central Data/Mem Taps,2021-10-22T05:33:29Z,closed,"bug, FIRRTL","I believe that https://github.com/llvm/circt/pull/2020 needs to be extended to work with Grand Central data and mem tap blackboxes. Likely, this needs the same approach as #2020 where prefix modules is updated to mutate data/mem tap annotations. That should be enough for `GrandCentralTaps` to use the new names without modifications.",,,,,,,,,,
2026,[FIRRTL] BlackBoxMemory Pass Needs to Handle All Annotations,2021-10-22T04:43:51Z,open,"bug, FIRRTL","The `BlackBoxMemory` pass was updated to copy annotations from memories onto the blackboxed instance in f239be4cd23bb21a1a19854f5bdc325ddf953ec1. However, port annotations are currently being dropped.

Update this pass to copy over port annotations with the following strategy:
- An annotation on a memory port should be applied to all flattened ports associated with the original port
- An annotation on a specific field of a memory port should be copied to its respective flattened new port

Additionally, it may make more sense to copy annotations onto the external module as opposed to onto the instance (which is how f239be4cd23bb21a1a19854f5bdc325ddf953ec1) does it. One or the other should be entirely equivalent (from the perspective of preserving the information, though copying onto the module may be better).",,,,,,,,,,
1996,[FIRRTL] Mark extmodules that had black box anno consumed,2021-10-14T17:41:08Z,closed,"bug, FIRRTL","Fix an issue where generating metadata after the blackbox reader pass has run would cause additional blackbox modules to appear in the generated metadata. This happens because the blackbox reader removes the blackbox annotations, which the metadata pass is looking for to blacklist the corresponding extmodules.

This change causes the blackbox reader pass to add a `BlackBox` annotation on any extmodule for which it has processed one of the blackbox annotations. The metadata pass then additionally blacklists this annotation. Also add a unit and integration test to ensure this happens.

Fixes an issue in the SiFive flow (@Ramlakshmi3733).",,,,,,,,,,
1988,[Simulator] UB when using llhd.shr on signal,2021-10-13T10:26:15Z,open,"bug, LLHD, Simulator","The following code leads to UB in the output trace, although, the semantics are clearly defined. This is because of a bug in the `ShrOpConversion` pattern in the `LLHDToLLVM` pass, where there is a slice extract performed only on the `%basesig` value instead of a concatenation of hidden and base.

```mlir
llhd.entity @root () -> () {
  %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>

  %hidden = hw.constant 0xff : i8
  %base = hw.constant 0 : i8
  %amnt = hw.constant 4 : i3

  %resultsig = llhd.sig ""result"" %base : i8
  %basesig = llhd.sig ""base"" %base : i8
  %hiddensig = llhd.sig ""hidden"" %hidden : i8
  %shr = llhd.shr %basesig, %hiddensig, %amnt : (!llhd.sig<i8>, !llhd.sig<i8>, i3) -> !llhd.sig<i8>
  %prbshr = llhd.prb %shr : !llhd.sig<i8>
  llhd.drv %resultsig, %prbshr after %time : !llhd.sig<i8>
}
```

Expected output:
```
0ps 0d 0e  root/base  0x00
0ps 0d 0e  root/hidden  0xff
0ps 0d 0e  root/result  0x00
1000ps 0d 0e  root/result  0xf0         // UB here (also seen 0x70, 0x10, etc.)
Finished at 2000ps 0d 0e (3 cycles)
```","llhd.entity @root () -> () {
  %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>

  %hidden = hw.constant 0xff : i8
  %base = hw.constant 0 : i8
  %amnt = hw.constant 4 : i3

  %resultsig = llhd.sig ""result"" %base : i8
  %basesig = llhd.sig ""base"" %base : i8
  %hiddensig = llhd.sig ""hidden"" %hidden : i8
  %shr = llhd.shr %basesig, %hiddensig, %amnt : (!llhd.sig<i8>, !llhd.sig<i8>, i3) -> !llhd.sig<i8>
  %prbshr = llhd.prb %shr : !llhd.sig<i8>
  llhd.drv %resultsig, %prbshr after %time : !llhd.sig<i8>
}","0ps 0d 0e  root/base  0x00
0ps 0d 0e  root/hidden  0xff
0ps 0d 0e  root/result  0x00
1000ps 0d 0e  root/result  0xf0         // UB here (also seen 0x70, 0x10, etc.)
Finished at 2000ps 0d 0e (3 cycles)",,,,,,,,
1971,[FIRRTL] Annotation Parsing Performance Bug,2021-10-11T19:50:49Z,closed,"bug, FIRRTL","As found by @Ramlakshmi3733, large designs seem to exhibit bad scaling performance with the existing FIRRTL Parser's annotation parsing/scattering.  I don't have a minimal example, but a ""large"" design is spending 50% of its total compile in the parser and ~60% of the parser time appears to be dealing with annotations. (This was tested by running with and without an annotation file.)

We should figure out what's going on here.  This likely involves moving the annotation scattering/application into the annotation handling pass and removing the old processing logic.",,,,,,,,,,
1969,"[FIRRTL] Investigate, Fix Grand Central Slowness",2021-10-11T13:40:55Z,closed,"bug, FIRRTL","The Grand Central (`lib/Dialect/FIRRTL/Transforms/GrandCentral.cpp`), Grand Central Taps (`lib/Dialect/FIRRTL/Transforms/GrandCentralTaps.cpp`), and Grand Central Signal Mappings (`lib/Dialect/FIRRTL/Transforms/GrandCentralSignalMappings.cpp`) have been reported as running slow on large designs (with duplicated modules). Investigate what's going on here and fix it.

Some ideas:

1. (@fabianschuiki states) that this may just be stemming from the lack of deduplication, so this is the expected scaling we get.
2. (@Ramlakshmi3733 suggests) exploring parallelizing these passes. There may be some issues here as the passes are mostly just a two-phase process of collecting information during a global walk, then adding IR constructs. The collect information phase could be parallelized (with workers competing to write to a global data store?).
3. Combine all these passes.
4. Promote Grand Central information collection to an analysis then remove Grand Central annotations during `LowerToHW`.
5. (@fabianschuiki suggests) leaving breadcrumbs on the FIRRTL modules during scattering indicating that they have no GCT-related information. This would speed up the walk by avoiding modules that will not contribute to a GCT construct. (EmitSignalMappings already works this way.)
",,,,,,,,,,
1902,[FIRRTL] Fix use of invalidated iterators in InferResets,2021-09-29T14:01:50Z,closed,"bug, FIRRTL","Fix two issues in InferResets:

1.  References into a dense map that may get invalidated while being live by inserts being done into the map through subsequent accesses.
2.  Vectors being `std::move`d out of potentially multiple times. This is problematic because the move may leave an invalid vector behind which is no longer safe to access again. The fix properly uses a `std::swap` to move data out of the vector and leave an empty one behind.",,,,,,,,,,
1851,[FIRRTL] (mem) sv.alwaysff should be in a non-procedural region,2021-09-22T21:19:31Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 51
circuit top_mod :
  module top_mod :
    input clock: Clock
    input inp_k: SInt<0>
    input inp_cb: UInt<0>
    mem tmp153:
      data-type => SInt<4>
      depth => 9
      read-latency => 1
      write-latency => 2
      read-under-write => undefined
      reader => r0
      writer => w0
      writer => w1
      writer => w2
    tmp153.r0.clk <= clock
    tmp153.r0.en <= asUInt(inp_k)
    tmp153.r0.addr <= asUInt(SInt<31>(-596888200))
    tmp153.w0.clk <= clock
    tmp153.w0.en <= head(UInt<18>(""o14004""), 1)
    tmp153.w0.addr <= inp_cb
    tmp153.w0.data <= inp_k
    tmp153.w0.mask <= asUInt(SInt<26>(""h1875d5c""))
    tmp153.w1.clk <= clock
    tmp153.w1.en <= head(asUInt(SInt<4>(0)), 1)
    tmp153.w1.addr <= asUInt(inp_k)
    tmp153.w1.data <= SInt<31>(""h13a08ea3"")
    tmp153.w1.mask <= asUInt(inp_k)
    tmp153.w2.clk <= clock
    tmp153.w2.en <= head(asUInt(SInt<26>(""o-45356020"")), 1)
    tmp153.w2.addr <= asUInt(inp_k)
    tmp153.w2.data <= inp_k
    tmp153.w2.mask <= asUInt(inp_k)
    node tmp154 = tmp153.r0.data
```

Compiled with `firtool  --verilog -o=$VFILE2` produces this Error:

```mlir
<unknown>:0: error: sv.alwaysff should be in a non-procedural region
<unknown>:0: note: see current operation: ""sv.alwaysff""(%arg13) ( {
  ""sv.passign""(%27, %arg14) : (!hw.inout<i1>, i1) -> ()
},  {
}) {clockEdge = 0 : i32, resetStyle = 0 : i32} : (i1) -> ()
```
","; seed: 51
circuit top_mod :
  module top_mod :
    input clock: Clock
    input inp_k: SInt<0>
    input inp_cb: UInt<0>
    mem tmp153:
      data-type => SInt<4>
      depth => 9
      read-latency => 1
      write-latency => 2
      read-under-write => undefined
      reader => r0
      writer => w0
      writer => w1
      writer => w2
    tmp153.r0.clk <= clock
    tmp153.r0.en <= asUInt(inp_k)
    tmp153.r0.addr <= asUInt(SInt<31>(-596888200))
    tmp153.w0.clk <= clock
    tmp153.w0.en <= head(UInt<18>(""o14004""), 1)
    tmp153.w0.addr <= inp_cb
    tmp153.w0.data <= inp_k
    tmp153.w0.mask <= asUInt(SInt<26>(""h1875d5c""))
    tmp153.w1.clk <= clock
    tmp153.w1.en <= head(asUInt(SInt<4>(0)), 1)
    tmp153.w1.addr <= asUInt(inp_k)
    tmp153.w1.data <= SInt<31>(""h13a08ea3"")
    tmp153.w1.mask <= asUInt(inp_k)
    tmp153.w2.clk <= clock
    tmp153.w2.en <= head(asUInt(SInt<26>(""o-45356020"")), 1)
    tmp153.w2.addr <= asUInt(inp_k)
    tmp153.w2.data <= inp_k
    tmp153.w2.mask <= asUInt(inp_k)
    node tmp154 = tmp153.r0.data","<unknown>:0: error: sv.alwaysff should be in a non-procedural region
<unknown>:0: note: see current operation: ""sv.alwaysff""(%arg13) ( {
  ""sv.passign""(%27, %arg14) : (!hw.inout<i1>, i1) -> ()
},  {
}) {clockEdge = 0 : i32, resetStyle = 0 : i32} : (i1) -> ()",,,,,,,,
1828,[FIRRTL] BlackBoxInlineAnno file path,2021-09-21T19:55:07Z,closed,bug,"Annotation:
```json
    ""class"":""firrtl.transforms.BlackBoxInlineAnno"",
    ""target"":""CoreIPSubsystemVerifTestHarness.DummyVroom"",
```
Needs to pay attention to:
```json
    ""class"":""sifive.enterprise.firrtl.TestBenchDirAnnotation"",
```
to place files in correct directory","""class"":""firrtl.transforms.BlackBoxInlineAnno"",
    ""target"":""CoreIPSubsystemVerifTestHarness.DummyVroom"",","""class"":""sifive.enterprise.firrtl.TestBenchDirAnnotation"",",,,,,,,,
1822,[HW] Empty port names can't be roundtripped,2021-09-21T15:13:45Z,closed,bug,"modules made with empty names for arguments print out like this, which then doesn't parse.
```
hw.module @foo(%arg1: i32) attributes {argNames = [""""]} {
}
```","hw.module @foo(%arg1: i32) attributes {argNames = [""""]} {
}",,,,,,,,,
1802,[Calyx] Missing emission of 'else' branches,2021-09-16T14:53:23Z,closed,"bug, Calyx","In the following program, the ""else"" branch of the control `if`-statement missing in the emitted native Calyx IR, when running `circt-translate --export-calyx`:
```mlir
module  {
  calyx.program  {
    calyx.component @main(%in0: i32, %in1: i32, %clk: i1 {clk}, %reset: i1 {reset}, %go: i1 {go}) -> (%out0: i32, %done: i1 {done}) {
      %true = hw.constant true
      %std_add_2.left, %std_add_2.right, %std_add_2.out = calyx.std_add ""std_add_2"" : i32, i32, i32
      %std_add_1.left, %std_add_1.right, %std_add_1.out = calyx.std_add ""std_add_1"" : i32, i32, i32
      %std_add_0.left, %std_add_0.right, %std_add_0.out = calyx.std_add ""std_add_0"" : i32, i32, i32
      %std_sub_1.left, %std_sub_1.right, %std_sub_1.out = calyx.std_sub ""std_sub_1"" : i32, i32, i32
      %std_sub_0.left, %std_sub_0.right, %std_sub_0.out = calyx.std_sub ""std_sub_0"" : i32, i32, i32
      %std_ge_0.left, %std_ge_0.right, %std_ge_0.out = calyx.std_ge ""std_ge_0"" : i32, i32, i1
      %ret_arg0_reg.in, %ret_arg0_reg.write_en, %ret_arg0_reg.clk, %ret_arg0_reg.reset, %ret_arg0_reg.out, %ret_arg0_reg.done = calyx.register ""ret_arg0_reg"" : i32, i1, i1, i1, i32, i1
      %bb3_arg1_reg.in, %bb3_arg1_reg.write_en, %bb3_arg1_reg.clk, %bb3_arg1_reg.reset, %bb3_arg1_reg.out, %bb3_arg1_reg.done = calyx.register ""bb3_arg1_reg"" : i32, i1, i1, i1, i32, i1
      %bb3_arg0_reg.in, %bb3_arg0_reg.write_en, %bb3_arg0_reg.clk, %bb3_arg0_reg.reset, %bb3_arg0_reg.out, %bb3_arg0_reg.done = calyx.register ""bb3_arg0_reg"" : i32, i1, i1, i1, i32, i1
      %bb2_arg0_reg.in, %bb2_arg0_reg.write_en, %bb2_arg0_reg.clk, %bb2_arg0_reg.reset, %bb2_arg0_reg.out, %bb2_arg0_reg.done = calyx.register ""bb2_arg0_reg"" : i32, i1, i1, i1, i32, i1
      %bb1_arg0_reg.in, %bb1_arg0_reg.write_en, %bb1_arg0_reg.clk, %bb1_arg0_reg.reset, %bb1_arg0_reg.out, %bb1_arg0_reg.done = calyx.register ""bb1_arg0_reg"" : i32, i1, i1, i1, i32, i1
      calyx.wires  {
        calyx.assign %out0 = %ret_arg0_reg.out : i32
        calyx.group @bb0_to_bb1  {
          calyx.assign %bb1_arg0_reg.in = %in0 : i32
          calyx.assign %bb1_arg0_reg.write_en = %true : i1
          calyx.group_done %bb1_arg0_reg.done : i1
        }
        calyx.group @bb0_to_bb2  {
          calyx.assign %bb2_arg0_reg.in = %in1 : i32
          calyx.assign %bb2_arg0_reg.write_en = %true : i1
          calyx.group_done %bb2_arg0_reg.done : i1
        }
        calyx.group @bb1_to_bb3  {
          calyx.assign %bb3_arg0_reg.in = %std_sub_0.out : i32
          calyx.assign %bb3_arg0_reg.write_en = %true : i1
          calyx.assign %bb3_arg1_reg.in = %std_sub_1.out : i32
          calyx.assign %bb3_arg1_reg.write_en = %true : i1
          calyx.assign %std_sub_0.left = %bb1_arg0_reg.out : i32
          calyx.assign %std_sub_0.right = %in1 : i32
          calyx.assign %std_sub_1.left = %bb1_arg0_reg.out : i32
          calyx.assign %std_sub_1.right = %in0 : i32
          %0 = comb.and %bb3_arg0_reg.done, %bb3_arg1_reg.done : i1
          calyx.group_done %true, %0 ? : i1
        }
        calyx.group @bb2_to_bb3  {
          calyx.assign %bb3_arg0_reg.in = %std_add_0.out : i32
          calyx.assign %bb3_arg0_reg.write_en = %true : i1
          calyx.assign %bb3_arg1_reg.in = %std_add_1.out : i32
          calyx.assign %bb3_arg1_reg.write_en = %true : i1
          calyx.assign %std_add_0.left = %bb2_arg0_reg.out : i32
          calyx.assign %std_add_0.right = %in1 : i32
          calyx.assign %std_add_1.left = %bb2_arg0_reg.out : i32
          calyx.assign %std_add_1.right = %in0 : i32
          %0 = comb.and %bb3_arg0_reg.done, %bb3_arg1_reg.done : i1
          calyx.group_done %true, %0 ? : i1
        }
        calyx.group @ret_assign_0  {
          calyx.assign %ret_arg0_reg.in = %std_add_2.out : i32
          calyx.assign %ret_arg0_reg.write_en = %true : i1
          calyx.assign %std_add_2.left = %bb3_arg0_reg.out : i32
          calyx.assign %std_add_2.right = %bb3_arg1_reg.out : i32
          calyx.group_done %ret_arg0_reg.done : i1
        }
        calyx.comb_group @comb_bb0_0  {
          calyx.assign %std_ge_0.left = %in0 : i32
          calyx.assign %std_ge_0.right = %in1 : i32
        }
      }
      calyx.control  {
        calyx.seq  {
          calyx.if %std_ge_0.out with @comb_bb0_0  {
            calyx.seq  {
              calyx.enable @bb0_to_bb1 {compiledGroups = []}
              calyx.enable @bb1_to_bb3 {compiledGroups = []}
            }
          } else  {
            calyx.seq  {
              calyx.enable @bb0_to_bb2 {compiledGroups = []}
              calyx.enable @bb2_to_bb3 {compiledGroups = []}
            }
          }
          calyx.enable @ret_assign_0 {compiledGroups = []}
        }
      }
    }
  }
}
```

emits to the native calyx IR:
```
import ""primitives/core.futil"";
component main(in0: 32, in1: 32, @clk clk: 1, @reset reset: 1, @go go: 1) -> (out0: 32, @done done: 1) {
  cells {
    std_add_2 = std_add(32);
    std_add_1 = std_add(32);
    std_add_0 = std_add(32);
    std_sub_1 = std_sub(32);
    std_sub_0 = std_sub(32);
    std_ge_0 = std_ge(32);
    ret_arg0_reg = std_reg(32);
    bb3_arg1_reg = std_reg(32);
    bb3_arg0_reg = std_reg(32);
    bb2_arg0_reg = std_reg(32);
    bb1_arg0_reg = std_reg(32);
  }
  wires {
    out0 = ret_arg0_reg.out;
    group bb0_to_bb1 {
      bb1_arg0_reg.in = in0;
      bb1_arg0_reg.write_en = 1'd1;
      bb0_to_bb1[done] = bb1_arg0_reg.done;
    }
    group bb0_to_bb2 {
      bb2_arg0_reg.in = in1;
      bb2_arg0_reg.write_en = 1'd1;
      bb0_to_bb2[done] = bb2_arg0_reg.done;
    }
    group bb1_to_bb3 {
      bb3_arg0_reg.in = std_sub_0.out;
      bb3_arg0_reg.write_en = 1'd1;
      bb3_arg1_reg.in = std_sub_1.out;
      bb3_arg1_reg.write_en = 1'd1;
      std_sub_0.left = bb1_arg0_reg.out;
      std_sub_0.right = in1;
      std_sub_1.left = bb1_arg0_reg.out;
      std_sub_1.right = in0;
      bb1_to_bb3[done] = (bb3_arg0_reg.done & bb3_arg1_reg.done) ? 1'd1;
    }
    group bb2_to_bb3 {
      bb3_arg0_reg.in = std_add_0.out;
      bb3_arg0_reg.write_en = 1'd1;
      bb3_arg1_reg.in = std_add_1.out;
      bb3_arg1_reg.write_en = 1'd1;
      std_add_0.left = bb2_arg0_reg.out;
      std_add_0.right = in1;
      std_add_1.left = bb2_arg0_reg.out;
      std_add_1.right = in0;
      bb2_to_bb3[done] = (bb3_arg0_reg.done & bb3_arg1_reg.done) ? 1'd1;
    }
    group ret_assign_0 {
      ret_arg0_reg.in = std_add_2.out;
      ret_arg0_reg.write_en = 1'd1;
      std_add_2.left = bb3_arg0_reg.out;
      std_add_2.right = bb3_arg1_reg.out;
      ret_assign_0[done] = ret_arg0_reg.done;
    }
    comb group comb_bb0_0 {
      std_ge_0.left = in0;
      std_ge_0.right = in1;
    }
  }
  control {
    seq {
      if std_ge_0.out with comb_bb0_0 {
        seq {
          bb0_to_bb1;
          bb1_to_bb3;
        }
      }
      ret_assign_0;
    }
  }
}
```","module  {
  calyx.program  {
    calyx.component @main(%in0: i32, %in1: i32, %clk: i1 {clk}, %reset: i1 {reset}, %go: i1 {go}) -> (%out0: i32, %done: i1 {done}) {
      %true = hw.constant true
      %std_add_2.left, %std_add_2.right, %std_add_2.out = calyx.std_add ""std_add_2"" : i32, i32, i32
      %std_add_1.left, %std_add_1.right, %std_add_1.out = calyx.std_add ""std_add_1"" : i32, i32, i32
      %std_add_0.left, %std_add_0.right, %std_add_0.out = calyx.std_add ""std_add_0"" : i32, i32, i32
      %std_sub_1.left, %std_sub_1.right, %std_sub_1.out = calyx.std_sub ""std_sub_1"" : i32, i32, i32
      %std_sub_0.left, %std_sub_0.right, %std_sub_0.out = calyx.std_sub ""std_sub_0"" : i32, i32, i32
      %std_ge_0.left, %std_ge_0.right, %std_ge_0.out = calyx.std_ge ""std_ge_0"" : i32, i32, i1
      %ret_arg0_reg.in, %ret_arg0_reg.write_en, %ret_arg0_reg.clk, %ret_arg0_reg.reset, %ret_arg0_reg.out, %ret_arg0_reg.done = calyx.register ""ret_arg0_reg"" : i32, i1, i1, i1, i32, i1
      %bb3_arg1_reg.in, %bb3_arg1_reg.write_en, %bb3_arg1_reg.clk, %bb3_arg1_reg.reset, %bb3_arg1_reg.out, %bb3_arg1_reg.done = calyx.register ""bb3_arg1_reg"" : i32, i1, i1, i1, i32, i1
      %bb3_arg0_reg.in, %bb3_arg0_reg.write_en, %bb3_arg0_reg.clk, %bb3_arg0_reg.reset, %bb3_arg0_reg.out, %bb3_arg0_reg.done = calyx.register ""bb3_arg0_reg"" : i32, i1, i1, i1, i32, i1
      %bb2_arg0_reg.in, %bb2_arg0_reg.write_en, %bb2_arg0_reg.clk, %bb2_arg0_reg.reset, %bb2_arg0_reg.out, %bb2_arg0_reg.done = calyx.register ""bb2_arg0_reg"" : i32, i1, i1, i1, i32, i1
      %bb1_arg0_reg.in, %bb1_arg0_reg.write_en, %bb1_arg0_reg.clk, %bb1_arg0_reg.reset, %bb1_arg0_reg.out, %bb1_arg0_reg.done = calyx.register ""bb1_arg0_reg"" : i32, i1, i1, i1, i32, i1
      calyx.wires  {
        calyx.assign %out0 = %ret_arg0_reg.out : i32
        calyx.group @bb0_to_bb1  {
          calyx.assign %bb1_arg0_reg.in = %in0 : i32
          calyx.assign %bb1_arg0_reg.write_en = %true : i1
          calyx.group_done %bb1_arg0_reg.done : i1
        }
        calyx.group @bb0_to_bb2  {
          calyx.assign %bb2_arg0_reg.in = %in1 : i32
          calyx.assign %bb2_arg0_reg.write_en = %true : i1
          calyx.group_done %bb2_arg0_reg.done : i1
        }
        calyx.group @bb1_to_bb3  {
          calyx.assign %bb3_arg0_reg.in = %std_sub_0.out : i32
          calyx.assign %bb3_arg0_reg.write_en = %true : i1
          calyx.assign %bb3_arg1_reg.in = %std_sub_1.out : i32
          calyx.assign %bb3_arg1_reg.write_en = %true : i1
          calyx.assign %std_sub_0.left = %bb1_arg0_reg.out : i32
          calyx.assign %std_sub_0.right = %in1 : i32
          calyx.assign %std_sub_1.left = %bb1_arg0_reg.out : i32
          calyx.assign %std_sub_1.right = %in0 : i32
          %0 = comb.and %bb3_arg0_reg.done, %bb3_arg1_reg.done : i1
          calyx.group_done %true, %0 ? : i1
        }
        calyx.group @bb2_to_bb3  {
          calyx.assign %bb3_arg0_reg.in = %std_add_0.out : i32
          calyx.assign %bb3_arg0_reg.write_en = %true : i1
          calyx.assign %bb3_arg1_reg.in = %std_add_1.out : i32
          calyx.assign %bb3_arg1_reg.write_en = %true : i1
          calyx.assign %std_add_0.left = %bb2_arg0_reg.out : i32
          calyx.assign %std_add_0.right = %in1 : i32
          calyx.assign %std_add_1.left = %bb2_arg0_reg.out : i32
          calyx.assign %std_add_1.right = %in0 : i32
          %0 = comb.and %bb3_arg0_reg.done, %bb3_arg1_reg.done : i1
          calyx.group_done %true, %0 ? : i1
        }
        calyx.group @ret_assign_0  {
          calyx.assign %ret_arg0_reg.in = %std_add_2.out : i32
          calyx.assign %ret_arg0_reg.write_en = %true : i1
          calyx.assign %std_add_2.left = %bb3_arg0_reg.out : i32
          calyx.assign %std_add_2.right = %bb3_arg1_reg.out : i32
          calyx.group_done %ret_arg0_reg.done : i1
        }
        calyx.comb_group @comb_bb0_0  {
          calyx.assign %std_ge_0.left = %in0 : i32
          calyx.assign %std_ge_0.right = %in1 : i32
        }
      }
      calyx.control  {
        calyx.seq  {
          calyx.if %std_ge_0.out with @comb_bb0_0  {
            calyx.seq  {
              calyx.enable @bb0_to_bb1 {compiledGroups = []}
              calyx.enable @bb1_to_bb3 {compiledGroups = []}
            }
          } else  {
            calyx.seq  {
              calyx.enable @bb0_to_bb2 {compiledGroups = []}
              calyx.enable @bb2_to_bb3 {compiledGroups = []}
            }
          }
          calyx.enable @ret_assign_0 {compiledGroups = []}
        }
      }
    }
  }
}","import ""primitives/core.futil"";
component main(in0: 32, in1: 32, @clk clk: 1, @reset reset: 1, @go go: 1) -> (out0: 32, @done done: 1) {
  cells {
    std_add_2 = std_add(32);
    std_add_1 = std_add(32);
    std_add_0 = std_add(32);
    std_sub_1 = std_sub(32);
    std_sub_0 = std_sub(32);
    std_ge_0 = std_ge(32);
    ret_arg0_reg = std_reg(32);
    bb3_arg1_reg = std_reg(32);
    bb3_arg0_reg = std_reg(32);
    bb2_arg0_reg = std_reg(32);
    bb1_arg0_reg = std_reg(32);
  }
  wires {
    out0 = ret_arg0_reg.out;
    group bb0_to_bb1 {
      bb1_arg0_reg.in = in0;
      bb1_arg0_reg.write_en = 1'd1;
      bb0_to_bb1[done] = bb1_arg0_reg.done;
    }
    group bb0_to_bb2 {
      bb2_arg0_reg.in = in1;
      bb2_arg0_reg.write_en = 1'd1;
      bb0_to_bb2[done] = bb2_arg0_reg.done;
    }
    group bb1_to_bb3 {
      bb3_arg0_reg.in = std_sub_0.out;
      bb3_arg0_reg.write_en = 1'd1;
      bb3_arg1_reg.in = std_sub_1.out;
      bb3_arg1_reg.write_en = 1'd1;
      std_sub_0.left = bb1_arg0_reg.out;
      std_sub_0.right = in1;
      std_sub_1.left = bb1_arg0_reg.out;
      std_sub_1.right = in0;
      bb1_to_bb3[done] = (bb3_arg0_reg.done & bb3_arg1_reg.done) ? 1'd1;
    }
    group bb2_to_bb3 {
      bb3_arg0_reg.in = std_add_0.out;
      bb3_arg0_reg.write_en = 1'd1;
      bb3_arg1_reg.in = std_add_1.out;
      bb3_arg1_reg.write_en = 1'd1;
      std_add_0.left = bb2_arg0_reg.out;
      std_add_0.right = in1;
      std_add_1.left = bb2_arg0_reg.out;
      std_add_1.right = in0;
      bb2_to_bb3[done] = (bb3_arg0_reg.done & bb3_arg1_reg.done) ? 1'd1;
    }
    group ret_assign_0 {
      ret_arg0_reg.in = std_add_2.out;
      ret_arg0_reg.write_en = 1'd1;
      std_add_2.left = bb3_arg0_reg.out;
      std_add_2.right = bb3_arg1_reg.out;
      ret_assign_0[done] = ret_arg0_reg.done;
    }
    comb group comb_bb0_0 {
      std_ge_0.left = in0;
      std_ge_0.right = in1;
    }
  }
  control {
    seq {
      if std_ge_0.out with comb_bb0_0 {
        seq {
          bb0_to_bb1;
          bb1_to_bb3;
        }
      }
      ret_assign_0;
    }
  }
}",,,,,,,,
1799,[FIRRTL] Grand Central Views Needs to Mangle Verilog Keywords in XMRs,2021-09-15T23:57:22Z,closed,"bug, FIRRTL","Currently, if a field in a Grand Central-generated interface conflicts with a Verilog keyword, this will get mangled properly during `HWLegalizeNames`. However, this will not update the XMR that has already been dumped into an `sv.verbatim` op.

The simple solution would be to mangle names at the point at which they are created so that the verbatim XMRs will be correct.

Concretely, I'm seeing this issue for an interface field called `signed` where it is mangled to `signed_0`, but the XMR still points to `foo.bar.signed`.",,,,,,,,,,
1795,[Simulator] Crash when initializing `llhd.sig` with non-constant value,2021-09-15T12:19:24Z,open,"bug, LLHD","When trying to simulate a module such as the following, the simulator crashes without a meaningful error message or assertion (just telling you that a value not defined in this region is used or the reconcile conversion cast pass complaining that some op was already replaced). This is because in `LLHDToLLVM.cpp` the operations creating `%get` are recursively cloned into a init function created indirectly by the simulation engine, but it only considers `hw.array_create`, `hw.struct_create`, and operations without operands (stop condition of recursion).

It would be ideal to support any operation not just these three, or at least throw a meaningful error message for the user in `recursiveCloneInit`.
Also, wouldn't it be better to clone these operations in a separate function and let the LLVM inliner decide whether to inline it or not (because the operation chain might be a lot bigger than just a constant op, leading to a lot of duplicated code)?

```mlir
llhd.entity @root () -> () {
    %0 = hw.constant 0 : i8
    %index = hw.constant 1 : i1

    %array = hw.array_create %0, %0 : i8
    %get = hw.array_get %array[%index] : !hw.array<2xi8>

    %getsig = llhd.sig ""get"" %get : i8  // Using %0 instead of %get works just fine; %get leads to a crash

    %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>
    llhd.drv %getsig, %get after %time : !llhd.sig<i8>
}
```","llhd.entity @root () -> () {
    %0 = hw.constant 0 : i8
    %index = hw.constant 1 : i1

    %array = hw.array_create %0, %0 : i8
    %get = hw.array_get %array[%index] : !hw.array<2xi8>

    %getsig = llhd.sig ""get"" %get : i8  // Using %0 instead of %get works just fine; %get leads to a crash

    %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>
    llhd.drv %getsig, %get after %time : !llhd.sig<i8>
}",,,,,,,,,
1793,[FIRRTL] IMConstprop doesn't always catch dontTouch output ports,2021-09-14T23:30:32Z,closed,bug,"```
firrtl.circuit ""bar"" {

firrtl.module @foo(out %b: !firrtl.uint<3> {firrtl.annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}]}) {
  %const = firrtl.constant 1 : !firrtl.uint<3>
  firrtl.connect %b, %const : !firrtl.uint<3>, !firrtl.uint<3>
}

firrtl.module @bar(out %b : !firrtl.uint<3>, in %c : !firrtl.uint<1>) {
      %const = firrtl.constant 2 : !firrtl.uint<3>
      %int_b = firrtl.instance @foo  {name = ""int""} : !firrtl.uint<3>
      %m = firrtl.mux(%c, %int_b, %const) : (!firrtl.uint<1>, !firrtl.uint<3>, !firrtl.uint<3>) -> !firrtl.uint<3>
      firrtl.connect %b, %m : !firrtl.uint<3>, !firrtl.uint<3>
}
}
```

markInstanceOp should mark the modulePortVal with dontTouch as overdefined, then the lattice prop skip in visitConnect is correct.","firrtl.circuit ""bar"" {

firrtl.module @foo(out %b: !firrtl.uint<3> {firrtl.annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}]}) {
  %const = firrtl.constant 1 : !firrtl.uint<3>
  firrtl.connect %b, %const : !firrtl.uint<3>, !firrtl.uint<3>
}

firrtl.module @bar(out %b : !firrtl.uint<3>, in %c : !firrtl.uint<1>) {
      %const = firrtl.constant 2 : !firrtl.uint<3>
      %int_b = firrtl.instance @foo  {name = ""int""} : !firrtl.uint<3>
      %m = firrtl.mux(%c, %int_b, %const) : (!firrtl.uint<1>, !firrtl.uint<3>, !firrtl.uint<3>) -> !firrtl.uint<3>
      firrtl.connect %b, %m : !firrtl.uint<3>, !firrtl.uint<3>
}
}",,,,,,,,,
1788,[Python] Update InstanceBuilder to populate input/output names for hw.InstanceOp,2021-09-14T20:25:00Z,closed,"bug, HW, Python","After https://github.com/llvm/circt/commit/3d19aa785468d4819961acf296c015d6f7fb318f, `HWInstanceOp` (in C++) has two new attributes to store arrays of input/output port names. Since this changed in ODS, the generated `hw.InstanceOp` (in Python) has two new arguments to the constructor. We need to update this to pass them in accordingly as `post_args`:

https://github.com/llvm/circt/blob/8b08c41e6cc5b6765b34ba1d037667881d69191a/lib/Bindings/Python/circt/dialects/_hw_ops_ext.py#L34

This manifests as errors in the Python bindings tests that look like this:

```
TypeError: __init__() missing 2 required positional arguments: 'parameters' and 'sym_name'
```",TypeError: __init__() missing 2 required positional arguments: 'parameters' and 'sym_name',,,,,,,,,
1771,[FIRRTL] Lexing Issues With Deeply Nested Expressions?,2021-09-10T23:09:58Z,open,"bug, FIRRTL","Circuits with long lines and/or deeply nested expressions seem to crash the lexer.

Here's a failing circuit (this is a 1024-deep concatenation):

```scala
circuit Bar :
  module Bar :
    input a: UInt<1>
    output b: UInt<1024>

    b <= cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
```

This is erroring out with an `EXC_BAD_ACCESS` occurring in the lexer:

```
# lldb firtool -- Bar.fir
(lldb) target create ""firtool""
Current executable set to 'firtool' (x86_64).
(lldb) settings set -- target.run-args  ""Bar.fir""
(lldb) run
Process 10399 launched: '/Users/schuylere/usr/bin/firtool' (x86_64)
Process 10399 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=2, address=0x7ffeef3fffff)
    frame #0: 0x00000001005857e4 firtool`llvm::isAlpha(C=<unavailable>) at StringExtras.h:95
   92  	inline bool isHexDigit(char C) { return hexDigitValue(C) != ~0U; }
   93  	
   94  	/// Checks if character \p C is a valid letter as classified by ""C"" locale.
-> 95  	inline bool isAlpha(char C) {
   96  	  return ('a' <= C && C <= 'z') || ('A' <= C && C <= 'Z');
   97  	}
   98  	
Target 0: (firtool) stopped.
(lldb) frame select 1
frame #1: 0x000000010024a592 firtool`circt::firrtl::FIRLexer::lexIdentifierOrKeyword(this=0x00007ffeefbfdbe8, tokStart=""cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))""...) at FIRLexer.cpp:386:10
   383 	///
   384 	FIRToken FIRLexer::lexIdentifierOrKeyword(const char *tokStart) {
   385 	  // Match the rest of the identifier regex: [0-9a-zA-Z_$-]*
-> 386 	  while (llvm::isAlpha(*curPtr) || llvm::isDigit(*curPtr) || *curPtr == '_' ||
   387 	         *curPtr == '$' || *curPtr == '-')
   388 	    ++curPtr;
   389
```","circuit Bar :
  module Bar :
    input a: UInt<1>
    output b: UInt<1024>

    b <= cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))","# lldb firtool -- Bar.fir
(lldb) target create ""firtool""
Current executable set to 'firtool' (x86_64).
(lldb) settings set -- target.run-args  ""Bar.fir""
(lldb) run
Process 10399 launched: '/Users/schuylere/usr/bin/firtool' (x86_64)
Process 10399 stopped
* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=2, address=0x7ffeef3fffff)
    frame #0: 0x00000001005857e4 firtool`llvm::isAlpha(C=<unavailable>) at StringExtras.h:95
   92  	inline bool isHexDigit(char C) { return hexDigitValue(C) != ~0U; }
   93  	
   94  	/// Checks if character \p C is a valid letter as classified by ""C"" locale.
-> 95  	inline bool isAlpha(char C) {
   96  	  return ('a' <= C && C <= 'z') || ('A' <= C && C <= 'Z');
   97  	}
   98  	
Target 0: (firtool) stopped.
(lldb) frame select 1
frame #1: 0x000000010024a592 firtool`circt::firrtl::FIRLexer::lexIdentifierOrKeyword(this=0x00007ffeefbfdbe8, tokStart=""cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))""...) at FIRLexer.cpp:386:10
   383 	///
   384 	FIRToken FIRLexer::lexIdentifierOrKeyword(const char *tokStart) {
   385 	  // Match the rest of the identifier regex: [0-9a-zA-Z_$-]*
-> 386 	  while (llvm::isAlpha(*curPtr) || llvm::isDigit(*curPtr) || *curPtr == '_' ||
   387 	         *curPtr == '$' || *curPtr == '-')
   388 	    ++curPtr;
   389",,,,,,,,
1757,[FIRRTL] SFC Memory Lowering: Respect Write Collision Behavior,2021-09-09T18:57:01Z,closed,"bug, FIRRTL","The default lowering for memories in the Scala FIRRTL Compiler (SFC) introduces a write ordering if the memories have the ports have the same clock.  This creates problems when trying to formally verify SFC-generate Verilog with CIRCT-generate Verilog.

Add an option that merges ports with the same clock into the same always block where the writes are ordered based on the port order.  This should probably be done as an extension of the existing generator schema that sets an optional ordering of write ports.  During FIRRTL memory lowering, this flag would then set the ordering based on the declared order of FIRRTL memory write ports.

As an example, consider the following FIRRTL circuit:

```scala
circuit Foo:
  module Foo:
    input clock: Clock
    input r0: {addr: UInt<4>, en: UInt<1>, flip data: UInt<8>}
    input w0: {addr: UInt<4>, en: UInt<1>, data: UInt<8>, mask: UInt<1>}
    input w1: {addr: UInt<4>, en: UInt<1>, data: UInt<8>, mask: UInt<1>}

    wire _r0: {addr: UInt<4>, en: UInt<1>, clk: Clock, flip data: UInt<8>}
    _r0 <- r0
    _r0.clk <= clock

    wire _w0: {addr: UInt<4>, en: UInt<1>, clk: Clock, data: UInt<8>, mask: UInt<1>}
    _w0 <- w0
    _w0.clk <= clock

    wire _w1: {addr: UInt<4>, en: UInt<1>, clk: Clock, data: UInt<8>, mask: UInt<1>}
    _w1 <- w1
    _w1.clk <= clock

    mem memory:
      data-type => UInt<8>
      depth => 16
      reader => r0
      writer => w0
      writer => w1
      read-latency => 1
      write-latency => 1
      read-under-write => undefined

    memory.r0 <= _r0
    memory.w0 <= _w0
    memory.w1 <= _w1
```

The SFC will produce the following verilog (`firrtl -i Foo.fir && cat Foo.v | verilator -E -P /dev/stdin`):

```verilog
module Foo(
  input        clock,
  input  [3:0] r0_addr,
  input        r0_en,
  output [7:0] r0_data,
  input  [3:0] w0_addr,
  input        w0_en,
  input  [7:0] w0_data,
  input        w0_mask,
  input  [3:0] w1_addr,
  input        w1_en,
  input  [7:0] w1_data,
  input        w1_mask
);
  reg [7:0] memory [0:15];
  wire  memory_r0_en;
  wire [3:0] memory_r0_addr;
  wire [7:0] memory_r0_data;
  wire [7:0] memory_w0_data;
  wire [3:0] memory_w0_addr;
  wire  memory_w0_mask;
  wire  memory_w0_en;
  wire [7:0] memory_w1_data;
  wire [3:0] memory_w1_addr;
  wire  memory_w1_mask;
  wire  memory_w1_en;
  reg  memory_r0_en_pipe_0;
  reg [3:0] memory_r0_addr_pipe_0;
  assign memory_r0_en = memory_r0_en_pipe_0;
  assign memory_r0_addr = memory_r0_addr_pipe_0;
  assign memory_r0_data = memory[memory_r0_addr];
  assign memory_w0_data = w0_data;
  assign memory_w0_addr = w0_addr;
  assign memory_w0_mask = w0_mask;
  assign memory_w0_en = w0_en;
  assign memory_w1_data = w1_data;
  assign memory_w1_addr = w1_addr;
  assign memory_w1_mask = w1_mask;
  assign memory_w1_en = w1_en;
  assign r0_data = memory_r0_data;
  always @(posedge clock) begin
    if (memory_w0_en & memory_w0_mask) begin
      memory[memory_w0_addr] <= memory_w0_data;
    end
    if (memory_w1_en & memory_w1_mask) begin
      memory[memory_w1_addr] <= memory_w1_data;
    end
    memory_r0_en_pipe_0 <= r0_en;
    if (r0_en) begin
      memory_r0_addr_pipe_0 <= r0_addr;
    end
  end
initial begin
end  
endmodule
```

CIRCT produces the following which is not formally equivalent (`firtool Foo.fir -verilog`):

```verilog
module FIRRTLMem_1_2_0_8_16_1_1_0(	// Foo.fir:25:5
  input        ro_clock_0, ro_en_0,
  input  [3:0] ro_addr_0,
  input        wo_clock_0, wo_en_0,
  input  [3:0] wo_addr_0,
  input        wo_mask_0,
  input  [7:0] wo_data_0,
  input        wo_clock_1, wo_en_1,
  input  [3:0] wo_addr_1,
  input        wo_mask_1,
  input  [7:0] wo_data_1,
  output [7:0] ro_data_0);

  reg [7:0] Memory[0:15];
  reg       _T;
  reg [3:0] _T_0;

  always @(posedge ro_clock_0) begin
    _T <= ro_en_0;
    _T_0 <= ro_addr_0;
  end // always @(posedge)
  always @(posedge wo_clock_0) begin
    if (wo_en_0 & wo_mask_0)
      Memory[wo_addr_0] <= wo_data_0;
  end // always @(posedge)
  always @(posedge wo_clock_1) begin
    if (wo_en_1 & wo_mask_1)
      Memory[wo_addr_1] <= wo_data_1;
  end // always @(posedge)
  assign ro_data_0 = _T ? Memory[_T_0] : 8'bx;	// Foo.fir:25:5
endmodule

module Foo(	// Foo.fir:2:10
  input        clock,
  input  [3:0] r0_addr,
  input        r0_en,
  input  [3:0] w0_addr,
  input        w0_en,
  input  [7:0] w0_data,
  input        w0_mask,
  input  [3:0] w1_addr,
  input        w1_en,
  input  [7:0] w1_data,
  input        w1_mask,
  output [7:0] r0_data);

  FIRRTLMem_1_2_0_8_16_1_1_0 memory (	// Foo.fir:25:5
    .ro_clock_0 (clock),
    .ro_en_0    (r0_en),
    .ro_addr_0  (r0_addr),
    .wo_clock_0 (clock),
    .wo_en_0    (w0_en),
    .wo_addr_0  (w0_addr),
    .wo_mask_0  (w0_mask),
    .wo_data_0  (w0_data),
    .wo_clock_1 (clock),
    .wo_en_1    (w1_en),
    .wo_addr_1  (w1_addr),
    .wo_mask_1  (w1_mask),
    .wo_data_1  (w1_data),
    .ro_data_0  (r0_data)
  );
endmodule
```

The specific issue is that the SFC version is enforcing a write ordering where simultaneous writes to the `w0` and `w1` port will result in the `w1` port winning. In the CIRCT version, this is undefined behavior. Abstractly, and without any other information, the CIRCT generation is ""better"" as it leaves it up to the Synthesis tool to choose an ordering.  (E.g., FPGA tools prefer separate always blocks so that they don't have to code in an explicit ordering to align with what the SFC code is behaviorally describing.)

Note that If the write ports are reordered in the FIRRTL definition so that `w1` comes before `w0`, then you will get `w0` ""winning"" on collision","circuit Foo:
  module Foo:
    input clock: Clock
    input r0: {addr: UInt<4>, en: UInt<1>, flip data: UInt<8>}
    input w0: {addr: UInt<4>, en: UInt<1>, data: UInt<8>, mask: UInt<1>}
    input w1: {addr: UInt<4>, en: UInt<1>, data: UInt<8>, mask: UInt<1>}

    wire _r0: {addr: UInt<4>, en: UInt<1>, clk: Clock, flip data: UInt<8>}
    _r0 <- r0
    _r0.clk <= clock

    wire _w0: {addr: UInt<4>, en: UInt<1>, clk: Clock, data: UInt<8>, mask: UInt<1>}
    _w0 <- w0
    _w0.clk <= clock

    wire _w1: {addr: UInt<4>, en: UInt<1>, clk: Clock, data: UInt<8>, mask: UInt<1>}
    _w1 <- w1
    _w1.clk <= clock

    mem memory:
      data-type => UInt<8>
      depth => 16
      reader => r0
      writer => w0
      writer => w1
      read-latency => 1
      write-latency => 1
      read-under-write => undefined

    memory.r0 <= _r0
    memory.w0 <= _w0
    memory.w1 <= _w1","module Foo(
  input        clock,
  input  [3:0] r0_addr,
  input        r0_en,
  output [7:0] r0_data,
  input  [3:0] w0_addr,
  input        w0_en,
  input  [7:0] w0_data,
  input        w0_mask,
  input  [3:0] w1_addr,
  input        w1_en,
  input  [7:0] w1_data,
  input        w1_mask
);
  reg [7:0] memory [0:15];
  wire  memory_r0_en;
  wire [3:0] memory_r0_addr;
  wire [7:0] memory_r0_data;
  wire [7:0] memory_w0_data;
  wire [3:0] memory_w0_addr;
  wire  memory_w0_mask;
  wire  memory_w0_en;
  wire [7:0] memory_w1_data;
  wire [3:0] memory_w1_addr;
  wire  memory_w1_mask;
  wire  memory_w1_en;
  reg  memory_r0_en_pipe_0;
  reg [3:0] memory_r0_addr_pipe_0;
  assign memory_r0_en = memory_r0_en_pipe_0;
  assign memory_r0_addr = memory_r0_addr_pipe_0;
  assign memory_r0_data = memory[memory_r0_addr];
  assign memory_w0_data = w0_data;
  assign memory_w0_addr = w0_addr;
  assign memory_w0_mask = w0_mask;
  assign memory_w0_en = w0_en;
  assign memory_w1_data = w1_data;
  assign memory_w1_addr = w1_addr;
  assign memory_w1_mask = w1_mask;
  assign memory_w1_en = w1_en;
  assign r0_data = memory_r0_data;
  always @(posedge clock) begin
    if (memory_w0_en & memory_w0_mask) begin
      memory[memory_w0_addr] <= memory_w0_data;
    end
    if (memory_w1_en & memory_w1_mask) begin
      memory[memory_w1_addr] <= memory_w1_data;
    end
    memory_r0_en_pipe_0 <= r0_en;
    if (r0_en) begin
      memory_r0_addr_pipe_0 <= r0_addr;
    end
  end
initial begin
end  
endmodule","module FIRRTLMem_1_2_0_8_16_1_1_0(	// Foo.fir:25:5
  input        ro_clock_0, ro_en_0,
  input  [3:0] ro_addr_0,
  input        wo_clock_0, wo_en_0,
  input  [3:0] wo_addr_0,
  input        wo_mask_0,
  input  [7:0] wo_data_0,
  input        wo_clock_1, wo_en_1,
  input  [3:0] wo_addr_1,
  input        wo_mask_1,
  input  [7:0] wo_data_1,
  output [7:0] ro_data_0);

  reg [7:0] Memory[0:15];
  reg       _T;
  reg [3:0] _T_0;

  always @(posedge ro_clock_0) begin
    _T <= ro_en_0;
    _T_0 <= ro_addr_0;
  end // always @(posedge)
  always @(posedge wo_clock_0) begin
    if (wo_en_0 & wo_mask_0)
      Memory[wo_addr_0] <= wo_data_0;
  end // always @(posedge)
  always @(posedge wo_clock_1) begin
    if (wo_en_1 & wo_mask_1)
      Memory[wo_addr_1] <= wo_data_1;
  end // always @(posedge)
  assign ro_data_0 = _T ? Memory[_T_0] : 8'bx;	// Foo.fir:25:5
endmodule

module Foo(	// Foo.fir:2:10
  input        clock,
  input  [3:0] r0_addr,
  input        r0_en,
  input  [3:0] w0_addr,
  input        w0_en,
  input  [7:0] w0_data,
  input        w0_mask,
  input  [3:0] w1_addr,
  input        w1_en,
  input  [7:0] w1_data,
  input        w1_mask,
  output [7:0] r0_data);

  FIRRTLMem_1_2_0_8_16_1_1_0 memory (	// Foo.fir:25:5
    .ro_clock_0 (clock),
    .ro_en_0    (r0_en),
    .ro_addr_0  (r0_addr),
    .wo_clock_0 (clock),
    .wo_en_0    (w0_en),
    .wo_addr_0  (w0_addr),
    .wo_mask_0  (w0_mask),
    .wo_data_0  (w0_data),
    .wo_clock_1 (clock),
    .wo_en_1    (w1_en),
    .wo_addr_1  (w1_addr),
    .wo_mask_1  (w1_mask),
    .wo_data_1  (w1_data),
    .ro_data_0  (r0_data)
  );
endmodule",,,,,,,
1734,[FIRRTL] Add non-local annotation support to GCT Data Taps,2021-09-06T15:13:33Z,open,"bug, FIRRTL","The Grand Central Data/Mem Taps pass currently only works with annotations that refer to entire modules. With the non-local annotations having been merged recently, it should now be expanded to also properly support those. We've seen a few cases internally where this is necessary.",,,,,,,,,,
1705,[FIRRTL] (mem) Procedural assignment to wire ,2021-09-03T01:35:54Z,closed,"bug, FIRRTL, ExportVerilog","The following FIRRTL program

```python
; seed: 1
circuit top_mod :
  module top_mod :
    input clock: Clock
    input inp_bb: SInt<24>
    input inp_g: UInt<0>
    mem tmp173:
      data-type => SInt<5>
      depth => 2
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp173.r0.clk <= clock
    tmp173.r0.en <= head(UInt<4>(""h6""), 1)
    tmp173.r0.addr <= asUInt(SInt<30>(""o-744515272""))
    tmp173.w0.clk <= clock
    tmp173.w0.en <= head(asUInt(inp_bb), 1)
    tmp173.w0.addr <= inp_g
    tmp173.w0.data <= asSInt(inp_g)
    tmp173.w0.mask <= inp_g
```

Compiled with `firtool   --lower-to-hw --infer-widths --imconstprop --lowering-options=disallowPackedArrays,emittedLineLength=8192 --mlir-timing --verilog -o=$VFILE2` produces this Verilog:

```verilog
module FIRRTLMem_1_1_0_5_2_0_1_0(	// a_top_mod.fir:7:5
  input        ro_clock_0, ro_en_0, ro_addr_0, wo_clock_0, wo_en_0, wo_addr_0, wo_mask_0,
  input  [4:0] wo_data_0,
  output [4:0] ro_data_0);

  reg [4:0] Memory[0:1];

  wire _T = wo_en_0 & wo_mask_0;
  wire [4:0] _T_0 = Memory[wo_addr_0];
  always @(posedge wo_clock_0) begin
    if (_T)
      _T_0 <= wo_data_0;
  end // always @(posedge)
  assign ro_data_0 = ro_en_0 ? Memory[ro_addr_0] : 5'bx;	// a_top_mod.fir:7:5
endmodule

module top_mod(	// a_top_mod.fir:3:10
  input        clock,
  input [23:0] inp_bb);

  wire [4:0] tmp173_ro_data_0;	// a_top_mod.fir:7:5

  FIRRTLMem_1_1_0_5_2_0_1_0 tmp173 (	// a_top_mod.fir:7:5
    .ro_clock_0 (clock),
    .ro_en_0    (1'h0),	// a_top_mod.fir:16:21
    .ro_addr_0  (1'h0),	// a_top_mod.fir:16:21
    .wo_clock_0 (clock),
    .wo_en_0    (inp_bb[23]),	// a_top_mod.fir:19:21
    .wo_addr_0  (1'h0),	// a_top_mod.fir:16:21
    .wo_mask_0  (1'h0),	// a_top_mod.fir:16:21
    .wo_data_0  (5'h0),	// a_top_mod.fir:21:20
    .ro_data_0  (tmp173_ro_data_0)
  );
endmodule
```

```
Verilator 4.211 devel rev v4.210-70-gc69ddc46
```

Gives the following error:

```
%Error-PROCASSWIRE: a_top_mod.fir.mfc.v:12:7: Procedural assignment to wire, perhaps intended var (IEEE 1800-2017 6.5): '_T_0'
                                            : ... In instance top_mod.tmp173
   12 |       _T_0 <= wo_data_0;
      |       ^~~~
                    ... For error description see https://verilator.org/warn/PROCASSWIRE?v=4.211
%Error: Exiting due to 1 error(s)
        ... See the manual at https://verilator.org/verilator_doc.html for more assistance.
```
","; seed: 1
circuit top_mod :
  module top_mod :
    input clock: Clock
    input inp_bb: SInt<24>
    input inp_g: UInt<0>
    mem tmp173:
      data-type => SInt<5>
      depth => 2
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp173.r0.clk <= clock
    tmp173.r0.en <= head(UInt<4>(""h6""), 1)
    tmp173.r0.addr <= asUInt(SInt<30>(""o-744515272""))
    tmp173.w0.clk <= clock
    tmp173.w0.en <= head(asUInt(inp_bb), 1)
    tmp173.w0.addr <= inp_g
    tmp173.w0.data <= asSInt(inp_g)
    tmp173.w0.mask <= inp_g","module FIRRTLMem_1_1_0_5_2_0_1_0(	// a_top_mod.fir:7:5
  input        ro_clock_0, ro_en_0, ro_addr_0, wo_clock_0, wo_en_0, wo_addr_0, wo_mask_0,
  input  [4:0] wo_data_0,
  output [4:0] ro_data_0);

  reg [4:0] Memory[0:1];

  wire _T = wo_en_0 & wo_mask_0;
  wire [4:0] _T_0 = Memory[wo_addr_0];
  always @(posedge wo_clock_0) begin
    if (_T)
      _T_0 <= wo_data_0;
  end // always @(posedge)
  assign ro_data_0 = ro_en_0 ? Memory[ro_addr_0] : 5'bx;	// a_top_mod.fir:7:5
endmodule

module top_mod(	// a_top_mod.fir:3:10
  input        clock,
  input [23:0] inp_bb);

  wire [4:0] tmp173_ro_data_0;	// a_top_mod.fir:7:5

  FIRRTLMem_1_1_0_5_2_0_1_0 tmp173 (	// a_top_mod.fir:7:5
    .ro_clock_0 (clock),
    .ro_en_0    (1'h0),	// a_top_mod.fir:16:21
    .ro_addr_0  (1'h0),	// a_top_mod.fir:16:21
    .wo_clock_0 (clock),
    .wo_en_0    (inp_bb[23]),	// a_top_mod.fir:19:21
    .wo_addr_0  (1'h0),	// a_top_mod.fir:16:21
    .wo_mask_0  (1'h0),	// a_top_mod.fir:16:21
    .wo_data_0  (5'h0),	// a_top_mod.fir:21:20
    .ro_data_0  (tmp173_ro_data_0)
  );
endmodule",Verilator 4.211 devel rev v4.210-70-gc69ddc46,"%Error-PROCASSWIRE: a_top_mod.fir.mfc.v:12:7: Procedural assignment to wire, perhaps intended var (IEEE 1800-2017 6.5): '_T_0'
                                            : ... In instance top_mod.tmp173
   12 |       _T_0 <= wo_data_0;
      |       ^~~~
                    ... For error description see https://verilator.org/warn/PROCASSWIRE?v=4.211
%Error: Exiting due to 1 error(s)
        ... See the manual at https://verilator.org/verilator_doc.html for more assistance.",,,,,,
1664,"[FIRRTL] Add data taps integration test, fix issues",2021-08-30T12:51:25Z,closed,"bug, FIRRTL",Add the `DataTapTests` from the Scala implementation of FIRRTL as an integration test for the FIRRTL dialect. This uncovers a few subtle breakages in the `GrandCentralTaps` introduced by changes to the annotation scattering code that happened a while back. This fixes those issues and the test ensures we don't have any regressions of this in the future.,,,,,,,,,,
1645,[FIRRTL] Resolve `portAnnotations`/`arg_attrs` ambiguity,2021-08-26T17:54:53Z,closed,"bug, FIRRTL","Our code base expects port annotations to live in the `portAnnotations` attribute on `FModuleOp` and `FExtModuleOp`, but the parser, printer, and op builders store these in the `arg_attrs` through the standard argument attribute mechanism of upstream MLIR. This PR fixes this by declaring `portAnnotations` as the way forward, and removes any redundant/conflicting portions in the code base. To keep things ergonomic for the custom syntax, we parse and print port annotations as part of the regular argument attributes, but then immediately separate them out into the `portAnnotations` where all of our code expects this to live.

*Still breaks some tests, working on those.*",,,,,,,,,,
1643,[FIRRTL] (dshl) long mismatch,2021-08-26T06:34:00Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_db: SInt<0>
    output tmp27: UInt<512>
    node tmp25 = dshl(UInt<27>(6567271), asUInt(inp_db))
    tmp27 <= dshl(UInt(2183), tail(tmp25, 17))
```

Compiled with `firtool` produces this Verilog:

```verilog
module top_mod(
  output [511:0] tmp27);

  assign tmp27 = 512'h443800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;	// a_top_mod.fir:2:10, :6:11
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:

```verilog
module top_mod(
  output [511:0] tmp27
);
  assign tmp27 = 512'h0;
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
ERROR: Found 5 unproven $equiv cells in 'equiv_status -assert'.
```","circuit top_mod :
  module top_mod :
    input inp_db: SInt<0>
    output tmp27: UInt<512>
    node tmp25 = dshl(UInt<27>(6567271), asUInt(inp_db))
    tmp27 <= dshl(UInt(2183), tail(tmp25, 17))","module top_mod(
  output [511:0] tmp27);

  assign tmp27 = 512'h443800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;	// a_top_mod.fir:2:10, :6:11
endmodule","module top_mod(
  output [511:0] tmp27
);
  assign tmp27 = 512'h0;
endmodule",ERROR: Found 5 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
1639,"[FIRRTL] (add(a, a)) mismatch",2021-08-25T18:30:50Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_db: SInt<38>
    output tmp1972: SInt<39>
    tmp1972 <= add(inp_db, inp_db)
```

Compiled with `firtool` produces this Verilog:

```verilog
module top_mod(
  input  [37:0] inp_db,
  output [38:0] tmp1972);

  wire [38:0] _T = {inp_db[37], inp_db};	// a_top_mod.fir:6:16
  assign tmp1972 = {_T[38:1], 1'h0};	// a_top_mod.fir:3:10, :6:16
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:

```verilog
module top_mod(
  input  [37:0] inp_db,
  output [38:0] tmp1972
);
  assign tmp1972 = $signed(inp_db) + $signed(inp_db);
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
ERROR: Found 37 unproven $equiv cells in 'equiv_status -assert'.
```","circuit top_mod :
  module top_mod :
    input inp_db: SInt<38>
    output tmp1972: SInt<39>
    tmp1972 <= add(inp_db, inp_db)","module top_mod(
  input  [37:0] inp_db,
  output [38:0] tmp1972);

  wire [38:0] _T = {inp_db[37], inp_db};	// a_top_mod.fir:6:16
  assign tmp1972 = {_T[38:1], 1'h0};	// a_top_mod.fir:3:10, :6:16
endmodule","module top_mod(
  input  [37:0] inp_db,
  output [38:0] tmp1972
);
  assign tmp1972 = $signed(inp_db) + $signed(inp_db);
endmodule",ERROR: Found 37 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
1594,"[HW] Register w/ Wire Reset Produces Two Always Blocks, not CSE'd",2021-08-17T22:09:31Z,closed,"bug, HW","As identified https://llvm.discourse.group/t/firtool-register-verilog-emitter/4097, formulations of registers that are reset by wires may cause multiple always blocks to be generated. 

Consider:

```mlir
module  {
  firrtl.circuit ""MyTop""   {
    firrtl.module @MyTop(in %clk: !firrtl.clock, in %reset: !firrtl.uint<1>, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<2>) {
      %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1>
      %reset_n = firrtl.wire  : !firrtl.uint<1>
      %0 = firrtl.not %reset : (!firrtl.uint<1>) -> !firrtl.uint<1>
      firrtl.connect %reset_n, %0 : !firrtl.uint<1>, !firrtl.uint<1>
      %r = firrtl.regreset %clk, %reset_n, %c0_ui1  : !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %r, %a : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %b, %r : !firrtl.uint<2>, !firrtl.uint<1>
    }
  }
}
```

This is getting lowered to two always blocks:

```mlir
  hw.module @MyTop(%clk: i1, %reset: i1, %a: i1) -> (%b: i2) {
    %true = hw.constant true
    %false = hw.constant false
    %reset_n = sv.wire  : !hw.inout<i1>
    %0 = comb.xor %reset, %true : i1
    sv.assign %reset_n, %0 : i1
    %1 = sv.read_inout %reset_n : !hw.inout<i1>
    %r = sv.reg  : !hw.inout<i1>
    sv.alwaysff(posedge %clk)  {
    }(syncreset : posedge %1)  {
      sv.passign %r, %false : i1
    }
    %2 = sv.read_inout %reset_n : !hw.inout<i1>
    sv.alwaysff(posedge %clk)  {
      sv.passign %r, %a : i1
    }(syncreset : posedge %2)  {
    }
    %3 = sv.read_inout %r : !hw.inout<i1>
    %4 = comb.concat %false, %3 : (i1, i1) -> i2
    hw.output %4 : i2
  }
```

These two always blocks aren't cleaned up by HWCleanup because it runs before CSE can unify `%1` and `%2`.","module  {
  firrtl.circuit ""MyTop""   {
    firrtl.module @MyTop(in %clk: !firrtl.clock, in %reset: !firrtl.uint<1>, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<2>) {
      %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1>
      %reset_n = firrtl.wire  : !firrtl.uint<1>
      %0 = firrtl.not %reset : (!firrtl.uint<1>) -> !firrtl.uint<1>
      firrtl.connect %reset_n, %0 : !firrtl.uint<1>, !firrtl.uint<1>
      %r = firrtl.regreset %clk, %reset_n, %c0_ui1  : !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %r, %a : !firrtl.uint<1>, !firrtl.uint<1>
      firrtl.connect %b, %r : !firrtl.uint<2>, !firrtl.uint<1>
    }
  }
}","hw.module @MyTop(%clk: i1, %reset: i1, %a: i1) -> (%b: i2) {
    %true = hw.constant true
    %false = hw.constant false
    %reset_n = sv.wire  : !hw.inout<i1>
    %0 = comb.xor %reset, %true : i1
    sv.assign %reset_n, %0 : i1
    %1 = sv.read_inout %reset_n : !hw.inout<i1>
    %r = sv.reg  : !hw.inout<i1>
    sv.alwaysff(posedge %clk)  {
    }(syncreset : posedge %1)  {
      sv.passign %r, %false : i1
    }
    %2 = sv.read_inout %reset_n : !hw.inout<i1>
    sv.alwaysff(posedge %clk)  {
      sv.passign %r, %a : i1
    }(syncreset : posedge %2)  {
    }
    %3 = sv.read_inout %r : !hw.inout<i1>
    %4 = comb.concat %false, %3 : (i1, i1) -> i2
    hw.output %4 : i2
  }",,,,,,,,
1587,[ExportVerilog] Mux Tree Lowering Producing Busted Verilog,2021-08-16T20:21:46Z,closed,"bug, ExportVerilog, Verilog/SystemVerilog","The mux tree lowering that was added in ee457605169c16b1ce1400201e66d06d723f282b is producing some invalid Verilog in certain situations.

Consider the following FIRRTL IR:

```scala
circuit Foo:
  module Foo:
    input idx: UInt<2>
    input a: UInt<4>[4]
    output b: UInt<4>

    b <= a[idx]
```

This is lowered to the following HW dialect mix:

```mlir
module attributes {firrtl.mainModule = ""Foo""}  {
  hw.module @Foo(%idx: i2, %a_0: i4, %a_1: i4, %a_2: i4, %a_3: i4) -> (%b: i4) {
    %0 = hw.array_create %a_0, %a_1, %a_2, %a_3 : i4
    %1 = hw.array_get %0[%idx] : !hw.array<4xi4>
    hw.output %1 : i4
  }
}
```

And this produces the following Verilog:

```verilog
module Foo(
  input  [1:0] idx,
  input  [3:0] a_0, a_1, a_2, a_3,
  output [3:0] b);

  assign b = ({{a_0}, {a_1}, {a_2}, {a_3}})[idx];	// Tmp.fir:2:10, :7:12
endmodule
```

The problem is that the wire associated with `{{a_0}, {a_1}, ...}` cannot be inlined as this becomes illegal Verilog.  This can be hit for situations where the mux-encoded wire is small enough to be inlined.  The problem doesn't show up for situations where the mux-encoded wire is getting spilled.

Concretely, the above has to emit as:

```verilog
wire bar [3:0][3:0] = {{a_0}, {a_1}, ...};
assign b = bar[idx];
```

The other two inlined approaches both are wrong. 

The following is trying to bit extract out of a concatenation:

```verilog
assign b = {{a_0}, {a_1}, ...}[idx];
```

The following is just illegal:

```verilog
assign b = ({{a_0}, {a_1}, ...})[idx];
```","circuit Foo:
  module Foo:
    input idx: UInt<2>
    input a: UInt<4>[4]
    output b: UInt<4>

    b <= a[idx]","module attributes {firrtl.mainModule = ""Foo""}  {
  hw.module @Foo(%idx: i2, %a_0: i4, %a_1: i4, %a_2: i4, %a_3: i4) -> (%b: i4) {
    %0 = hw.array_create %a_0, %a_1, %a_2, %a_3 : i4
    %1 = hw.array_get %0[%idx] : !hw.array<4xi4>
    hw.output %1 : i4
  }
}","module Foo(
  input  [1:0] idx,
  input  [3:0] a_0, a_1, a_2, a_3,
  output [3:0] b);

  assign b = ({{a_0}, {a_1}, {a_2}, {a_3}})[idx];	// Tmp.fir:2:10, :7:12
endmodule","wire bar [3:0][3:0] = {{a_0}, {a_1}, ...};
assign b = bar[idx];","assign b = {{a_0}, {a_1}, ...}[idx];","assign b = ({{a_0}, {a_1}, ...})[idx];",,,,
1541,[FIRRTL] name conflict resolution mismatch,2021-08-10T23:59:40Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod:
  module top_mod:
    input a: { b: UInt<1> }
    input a_b: UInt<2>
```

Compiled with `firtool` produces this Verilog:

```verilog
module top_mod(
  input       a_b,
  input [1:0] a_b_0);

endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:

```verilog
module top_mod(
  input        a__b,
  input  [1:0] a_b
);
endmodule
```

note:
Not only names are different, but also order of the conflict resolution.","circuit top_mod:
  module top_mod:
    input a: { b: UInt<1> }
    input a_b: UInt<2>","module top_mod(
  input       a_b,
  input [1:0] a_b_0);

endmodule","module top_mod(
  input        a__b,
  input  [1:0] a_b
);
endmodule",,,,,,,
1531,"[FIRRTL] Add WidthSpec Scala tests, fix issues",2021-08-06T12:32:26Z,closed,"bug, FIRRTL","Port the `WidthSpec` tests from the Scala FIRRTL implementation over into an integration test for firtool. This uncovers a few integer overflow issues in the parser/types, which this fixes alongside the tests.

### Todo
- [x] Land #1527 ",,,,,,,,,,
1518,[FIRRTL] (false negative) don't touch invalid reg,2021-08-03T23:13:25Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 32
circuit top_mod :
  module top_mod :
    input clock: Clock
    input arst: AsyncReset
    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))
    tmp107 is invalid
```

and annotation file:

```json
[{""class"":""firrtl.transforms.DontTouchAnnotation"",""target"":""~top_mod|top_mod>tmp107""}]
```

Compiled with `valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --imconstprop --annotation-file=${INPUT}.json --mlir-timing --verilog -o=$VFILE2` produces this error:

```cpp
a_top_mod.fir:7:12: error: 'firrtl.connect' op LowerToHW couldn't handle this operation
    tmp107 is invalid
           ^
a_top_mod.fir:7:12: note: see current operation: ""firrtl.connect""(%6, %3) : (!firrtl.uint<1>, !firrtl.uint) -> ()
a_top_mod.fir:6:52: error: value has an unsupported verilog type '!firrtl.uint<1>'
    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))
                                                   ^
a_top_mod.fir:6:52: note: see current operation: %0 = ""firrtl.constant""() {value = 0 : ui1} : () -> !firrtl.uint<1>
a_top_mod.fir:7:12: error: value has an unsupported verilog type '!firrtl.uint'
    tmp107 is invalid
           ^
a_top_mod.fir:7:12: note: see current operation: %1 = ""firrtl.invalidvalue""() : () -> !firrtl.uint
a_top_mod.fir:3:10: error: value has an unsupported verilog type '!firrtl.clock'
  module top_mod :
         ^
a_top_mod.fir:3:10: note: see current operation: %2 = ""firrtl.stdIntCast""(%arg0) : (i1) -> !firrtl.clock
a_top_mod.fir:3:10: error: value has an unsupported verilog type '!firrtl.asyncreset'
  module top_mod :
         ^
a_top_mod.fir:3:10: note: see current operation: %3 = ""firrtl.stdIntCast""(%arg1) : (i1) -> !firrtl.asyncreset
a_top_mod.fir:6:5: error: value has an unsupported verilog type '!firrtl.uint<1>'
    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))
    ^
a_top_mod.fir:6:5: note: see current operation: %5 = ""firrtl.regreset""(%2, %3, %0) {annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}], name = ""tmp107""} : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.uint<1>
a_top_mod.fir:6:52: error: 'firrtl.constant' op cannot emit this operation to Verilog
    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))
                                                   ^
a_top_mod.fir:6:52: note: see current operation: %0 = ""firrtl.constant""() {value = 0 : ui1} : () -> !firrtl.uint<1>
a_top_mod.fir:7:12: error: 'firrtl.invalidvalue' op cannot emit this operation to Verilog
    tmp107 is invalid
           ^
a_top_mod.fir:7:12: note: see current operation: %1 = ""firrtl.invalidvalue""() : () -> !firrtl.uint
a_top_mod.fir:3:10: error: 'firrtl.stdIntCast' op cannot emit this operation to Verilog
  module top_mod :
         ^
a_top_mod.fir:3:10: note: see current operation: %2 = ""firrtl.stdIntCast""(%arg0) : (i1) -> !firrtl.clock
a_top_mod.fir:3:10: error: 'firrtl.stdIntCast' op cannot emit this operation to Verilog
  module top_mod :
         ^
a_top_mod.fir:3:10: note: see current operation: %3 = ""firrtl.stdIntCast""(%arg1) : (i1) -> !firrtl.asyncreset
a_top_mod.fir:6:5: error: 'firrtl.regreset' op cannot emit this operation to Verilog
    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))
    ^
a_top_mod.fir:6:5: note: see current operation: %5 = ""firrtl.regreset""(%2, %3, %0) {annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}], name = ""tmp107""} : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.uint<1>
a_top_mod.fir:7:12: error: 'firrtl.connect' op cannot emit this operation to Verilog
    tmp107 is invalid
           ^
a_top_mod.fir:7:12: note: see current operation: ""firrtl.connect""(%5, %1) : (!firrtl.uint<1>, !firrtl.uint) -> ()
```

Compiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:

```verilog
module top_mod(
  input   clock,
  input   arst
);
endmodule
```
","; seed: 32
circuit top_mod :
  module top_mod :
    input clock: Clock
    input arst: AsyncReset
    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))
    tmp107 is invalid","[{""class"":""firrtl.transforms.DontTouchAnnotation"",""target"":""~top_mod|top_mod>tmp107""}]","a_top_mod.fir:7:12: error: 'firrtl.connect' op LowerToHW couldn't handle this operation
    tmp107 is invalid
           ^
a_top_mod.fir:7:12: note: see current operation: ""firrtl.connect""(%6, %3) : (!firrtl.uint<1>, !firrtl.uint) -> ()
a_top_mod.fir:6:52: error: value has an unsupported verilog type '!firrtl.uint<1>'
    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))
                                                   ^
a_top_mod.fir:6:52: note: see current operation: %0 = ""firrtl.constant""() {value = 0 : ui1} : () -> !firrtl.uint<1>
a_top_mod.fir:7:12: error: value has an unsupported verilog type '!firrtl.uint'
    tmp107 is invalid
           ^
a_top_mod.fir:7:12: note: see current operation: %1 = ""firrtl.invalidvalue""() : () -> !firrtl.uint
a_top_mod.fir:3:10: error: value has an unsupported verilog type '!firrtl.clock'
  module top_mod :
         ^
a_top_mod.fir:3:10: note: see current operation: %2 = ""firrtl.stdIntCast""(%arg0) : (i1) -> !firrtl.clock
a_top_mod.fir:3:10: error: value has an unsupported verilog type '!firrtl.asyncreset'
  module top_mod :
         ^
a_top_mod.fir:3:10: note: see current operation: %3 = ""firrtl.stdIntCast""(%arg1) : (i1) -> !firrtl.asyncreset
a_top_mod.fir:6:5: error: value has an unsupported verilog type '!firrtl.uint<1>'
    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))
    ^
a_top_mod.fir:6:5: note: see current operation: %5 = ""firrtl.regreset""(%2, %3, %0) {annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}], name = ""tmp107""} : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.uint<1>
a_top_mod.fir:6:52: error: 'firrtl.constant' op cannot emit this operation to Verilog
    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))
                                                   ^
a_top_mod.fir:6:52: note: see current operation: %0 = ""firrtl.constant""() {value = 0 : ui1} : () -> !firrtl.uint<1>
a_top_mod.fir:7:12: error: 'firrtl.invalidvalue' op cannot emit this operation to Verilog
    tmp107 is invalid
           ^
a_top_mod.fir:7:12: note: see current operation: %1 = ""firrtl.invalidvalue""() : () -> !firrtl.uint
a_top_mod.fir:3:10: error: 'firrtl.stdIntCast' op cannot emit this operation to Verilog
  module top_mod :
         ^
a_top_mod.fir:3:10: note: see current operation: %2 = ""firrtl.stdIntCast""(%arg0) : (i1) -> !firrtl.clock
a_top_mod.fir:3:10: error: 'firrtl.stdIntCast' op cannot emit this operation to Verilog
  module top_mod :
         ^
a_top_mod.fir:3:10: note: see current operation: %3 = ""firrtl.stdIntCast""(%arg1) : (i1) -> !firrtl.asyncreset
a_top_mod.fir:6:5: error: 'firrtl.regreset' op cannot emit this operation to Verilog
    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))
    ^
a_top_mod.fir:6:5: note: see current operation: %5 = ""firrtl.regreset""(%2, %3, %0) {annotations = [{class = ""firrtl.transforms.DontTouchAnnotation""}], name = ""tmp107""} : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.uint<1>
a_top_mod.fir:7:12: error: 'firrtl.connect' op cannot emit this operation to Verilog
    tmp107 is invalid
           ^
a_top_mod.fir:7:12: note: see current operation: ""firrtl.connect""(%5, %1) : (!firrtl.uint<1>, !firrtl.uint) -> ()","module top_mod(
  input   clock,
  input   arst
);
endmodule",,,,,,
1514,"[FIRRTL] (core dump) (!intType.hasWidth() || (unsigned)intType.getWidthOrSentinel() == value.getBitWidth()) && ""value / type width mismatch""",2021-08-03T04:19:43Z,closed,"bug, FIRRTL","The following FIRRTL program:

```python
; seed: 220
circuit top_mod :
  module mod_0 :
    input clock: Clock
    input inp_bb: SInt<0>
    reg tmp23: UInt<16>, clock
    wire _tmp31: UInt<17>
    wire _tmp58: UInt<17>
    tmp23 <= tail(SInt(""o-713317423""), 13)
    _tmp31 <= add(UInt<2>(""h1""), tmp23)
    node tmp49 = or(_tmp31, asUInt(SInt<5>(""h-5"")))
    _tmp58 <= and(inp_bb, asSInt(tmp49))
    skip
  module top_mod :
    input clock: Clock
    inst U0 of mod_0
    U0 is invalid
    U0.clock <= clock
```

Compiled with `valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2` fails with the following core dump:

```cpp
firtool: /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:34: mlir::IntegerAttr getIntAttr(mlir::Type, const llvm::APInt&): Assertion `(!intType.hasWidth() || (unsigned)intType.getWidthOrSentinel() == value.getBitWidth()) && ""value / type width mismatch""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v
 #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20
 #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)
 #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)
 #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)
 #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)
 #9 0x00000000008d2cfe getIntAttr(mlir::Type, llvm::APInt const&) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:34:3
#10 0x00000000008d8778 circt::firrtl::AsSIntPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:752:24
#11 0x00000000008b5441 mlir::LogicalResult mlir::Op<circt::firrtl::AsSIntPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::AsSIntPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1723:53
#12 0x00000000008ae812 _ZZN4mlir2OpIN5circt6firrtl12AsSIntPrimOpEJNS_7OpTrait10ZeroRegionENS4_9OneResultENS4_14OneTypedResultINS2_8SIntTypeEE4ImplENS4_13ZeroSuccessorENS4_10OneOperandENS_20InferTypeOpInterface5TraitENS_23MemoryEffectOpInterface5TraitEEE17getFoldHookFnImplIS3_EENSt9enable_ifIXaasrN4llvm11disjunctionIJSt7is_sameINS6_IT_EENS5_ISN_EEESM_ISO_SO_ESM_ISO_NS9_4ImplISN_EEESM_ISO_NSB_ISN_EEESM_ISO_NSC_ISN_EEESM_ISO_NSD_5TraitISN_EEESM_ISO_NSF_5TraitISN_EEEEEE5valuesrNSK_6detail8detectorIvNSH_22has_single_result_foldEJSN_EE7value_tE5valueENSK_15unique_functionIKFNS_13LogicalResultEPNS_9OperationENSK_8ArrayRefINS_9AttributeEEERNSK_15SmallVectorImplINS_12OpFoldResultEEEEEEE4typeEvENKUlS1E_S1H_S1L_E_clES1E_S1H_S1L_ /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1685:12
#13 0x00000000008c7811 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&>::CallImpl<std::enable_if<(llvm::disjunction<std::is_same<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp>, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::ZeroSuccessor<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::OneOperand<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::InferTypeOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::MemoryEffectOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > > >::value) && (llvm::detail::detector<void, mlir::Op<circt::firrtl::AsSIntPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::has_single_result_fold, mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >::value_t::value), llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const> >::type mlir::Op<circt::firrtl::AsSIntPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::getFoldHookFnImpl<circt::firrtl::AsSIntPrimOp>()::'lambda'(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>(void*, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:217:3
#14 0x000000000080c596 llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>::operator()(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:405:3
#15 0x000000000080ba3e mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:131:3
#16 0x00000000008045b6 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:556:30
#17 0x000000000064c4c1 (anonymous namespace)::IMConstPropPass::visitOperation(mlir::Operation*) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:608:13
#18 0x000000000064b093 (anonymous namespace)::IMConstPropPass::runOnOperation() /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:304:48
#19 0x0000000000ba989d mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:386:27
#20 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15
#21 0x0000000000bac665 auto mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)::operator()<std::pair<mlir::Operation*, mlir::AnalysisManager> >(auto&) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:607:20
#22 0x0000000000bac84e mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<std::pair<mlir::Operation*, mlir::AnalysisManager>*, std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto, auto, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:49:17
#23 0x0000000000bac021 mlir::LogicalResult mlir::failableParallelForEach<std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto&&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1
#24 0x0000000000baaab5 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:13
#25 0x0000000000baa24f mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:523:1
#26 0x0000000000ba987e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:383:28
#27 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15
#28 0x0000000000bab084 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:689:40
#29 0x0000000000baaf0b mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:669:69
#30 0x0000000000406529 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:297:13
#31 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30
#32 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31
#33 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)
#34 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 43: 26250 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2
```
","; seed: 220
circuit top_mod :
  module mod_0 :
    input clock: Clock
    input inp_bb: SInt<0>
    reg tmp23: UInt<16>, clock
    wire _tmp31: UInt<17>
    wire _tmp58: UInt<17>
    tmp23 <= tail(SInt(""o-713317423""), 13)
    _tmp31 <= add(UInt<2>(""h1""), tmp23)
    node tmp49 = or(_tmp31, asUInt(SInt<5>(""h-5"")))
    _tmp58 <= and(inp_bb, asSInt(tmp49))
    skip
  module top_mod :
    input clock: Clock
    inst U0 of mod_0
    U0 is invalid
    U0.clock <= clock","firtool: /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:34: mlir::IntegerAttr getIntAttr(mlir::Type, const llvm::APInt&): Assertion `(!intType.hasWidth() || (unsigned)intType.getWidthOrSentinel() == value.getBitWidth()) && ""value / type width mismatch""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v
 #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20
 #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)
 #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)
 #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)
 #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)
 #9 0x00000000008d2cfe getIntAttr(mlir::Type, llvm::APInt const&) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:34:3
#10 0x00000000008d8778 circt::firrtl::AsSIntPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:752:24
#11 0x00000000008b5441 mlir::LogicalResult mlir::Op<circt::firrtl::AsSIntPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::AsSIntPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1723:53
#12 0x00000000008ae812 _ZZN4mlir2OpIN5circt6firrtl12AsSIntPrimOpEJNS_7OpTrait10ZeroRegionENS4_9OneResultENS4_14OneTypedResultINS2_8SIntTypeEE4ImplENS4_13ZeroSuccessorENS4_10OneOperandENS_20InferTypeOpInterface5TraitENS_23MemoryEffectOpInterface5TraitEEE17getFoldHookFnImplIS3_EENSt9enable_ifIXaasrN4llvm11disjunctionIJSt7is_sameINS6_IT_EENS5_ISN_EEESM_ISO_SO_ESM_ISO_NS9_4ImplISN_EEESM_ISO_NSB_ISN_EEESM_ISO_NSC_ISN_EEESM_ISO_NSD_5TraitISN_EEESM_ISO_NSF_5TraitISN_EEEEEE5valuesrNSK_6detail8detectorIvNSH_22has_single_result_foldEJSN_EE7value_tE5valueENSK_15unique_functionIKFNS_13LogicalResultEPNS_9OperationENSK_8ArrayRefINS_9AttributeEEERNSK_15SmallVectorImplINS_12OpFoldResultEEEEEEE4typeEvENKUlS1E_S1H_S1L_E_clES1E_S1H_S1L_ /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1685:12
#13 0x00000000008c7811 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&>::CallImpl<std::enable_if<(llvm::disjunction<std::is_same<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp>, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::ZeroSuccessor<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::OneOperand<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::InferTypeOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::MemoryEffectOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > > >::value) && (llvm::detail::detector<void, mlir::Op<circt::firrtl::AsSIntPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::has_single_result_fold, mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >::value_t::value), llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const> >::type mlir::Op<circt::firrtl::AsSIntPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::getFoldHookFnImpl<circt::firrtl::AsSIntPrimOp>()::'lambda'(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>(void*, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:217:3
#14 0x000000000080c596 llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>::operator()(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:405:3
#15 0x000000000080ba3e mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:131:3
#16 0x00000000008045b6 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:556:30
#17 0x000000000064c4c1 (anonymous namespace)::IMConstPropPass::visitOperation(mlir::Operation*) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:608:13
#18 0x000000000064b093 (anonymous namespace)::IMConstPropPass::runOnOperation() /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:304:48
#19 0x0000000000ba989d mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:386:27
#20 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15
#21 0x0000000000bac665 auto mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)::operator()<std::pair<mlir::Operation*, mlir::AnalysisManager> >(auto&) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:607:20
#22 0x0000000000bac84e mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<std::pair<mlir::Operation*, mlir::AnalysisManager>*, std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto, auto, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:49:17
#23 0x0000000000bac021 mlir::LogicalResult mlir::failableParallelForEach<std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto&&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1
#24 0x0000000000baaab5 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:13
#25 0x0000000000baa24f mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:523:1
#26 0x0000000000ba987e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:383:28
#27 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15
#28 0x0000000000bab084 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:689:40
#29 0x0000000000baaf0b mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:669:69
#30 0x0000000000406529 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:297:13
#31 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30
#32 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31
#33 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)
#34 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 43: 26250 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2",,,,,,,,
1513,[FIRRTL] (core dump) Ptr >= BufStart && Ptr <= Buffer->getBufferEnd(),2021-08-03T03:49:06Z,closed,"bug, FIRRTL","Running `firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v`

I am getting this error at random:
```
firtool
firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:97: unsigned int llvm::SourceMgr::SrcBuffer::getLineNumberSpecialized(const char*) const [with T = short unsigned int]: Assertion `Ptr >= BufStart && Ptr <= Buffer->getBufferEnd()' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v
1.      In-Flight Diagnostics:
    loc(""a_top_mod.fir"":419:14): error: expected statement to be on its own line
 #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20
 #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)
 #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)
 #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)
 #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)
 #9 0x000000000045ac32 unsigned int llvm::SourceMgr::SrcBuffer::getLineNumberSpecialized<unsigned short>(char const*) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:98:13
#10 0x0000000000457a5c llvm::SourceMgr::SrcBuffer::getLineNumber(char const*) const (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:115:50
#11 0x0000000000457d83 llvm::SourceMgr::getLineAndColumn(llvm::SMLoc, unsigned int) const (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:188:41
#12 0x00000000005bd4d9 circt::firrtl::FIRLexer::translateLocation(llvm::SMLoc) (.localalias) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRLexer.cpp:172:50
#13 0x0000000000565e25 (anonymous namespace)::FIRParser::translateLocation(llvm::SMLoc) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:189:3
#14 0x000000000056af90 (anonymous namespace)::LazyLocationListener::endStatement((anonymous namespace)::FIRParser&) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:1412:33
#15 0x00000000005719b2 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2124:10
#16 0x000000000057192a (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2115:24
#17 0x0000000000574209 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int)::'lambda'(mlir::Block&)::operator()(mlir::Block&) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2545:42
#18 0x000000000057446f (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2549:17
#19 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#20 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#21 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#22 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#23 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#24 0x000000000057192a (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2115:24
#25 0x0000000000574209 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int)::'lambda'(mlir::Block&)::operator()(mlir::Block&) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2545:42
#26 0x000000000057446f (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2549:17
#27 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#28 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#29 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#30 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#31 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#32 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#33 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#34 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#35 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#36 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#37 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#38 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#39 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#40 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#41 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#42 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#43 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#44 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#45 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#46 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#47 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#48 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#49 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#50 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#51 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#52 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#53 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#54 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#55 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#56 0x000000000057192a (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2115:24
#57 0x000000000057a53c (anonymous namespace)::FIRCircuitParser::parseModuleBody((anonymous namespace)::FIRCircuitParser::DeferredModuleToParse&) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3449:48
#58 0x000000000057a5e9 (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)::operator()(unsigned long) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3548:28
#59 0x000000000057cc1e mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:65:17
#60 0x000000000057cec5 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:81:3
#61 0x000000000057c55e mlir::LogicalResult mlir::failableParallelForEach<llvm::iota_range<unsigned long>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, llvm::iota_range<unsigned long>&&, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1
#62 0x000000000057bd9b mlir::LogicalResult mlir::failableParallelForEachN<(anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, unsigned long, unsigned long, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:114:1
#63 0x000000000057aee3 (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3546:50
#64 0x000000000057b3d0 circt::firrtl::importFIRFile(llvm::SourceMgr&, mlir::MLIRContext*, circt::firrtl::FIRParserOptions) (.localalias) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3600:59
#65 0x0000000000405bfd processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:198:56
#66 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30
#67 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31
#68 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)
#69 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 43: 22168 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2
```","firtool
firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:97: unsigned int llvm::SourceMgr::SrcBuffer::getLineNumberSpecialized(const char*) const [with T = short unsigned int]: Assertion `Ptr >= BufStart && Ptr <= Buffer->getBufferEnd()' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v
1.      In-Flight Diagnostics:
    loc(""a_top_mod.fir"":419:14): error: expected statement to be on its own line
 #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20
 #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)
 #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)
 #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)
 #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)
 #9 0x000000000045ac32 unsigned int llvm::SourceMgr::SrcBuffer::getLineNumberSpecialized<unsigned short>(char const*) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:98:13
#10 0x0000000000457a5c llvm::SourceMgr::SrcBuffer::getLineNumber(char const*) const (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:115:50
#11 0x0000000000457d83 llvm::SourceMgr::getLineAndColumn(llvm::SMLoc, unsigned int) const (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:188:41
#12 0x00000000005bd4d9 circt::firrtl::FIRLexer::translateLocation(llvm::SMLoc) (.localalias) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRLexer.cpp:172:50
#13 0x0000000000565e25 (anonymous namespace)::FIRParser::translateLocation(llvm::SMLoc) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:189:3
#14 0x000000000056af90 (anonymous namespace)::LazyLocationListener::endStatement((anonymous namespace)::FIRParser&) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:1412:33
#15 0x00000000005719b2 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2124:10
#16 0x000000000057192a (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2115:24
#17 0x0000000000574209 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int)::'lambda'(mlir::Block&)::operator()(mlir::Block&) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2545:42
#18 0x000000000057446f (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2549:17
#19 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#20 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#21 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#22 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#23 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#24 0x000000000057192a (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2115:24
#25 0x0000000000574209 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int)::'lambda'(mlir::Block&)::operator()(mlir::Block&) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2545:42
#26 0x000000000057446f (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2549:17
#27 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#28 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#29 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#30 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#31 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#32 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#33 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#34 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#35 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#36 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#37 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#38 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#39 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#40 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#41 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#42 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#43 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#44 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#45 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#46 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#47 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#48 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#49 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#50 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#51 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#52 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#53 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37
#54 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32
#55 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36
#56 0x000000000057192a (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2115:24
#57 0x000000000057a53c (anonymous namespace)::FIRCircuitParser::parseModuleBody((anonymous namespace)::FIRCircuitParser::DeferredModuleToParse&) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3449:48
#58 0x000000000057a5e9 (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)::operator()(unsigned long) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3548:28
#59 0x000000000057cc1e mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:65:17
#60 0x000000000057cec5 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:81:3
#61 0x000000000057c55e mlir::LogicalResult mlir::failableParallelForEach<llvm::iota_range<unsigned long>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, llvm::iota_range<unsigned long>&&, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1
#62 0x000000000057bd9b mlir::LogicalResult mlir::failableParallelForEachN<(anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, unsigned long, unsigned long, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:114:1
#63 0x000000000057aee3 (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3546:50
#64 0x000000000057b3d0 circt::firrtl::importFIRFile(llvm::SourceMgr&, mlir::MLIRContext*, circt::firrtl::FIRParserOptions) (.localalias) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3600:59
#65 0x0000000000405bfd processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:198:56
#66 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30
#67 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31
#68 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)
#69 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 43: 22168 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2",,,,,,,,,
1512,"[FIRRTL] (core dump) ShiftAmt <= BitWidth && ""Invalid shift amount""",2021-08-03T03:25:24Z,closed,"bug, FIRRTL","The following FIRRTL program:

```python
; seed: 153
circuit top_mod :
  module mod_0 :
    input clock: Clock
    input arst: AsyncReset
    input inp_cb: UInt<67>
    output fsm_97_next: UInt<4>
    reg fsm_97_state: UInt, clock with: (reset => (arst, UInt(0)))
    node tmp24 = xor(inp_cb, asUInt(SInt<14>(42)))
    node tmp73 = dshl(UInt<20>(42), head(tmp24, 5))
    when eq(fsm_97_state, UInt<4>(10)) :
      when xorr(tmp73) :
        fsm_97_next <= UInt<4>(0)
      else :
        fsm_97_next <= fsm_97_state
    else :
      fsm_97_next <= fsm_97_state
    fsm_97_state <= fsm_97_next
  module top_mod :
    inst U0 of mod_0
    U0 is invalid
```

Compiled with `valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2` fails with the following core dump:

```cpp
firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:995: void llvm::APInt::lshrInPlace(unsigned int): Assertion `ShiftAmt <= BitWidth && ""Invalid shift amount""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v
 #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20
 #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)
 #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)
 #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)
 #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)
 #9 0x00000000004fc5c3 llvm::APInt::lshrInPlace(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:996:21
#10 0x000000000050e77b llvm::APInt::lshr(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:990:12
#11 0x00000000008d9e3a circt::firrtl::BitsPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:973:63
#12 0x00000000008b5dbb mlir::LogicalResult mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::BitsPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1723:53
#13 0x00000000008aef34 _ZZN4mlir2OpIN5circt6firrtl10BitsPrimOpEJNS_7OpTrait10ZeroRegionENS4_9OneResultENS4_14OneTypedResultINS2_8UIntTypeEE4ImplENS4_13ZeroSuccessorENS4_10OneOperandENS_20InferTypeOpInterface5TraitENS_23MemoryEffectOpInterface5TraitEEE17getFoldHookFnImplIS3_EENSt9enable_ifIXaasrN4llvm11disjunctionIJSt7is_sameINS6_IT_EENS5_ISN_EEESM_ISO_SO_ESM_ISO_NS9_4ImplISN_EEESM_ISO_NSB_ISN_EEESM_ISO_NSC_ISN_EEESM_ISO_NSD_5TraitISN_EEESM_ISO_NSF_5TraitISN_EEEEEE5valuesrNSK_6detail8detectorIvNSH_22has_single_result_foldEJSN_EE7value_tE5valueENSK_15unique_functionIKFNS_13LogicalResultEPNS_9OperationENSK_8ArrayRefINS_9AttributeEEERNSK_15SmallVectorImplINS_12OpFoldResultEEEEEEE4typeEvENKUlS1E_S1H_S1L_E_clES1E_S1H_S1L_ /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1685:12
#14 0x00000000008c7fed mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&>::CallImpl<std::enable_if<(llvm::disjunction<std::is_same<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp>, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::ZeroSuccessor<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::OneOperand<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::InferTypeOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::MemoryEffectOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > > >::value) && (llvm::detail::detector<void, mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::has_single_result_fold, mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >::value_t::value), llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const> >::type mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::getFoldHookFnImpl<circt::firrtl::BitsPrimOp>()::'lambda'(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>(void*, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:217:3
#15 0x000000000080c596 llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>::operator()(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:405:3
#16 0x000000000080ba3e mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:131:3
#17 0x00000000008045b6 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:556:30
#18 0x000000000064c4c1 (anonymous namespace)::IMConstPropPass::visitOperation(mlir::Operation*) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:608:13
#19 0x000000000064b093 (anonymous namespace)::IMConstPropPass::runOnOperation() /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:304:48
#20 0x0000000000ba989d mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:386:27
#21 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15
#22 0x0000000000bac665 auto mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)::operator()<std::pair<mlir::Operation*, mlir::AnalysisManager> >(auto&) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:607:20
#23 0x0000000000bac84e mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<std::pair<mlir::Operation*, mlir::AnalysisManager>*, std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto, auto, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:49:17
#24 0x0000000000bac021 mlir::LogicalResult mlir::failableParallelForEach<std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto&&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1
#25 0x0000000000baaab5 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:13
#26 0x0000000000baa24f mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:523:1
#27 0x0000000000ba987e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:383:28
#28 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15
#29 0x0000000000bab084 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:689:40
#30 0x0000000000baaf0b mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:669:69
#31 0x0000000000406529 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:297:13
#32 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30
#33 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31
#34 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)
#35 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 43: 20930 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2
```
","; seed: 153
circuit top_mod :
  module mod_0 :
    input clock: Clock
    input arst: AsyncReset
    input inp_cb: UInt<67>
    output fsm_97_next: UInt<4>
    reg fsm_97_state: UInt, clock with: (reset => (arst, UInt(0)))
    node tmp24 = xor(inp_cb, asUInt(SInt<14>(42)))
    node tmp73 = dshl(UInt<20>(42), head(tmp24, 5))
    when eq(fsm_97_state, UInt<4>(10)) :
      when xorr(tmp73) :
        fsm_97_next <= UInt<4>(0)
      else :
        fsm_97_next <= fsm_97_state
    else :
      fsm_97_next <= fsm_97_state
    fsm_97_state <= fsm_97_next
  module top_mod :
    inst U0 of mod_0
    U0 is invalid","firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:995: void llvm::APInt::lshrInPlace(unsigned int): Assertion `ShiftAmt <= BitWidth && ""Invalid shift amount""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v
 #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20
 #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)
 #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)
 #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)
 #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)
 #9 0x00000000004fc5c3 llvm::APInt::lshrInPlace(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:996:21
#10 0x000000000050e77b llvm::APInt::lshr(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:990:12
#11 0x00000000008d9e3a circt::firrtl::BitsPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:973:63
#12 0x00000000008b5dbb mlir::LogicalResult mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::BitsPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1723:53
#13 0x00000000008aef34 _ZZN4mlir2OpIN5circt6firrtl10BitsPrimOpEJNS_7OpTrait10ZeroRegionENS4_9OneResultENS4_14OneTypedResultINS2_8UIntTypeEE4ImplENS4_13ZeroSuccessorENS4_10OneOperandENS_20InferTypeOpInterface5TraitENS_23MemoryEffectOpInterface5TraitEEE17getFoldHookFnImplIS3_EENSt9enable_ifIXaasrN4llvm11disjunctionIJSt7is_sameINS6_IT_EENS5_ISN_EEESM_ISO_SO_ESM_ISO_NS9_4ImplISN_EEESM_ISO_NSB_ISN_EEESM_ISO_NSC_ISN_EEESM_ISO_NSD_5TraitISN_EEESM_ISO_NSF_5TraitISN_EEEEEE5valuesrNSK_6detail8detectorIvNSH_22has_single_result_foldEJSN_EE7value_tE5valueENSK_15unique_functionIKFNS_13LogicalResultEPNS_9OperationENSK_8ArrayRefINS_9AttributeEEERNSK_15SmallVectorImplINS_12OpFoldResultEEEEEEE4typeEvENKUlS1E_S1H_S1L_E_clES1E_S1H_S1L_ /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1685:12
#14 0x00000000008c7fed mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&>::CallImpl<std::enable_if<(llvm::disjunction<std::is_same<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp>, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::ZeroSuccessor<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::OneOperand<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::InferTypeOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::MemoryEffectOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > > >::value) && (llvm::detail::detector<void, mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::has_single_result_fold, mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >::value_t::value), llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const> >::type mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::getFoldHookFnImpl<circt::firrtl::BitsPrimOp>()::'lambda'(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>(void*, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:217:3
#15 0x000000000080c596 llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>::operator()(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:405:3
#16 0x000000000080ba3e mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:131:3
#17 0x00000000008045b6 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:556:30
#18 0x000000000064c4c1 (anonymous namespace)::IMConstPropPass::visitOperation(mlir::Operation*) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:608:13
#19 0x000000000064b093 (anonymous namespace)::IMConstPropPass::runOnOperation() /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:304:48
#20 0x0000000000ba989d mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:386:27
#21 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15
#22 0x0000000000bac665 auto mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)::operator()<std::pair<mlir::Operation*, mlir::AnalysisManager> >(auto&) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:607:20
#23 0x0000000000bac84e mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<std::pair<mlir::Operation*, mlir::AnalysisManager>*, std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto, auto, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:49:17
#24 0x0000000000bac021 mlir::LogicalResult mlir::failableParallelForEach<std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto&&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1
#25 0x0000000000baaab5 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:13
#26 0x0000000000baa24f mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:523:1
#27 0x0000000000ba987e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:383:28
#28 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15
#29 0x0000000000bab084 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:689:40
#30 0x0000000000baaf0b mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:669:69
#31 0x0000000000406529 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:297:13
#32 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30
#33 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31
#34 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)
#35 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 43: 20930 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2",,,,,,,,
1511,[FIRRTL] (code dump) type/value width mismatch materializing constant,2021-08-03T02:51:49Z,closed,"bug, FIRRTL","The following FIRRTL program:

```python
; seed: 133
circuit top_mod :
  module mod_1 :
    input clock: Clock
    input arst: AsyncReset
    input inp_bb: SInt<26>
    reg tmp61: UInt<26>, clock with: (reset => (arst, UInt<26>(0)))
    tmp61 <= xor(SInt(0), inp_bb)
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input arst: AsyncReset
    inst U1 of mod_1
    U1 is invalid
    ; U1
    U1.arst <= arst
    U1.clock <= clock
```

Compiled with `valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2` fails with the following core dump:

```cpp
firtool: /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLDialect.cpp:325: virtual mlir::Operation* circt::firrtl::FIRRTLDialect::materializeConstant(mlir::OpBuilder&, mlir::Attribute, mlir::Type, mlir::Location): Assertion `(!intType.hasWidth() || (unsigned)intType.getWidthOrSentinel() == attrValue.getValue().getBitWidth()) && ""type/value width mismatch materializing constant""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc2.v
1.       #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20
 #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)
 #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)
 #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)
 #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)
 #9 0x0000000000895621 circt::firrtl::FIRRTLDialect::materializeConstant(mlir::OpBuilder&, mlir::Attribute, mlir::Type, mlir::Location) (.localalias) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLDialect.cpp:325:5
#10 0x000000000064c9c6 (anonymous namespace)::IMConstPropPass::rewriteModuleBody(circt::firrtl::FModuleOp)::'lambda'(mlir::Value)::operator()(mlir::Value) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:661:58
#11 0x000000000064cdeb (anonymous namespace)::IMConstPropPass::rewriteModuleBody(circt::firrtl::FModuleOp) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:716:17
#12 0x000000000064e522 auto (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)::operator()<circt::firrtl::FModuleOp>(auto) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:313:63
#13 0x000000000064e555 auto void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'(auto&&)::operator()<circt::firrtl::FModuleOp>(auto&&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:125:63
#14 0x000000000064e609 mlir::LogicalResult mlir::failableParallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'(auto&&)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:65:17
#15 0x000000000064e8a3 mlir::LogicalResult mlir::failableParallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'(auto&&)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:81:3
#16 0x000000000064de44 void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:124:32
#17 0x000000000064d4c0 void mlir::parallelForEach<llvm::iterator_range<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> > >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto&&, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:136:18
#18 0x000000000064b13c (anonymous namespace)::IMConstPropPass::runOnOperation() /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:316:17
#19 0x0000000000ba989d mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:386:27
#20 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15
#21 0x0000000000bac665 auto mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)::operator()<std::pair<mlir::Operation*, mlir::AnalysisManager> >(auto&) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:607:20
#22 0x0000000000bac84e mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<std::pair<mlir::Operation*, mlir::AnalysisManager>*, std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto, auto, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:49:17
#23 0x0000000000bac021 mlir::LogicalResult mlir::failableParallelForEach<std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto&&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1
#24 0x0000000000baaab5 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:13
#25 0x0000000000baa24f mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:523:1
#26 0x0000000000ba987e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:383:28
#27 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15
#28 0x0000000000bab084 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:689:40
#29 0x0000000000baaf0b mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:669:69
#30 0x0000000000406529 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:297:13
#31 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30
#32 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31
#33 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)
#34 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 56: 17325 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE3
```
","; seed: 133
circuit top_mod :
  module mod_1 :
    input clock: Clock
    input arst: AsyncReset
    input inp_bb: SInt<26>
    reg tmp61: UInt<26>, clock with: (reset => (arst, UInt<26>(0)))
    tmp61 <= xor(SInt(0), inp_bb)
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input arst: AsyncReset
    inst U1 of mod_1
    U1 is invalid
    ; U1
    U1.arst <= arst
    U1.clock <= clock","firtool: /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLDialect.cpp:325: virtual mlir::Operation* circt::firrtl::FIRRTLDialect::materializeConstant(mlir::OpBuilder&, mlir::Attribute, mlir::Type, mlir::Location): Assertion `(!intType.hasWidth() || (unsigned)intType.getWidthOrSentinel() == attrValue.getValue().getBitWidth()) && ""type/value width mismatch materializing constant""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc2.v
1.       #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20
 #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)
 #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)
 #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)
 #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)
 #9 0x0000000000895621 circt::firrtl::FIRRTLDialect::materializeConstant(mlir::OpBuilder&, mlir::Attribute, mlir::Type, mlir::Location) (.localalias) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLDialect.cpp:325:5
#10 0x000000000064c9c6 (anonymous namespace)::IMConstPropPass::rewriteModuleBody(circt::firrtl::FModuleOp)::'lambda'(mlir::Value)::operator()(mlir::Value) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:661:58
#11 0x000000000064cdeb (anonymous namespace)::IMConstPropPass::rewriteModuleBody(circt::firrtl::FModuleOp) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:716:17
#12 0x000000000064e522 auto (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)::operator()<circt::firrtl::FModuleOp>(auto) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:313:63
#13 0x000000000064e555 auto void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'(auto&&)::operator()<circt::firrtl::FModuleOp>(auto&&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:125:63
#14 0x000000000064e609 mlir::LogicalResult mlir::failableParallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'(auto&&)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:65:17
#15 0x000000000064e8a3 mlir::LogicalResult mlir::failableParallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'(auto&&)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:81:3
#16 0x000000000064de44 void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:124:32
#17 0x000000000064d4c0 void mlir::parallelForEach<llvm::iterator_range<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> > >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto&&, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:136:18
#18 0x000000000064b13c (anonymous namespace)::IMConstPropPass::runOnOperation() /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:316:17
#19 0x0000000000ba989d mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:386:27
#20 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15
#21 0x0000000000bac665 auto mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)::operator()<std::pair<mlir::Operation*, mlir::AnalysisManager> >(auto&) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:607:20
#22 0x0000000000bac84e mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<std::pair<mlir::Operation*, mlir::AnalysisManager>*, std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto, auto, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:49:17
#23 0x0000000000bac021 mlir::LogicalResult mlir::failableParallelForEach<std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto&&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1
#24 0x0000000000baaab5 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:13
#25 0x0000000000baa24f mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:523:1
#26 0x0000000000ba987e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:383:28
#27 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15
#28 0x0000000000bab084 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:689:40
#29 0x0000000000baaf0b mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:669:69
#30 0x0000000000406529 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:297:13
#31 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30
#32 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31
#33 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)
#34 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 56: 17325 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE3",,,,,,,,
1491,[FIRRTL] Infer width from mux sel for known result,2021-07-29T04:38:57Z,closed,"bug, FIRRTL","Relax short circuit logic inside InferWidths so that a MuxPrimOp still
generates constraints from its select line (which sets a hard
requirement on a 1-bit width) even if the width of the mux result is
already known.

Previously, this would set no constraints derived from the select line if the width was already known. This would cause circuits like the following to have uninferred widths:

```scala
circuit top_mod :
  module top_mod :
    input sel: UInt
    input t: UInt<1>
    input f: UInt<1>
    output out: UInt<1>

    out <= mux(sel, t, f)
```","circuit top_mod :
  module top_mod :
    input sel: UInt
    input t: UInt<1>
    input f: UInt<1>
    output out: UInt<1>

    out <= mux(sel, t, f)",,,,,,,,,
1488,[FIRRTL] imconstprop mismatch,2021-07-28T19:33:55Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module Bar :
    input a: UInt<1>
    input b: UInt<1>
    output c: UInt<1>
    output d: UInt<1>
    c <= b
    wire _c: UInt<1>
    _c <= xor(a, c)
    d <= _c
  module top_mod :
    input a: UInt<1>
    input b: UInt<1>
    output c: UInt<1>
    output d: UInt<1>
    inst bar of Bar
    bar.a <= a
    bar.b <= b
    c <= bar.c
    d <= bar.d
```

Compiled with `firtool -imconstprop` produces this Verilog:

```verilog
module Bar(
  input  a, b,
  output c, d);

  assign c = b;	// a_top_mod.fir:2:10
  assign d = 1'h0;	// a_top_mod.fir:2:10, :8:5
endmodule

module top_mod(
  input  a, b,
  output c, d);

  wire bar_d;	// a_top_mod.fir:16:5

  Bar bar (	// a_top_mod.fir:16:5
    .a (a),
    .b (b),
    .c (c),
    .d (bar_d)
  );
  assign d = 1'h0;	// a_top_mod.fir:11:10, :16:5
endmodule
```

![image](https://user-images.githubusercontent.com/511872/127385642-59d723fc-1f03-49a6-bfd7-09f6b403c1f1.png)

Compiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:

```verilog
module Bar(
  input   a,
  input   b,
  output  c,
  output  d
);
  assign c = b;
  assign d = a ^ c;
endmodule
module top_mod(
  input   a,
  input   b,
  output  c,
  output  d
);
  wire  bar_a;
  wire  bar_b;
  wire  bar_c;
  wire  bar_d;
  Bar bar (
    .a(bar_a),
    .b(bar_b),
    .c(bar_c),
    .d(bar_d)
  );
  assign c = bar_c;
  assign d = bar_d;
  assign bar_a = a;
  assign bar_b = b;
endmodule

```
![image](https://user-images.githubusercontent.com/511872/127385700-ac28908c-3e7d-4d2b-952d-67b7dedec153.png)

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
```","circuit top_mod :
  module Bar :
    input a: UInt<1>
    input b: UInt<1>
    output c: UInt<1>
    output d: UInt<1>
    c <= b
    wire _c: UInt<1>
    _c <= xor(a, c)
    d <= _c
  module top_mod :
    input a: UInt<1>
    input b: UInt<1>
    output c: UInt<1>
    output d: UInt<1>
    inst bar of Bar
    bar.a <= a
    bar.b <= b
    c <= bar.c
    d <= bar.d","module Bar(
  input  a, b,
  output c, d);

  assign c = b;	// a_top_mod.fir:2:10
  assign d = 1'h0;	// a_top_mod.fir:2:10, :8:5
endmodule

module top_mod(
  input  a, b,
  output c, d);

  wire bar_d;	// a_top_mod.fir:16:5

  Bar bar (	// a_top_mod.fir:16:5
    .a (a),
    .b (b),
    .c (c),
    .d (bar_d)
  );
  assign d = 1'h0;	// a_top_mod.fir:11:10, :16:5
endmodule","module Bar(
  input   a,
  input   b,
  output  c,
  output  d
);
  assign c = b;
  assign d = a ^ c;
endmodule
module top_mod(
  input   a,
  input   b,
  output  c,
  output  d
);
  wire  bar_a;
  wire  bar_b;
  wire  bar_c;
  wire  bar_d;
  Bar bar (
    .a(bar_a),
    .b(bar_b),
    .c(bar_c),
    .d(bar_d)
  );
  assign c = bar_c;
  assign d = bar_d;
  assign bar_a = a;
  assign bar_b = b;
endmodule",ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
1485,[FIRRTL] Handle Illegal Aggregate Connects in Parser (or LowerTypes?),2021-07-28T02:25:50Z,closed,"bug, FIRRTL","Currently, we will convert illegal ground connects to partial connects where the RHS is larger than the LHS. However, if a user passes in an aggregate with this property, we need to emit element-wise partial connects.  (Emitting an aggregate partial connect will change connection semantics.)  Currently `LowerTypes` will create an illegal connect when it needs to pad.

Consider:

```scala
circuit Foo:
  module Foo:
    input a: {a: UInt<2>}
    output b: {a: UInt<1>}

    b <= a
```

This produces: 

```
# firtool Foo.fir                    
Foo.fir:6:7: error: destination width 1 is not greater than or equal to source width 2
    b <= a
      ^
Foo.fir:6:7: note: see current operation: ""firrtl.connect""(%arg1, %arg0) : (!firrtl.uint<1>, !firrtl.uint<2>) -> ()
```","circuit Foo:
  module Foo:
    input a: {a: UInt<2>}
    output b: {a: UInt<1>}

    b <= a","# firtool Foo.fir                    
Foo.fir:6:7: error: destination width 1 is not greater than or equal to source width 2
    b <= a
      ^
Foo.fir:6:7: note: see current operation: ""firrtl.connect""(%arg1, %arg0) : (!firrtl.uint<1>, !firrtl.uint<2>) -> ()",,,,,,,,
1478,[FIRRTL] IMConstProp Bug: Output used as wire,2021-07-25T07:06:20Z,closed,"bug, FIRRTL","One more IMConstProp bug.  Registers in instances that read from an output port are getting incorrectly optimized away. Note: this bug doesn't seem to exist for modules where the register is in the top module.  

Consider the following circuit where register `%r` reads from output port `%a` and also writes to it (effectively creating a self connection):

```mlir
firrtl.circuit ""Foo""   {
  firrtl.module @Bar(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {
    %r = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>
    %0 = firrtl.not %a : (!firrtl.uint<1>) -> !firrtl.uint<1>
    firrtl.connect %r, %0 : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %a, %r : !firrtl.uint<1>, !firrtl.uint<1>
  }
  firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {
    %bar_clock, %bar_a = firrtl.instance @Bar  {name = ""bar""} : !firrtl.clock, !firrtl.uint<1>
    firrtl.connect %bar_clock, %clock : !firrtl.clock, !firrtl.clock
    firrtl.connect %a, %bar_a : !firrtl.uint<1>, !firrtl.uint<1>
  }
}
```

IMConstProp is deleting the register `%r` when it should keep it around.  After IMConstProp, the circuit is:

```mlir
firrtl.circuit ""Foo""   {
  firrtl.module @Bar(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
  }
  firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    %bar_clock, %bar_a = firrtl.instance @Bar  {name = ""bar""} : !firrtl.clock, !firrtl.uint<1>
    firrtl.connect %bar_clock, %clock : !firrtl.clock, !firrtl.clock
    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
  }
}
```

### Background

The source FIRRTL for this is:

```scala
circuit Foo :
  module Bar :
    input clock : Clock
    output a : UInt<1>

    reg r : UInt<1>, clock
    r <= not(a)
    a <= r

  module Foo :
    input clock : Clock
    output a : UInt<1>

    inst bar of Bar
    bar.clock <= clock
    a <= bar.a
```

Running this through the Scala FIRRTL Compiler produces the following:

```verilog
module Bar(
  input   clock,
  output  a
);
  reg  r;
  assign a = r;
  always @(posedge clock) begin
    r <= ~a;
  end
endmodule
module Foo(
  input   clock,
  output  a
);
  wire  bar_clock;
  wire  bar_a;
  Bar bar (
    .clock(bar_clock),
    .a(bar_a)
  );
  assign a = bar_a;
  assign bar_clock = clock;
endmodule

```

Running this through CIRCT produces:

```verilog
module Bar(
  input  clock,
  output a);

  assign a = 1'h0;	// Foo.fir:2:10, :6:5
endmodule

module Foo(
  input  clock,
  output a);

  wire bar_a;	// Foo.fir:14:5

  Bar bar (	// Foo.fir:14:5
    .clock (clock),
    .a     (bar_a)
  );
  assign a = 1'h0;	// Foo.fir:10:10, :14:5
endmodule
```

I was surprised that formulations where the register is in the top module work. I.e., the following compiles just fine:

```scala
circuit Foo :
  module Foo :
    input clock : Clock
    output a : UInt<1>

    reg r : UInt<1>, clock
    r <= not(a)
    a <= r
```","firrtl.circuit ""Foo""   {
  firrtl.module @Bar(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {
    %r = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>
    %0 = firrtl.not %a : (!firrtl.uint<1>) -> !firrtl.uint<1>
    firrtl.connect %r, %0 : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %a, %r : !firrtl.uint<1>, !firrtl.uint<1>
  }
  firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {
    %bar_clock, %bar_a = firrtl.instance @Bar  {name = ""bar""} : !firrtl.clock, !firrtl.uint<1>
    firrtl.connect %bar_clock, %clock : !firrtl.clock, !firrtl.clock
    firrtl.connect %a, %bar_a : !firrtl.uint<1>, !firrtl.uint<1>
  }
}","firrtl.circuit ""Foo""   {
  firrtl.module @Bar(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
  }
  firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    %bar_clock, %bar_a = firrtl.instance @Bar  {name = ""bar""} : !firrtl.clock, !firrtl.uint<1>
    firrtl.connect %bar_clock, %clock : !firrtl.clock, !firrtl.clock
    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
  }
}","circuit Foo :
  module Bar :
    input clock : Clock
    output a : UInt<1>

    reg r : UInt<1>, clock
    r <= not(a)
    a <= r

  module Foo :
    input clock : Clock
    output a : UInt<1>

    inst bar of Bar
    bar.clock <= clock
    a <= bar.a","module Bar(
  input   clock,
  output  a
);
  reg  r;
  assign a = r;
  always @(posedge clock) begin
    r <= ~a;
  end
endmodule
module Foo(
  input   clock,
  output  a
);
  wire  bar_clock;
  wire  bar_a;
  Bar bar (
    .clock(bar_clock),
    .a(bar_a)
  );
  assign a = bar_a;
  assign bar_clock = clock;
endmodule","module Bar(
  input  clock,
  output a);

  assign a = 1'h0;	// Foo.fir:2:10, :6:5
endmodule

module Foo(
  input  clock,
  output a);

  wire bar_a;	// Foo.fir:14:5

  Bar bar (	// Foo.fir:14:5
    .clock (clock),
    .a     (bar_a)
  );
  assign a = 1'h0;	// Foo.fir:10:10, :14:5
endmodule","circuit Foo :
  module Foo :
    input clock : Clock
    output a : UInt<1>

    reg r : UInt<1>, clock
    r <= not(a)
    a <= r",,,,
1477,[FIRRTL] Add Verifier Check that Register Init Type Matches Register Type,2021-07-25T05:47:48Z,closed,"bug, good first issue, FIRRTL","Add a check that FIRRTL's `regreset` errors if the type of the reset value doesn't match the type of reset.  E.g., the following should fail because a vector register is being reset to a ground type.  However, it does not fail and will crash LowerTypes:

```mlir
%r = firrtl.regreset %clock, %reset, %c0_ui1  : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.vector<uint<1>, 1>
```

I think there's something clever that can be done here with the `AllTypesMatch` or `AllTypesMatchWith` ODS functions (or something similar). However, I'm not finding an immediate solution. ","%r = firrtl.regreset %clock, %reset, %c0_ui1  : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.vector<uint<1>, 1>",,,,,,,,,
1471,[FIRRTL] (mux) zero-width false positive,2021-07-23T01:51:42Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input y: UInt<0>
    input a: UInt<8>
    input b: UInt<8>
    output res: UInt<8>
    res <= mux(y, a, b)
```

Compiled with `firtool` produces this Verilog:

```verilog
module top_mod(
  input  [7:0] a, b,
  output [7:0] res);

  assign res = b;	// a_top_mod.fir:2:10
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT` produces this Error:

```
Exception in thread ""main"" firrtl.passes.CheckTypes$MuxCondUInt: : [module top_mod]
   A mux condition must be of type 1-bit UInt.
```
","circuit top_mod :
  module top_mod :
    input y: UInt<0>
    input a: UInt<8>
    input b: UInt<8>
    output res: UInt<8>
    res <= mux(y, a, b)","module top_mod(
  input  [7:0] a, b,
  output [7:0] res);

  assign res = b;	// a_top_mod.fir:2:10
endmodule","Exception in thread ""main"" firrtl.passes.CheckTypes$MuxCondUInt: : [module top_mod]
   A mux condition must be of type 1-bit UInt.",,,,,,,
1466,[FIRRTL][IMConstProp] Bug with Instance Input -> Wire -> Output,2021-07-22T07:51:35Z,closed,"bug, FIRRTL","Here's a fun one.  Consider the following FIRRTL dialect.  There is an _input port_ of an instance connected to a wire connected to an output, `b`. What should the value of `b` be?  

```mlir
firrtl.circuit ""Top""   {
  firrtl.extmodule @Ext(in %a: !firrtl.uint<1>)
  firrtl.module @Top(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
    %ext_a = firrtl.instance @Ext  {name = ""ext""} : !firrtl.uint<1>
    firrtl.connect %ext_a, %a : !firrtl.uint<1>, !firrtl.uint<1>
    %w = firrtl.wire  : !firrtl.uint<1>
    firrtl.connect %w, %ext_a : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %b, %w : !firrtl.uint<1>, !firrtl.uint<1>
  }  
}
```

IMConstProp is botching this.  It removes the wire and connects `%b` to invalid.

I.e., if you compile this with: `circt-opt Top.mlir -pass-pipeline='firrtl.circuit(firrtl-imconstprop)'` you get:

```verilog
firrtl.circuit ""Top""   {
  firrtl.extmodule @Ext(in %a: !firrtl.uint<1>)
  firrtl.module @Top(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
    %ext_a = firrtl.instance @Ext  {name = ""ext""} : !firrtl.uint<1>
    firrtl.connect %ext_a, %a : !firrtl.uint<1>, !firrtl.uint<1>
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
  }
}
```

For a perhaps easier to read version of the above, you can compile the following FIRRTL text:

```scala
circuit Top:
  extmodule Ext:
    input a: UInt<1>

  module Top:
    input a: UInt<1>
    output b: UInt<1>

    inst ext of Ext
    ext.a <= a

    wire w: UInt<1>
    w <= ext.a

    b <= w
```

With CIRCT you get:

```verilog
module Top(
  input  a,
  output b);

  Ext ext (	// Top.fir:9:5
    .a (a)
  );
  assign b = 1'h0;	// Top.fir:5:10, :12:5
endmodule
```

With the Scala FIRRTL Compiler (SFC) you get:

```verilog
module Top(
  input   a,
  output  b
);
  wire  ext_a;
  Ext ext (
    .a(ext_a)
  );
  assign b = ext_a;
  assign ext_a = a;
endmodule
```","firrtl.circuit ""Top""   {
  firrtl.extmodule @Ext(in %a: !firrtl.uint<1>)
  firrtl.module @Top(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
    %ext_a = firrtl.instance @Ext  {name = ""ext""} : !firrtl.uint<1>
    firrtl.connect %ext_a, %a : !firrtl.uint<1>, !firrtl.uint<1>
    %w = firrtl.wire  : !firrtl.uint<1>
    firrtl.connect %w, %ext_a : !firrtl.uint<1>, !firrtl.uint<1>
    firrtl.connect %b, %w : !firrtl.uint<1>, !firrtl.uint<1>
  }  
}","firrtl.circuit ""Top""   {
  firrtl.extmodule @Ext(in %a: !firrtl.uint<1>)
  firrtl.module @Top(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {
    %ext_a = firrtl.instance @Ext  {name = ""ext""} : !firrtl.uint<1>
    firrtl.connect %ext_a, %a : !firrtl.uint<1>, !firrtl.uint<1>
    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>
  }
}","circuit Top:
  extmodule Ext:
    input a: UInt<1>

  module Top:
    input a: UInt<1>
    output b: UInt<1>

    inst ext of Ext
    ext.a <= a

    wire w: UInt<1>
    w <= ext.a

    b <= w","module Top(
  input  a,
  output b);

  Ext ext (	// Top.fir:9:5
    .a (a)
  );
  assign b = 1'h0;	// Top.fir:5:10, :12:5
endmodule","module Top(
  input   a,
  output  b
);
  wire  ext_a;
  Ext ext (
    .a(ext_a)
  );
  assign b = ext_a;
  assign ext_a = a;
endmodule",,,,,
1465,[FIRRTL][IMConstProp] Bug with Self-Driven Register,2021-07-22T07:03:13Z,closed,"bug, FIRRTL","IMConstProp is botching the following example. Start with an oscillator called `foobar` that toggles every cycle:

```mlir
firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {
  %foobar = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>
  %0 = firrtl.not %foobar : (!firrtl.uint<1>) -> !firrtl.uint<1>
  firrtl.connect %foobar, %0 : !firrtl.uint<1>, !firrtl.uint<1>
  firrtl.connect %a, %foobar : !firrtl.uint<1>, !firrtl.uint<1>
}
```

After IMConstprop, this will produce:

```mlir
firrtl.circuit ""Foo""   {
  firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {
    %foobar = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>
    firrtl.connect %a, %foobar : !firrtl.uint<1>, !firrtl.uint<1>
  }
}
```

The self connection is removed which is illegal to do.  I haven't looked at IMConstProp to see what might be going on here.

For possibly easier inspection, this is taken from the following FIRRTL text:

```scala
circuit Foo:
  module Foo:
    input clock: Clock
    output a: UInt<1>

    reg foobar: UInt<1>, clock

    foobar <= not(foobar)
    a <= foobar
```

Going all the way to Verilog gives us (trimming randomization logic):

```verilog
module Foo(
  input  clock,
  output a);

  reg foobar;	// Tmp.fir:6:5
  assign a = foobar;	// Tmp.fir:2:10
endmodule
```

The Scala FIRRTL Compiler (SFC) produces:

```verilog
module Foo(
  input   clock,
  output  a
);
  reg  foobar;
  assign a = foobar;
  always @(posedge clock) begin
    foobar <= ~foobar;
  end
endmodule
```
","firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {
  %foobar = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>
  %0 = firrtl.not %foobar : (!firrtl.uint<1>) -> !firrtl.uint<1>
  firrtl.connect %foobar, %0 : !firrtl.uint<1>, !firrtl.uint<1>
  firrtl.connect %a, %foobar : !firrtl.uint<1>, !firrtl.uint<1>
}","firrtl.circuit ""Foo""   {
  firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {
    %foobar = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>
    firrtl.connect %a, %foobar : !firrtl.uint<1>, !firrtl.uint<1>
  }
}","circuit Foo:
  module Foo:
    input clock: Clock
    output a: UInt<1>

    reg foobar: UInt<1>, clock

    foobar <= not(foobar)
    a <= foobar","module Foo(
  input  clock,
  output a);

  reg foobar;	// Tmp.fir:6:5
  assign a = foobar;	// Tmp.fir:2:10
endmodule","module Foo(
  input   clock,
  output  a
);
  reg  foobar;
  assign a = foobar;
  always @(posedge clock) begin
    foobar <= ~foobar;
  end
endmodule",,,,,
1453,[FIRRTL] Lower Types Vector Lowering Bug,2021-07-20T19:52:12Z,closed,"bug, FIRRTL","Annotations on vectors aren't being handled correctly during FIRRTL's LowerTypes pass:

- If the annotation is on the first element, everything is lowered correctly. 
- If the annotation is on an element after the first element, the annotation is lowered to both that element and the one before it.


Consider the following circuit with the annotation `""a""` on the first element of a wire:

```mlir
module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo() {
      %a = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [1, 1], {a}>]} : !firrtl.vector<uint<1>, 4>
    }
  }
}
```

After types are lowered, this becomes:

```mlir
module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo() {
      %a_0 = firrtl.wire  {annotations = [{a}]} : !firrtl.uint<1>
      %a_1 = firrtl.wire  : !firrtl.uint<1>
      %a_2 = firrtl.wire  : !firrtl.uint<1>
      %a_3 = firrtl.wire  : !firrtl.uint<1>
    }
  }
}
```

This looks great.

Now if you annotate the second element:

```mlir
module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo() {
      %a = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [2, 2], {a}>]} : !firrtl.vector<uint<1>, 4>
    }
  }
}
```

This lowers to:

```mlir
module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo() {
      %a_0 = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [1, 1], {a}>]} : !firrtl.uint<1>
      %a_1 = firrtl.wire  {annotations = [{a}]} : !firrtl.uint<1>
      %a_2 = firrtl.wire  : !firrtl.uint<1>
      %a_3 = firrtl.wire  : !firrtl.uint<1>
    }
  }
}
```

And just so it's clear that only the element before is annotated, this is what happens for the third element:

```mlir
module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo() {
      %a_0 = firrtl.wire  : !firrtl.uint<1>
      %a_1 = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [1, 1], {a}>]} : !firrtl.uint<1>
      %a_2 = firrtl.wire  {annotations = [{a}]} : !firrtl.uint<1>
      %a_3 = firrtl.wire  : !firrtl.uint<1>
    }
  }
}

```","module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo() {
      %a = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [1, 1], {a}>]} : !firrtl.vector<uint<1>, 4>
    }
  }
}","module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo() {
      %a_0 = firrtl.wire  {annotations = [{a}]} : !firrtl.uint<1>
      %a_1 = firrtl.wire  : !firrtl.uint<1>
      %a_2 = firrtl.wire  : !firrtl.uint<1>
      %a_3 = firrtl.wire  : !firrtl.uint<1>
    }
  }
}","module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo() {
      %a = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [2, 2], {a}>]} : !firrtl.vector<uint<1>, 4>
    }
  }
}","module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo() {
      %a_0 = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [1, 1], {a}>]} : !firrtl.uint<1>
      %a_1 = firrtl.wire  {annotations = [{a}]} : !firrtl.uint<1>
      %a_2 = firrtl.wire  : !firrtl.uint<1>
      %a_3 = firrtl.wire  : !firrtl.uint<1>
    }
  }
}","module  {
  firrtl.circuit ""Foo""   {
    firrtl.module @Foo() {
      %a_0 = firrtl.wire  : !firrtl.uint<1>
      %a_1 = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [1, 1], {a}>]} : !firrtl.uint<1>
      %a_2 = firrtl.wire  {annotations = [{a}]} : !firrtl.uint<1>
      %a_3 = firrtl.wire  : !firrtl.uint<1>
    }
  }
}",,,,,
1450,[ExportVerilog] Add option to force posedge/negedge values to be in a wire,2021-07-20T13:17:02Z,closed,"bug, FIRRTL","Some tools don't like it if the `x` in a `@(posedge x)` is not strictly a name referring to a wire. Specifically, we've seen `localparam x = ...; @(posedge x)` break. We should add an option to ExportVerilog/firtool that forces all values used in sensitivity lists of processes to be spilled into wires.",,,,,,,,,,
1449,[FIRRTL] Grand Central DataTap Needs to Tap in Parent Module,2021-07-20T05:30:13Z,closed,"bug, FIRRTL","Currently, if you try to data tap into the current module, the generated XMR will have no hierarchy.  I don't think this will resolve correctly.  Instead, there should be an additional level of hierarchy.

Consider (and sorry for the verbosity) the following.  This is trying to tap `~Top|GCTDataTap>r`:

```scala
circuit Top : %[
[
  {
    ""class"": ""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"": ""~Top|DataTap"",
    ""keys"": [
      {
        ""class"": ""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"": ""~Top|GCTDataTap>r"",
        ""portName"": ""~Top|DataTap>_0""
      }
    ]
  }
]]
  extmodule DataTap :
    output _0 : UInt<1>

    defname = DataTap

  module Bar:
    input clock: Clock
    input a: UInt<1>
    output b: UInt<1>

    reg r : UInt<1>, clock

    r <= a
    b <= r


  module GCTDataTap :
    input clock : Clock
    input a : UInt<1>
    output b : UInt<1>

    reg r : UInt<1>, clock

    inst bar of Bar
    bar.clock <= clock
    bar.a <= a
    r <= bar.b
    b <= r

    wire cloneType : UInt<1>
    inst DataTap of DataTap
    DataTap._0 is invalid
    cloneType <= DataTap._0

  module Top:
    input clock: Clock
    input a: UInt<1>
    output b: UInt<1>

    inst DUT of GCTDataTap
    DUT.clock <= clock
    DUT.a <= a
    b <= DUT.b

```

The generated XMR is:

```verilog
module DataTap_impl_0(
  output _0);

  assign _0 = r;        // gct/DataTap.fir:15:13
endmodule
```

And for confirmation that this is a problem, Verilator can't find `r`:
```
%Error: /dev/stdin:37:15: Can't find definition of variable: 'r'
   37 |   assign _0 = r;  
      |               ^
%Error: Exiting due to 1 error(s)
```

However, if I instead tap `~Top|Bar>r`, everything works.  This produces the following Verilog and Verilator is happy:

```verilog
module DataTap_impl_0(
  output _0);

  assign _0 = bar.r;    // gct/DataTap.fir:15:13
endmodule
```

(Also, who knew that Verilator could handle hierarchical references?  To test this, I'm just using `firtool Foo.fir | verilator --lint-only /dev/stdin`.)","circuit Top : %[
[
  {
    ""class"": ""sifive.enterprise.grandcentral.DataTapsAnnotation"",
    ""blackBox"": ""~Top|DataTap"",
    ""keys"": [
      {
        ""class"": ""sifive.enterprise.grandcentral.ReferenceDataTapKey"",
        ""source"": ""~Top|GCTDataTap>r"",
        ""portName"": ""~Top|DataTap>_0""
      }
    ]
  }
]]
  extmodule DataTap :
    output _0 : UInt<1>

    defname = DataTap

  module Bar:
    input clock: Clock
    input a: UInt<1>
    output b: UInt<1>

    reg r : UInt<1>, clock

    r <= a
    b <= r


  module GCTDataTap :
    input clock : Clock
    input a : UInt<1>
    output b : UInt<1>

    reg r : UInt<1>, clock

    inst bar of Bar
    bar.clock <= clock
    bar.a <= a
    r <= bar.b
    b <= r

    wire cloneType : UInt<1>
    inst DataTap of DataTap
    DataTap._0 is invalid
    cloneType <= DataTap._0

  module Top:
    input clock: Clock
    input a: UInt<1>
    output b: UInt<1>

    inst DUT of GCTDataTap
    DUT.clock <= clock
    DUT.a <= a
    b <= DUT.b","module DataTap_impl_0(
  output _0);

  assign _0 = r;        // gct/DataTap.fir:15:13
endmodule","%Error: /dev/stdin:37:15: Can't find definition of variable: 'r'
   37 |   assign _0 = r;  
      |               ^
%Error: Exiting due to 1 error(s)","module DataTap_impl_0(
  output _0);

  assign _0 = bar.r;    // gct/DataTap.fir:15:13
endmodule",,,,,,
1384,[FIRRTL] Support LiteralDataTapKey in grand central data taps pass,2021-07-07T07:01:19Z,closed,"bug, FIRRTL",Currently the `GrandCentralTaps` pass complains about `LiteralDataTapKey` not being supported. These should be fairly straightforward to implement (possibly requiring parsing of FIR-style literals).,,,,,,,,,,
1375,Accept ReferenceDataTapKey on FIRRTL nodes,2021-07-06T12:28:50Z,closed,"bug, FIRRTL","The FIRRTL `GrandCentralTaps` pass currently complains about `ReferenceDataTapKey` annotations on `firrtl.node` ops. These should actually be allowed, since the nodes get a name assigned during Verilog emission that can be used in a hierarchical lookup. These annotations do appear on nodes also out in the wild.",,,,,,,,,,
1356,Syntax error in generated System Verilog with struct in register.,2021-07-01T05:51:53Z,closed,"bug, ExportVerilog","I'm looking at a case like the following:

```mlir
hw.module @Test(%in: !hw.struct<a: i1, b: i1>, %clk: i1) -> (%out: !hw.struct<a: i1, b: i1>) {
  %0 = seq.compreg %in, %clk : !hw.struct<a: i1, b: i1>
  hw.output %0 : !hw.struct<a: i1, b: i1>
}
```

The desire is to register a packed struct. Technically, we're trying to register a packed array of packed structs, but just a struct is sufficient to demonstrate this issue.

I think it should be legal to register a packed struct, or a packed array of packed structs, but please stop me here if I'm wrong.

To lower this, I am using the following passes:

```sh
circt-opt test.mlir -lower-seq-to-sv -hw-legalize-names
```

Which produces:

```mlir
module  {
  hw.module @Test(%in: !hw.struct<a: i1, b: i1>, %clk: i1) -> (%out: !hw.struct<a: i1, b: i1>) {
    %_T = sv.reg  : !hw.inout<struct<a: i1, b: i1>>
    %0 = sv.read_inout %_T : !hw.inout<struct<a: i1, b: i1>>
    sv.alwaysff(posedge %clk)  {
      sv.passign %_T, %in : !hw.struct<a: i1, b: i1>
    }
    hw.output %0 : !hw.struct<a: i1, b: i1>
  }
}
```

Unless I'm missing something, so far so good. The issue is in the generated System Verilog.

I'm using:

```sh
circt-translate -export-verilog
```

Which produces:

```verilog
module Test(
  input  struct packed {logic a; logic b; } in,
  input                                     clk,
  output struct packed {logic a; logic b; } out);

  reg struct packed {logic a; logic b; } _T;	// <stdin>:3:11

  always @(posedge clk)	// <stdin>:5:5
    _T <= in;	// <stdin>:6:7
  assign out = _T;	// <stdin>:4:10, :8:5
endmodule
```

This seems like a faithful translation of the IR, but the issue is on the `reg` line.

Running that through Verilator with:

```sh
verilator -sv -lint-only
```

Produces these errors:

```sh
%Error: /tmp/a:6:7: syntax error, unexpected struct
    6 |   reg struct packed {logic a; logic b; } _T;
      |       ^~~~~~
%Error: /tmp/a:6:40: syntax error, unexpected '}'
    6 |   reg struct packed {logic a; logic b; } _T;
      |                                        ^
%Error: Exiting due to 2 error(s)
```

If I manually remove the `reg ` from the System Verilog, Verilator doesn't complain. @teqdruid has reported the same behavior from Questa. My reading of section 6.8 of the spec seems to confirm the removal of `reg ` is correct: in the grammar defined in section 6.8, `data_type` appears to support `reg` or a `struct` type, but not `reg struct ...`.

Is this something we can adjust in the ExportVerilog handling of registers of structs (and arrays of structs)? If there's consensus that this is the right line of thought, I can take that task.","hw.module @Test(%in: !hw.struct<a: i1, b: i1>, %clk: i1) -> (%out: !hw.struct<a: i1, b: i1>) {
  %0 = seq.compreg %in, %clk : !hw.struct<a: i1, b: i1>
  hw.output %0 : !hw.struct<a: i1, b: i1>
}",circt-opt test.mlir -lower-seq-to-sv -hw-legalize-names,"module  {
  hw.module @Test(%in: !hw.struct<a: i1, b: i1>, %clk: i1) -> (%out: !hw.struct<a: i1, b: i1>) {
    %_T = sv.reg  : !hw.inout<struct<a: i1, b: i1>>
    %0 = sv.read_inout %_T : !hw.inout<struct<a: i1, b: i1>>
    sv.alwaysff(posedge %clk)  {
      sv.passign %_T, %in : !hw.struct<a: i1, b: i1>
    }
    hw.output %0 : !hw.struct<a: i1, b: i1>
  }
}",circt-translate -export-verilog,"module Test(
  input  struct packed {logic a; logic b; } in,
  input                                     clk,
  output struct packed {logic a; logic b; } out);

  reg struct packed {logic a; logic b; } _T;	// <stdin>:3:11

  always @(posedge clk)	// <stdin>:5:5
    _T <= in;	// <stdin>:6:7
  assign out = _T;	// <stdin>:4:10, :8:5
endmodule",verilator -sv -lint-only,"%Error: /tmp/a:6:7: syntax error, unexpected struct
    6 |   reg struct packed {logic a; logic b; } _T;
      |       ^~~~~~
%Error: /tmp/a:6:40: syntax error, unexpected '}'
    6 |   reg struct packed {logic a; logic b; } _T;
      |                                        ^
%Error: Exiting due to 2 error(s)",,,
1350,[FIRRTL] Verify Zero-width Behavior,2021-06-30T05:17:39Z,closed,"bug, FIRRTL","It's unclear to me if CIRCT is aligning with Scala FIRRTL Compiler zero width behavior as defined in: 
- https://github.com/chipsalliance/firrtl/blob/master/src/test/scala/firrtlTests/ZeroWidthTests.scala

Verify that CIRCT is doing the right thing here, expand this issue with any differences that may exist, and close this once CIRCT passes all these tests.

- [x] Port
- [x] Add
- [x] Mux: https://github.com/llvm/circt/pull/1349
- [ ] ???",,,,,,,,,,
1312,[FIRRTL] Windows build broken,2021-06-22T19:35:37Z,closed,"bug, FIRRTL","https://github.com/llvm/circt/actions/runs/961864100

```
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRTokenKinds.def(132,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRTokenKinds.def(132,1): error C2065: 'lp_': undeclared identifier (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRTokenKinds.def(132,1): error C2059: syntax error: ':' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRTokenKinds.def(155,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRTokenKinds.def(156,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRTokenKinds.def(164,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
```","D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRTokenKinds.def(132,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRTokenKinds.def(132,1): error C2065: 'lp_': undeclared identifier (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRTokenKinds.def(132,1): error C2059: syntax error: ':' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRTokenKinds.def(155,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRTokenKinds.def(156,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRTokenKinds.def(164,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]
D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\a\circt\circt\lib\Dialect\FIRRTL\Import\FIRParser.cpp) [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\Import\obj.CIRCTImportFIRRTL.vcxproj]",,,,,,,,,
1303,[FIRRTL] Allow connecting `uint` to `reset`,2021-06-21T15:20:56Z,closed,"bug, FIRRTL","The following connect currently breaks:
```firrtl
circuit test :
  module test :
    output out : Reset
    out <= UInt(1)
```
With the following message:
```plain
error: type mismatch between destination '!firrtl.reset' and source '!firrtl.uint'
  firrtl.connect %out, %c1_ui : !firrtl.reset, !firrtl.uint
  ^
```
The connect *does* work for `out <= UInt<1>(1)`.

This should work according to the following reset inference test case: https://github.com/chipsalliance/firrtl/blob/eb0841d27f5cd077c5f27f339ef9eb86cbe64599/src/test/scala/firrtlTests/InferResetsSpec.scala#L129-L134","circuit test :
  module test :
    output out : Reset
    out <= UInt(1)","error: type mismatch between destination '!firrtl.reset' and source '!firrtl.uint'
  firrtl.connect %out, %c1_ui : !firrtl.reset, !firrtl.uint
  ^",,,,,,,,
1302,[FIRRTL] Allow connecting `Reset` and `AsyncReset`,2021-06-21T15:12:36Z,closed,"bug, FIRRTL","Bundles where corresponding fields have a reset type should be allowed in connects, but the following code breaks:
```firrtl
circuit top :
  module top :
    input foo : { a : AsyncReset, flip b: Reset }
    output bar : { a : Reset, flip b: AsyncReset }
    bar <= foo
```
With the following error:
```plain
error: type mismatch between destination '!firrtl.bundle<a: reset, b: flip<asyncreset>>'
                              and source '!firrtl.bundle<a: asyncreset, b: flip<reset>>'
    bar <= foo
        ^
```
This only occurs if the resets are nested in bundles or vectors. Directly connecting a `AsyncReset` to a `Reset` wire, or vice versa, works.

Extracted from test case for [reset inference](https://github.com/chipsalliance/firrtl/blob/eb0841d27f5cd077c5f27f339ef9eb86cbe64599/src/test/scala/firrtlTests/InferResetsSpec.scala#L96-L105).","circuit top :
  module top :
    input foo : { a : AsyncReset, flip b: Reset }
    output bar : { a : Reset, flip b: AsyncReset }
    bar <= foo","error: type mismatch between destination '!firrtl.bundle<a: reset, b: flip<asyncreset>>'
                              and source '!firrtl.bundle<a: asyncreset, b: flip<reset>>'
    bar <= foo
        ^",,,,,,,,
1289,"[FIRRTL] (dshl, tail, mul) width inference mismatch",2021-06-16T16:43:39Z,open,"bug, FIRRTL","The following FIRRTL program

Produces different width for the output port `_tmp40`

```python
; seed: 1144
circuit top_mod :
  module top_mod :
    output _tmp40: UInt
    wire tmp19: UInt
    tmp19 <= mul(UInt(""o20575""), UInt<1>(0))
    _tmp40 <= dshl(UInt(""b10011010000001011101""), tail(tmp19, 15))
```

Compiled with `firtool` produces this Verilog:

```verilog
module top_mod(
  output [19:0] _tmp40);

  assign _tmp40 = 20'h9A05D;	// a_top_mod.fir:3:3, :7:20
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:

```verilog
module top_mod(
  output [18:0] _tmp40
);
  assign _tmp40 = 19'h1a05d;
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
ERROR: Can't match gold port `_tmp40_gold' to a gate port.
```","; seed: 1144
circuit top_mod :
  module top_mod :
    output _tmp40: UInt
    wire tmp19: UInt
    tmp19 <= mul(UInt(""o20575""), UInt<1>(0))
    _tmp40 <= dshl(UInt(""b10011010000001011101""), tail(tmp19, 15))","module top_mod(
  output [19:0] _tmp40);

  assign _tmp40 = 20'h9A05D;	// a_top_mod.fir:3:3, :7:20
endmodule","module top_mod(
  output [18:0] _tmp40
);
  assign _tmp40 = 19'h1a05d;
endmodule",ERROR: Can't match gold port `_tmp40_gold' to a gate port.,,,,,,
1288,"[FIRRTL] (dshl, head) mismatch",2021-06-16T15:53:05Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 759
circuit top_mod :
  module top_mod :
    input inp_cb: UInt<60>
    output _tmp66: UInt<91>
    wire tmp12: SInt
    wire _tmp13: UInt
    wire tmp58: UInt
    tmp12 <= shl(SInt(""b-100101100101""), 1)
    _tmp13 <= dshl(inp_cb, tail(asUInt(tmp12), 11))
    tmp58 <= pad(inp_cb, 41)
    _tmp66 <= dshl(_tmp13, head(tmp58, 0))
```

Compiled with `firtool` produces this Verilog:

```verilog
module top_mod(
  input  [59:0] inp_cb,
  output [90:0] _tmp66);

  assign _tmp66 = {24'h0, {1'h0, inp_cb, 6'h0} << 67'h0};	// a_top_mod.fir:3:3, :10:15, :12:15
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:

```verilog
module top_mod(
  input  [59:0] inp_cb,
  output [90:0] _tmp66
);
  wire [65:0] _GEN_0 = {inp_cb, 6'h0};
  wire [66:0] _GEN_1 = {{1'd0}, _GEN_0};
  wire [59:0] _GEN_2 = {{1'd0}, _GEN_1[58:0]};
  assign _tmp66 = {{31'd0}, _GEN_2};
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
ERROR: Found 7 unproven $equiv cells in 'equiv_status -assert'.
```","; seed: 759
circuit top_mod :
  module top_mod :
    input inp_cb: UInt<60>
    output _tmp66: UInt<91>
    wire tmp12: SInt
    wire _tmp13: UInt
    wire tmp58: UInt
    tmp12 <= shl(SInt(""b-100101100101""), 1)
    _tmp13 <= dshl(inp_cb, tail(asUInt(tmp12), 11))
    tmp58 <= pad(inp_cb, 41)
    _tmp66 <= dshl(_tmp13, head(tmp58, 0))","module top_mod(
  input  [59:0] inp_cb,
  output [90:0] _tmp66);

  assign _tmp66 = {24'h0, {1'h0, inp_cb, 6'h0} << 67'h0};	// a_top_mod.fir:3:3, :10:15, :12:15
endmodule","module top_mod(
  input  [59:0] inp_cb,
  output [90:0] _tmp66
);
  wire [65:0] _GEN_0 = {inp_cb, 6'h0};
  wire [66:0] _GEN_1 = {{1'd0}, _GEN_0};
  wire [59:0] _GEN_2 = {{1'd0}, _GEN_1[58:0]};
  assign _tmp66 = {{31'd0}, _GEN_2};
endmodule",ERROR: Found 7 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
1271,[FIRRTL] Width Inference Problem with Cycle,2021-06-14T20:19:50Z,closed,"bug, FIRRTL, infer width","The following circuit causes an error during width inference of register `a`. However, the SFC infers a width of two.

```scala
circuit Bar :
  module Bar :
    input clock : Clock
    input cond : UInt<1>

    reg a : UInt, clock

    node _false = add(a, UInt<1>(0))
    node false = tail(_false, 1)
    a <= mux(cond, UInt<2>(0), false)
```

With the MFC, I get:
```
Bar.fir:6:5: error: 'firrtl.reg' op is constrained to be wider than itself
    reg a : UInt, clock
    ^
Bar.fir:6:5: note: see current operation: %a = ""firrtl.reg""(%clock) {annotations = [], name = ""a""} : (!firrtl.clock) -> !firrtl.uint
Bar.fir:8:19: note: constrained width W >= W+2 here:
    node _false = add(a, UInt<1>(0))
                  ^
Bar.fir:9:18: note: constrained width W >= W+1 here:
    node false = tail(_false, 1)
                 ^
Bar.fir:10:10: note: constrained width W >= W+1 here:
    a <= mux(cond, UInt<2>(0), false)
         ^
```

With the SFC, I get:
```scala
circuit Bar :
  module Bar :
    input clock : Clock
    input cond : UInt<1>

    reg a : UInt<2>, clock with :
      reset => (UInt<1>(""h0""), a)
    node _false = add(a, UInt<1>(""h0""))
    node false = tail(_false, 1)
    a <= mux(cond, UInt<2>(""h0""), false)
```","circuit Bar :
  module Bar :
    input clock : Clock
    input cond : UInt<1>

    reg a : UInt, clock

    node _false = add(a, UInt<1>(0))
    node false = tail(_false, 1)
    a <= mux(cond, UInt<2>(0), false)","Bar.fir:6:5: error: 'firrtl.reg' op is constrained to be wider than itself
    reg a : UInt, clock
    ^
Bar.fir:6:5: note: see current operation: %a = ""firrtl.reg""(%clock) {annotations = [], name = ""a""} : (!firrtl.clock) -> !firrtl.uint
Bar.fir:8:19: note: constrained width W >= W+2 here:
    node _false = add(a, UInt<1>(0))
                  ^
Bar.fir:9:18: note: constrained width W >= W+1 here:
    node false = tail(_false, 1)
                 ^
Bar.fir:10:10: note: constrained width W >= W+1 here:
    a <= mux(cond, UInt<2>(0), false)
         ^","circuit Bar :
  module Bar :
    input clock : Clock
    input cond : UInt<1>

    reg a : UInt<2>, clock with :
      reset => (UInt<1>(""h0""), a)
    node _false = add(a, UInt<1>(""h0""))
    node false = tail(_false, 1)
    a <= mux(cond, UInt<2>(""h0""), false)",,,,,,,
1270,[FIRRTL] Connect Verifier False Positive,2021-06-14T19:17:39Z,closed,"bug, FIRRTL","The following circuit (extracted from a real design) is tripping a connect op verifier error:

```scala
circuit Foo :
  module Foo :
    input source: UInt<1>
    input cond: UInt<1>

    wire a_set : UInt<1>
    a_set <= UInt<1>(""h0"")
    when cond :
      node _a_set_T = dshl(UInt<1>(""h1""), source)
      a_set <= _a_set_T
```

The MFC's InferWidths pass is currently erroring out with:
```
fire-drill/TileLinkMonitor.hi.fir:10:13: error: destination width 1 is not greater than or equal to source width 2
      a_set <= _a_set_T
            ^
fire-drill/TileLinkMonitor.hi.fir:10:13: note: see current operation: ""firrtl.connect""(%a_set, %1) : (!firrtl.uint<1>, !firrtl.uint<2>) -> ()
```

However, the SFC allows this through. The SFC doesn't align with the spec and does auto-truncation on connects. 🤷‍♀️ 

The eventual SFC output Verilog is:
```
module Foo(
  input   source,
  input   cond
);
  wire [1:0] _a_set_T = 2'h1 << source;
  wire [1:0] _GEN_0 = cond ? _a_set_T : 2'h0; // @[]
  wire  a_set = _GEN_0[0];
endmodule
```","circuit Foo :
  module Foo :
    input source: UInt<1>
    input cond: UInt<1>

    wire a_set : UInt<1>
    a_set <= UInt<1>(""h0"")
    when cond :
      node _a_set_T = dshl(UInt<1>(""h1""), source)
      a_set <= _a_set_T","fire-drill/TileLinkMonitor.hi.fir:10:13: error: destination width 1 is not greater than or equal to source width 2
      a_set <= _a_set_T
            ^
fire-drill/TileLinkMonitor.hi.fir:10:13: note: see current operation: ""firrtl.connect""(%a_set, %1) : (!firrtl.uint<1>, !firrtl.uint<2>) -> ()","module Foo(
  input   source,
  input   cond
);
  wire [1:0] _a_set_T = 2'h1 << source;
  wire [1:0] _GEN_0 = cond ? _a_set_T : 2'h0; // @[]
  wire  a_set = _GEN_0[0];
endmodule",,,,,,,
1215,"[FIRRTL] (dshr, and) mismatch",2021-06-08T01:22:33Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_e: SInt<58>
    output tmp116: UInt<58>
    wire tmp109: SInt<58>
    tmp109 <= dshr(inp_e, tail(UInt<21>(""h1935b6""), 11))
    tmp116 <= and(asSInt(UInt<9>(""o246"")), tmp109)
```

Compiled with `firtool` produces this Verilog:

```verilog
module top_mod(
  input  [57:0] inp_e,
  output [57:0] tmp116);

  assign tmp116 = $signed(inp_e) >>> 58'sh1B6 & 58'hA6;	// a_top_mod.fir:2:3, :6:15, :7:15
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:

```verilog
module top_mod(
  input  [57:0] inp_e,
  output [57:0] tmp116
);
  wire  _GEN_1 = inp_e[57];
  wire [57:0] tmp109 = {58{_GEN_1}};
  assign tmp116 = 58'sha6 & $signed(tmp109);
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
ERROR: Found 4 unproven $equiv cells in 'equiv_status -assert'.
```","circuit top_mod :
  module top_mod :
    input inp_e: SInt<58>
    output tmp116: UInt<58>
    wire tmp109: SInt<58>
    tmp109 <= dshr(inp_e, tail(UInt<21>(""h1935b6""), 11))
    tmp116 <= and(asSInt(UInt<9>(""o246"")), tmp109)","module top_mod(
  input  [57:0] inp_e,
  output [57:0] tmp116);

  assign tmp116 = $signed(inp_e) >>> 58'sh1B6 & 58'hA6;	// a_top_mod.fir:2:3, :6:15, :7:15
endmodule","module top_mod(
  input  [57:0] inp_e,
  output [57:0] tmp116
);
  wire  _GEN_1 = inp_e[57];
  wire [57:0] tmp109 = {58{_GEN_1}};
  assign tmp116 = 58'sha6 & $signed(tmp109);
endmodule",ERROR: Found 4 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
1188,[FIRRTL] Integration test times out,2021-06-02T17:26:27Z,closed,"bug, FIRRTL","![image](https://user-images.githubusercontent.com/1498080/120525409-f5b43d80-c38c-11eb-88f4-05cb7f46dc23.png)

https://github.com/llvm/circt/runs/2727815005?check_suite_focus=true",,,,,,,,,,
1187,FIRRTL Error involving Division Fold,2021-06-02T15:49:51Z,closed,"bug, FIRRTL","The following circuit crashes `firtool`. 

```scala
circuit Foo:
  module Foo:
    input divisor: UInt<1>
    output result: UInt<0>

    wire dividend: UInt<0>
    dividend is invalid

    result <= div(dividend, divisor)
```

The issue is that `div(x, invalid)` or `div(invalid, x)` is trying to fold to `UInt<$width>(0)` where `$width` is the result type. This is the usual problem where `APInt` can't have a zero width.

This started to show up on `circt/perf`'s test1 because inter-module constant propagation got turned on in e73115d5969905b2def85af062d3feb15c204003 which tickles this for test1. The minimal circuit above hits the same code path but goes through the `SimpleCanonicalizer` which means that this will fail even without/before e73115d5969905b2def85af062d3feb15c204003.","circuit Foo:
  module Foo:
    input divisor: UInt<1>
    output result: UInt<0>

    wire dividend: UInt<0>
    dividend is invalid

    result <= div(dividend, divisor)",,,,,,,,,
1181,LowerTypes Exposes Bare Flips that Trip Primop Verifier,2021-05-31T03:35:43Z,closed,bug,"Consider the following circuit:

```scala
circuit Foo:
  module Bar:
    output a: { flip a: UInt<1> }
    input b: UInt<1>
  module Foo:
    input a: UInt<1>
    output b: UInt<1>

    inst bar of Bar
    bar is invalid

    b <= and(bar.a.a, bar.b)
```

Both `bar.a.a` and `bar.b` have sink flow. However, the `bar.a.a` reference results in a malformed `and` op (according to its verifier). That verifier requires that no flips appear:

```mlir
%0 = ""firrtl.asPassive""(%bar_b) : (!firrtl.flip<uint<1>>) -> !firrtl.uint<1>
%1 = ""firrtl.and""(%bar_a_a, %0) : (!firrtl.flip<uint<1>>, !firrtl.uint<1>) -> !firrtl.uint<1>
```

The reason why this _doesn't_ fail for `bar.b` is because an `asPassive` op is inserted during parsing. The parser checks for flips used as right-hand-side expression in a primitive op. However, this is just a subset of ""sink used as source"".

There are a bunch of ways that this could be fixed:

1) Expand the parser check to look for sinks used as sources and insert `asPassive` when needed.
2) Lower Types should recognize this case and insert `asPassive`.
3) This verifier should stop checking flip and actually check flow.

### Background

This is a reduced case that shows up when trying to compile a middle FIRRTL file from Chipyard. This pattern occurs in the `TLError` module.","circuit Foo:
  module Bar:
    output a: { flip a: UInt<1> }
    input b: UInt<1>
  module Foo:
    input a: UInt<1>
    output b: UInt<1>

    inst bar of Bar
    bar is invalid

    b <= and(bar.a.a, bar.b)","%0 = ""firrtl.asPassive""(%bar_b) : (!firrtl.flip<uint<1>>) -> !firrtl.uint<1>
%1 = ""firrtl.and""(%bar_a_a, %0) : (!firrtl.flip<uint<1>>, !firrtl.uint<1>) -> !firrtl.uint<1>",,,,,,,,
1173,[ExpandWhens] Strip flip types off of bundles before casting,2021-05-28T06:22:16Z,closed,"bug, FIRRTL","This code was erroneously assuming that the operand of subfield op was
always a bundle type.  BundleType can be wrapped in a FlipType if it is
an `in` port of an InstanceOp.  This change strips the flip type from
the bundle type when it is there.",,,,,,,,,,
1161,[FIRRTL] Remove black box annotations after ingesting them,2021-05-27T17:37:38Z,closed,"bug, FIRRTL","Currently the `BlackBoxReader` pass ingests black box annotations and reads the files into `sv.verbatim` files, but leaves the annotations there. This makes the pass non-idempotent, which is bad (running it again will replicate the black boxes). Run the transform twice in the test to reproduce this bug, then remove the annotation.",,,,,,,,,,
1158,[FIRRTL] Windows build broken,2021-05-26T18:45:22Z,closed,"bug, FIRRTL","https://github.com/llvm/circt/runs/2675122003?check_suite_focus=true

```
D:\a\circt\circt\lib\Dialect\FIRRTL\FIRRTLTypes.cpp(701,23): error C2398: Element '1': conversion from 'size_t' to 'T &&' requires a narrowing conversion [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\obj.CIRCTFIRRTL.vcxproj]
          with
          [
              T=unsigned int
          ]
```

Maybe this was already fixed, but last nights Windows build failed.","D:\a\circt\circt\lib\Dialect\FIRRTL\FIRRTLTypes.cpp(701,23): error C2398: Element '1': conversion from 'size_t' to 'T &&' requires a narrowing conversion [D:\a\circt\circt\build_release\lib\Dialect\FIRRTL\obj.CIRCTFIRRTL.vcxproj]
          with
          [
              T=unsigned int
          ]",,,,,,,,,
1153,[FIRRTL] Don't fold mux with unknown result width,2021-05-26T10:32:42Z,closed,"bug, FIRRTL","Fix an issue around mux canonicalization where folding a mux to one of its operands can result in invalidation of subsequent IR if the mux result does not have a known width. For example, picking an unsized constant can lead to the constant resolving to a width more narrow than assumed in the remaining IR. This change refuses to fold and canonicalize any multiplexers that have unkown result width.

Fixes #1142.",,,,,,,,,,
1121,[FIRRTL] LowerTypes: fix handing of mux ops,2021-05-21T19:37:06Z,closed,"bug, FIRRTL","Mux lowering forgot to check when the type was not a bundle, leading to
lots of crashes",,,,,,,,,,
1102,[FIRRTL] Fix constant width inference and connection truncation,2021-05-20T15:28:34Z,closed,"bug, FIRRTL, infer width","* Width inference can cause the RHS of a connect operation to become wider than the LHS. The behaviour prescribed by the Scala FIRRTL compiler is to insert a `bits` operation to truncate the RHS to the appropriate width. Add this behaviour to the InferWidths pass. Fixes #1088, fixes #1089, fixes #1091, fixes #1092, fixes #1093, fixes #1094, fixes #1095, fixes #1096, fixes #1097, fixes #1099.
* Fix an issue where unsized constants would infer a width that could be wider than the minimum number of bits necessary to represent the constant. This fixes width inference to properly compute the number of bits necessary to represent a signed/unsigned constant. Also updates the APInt store in ConstantOp after width inference. Fixes #1090, fixes #1098.

This will make @drom very happy :wink: ",,,,,,,,,,
1101,[FIRRTL] Connecting wide constant to narrow port crashes canonicalizer,2021-05-20T14:07:52Z,closed,"bug, FIRRTL","The canonicalizer currently crashes in `TailPrimOp::fold` on the following FIRRTL input:
```firrtl
circuit top_mod :
  module top_mod :
    output y: SInt<4>
    y <= SInt<10>(9)  // note the constant being wider than the port
```

This translates to the following MLIR before canonicalization:
```mlir
module  {
  firrtl.circuit ""top_mod""  {
    firrtl.module @top_mod(in %x: !firrtl.sint<5>, out %y: !firrtl.sint<4>) {
      %c9_si10 = firrtl.constant 9 : !firrtl.sint<10>
      firrtl.partialconnect %y, %c9_si10 : !firrtl.sint<4>, !firrtl.sint<10>
    }
  }
}
```

Running the above through `circt-opt --simple-canonicalizer` triggers the crash. Stack trace:
```plain
circt-opt: ../llvm/mlir/include/mlir/IR/Types.h:243: U mlir::Type::cast() const [U = circt::firrtl::UIntType]: Assertion `isa<U>()' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.  Program arguments: circt-opt --simple-canonicalizer
 #0 0x00007fc815bc7701 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) llvm/llvm/lib/Support/Unix/Signals.inc:565:13
 #1 0x00007fc815bc5760 llvm::sys::RunSignalHandlers() llvm/llvm/lib/Support/Signals.cpp:77:18
 #2 0x00007fc815bc7c2d SignalHandler(int) llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007fc8178dc960 __restore_rt (/usr/lib/libpthread.so.0+0x13960)
 #4 0x00007fc815561ef5 raise (/usr/lib/libc.so.6+0x3cef5)
 #5 0x00007fc81554b862 abort (/usr/lib/libc.so.6+0x26862)
 #6 0x00007fc81554b747 _nl_load_domain.cold (/usr/lib/libc.so.6+0x26747)
 #7 0x00007fc81555a646 (/usr/lib/libc.so.6+0x35646)
 #8 0x00007fc8175663cd llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> >::updatePointer(long, void*) llvm/llvm/include/llvm/ADT/PointerIntPair.h:178:5
 #9 0x00007fc8175663cd llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> > >::setPointerAndInt(void*, int) & llvm/llvm/include/llvm/ADT/PointerIntPair.h:76:29
#10 0x00007fc8175663cd llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> > >::PointerIntPair(void*, int) llvm/llvm/include/llvm/ADT/PointerIntPair.h:54:5
#11 0x00007fc8175663cd llvm::pointer_union_detail::PointerUnionMembers<llvm::PointerUnion<mlir::Attribute, mlir::Value>, llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> > >, 0, mlir::Attribute, mlir::Value>::PointerUnionMembers(mlir::Attribute) llvm/llvm/include/llvm/ADT/PointerUnion.h:118:16
#12 0x00007fc8175663cd llvm::PointerUnion<mlir::Attribute, mlir::Value>::PointerUnion(mlir::Attribute) llvm/llvm/include/llvm/ADT/PointerUnion.h:168:15
#13 0x00007fc8175663cd mlir::OpFoldResult::OpFoldResult(mlir::Attribute) llvm/mlir/include/mlir/IR/OpDefinition.h:207:41
#14 0x00007fc8175663cd circt::firrtl::TailPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) lib/Dialect/FIRRTL/FIRRTLFolds.cpp:947:14
#15 0x00007fc81755c470 mlir::LogicalResult mlir::Op<circt::firrtl::TailPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::TailPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) llvm/mlir/include/mlir/IR/OpDefinition.h:1702:49
```

Apparently the partial connect gets mapped to a `tail` operation but somehow the sign of the result is off.","circuit top_mod :
  module top_mod :
    output y: SInt<4>
    y <= SInt<10>(9)  // note the constant being wider than the port","module  {
  firrtl.circuit ""top_mod""  {
    firrtl.module @top_mod(in %x: !firrtl.sint<5>, out %y: !firrtl.sint<4>) {
      %c9_si10 = firrtl.constant 9 : !firrtl.sint<10>
      firrtl.partialconnect %y, %c9_si10 : !firrtl.sint<4>, !firrtl.sint<10>
    }
  }
}","circt-opt: ../llvm/mlir/include/mlir/IR/Types.h:243: U mlir::Type::cast() const [U = circt::firrtl::UIntType]: Assertion `isa<U>()' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.  Program arguments: circt-opt --simple-canonicalizer
 #0 0x00007fc815bc7701 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) llvm/llvm/lib/Support/Unix/Signals.inc:565:13
 #1 0x00007fc815bc5760 llvm::sys::RunSignalHandlers() llvm/llvm/lib/Support/Signals.cpp:77:18
 #2 0x00007fc815bc7c2d SignalHandler(int) llvm/llvm/lib/Support/Unix/Signals.inc:0:3
 #3 0x00007fc8178dc960 __restore_rt (/usr/lib/libpthread.so.0+0x13960)
 #4 0x00007fc815561ef5 raise (/usr/lib/libc.so.6+0x3cef5)
 #5 0x00007fc81554b862 abort (/usr/lib/libc.so.6+0x26862)
 #6 0x00007fc81554b747 _nl_load_domain.cold (/usr/lib/libc.so.6+0x26747)
 #7 0x00007fc81555a646 (/usr/lib/libc.so.6+0x35646)
 #8 0x00007fc8175663cd llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> >::updatePointer(long, void*) llvm/llvm/include/llvm/ADT/PointerIntPair.h:178:5
 #9 0x00007fc8175663cd llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> > >::setPointerAndInt(void*, int) & llvm/llvm/include/llvm/ADT/PointerIntPair.h:76:29
#10 0x00007fc8175663cd llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> > >::PointerIntPair(void*, int) llvm/llvm/include/llvm/ADT/PointerIntPair.h:54:5
#11 0x00007fc8175663cd llvm::pointer_union_detail::PointerUnionMembers<llvm::PointerUnion<mlir::Attribute, mlir::Value>, llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> > >, 0, mlir::Attribute, mlir::Value>::PointerUnionMembers(mlir::Attribute) llvm/llvm/include/llvm/ADT/PointerUnion.h:118:16
#12 0x00007fc8175663cd llvm::PointerUnion<mlir::Attribute, mlir::Value>::PointerUnion(mlir::Attribute) llvm/llvm/include/llvm/ADT/PointerUnion.h:168:15
#13 0x00007fc8175663cd mlir::OpFoldResult::OpFoldResult(mlir::Attribute) llvm/mlir/include/mlir/IR/OpDefinition.h:207:41
#14 0x00007fc8175663cd circt::firrtl::TailPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) lib/Dialect/FIRRTL/FIRRTLFolds.cpp:947:14
#15 0x00007fc81755c470 mlir::LogicalResult mlir::Op<circt::firrtl::TailPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::TailPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) llvm/mlir/include/mlir/IR/OpDefinition.h:1702:49",,,,,,,
1071,[LLHD] Buffer over-read during simulation,2021-05-18T08:40:48Z,closed,"bug, LLHD","In `LLHD/Engine.cpp`, a memory bytebuffer is converted to an APInt.  In order to do this, the buffer is converted from `uint8_t*` to `uint64_t*`, and the size of the buffer is rounded up to the next 64 bits.  After this, the constructor of APInt reads past the end of the original bytebuffer.

```c++
      APInt buff(
          curr.size * 8,
          llvm::makeArrayRef(reinterpret_cast<uint64_t *>(curr.value.get()),
                             llvm::divideCeil(curr.size, 8)));
```

There seems to be a purpose built function to do what we want, although I haven't checked how the memory buffer is supposed to be used on big endian systems.
```c++
      APInt buff(curr.size * 8, 0);
      LoadIntFromMemory(buff, curr.value.get(), curr.size);
```

There are at least two places that will have to be fixed:
https://github.com/llvm/circt/blob/main/lib/Dialect/LLHD/Simulator/Engine.cpp#L131
https://github.com/llvm/circt/blob/main/lib/Dialect/LLHD/Simulator/State.cpp#L113","c++
      APInt buff(
          curr.size * 8,
          llvm::makeArrayRef(reinterpret_cast<uint64_t *>(curr.value.get()),
                             llvm::divideCeil(curr.size, 8)));","c++
      APInt buff(curr.size * 8, 0);
      LoadIntFromMemory(buff, curr.value.get(), curr.size);",,,,,,,,
1069,[LLHD] Don't erase ops in the folder for Connect and Drv,2021-05-18T07:22:36Z,closed,"bug, LLHD","The folder does not allow an op to be explicitly erased, which was
causing the folder to use-after-free.  There doesn't seem to be a good
way to implement the folding of an op with no results, so this was
re-implemented as a canonicalization.",,,,,,,,,,
1068,[HandshakeToFIRRTL] Fix use of stack allocated vector.,2021-05-18T07:18:16Z,closed,"bug, Handshake","The stack allocated vector values was allocated inside a for loop and a
reference to it was stored in to an SmallVector.  Asan picked up the
invalid dangling reference. The SmallVector was changed to hold (own)
the child-vector instead of keeping a reference.",,,,,,,,,,
1065,[CI] Most tests fail on Ubuntu 18.04,2021-05-17T17:43:44Z,open,bug,"I have a Docker-based repro: https://github.com/llvm/circt/blob/crashes-1804/utils/run-docker-1804.sh. Just run `./utils/run-docker-1804.sh`. This is running the LLVM build in the release config w/ asserts enabled and CIRCT in debug. I've attached a log of the crashes: [test_fails.log](https://github.com/llvm/circt/files/6495753/test_fails.log).


```
Failed Tests (210):
  CIRCT :: CAPI/ir.c
  CIRCT :: Conversion/FIRRTLToHW/errors.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-errors.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-module.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw.mlir
  CIRCT :: Conversion/FIRRTLToHW/zero-width.mlir
  CIRCT :: Conversion/FIRRTLToLLHD/connect.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_inouts.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_ins.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_none.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_outs.fir
  CIRCT :: Conversion/HWToLLHD/errors.mlir
  CIRCT :: Conversion/HWToLLHD/structure.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/simple_addi.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_branch.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_buffer.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_cmerge.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_conditional_branch.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_constant.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_fork.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_join.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_lazy_fork.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_load.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_memory.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_merge.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_mux.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_sink.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_store.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_arithmetic.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_bitwise.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_entity.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_extract.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_insert.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_memory.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_process_persistence.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_signals.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_simple.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_value_creation.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_wait.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/errors.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-for.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-load-store.mlir
  CIRCT :: Conversion/StandardToHandshake/test1.mlir
  CIRCT :: Conversion/StandardToHandshake/test10.mlir
  CIRCT :: Conversion/StandardToHandshake/test11.mlir
  CIRCT :: Conversion/StandardToHandshake/test12.mlir
  CIRCT :: Conversion/StandardToHandshake/test13.mlir
  CIRCT :: Conversion/StandardToHandshake/test14.mlir
  CIRCT :: Conversion/StandardToHandshake/test15.mlir
  CIRCT :: Conversion/StandardToHandshake/test16.mlir
  CIRCT :: Conversion/StandardToHandshake/test17.mlir
  CIRCT :: Conversion/StandardToHandshake/test18.mlir
  CIRCT :: Conversion/StandardToHandshake/test19.mlir
  CIRCT :: Conversion/StandardToHandshake/test2.mlir
  CIRCT :: Conversion/StandardToHandshake/test20.mlir
  CIRCT :: Conversion/StandardToHandshake/test21.mlir
  CIRCT :: Conversion/StandardToHandshake/test22.mlir
  CIRCT :: Conversion/StandardToHandshake/test23.mlir
  CIRCT :: Conversion/StandardToHandshake/test24.mlir
  CIRCT :: Conversion/StandardToHandshake/test25.mlir
  CIRCT :: Conversion/StandardToHandshake/test26.mlir
  CIRCT :: Conversion/StandardToHandshake/test27.mlir
  CIRCT :: Conversion/StandardToHandshake/test28.mlir
  CIRCT :: Conversion/StandardToHandshake/test29.mlir
  CIRCT :: Conversion/StandardToHandshake/test3.mlir
  CIRCT :: Conversion/StandardToHandshake/test30.mlir
  CIRCT :: Conversion/StandardToHandshake/test31.mlir
  CIRCT :: Conversion/StandardToHandshake/test32.mlir
  CIRCT :: Conversion/StandardToHandshake/test33.mlir
  CIRCT :: Conversion/StandardToHandshake/test34.mlir
  CIRCT :: Conversion/StandardToHandshake/test35.mlir
  CIRCT :: Conversion/StandardToHandshake/test4.mlir
  CIRCT :: Conversion/StandardToHandshake/test5.mlir
  CIRCT :: Conversion/StandardToHandshake/test6.mlir
  CIRCT :: Conversion/StandardToHandshake/test7.mlir
  CIRCT :: Conversion/StandardToHandshake/test8.mlir
  CIRCT :: Conversion/StandardToHandshake/test9.mlir
  CIRCT :: Conversion/StandardToHandshake/test_canonicalize.mlir
  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer.mlir
  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer_errors.mlir
  CIRCT :: Conversion/StandardToStaticLogic/test_pipeline.mlir
  CIRCT :: Dialect/ESI/connectivity.mlir
  CIRCT :: Dialect/ESI/errors.mlir
  CIRCT :: Dialect/ESI/lowering.mlir
  CIRCT :: Dialect/ESI/modwrap.mlir
  CIRCT :: Dialect/ESI/wrapif-lowering.mlir
  CIRCT :: Dialect/FIRRTL/annotations.fir
  CIRCT :: Dialect/FIRRTL/blackbox-memory.mlir
  CIRCT :: Dialect/FIRRTL/canonicalization.mlir
  CIRCT :: Dialect/FIRRTL/check-widths-errors.mlir
  CIRCT :: Dialect/FIRRTL/connect-errors.mlir
  CIRCT :: Dialect/FIRRTL/connect.mlir
  CIRCT :: Dialect/FIRRTL/const-prop-single-module.mlir
  CIRCT :: Dialect/FIRRTL/cse.mlir
  CIRCT :: Dialect/FIRRTL/errors.mlir
  CIRCT :: Dialect/FIRRTL/expand-whens-errors.mlir
  CIRCT :: Dialect/FIRRTL/expand-whens.mlir
  CIRCT :: Dialect/FIRRTL/imconstprop.mlir
  CIRCT :: Dialect/FIRRTL/infer-widths-errors.mlir
  CIRCT :: Dialect/FIRRTL/infer-widths.mlir
  CIRCT :: Dialect/FIRRTL/inliner.mlir
  CIRCT :: Dialect/FIRRTL/lower-types-errors.mlir
  CIRCT :: Dialect/FIRRTL/lower-types.mlir
  CIRCT :: Dialect/FIRRTL/parse-basic.fir
  CIRCT :: Dialect/FIRRTL/parse-errors.fir
  CIRCT :: Dialect/FIRRTL/parse-locations.fir
  CIRCT :: Dialect/FIRRTL/test.mlir
  CIRCT :: Dialect/HW/basic.mlir
  CIRCT :: Dialect/HW/bitwise.mlir
  CIRCT :: Dialect/HW/canonicalization.mlir
  CIRCT :: Dialect/HW/errors.mlir
  CIRCT :: Dialect/HW/greybox.mlir
  CIRCT :: Dialect/HW/modules.mlir
  CIRCT :: Dialect/HW/svEmitErrors.mlir
  CIRCT :: Dialect/HW/typedecls.mlir
  CIRCT :: Dialect/HW/types.mlir
  CIRCT :: Dialect/Handshake/errors.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/arithmetic.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/bitwise.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/constant.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/extract.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/memory.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/probeCSE.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/signalOps.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_arithmetic.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_bitwise.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_entity.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_relations.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_sig.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_sig_errors.mlir
  CIRCT :: Dialect/LLHD/IR/arithmetic.mlir
  CIRCT :: Dialect/LLHD/IR/array.mlir
  CIRCT :: Dialect/LLHD/IR/bitwise.mlir
  CIRCT :: Dialect/LLHD/IR/connect-errors.mlir
  CIRCT :: Dialect/LLHD/IR/connect.mlir
  CIRCT :: Dialect/LLHD/IR/const.mlir
  CIRCT :: Dialect/LLHD/IR/entity.mlir
  CIRCT :: Dialect/LLHD/IR/extract-errors.mlir
  CIRCT :: Dialect/LLHD/IR/extract.mlir
  CIRCT :: Dialect/LLHD/IR/insert-errors.mlir
  CIRCT :: Dialect/LLHD/IR/insert.mlir
  CIRCT :: Dialect/LLHD/IR/inst-errors.mlir
  CIRCT :: Dialect/LLHD/IR/inst.mlir
  CIRCT :: Dialect/LLHD/IR/memory.mlir
  CIRCT :: Dialect/LLHD/IR/proc.mlir
  CIRCT :: Dialect/LLHD/IR/reg.mlir
  CIRCT :: Dialect/LLHD/IR/signal-errors.mlir
  CIRCT :: Dialect/LLHD/IR/signal.mlir
  CIRCT :: Dialect/LLHD/IR/time.mlir
  CIRCT :: Dialect/LLHD/IR/tuple.mlir
  CIRCT :: Dialect/LLHD/IR/wait.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_arbitrary_signal_size.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_array_boundary_check.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_bit_precision_drives.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_process.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_reg.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_shifts.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_simple.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_wait.mlir
  CIRCT :: Dialect/LLHD/Transforms/earlyCodeMotion.mlir
  CIRCT :: Dialect/LLHD/Transforms/memoryToBlockArgument.mlir
  CIRCT :: Dialect/LLHD/Transforms/processLowering.mlir
  CIRCT :: Dialect/LLHD/Transforms/processLoweringErrors.mlir
  CIRCT :: Dialect/LLHD/Transforms/totalFunctionInlining.mlir
  CIRCT :: Dialect/MSFT/location.mlir
  CIRCT :: Dialect/MSFT/opt-errors.mlir
  CIRCT :: Dialect/MSFT/translate-errors.mlir
  CIRCT :: Dialect/SV/basic.mlir
  CIRCT :: Dialect/SV/canonicalization.mlir
  CIRCT :: Dialect/SV/errors.mlir
  CIRCT :: Dialect/SV/hw-cleanup.mlir
  CIRCT :: Dialect/SV/hw-generator-callout.mlir
  CIRCT :: Dialect/SV/hw-legalize-names-errors.mlir
  CIRCT :: Dialect/SV/hw-legalize-names.mlir
  CIRCT :: Dialect/SV/hw-memsim.mlir
  CIRCT :: Dialect/SV/interfaces.mlir
  CIRCT :: Dialect/SV/prettify-verilog.mlir
  CIRCT :: Dialect/Seq/basic.mlir
  CIRCT :: ExportVerilog/hw-dialect.mlir
  CIRCT :: ExportVerilog/hw-typedecls.mlir
  CIRCT :: ExportVerilog/line-length.mlir
  CIRCT :: ExportVerilog/load-dialect.mlir
  CIRCT :: ExportVerilog/sv-alwaysff.mlir
  CIRCT :: ExportVerilog/sv-dialect.mlir
  CIRCT :: ExportVerilog/sv-interfaces.mlir
  CIRCT :: ExportVerilog/verilog-basic.mlir
  CIRCT :: ExportVerilog/verilog-errors.mlir
  CIRCT :: circt-opt/trivial.mlir
  CIRCT :: circt-translate/parse_int64.fir
  CIRCT :: firtool/firtool.fir
  CIRCT :: firtool/firtool.mlir
  CIRCT :: firtool/optimizations.fir
  CIRCT :: firtool/phase-ordering.fir
  CIRCT :: firtool/split-verilog.mlir
  CIRCT :: firtool/style.fir
  CIRCT :: handshake-runner/call_bb.mlir
  CIRCT :: handshake-runner/cdiv-old-std.mlir
  CIRCT :: handshake-runner/cdiv-std.mlir
  CIRCT :: handshake-runner/complex_bb.mlir
  CIRCT :: handshake-runner/floydwarshall-std.mlir
  CIRCT :: handshake-runner/histogram-std.mlir
  CIRCT :: handshake-runner/loadstore.mlir
  CIRCT :: handshake-runner/loop-check-1-std.mlir
  CIRCT :: handshake-runner/loop-check-2-std.mlir
  CIRCT :: handshake-runner/matmul-check-std.mlir
  CIRCT :: handshake-runner/matmul-std.mlir
  CIRCT :: handshake-runner/memory_simple_2_std.mlir
  CIRCT :: handshake-runner/memory_simple_std.mlir
  CIRCT :: handshake-runner/simple_loop.mlir


Testing Time: 1.34s
  Unsupported:   4
  Passed     :   6
  Failed     : 210
```","Failed Tests (210):
  CIRCT :: CAPI/ir.c
  CIRCT :: Conversion/FIRRTLToHW/errors.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-errors.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-module.mlir
  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw.mlir
  CIRCT :: Conversion/FIRRTLToHW/zero-width.mlir
  CIRCT :: Conversion/FIRRTLToLLHD/connect.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_inouts.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_ins.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_none.fir
  CIRCT :: Conversion/FIRRTLToLLHD/empty_outs.fir
  CIRCT :: Conversion/HWToLLHD/errors.mlir
  CIRCT :: Conversion/HWToLLHD/structure.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/simple_addi.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_branch.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_buffer.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_cmerge.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_conditional_branch.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_constant.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_fork.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_join.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_lazy_fork.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_load.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_memory.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_merge.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_mux.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_sink.mlir
  CIRCT :: Conversion/HandshakeToFIRRTL/test_store.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_arithmetic.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_bitwise.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_entity.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_extract.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_insert.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_memory.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_process_persistence.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_signals.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_simple.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_value_creation.mlir
  CIRCT :: Conversion/LLHDToLLVM/convert_wait.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/errors.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-for.mlir
  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-load-store.mlir
  CIRCT :: Conversion/StandardToHandshake/test1.mlir
  CIRCT :: Conversion/StandardToHandshake/test10.mlir
  CIRCT :: Conversion/StandardToHandshake/test11.mlir
  CIRCT :: Conversion/StandardToHandshake/test12.mlir
  CIRCT :: Conversion/StandardToHandshake/test13.mlir
  CIRCT :: Conversion/StandardToHandshake/test14.mlir
  CIRCT :: Conversion/StandardToHandshake/test15.mlir
  CIRCT :: Conversion/StandardToHandshake/test16.mlir
  CIRCT :: Conversion/StandardToHandshake/test17.mlir
  CIRCT :: Conversion/StandardToHandshake/test18.mlir
  CIRCT :: Conversion/StandardToHandshake/test19.mlir
  CIRCT :: Conversion/StandardToHandshake/test2.mlir
  CIRCT :: Conversion/StandardToHandshake/test20.mlir
  CIRCT :: Conversion/StandardToHandshake/test21.mlir
  CIRCT :: Conversion/StandardToHandshake/test22.mlir
  CIRCT :: Conversion/StandardToHandshake/test23.mlir
  CIRCT :: Conversion/StandardToHandshake/test24.mlir
  CIRCT :: Conversion/StandardToHandshake/test25.mlir
  CIRCT :: Conversion/StandardToHandshake/test26.mlir
  CIRCT :: Conversion/StandardToHandshake/test27.mlir
  CIRCT :: Conversion/StandardToHandshake/test28.mlir
  CIRCT :: Conversion/StandardToHandshake/test29.mlir
  CIRCT :: Conversion/StandardToHandshake/test3.mlir
  CIRCT :: Conversion/StandardToHandshake/test30.mlir
  CIRCT :: Conversion/StandardToHandshake/test31.mlir
  CIRCT :: Conversion/StandardToHandshake/test32.mlir
  CIRCT :: Conversion/StandardToHandshake/test33.mlir
  CIRCT :: Conversion/StandardToHandshake/test34.mlir
  CIRCT :: Conversion/StandardToHandshake/test35.mlir
  CIRCT :: Conversion/StandardToHandshake/test4.mlir
  CIRCT :: Conversion/StandardToHandshake/test5.mlir
  CIRCT :: Conversion/StandardToHandshake/test6.mlir
  CIRCT :: Conversion/StandardToHandshake/test7.mlir
  CIRCT :: Conversion/StandardToHandshake/test8.mlir
  CIRCT :: Conversion/StandardToHandshake/test9.mlir
  CIRCT :: Conversion/StandardToHandshake/test_canonicalize.mlir
  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer.mlir
  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer_errors.mlir
  CIRCT :: Conversion/StandardToStaticLogic/test_pipeline.mlir
  CIRCT :: Dialect/ESI/connectivity.mlir
  CIRCT :: Dialect/ESI/errors.mlir
  CIRCT :: Dialect/ESI/lowering.mlir
  CIRCT :: Dialect/ESI/modwrap.mlir
  CIRCT :: Dialect/ESI/wrapif-lowering.mlir
  CIRCT :: Dialect/FIRRTL/annotations.fir
  CIRCT :: Dialect/FIRRTL/blackbox-memory.mlir
  CIRCT :: Dialect/FIRRTL/canonicalization.mlir
  CIRCT :: Dialect/FIRRTL/check-widths-errors.mlir
  CIRCT :: Dialect/FIRRTL/connect-errors.mlir
  CIRCT :: Dialect/FIRRTL/connect.mlir
  CIRCT :: Dialect/FIRRTL/const-prop-single-module.mlir
  CIRCT :: Dialect/FIRRTL/cse.mlir
  CIRCT :: Dialect/FIRRTL/errors.mlir
  CIRCT :: Dialect/FIRRTL/expand-whens-errors.mlir
  CIRCT :: Dialect/FIRRTL/expand-whens.mlir
  CIRCT :: Dialect/FIRRTL/imconstprop.mlir
  CIRCT :: Dialect/FIRRTL/infer-widths-errors.mlir
  CIRCT :: Dialect/FIRRTL/infer-widths.mlir
  CIRCT :: Dialect/FIRRTL/inliner.mlir
  CIRCT :: Dialect/FIRRTL/lower-types-errors.mlir
  CIRCT :: Dialect/FIRRTL/lower-types.mlir
  CIRCT :: Dialect/FIRRTL/parse-basic.fir
  CIRCT :: Dialect/FIRRTL/parse-errors.fir
  CIRCT :: Dialect/FIRRTL/parse-locations.fir
  CIRCT :: Dialect/FIRRTL/test.mlir
  CIRCT :: Dialect/HW/basic.mlir
  CIRCT :: Dialect/HW/bitwise.mlir
  CIRCT :: Dialect/HW/canonicalization.mlir
  CIRCT :: Dialect/HW/errors.mlir
  CIRCT :: Dialect/HW/greybox.mlir
  CIRCT :: Dialect/HW/modules.mlir
  CIRCT :: Dialect/HW/svEmitErrors.mlir
  CIRCT :: Dialect/HW/typedecls.mlir
  CIRCT :: Dialect/HW/types.mlir
  CIRCT :: Dialect/Handshake/errors.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/arithmetic.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/bitwise.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/constant.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/extract.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/memory.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/probeCSE.mlir
  CIRCT :: Dialect/LLHD/Canonicalization/signalOps.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_arithmetic.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_bitwise.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_entity.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_relations.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_sig.mlir
  CIRCT :: Dialect/LLHD/Export/verilog_sig_errors.mlir
  CIRCT :: Dialect/LLHD/IR/arithmetic.mlir
  CIRCT :: Dialect/LLHD/IR/array.mlir
  CIRCT :: Dialect/LLHD/IR/bitwise.mlir
  CIRCT :: Dialect/LLHD/IR/connect-errors.mlir
  CIRCT :: Dialect/LLHD/IR/connect.mlir
  CIRCT :: Dialect/LLHD/IR/const.mlir
  CIRCT :: Dialect/LLHD/IR/entity.mlir
  CIRCT :: Dialect/LLHD/IR/extract-errors.mlir
  CIRCT :: Dialect/LLHD/IR/extract.mlir
  CIRCT :: Dialect/LLHD/IR/insert-errors.mlir
  CIRCT :: Dialect/LLHD/IR/insert.mlir
  CIRCT :: Dialect/LLHD/IR/inst-errors.mlir
  CIRCT :: Dialect/LLHD/IR/inst.mlir
  CIRCT :: Dialect/LLHD/IR/memory.mlir
  CIRCT :: Dialect/LLHD/IR/proc.mlir
  CIRCT :: Dialect/LLHD/IR/reg.mlir
  CIRCT :: Dialect/LLHD/IR/signal-errors.mlir
  CIRCT :: Dialect/LLHD/IR/signal.mlir
  CIRCT :: Dialect/LLHD/IR/time.mlir
  CIRCT :: Dialect/LLHD/IR/tuple.mlir
  CIRCT :: Dialect/LLHD/IR/wait.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_arbitrary_signal_size.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_array_boundary_check.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_bit_precision_drives.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_process.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_reg.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_shifts.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_simple.mlir
  CIRCT :: Dialect/LLHD/Simulator/sim_wait.mlir
  CIRCT :: Dialect/LLHD/Transforms/earlyCodeMotion.mlir
  CIRCT :: Dialect/LLHD/Transforms/memoryToBlockArgument.mlir
  CIRCT :: Dialect/LLHD/Transforms/processLowering.mlir
  CIRCT :: Dialect/LLHD/Transforms/processLoweringErrors.mlir
  CIRCT :: Dialect/LLHD/Transforms/totalFunctionInlining.mlir
  CIRCT :: Dialect/MSFT/location.mlir
  CIRCT :: Dialect/MSFT/opt-errors.mlir
  CIRCT :: Dialect/MSFT/translate-errors.mlir
  CIRCT :: Dialect/SV/basic.mlir
  CIRCT :: Dialect/SV/canonicalization.mlir
  CIRCT :: Dialect/SV/errors.mlir
  CIRCT :: Dialect/SV/hw-cleanup.mlir
  CIRCT :: Dialect/SV/hw-generator-callout.mlir
  CIRCT :: Dialect/SV/hw-legalize-names-errors.mlir
  CIRCT :: Dialect/SV/hw-legalize-names.mlir
  CIRCT :: Dialect/SV/hw-memsim.mlir
  CIRCT :: Dialect/SV/interfaces.mlir
  CIRCT :: Dialect/SV/prettify-verilog.mlir
  CIRCT :: Dialect/Seq/basic.mlir
  CIRCT :: ExportVerilog/hw-dialect.mlir
  CIRCT :: ExportVerilog/hw-typedecls.mlir
  CIRCT :: ExportVerilog/line-length.mlir
  CIRCT :: ExportVerilog/load-dialect.mlir
  CIRCT :: ExportVerilog/sv-alwaysff.mlir
  CIRCT :: ExportVerilog/sv-dialect.mlir
  CIRCT :: ExportVerilog/sv-interfaces.mlir
  CIRCT :: ExportVerilog/verilog-basic.mlir
  CIRCT :: ExportVerilog/verilog-errors.mlir
  CIRCT :: circt-opt/trivial.mlir
  CIRCT :: circt-translate/parse_int64.fir
  CIRCT :: firtool/firtool.fir
  CIRCT :: firtool/firtool.mlir
  CIRCT :: firtool/optimizations.fir
  CIRCT :: firtool/phase-ordering.fir
  CIRCT :: firtool/split-verilog.mlir
  CIRCT :: firtool/style.fir
  CIRCT :: handshake-runner/call_bb.mlir
  CIRCT :: handshake-runner/cdiv-old-std.mlir
  CIRCT :: handshake-runner/cdiv-std.mlir
  CIRCT :: handshake-runner/complex_bb.mlir
  CIRCT :: handshake-runner/floydwarshall-std.mlir
  CIRCT :: handshake-runner/histogram-std.mlir
  CIRCT :: handshake-runner/loadstore.mlir
  CIRCT :: handshake-runner/loop-check-1-std.mlir
  CIRCT :: handshake-runner/loop-check-2-std.mlir
  CIRCT :: handshake-runner/matmul-check-std.mlir
  CIRCT :: handshake-runner/matmul-std.mlir
  CIRCT :: handshake-runner/memory_simple_2_std.mlir
  CIRCT :: handshake-runner/memory_simple_std.mlir
  CIRCT :: handshake-runner/simple_loop.mlir


Testing Time: 1.34s
  Unsupported:   4
  Passed     :   6
  Failed     : 210",,,,,,,,,
1047,Tools in CI crash across the board,2021-05-13T14:08:10Z,closed,bug,Added two minimal changes (9746cd7 and 8156388) which now cause CI to produce tools and tests that all crash in weird locations: https://github.com/llvm/circt/runs/2575814179. Seems unrelated to the change. PR with the changes reverted to check if they somehow caused the problem: #1046.,,,,,,,,,,
1034,Segfault in test/Dialect/RTL/errors.mlir,2021-05-09T04:29:22Z,closed,bug,"test/Dialect/RTL/errors.mlir segfaults in getModuleResultNameAttr for the test of incorrect return result count.  The generic op printer when called from emitError uses getAsmResultNames gets the names of the returns on the referenced module based on the number of results on the instance, which is exactly what the test case is looking for.

I haven't looked into why a segfault passes lit.",,,,,,,,,,
1031,[circt-rtl-sim] Run each simulation in its own directory,2021-05-07T23:19:42Z,closed,bug,"Some simulators don't like being run in parallel in the same directory. Also, reset the handshake tests to include all IEEE simulators.",,,,,,,,,,
1023,[CAPI] Guard esi::exportCosimSchema by CAPNP ifdef,2021-05-07T06:11:03Z,closed,"bug, ESI","C API fails to link on builds that have CAPNP disabled, since some of the symbols in the C++ API get dropped. Make the corresponding uses in the C API conditional on the presence of the same ifdef, so things link again.",,,,,,,,,,
1001,LowerTypes Parallelism Bug?,2021-05-04T00:11:09Z,closed,"bug, FIRRTL","I'm seeing issues on `main` where FIRRT's LowerTypes transform is trying to erase block args which still have uses. This only happens with multithreading on.

You should be able to reproduce with the following `Foo.mlir`:

```mlir
module  {
  firrtl.circuit ""Foo""  {
    firrtl.module @Bar(%a: !firrtl.bundle<a: uint<1>>, %b: !firrtl.flip<bundle<a: uint<1>>>) {
      firrtl.connect %b, %a : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>
    }
    firrtl.module @Foo(%a: !firrtl.bundle<a: uint<1>>, %b: !firrtl.flip<bundle<a: uint<1>>>) {
      %bar_a, %bar_b = firrtl.instance @Bar  {name = ""bar""} : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>
      firrtl.connect %bar_a, %a : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>
      firrtl.connect %b, %bar_b : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>
    }
  }
}
```

Then put this in a while loop:

```bash
while circt-opt -pass-pipeline='firrtl.circuit(firrtl-lower-types)' Foo.mlir; do echo ""works""; done
```

This should eventually crash.

Alternatively, running without parallelism on shouldn't produce a crash:

```bash
while circt-opt -mlir-disable-threading -pass-pipeline='firrtl.circuit(firrtl-lower-types)' Foo.mlir; do echo ""works""; done
```

An example error log is below:

<details>
 <summary>Full log</summary>

```text
Assertion failed: (use_empty() && ""Cannot destroy a value that still has uses!""), function ~IRObjectWithUseList, file /Users/schuylere/repos/github.com/llvm/circt/llvm/mlir/include/mlir/IR/UseDefLists.h, line 37.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.	Program arguments: circt-opt -pass-pipeline=firrtl.circuit(firrtl-lower-types) Foo.mlir
1.	2.	Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  circt-opt                0x000000010fc8897d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  circt-opt                0x000000010fc88f2b PrintStackTraceSignalHandler(void*) + 27
2  circt-opt                0x000000010fc86c8b llvm::sys::RunSignalHandlers() + 123
3  circt-opt                0x000000010fc8b598 SignalHandler(int) + 232
4  libsystem_platform.dylib 0x00007fff20384d7d _sigtramp + 29
5  circt-opt                0x00000001111e9f80 _dyld_private + 0
6  libsystem_c.dylib        0x00007fff20294411 abort + 120
7  libsystem_c.dylib        0x00007fff202937e8 err + 0
8  circt-opt                0x00000001102778c2 mlir::IRObjectWithUseList<mlir::OpOperand>::~IRObjectWithUseList() + 98
9  circt-opt                0x0000000110277858 mlir::detail::ValueImpl::~ValueImpl() + 24
10 circt-opt                0x0000000110277838 mlir::detail::BlockArgumentImpl::~BlockArgumentImpl() + 24
11 circt-opt                0x0000000110277815 mlir::detail::BlockArgumentImpl::~BlockArgumentImpl() + 21
12 circt-opt                0x0000000110274f4c mlir::BlockArgument::destroy() + 44
13 circt-opt                0x000000011027670d mlir::Block::eraseArguments(llvm::function_ref<bool (mlir::BlockArgument)>) + 173
14 circt-opt                0x0000000110276658 mlir::Block::eraseArguments(llvm::BitVector const&) + 72
15 circt-opt                0x00000001102765d3 mlir::Block::eraseArguments(llvm::ArrayRef<unsigned int>) + 179
16 circt-opt                0x000000010fcc4fed (anonymous namespace)::TypeLoweringVisitor::visitDecl(circt::firrtl::FModuleOp) + 1549
17 circt-opt                0x000000010fcc4233 (anonymous namespace)::TypeLoweringVisitor::lowerModule(mlir::Operation*) + 83
18 circt-opt                0x000000010fcc27f3 auto (anonymous namespace)::LowerTypesPass::runAsync()::$_8::operator()<unsigned long>(unsigned long) const + 147
19 circt-opt                0x000000010fcc270f void llvm::parallel::detail::parallel_for_each_n<unsigned long, (anonymous namespace)::LowerTypesPass::runAsync()::$_8>(unsigned long, unsigned long, (anonymous namespace)::LowerTypesPass::runAsync()::$_8) + 415
20 circt-opt                0x000000010fcc135d void llvm::parallelForEachN<(anonymous namespace)::LowerTypesPass::runAsync()::$_8>(unsigned long, unsigned long, (anonymous namespace)::LowerTypesPass::runAsync()::$_8) + 109
21 circt-opt                0x000000010fcc111f (anonymous namespace)::LowerTypesPass::runAsync() + 191
22 circt-opt                0x000000010fcc02dd (anonymous namespace)::LowerTypesPass::runOnOperation() + 61
23 circt-opt                0x0000000110afaadb mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 587
24 circt-opt                0x0000000110afb137 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359
25 circt-opt                0x0000000110b0fa3f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const + 559
26 circt-opt                0x0000000110b0f558 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 152
27 circt-opt                0x0000000110afc984 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 180
28 circt-opt                0x0000000110afbf6f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 1279
29 circt-opt                0x0000000110afad8d mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) + 77
30 circt-opt                0x0000000110afaac6 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 566
31 circt-opt                0x0000000110afb137 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359
32 circt-opt                0x0000000110afda69 mlir::PassManager::run(mlir::Operation*) + 985
33 circt-opt                0x00000001103fccf8 performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, mlir::PassPipelineCLParser const&) + 520
34 circt-opt                0x00000001103fb36b processBuffer(llvm::raw_ostream&, std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&) + 331
35 circt-opt                0x00000001103fb166 mlir::MlirOptMain(llvm::raw_ostream&, std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool) + 358
36 circt-opt                0x00000001103fc0fe mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) + 3310
37 circt-opt                0x000000010fab5b5f main + 159
38 libdyld.dylib            0x00007fff2035af3d start + 1
39 libdyld.dylib            0x0000000000000003 start + 18446603339975774407
```

</details>","module  {
  firrtl.circuit ""Foo""  {
    firrtl.module @Bar(%a: !firrtl.bundle<a: uint<1>>, %b: !firrtl.flip<bundle<a: uint<1>>>) {
      firrtl.connect %b, %a : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>
    }
    firrtl.module @Foo(%a: !firrtl.bundle<a: uint<1>>, %b: !firrtl.flip<bundle<a: uint<1>>>) {
      %bar_a, %bar_b = firrtl.instance @Bar  {name = ""bar""} : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>
      firrtl.connect %bar_a, %a : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>
      firrtl.connect %b, %bar_b : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>
    }
  }
}","while circt-opt -pass-pipeline='firrtl.circuit(firrtl-lower-types)' Foo.mlir; do echo ""works""; done","while circt-opt -mlir-disable-threading -pass-pipeline='firrtl.circuit(firrtl-lower-types)' Foo.mlir; do echo ""works""; done","Assertion failed: (use_empty() && ""Cannot destroy a value that still has uses!""), function ~IRObjectWithUseList, file /Users/schuylere/repos/github.com/llvm/circt/llvm/mlir/include/mlir/IR/UseDefLists.h, line 37.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.	Program arguments: circt-opt -pass-pipeline=firrtl.circuit(firrtl-lower-types) Foo.mlir
1.	2.	Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  circt-opt                0x000000010fc8897d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  circt-opt                0x000000010fc88f2b PrintStackTraceSignalHandler(void*) + 27
2  circt-opt                0x000000010fc86c8b llvm::sys::RunSignalHandlers() + 123
3  circt-opt                0x000000010fc8b598 SignalHandler(int) + 232
4  libsystem_platform.dylib 0x00007fff20384d7d _sigtramp + 29
5  circt-opt                0x00000001111e9f80 _dyld_private + 0
6  libsystem_c.dylib        0x00007fff20294411 abort + 120
7  libsystem_c.dylib        0x00007fff202937e8 err + 0
8  circt-opt                0x00000001102778c2 mlir::IRObjectWithUseList<mlir::OpOperand>::~IRObjectWithUseList() + 98
9  circt-opt                0x0000000110277858 mlir::detail::ValueImpl::~ValueImpl() + 24
10 circt-opt                0x0000000110277838 mlir::detail::BlockArgumentImpl::~BlockArgumentImpl() + 24
11 circt-opt                0x0000000110277815 mlir::detail::BlockArgumentImpl::~BlockArgumentImpl() + 21
12 circt-opt                0x0000000110274f4c mlir::BlockArgument::destroy() + 44
13 circt-opt                0x000000011027670d mlir::Block::eraseArguments(llvm::function_ref<bool (mlir::BlockArgument)>) + 173
14 circt-opt                0x0000000110276658 mlir::Block::eraseArguments(llvm::BitVector const&) + 72
15 circt-opt                0x00000001102765d3 mlir::Block::eraseArguments(llvm::ArrayRef<unsigned int>) + 179
16 circt-opt                0x000000010fcc4fed (anonymous namespace)::TypeLoweringVisitor::visitDecl(circt::firrtl::FModuleOp) + 1549
17 circt-opt                0x000000010fcc4233 (anonymous namespace)::TypeLoweringVisitor::lowerModule(mlir::Operation*) + 83
18 circt-opt                0x000000010fcc27f3 auto (anonymous namespace)::LowerTypesPass::runAsync()::$_8::operator()<unsigned long>(unsigned long) const + 147
19 circt-opt                0x000000010fcc270f void llvm::parallel::detail::parallel_for_each_n<unsigned long, (anonymous namespace)::LowerTypesPass::runAsync()::$_8>(unsigned long, unsigned long, (anonymous namespace)::LowerTypesPass::runAsync()::$_8) + 415
20 circt-opt                0x000000010fcc135d void llvm::parallelForEachN<(anonymous namespace)::LowerTypesPass::runAsync()::$_8>(unsigned long, unsigned long, (anonymous namespace)::LowerTypesPass::runAsync()::$_8) + 109
21 circt-opt                0x000000010fcc111f (anonymous namespace)::LowerTypesPass::runAsync() + 191
22 circt-opt                0x000000010fcc02dd (anonymous namespace)::LowerTypesPass::runOnOperation() + 61
23 circt-opt                0x0000000110afaadb mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 587
24 circt-opt                0x0000000110afb137 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359
25 circt-opt                0x0000000110b0fa3f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const + 559
26 circt-opt                0x0000000110b0f558 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 152
27 circt-opt                0x0000000110afc984 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 180
28 circt-opt                0x0000000110afbf6f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 1279
29 circt-opt                0x0000000110afad8d mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) + 77
30 circt-opt                0x0000000110afaac6 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 566
31 circt-opt                0x0000000110afb137 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359
32 circt-opt                0x0000000110afda69 mlir::PassManager::run(mlir::Operation*) + 985
33 circt-opt                0x00000001103fccf8 performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, mlir::PassPipelineCLParser const&) + 520
34 circt-opt                0x00000001103fb36b processBuffer(llvm::raw_ostream&, std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&) + 331
35 circt-opt                0x00000001103fb166 mlir::MlirOptMain(llvm::raw_ostream&, std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool) + 358
36 circt-opt                0x00000001103fc0fe mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) + 3310
37 circt-opt                0x000000010fab5b5f main + 159
38 libdyld.dylib            0x00007fff2035af3d start + 1
39 libdyld.dylib            0x0000000000000003 start + 18446603339975774407",,,,,,
998,Non-deterministic failures in lower-types.mlir tests,2021-05-03T22:00:33Z,closed,"bug, FIRRTL","After https://github.com/llvm/circt/pull/997, I seem to be finding some non-deterministic test failures related to LowerTypes.

One issue is related to an index out of bounds error (attributes.txt). I tried adding a bounds check, but that exposed what appears to be the real issue: a firrtl.invalidvalue is being erased which still has uses. I tracked it down to this test: https://github.com/llvm/circt/blob/03de9739896ec4d2ad6df60948cce24185a67dd0/test/Dialect/FIRRTL/lower-types.mlir#L370.

Another issue, which pops up occasionally when the above is commented out, has to do with attempting to drop_front on a string that doesn't have the required number of characters (drop_front.txt). I haven't tracked this down yet, but it is related to the InstanceOp lowering in LowerTypes.

It's strange to me this doesn't get caught in CI, but I guess my workstation has enough parallelism to reveal it, while our build machines don't. I'm also not sure yet if this is a personal problem or others will face it. Is it worth reverting the LLVM version bump for now, since it seems related to parallelism?

[attributes.txt](https://github.com/llvm/circt/files/6417990/attributes.txt)
[drop_front.txt](https://github.com/llvm/circt/files/6417992/drop_front.txt)",,,,,,,,,,
976,"[FIRRTL] reg ""sink not fully initialized"" (false negative)",2021-04-29T01:09:40Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    reg tmp42: UInt<10>, clock with: (reset => (reset, UInt<10>(0)))
```

Compiled with `firtool --lower-to-rtl --lower-types` generates this error:

```
a_top_mod.fir:6:5: error: sink not fully initialized.
    reg tmp42: UInt<10>, clock with: (reset => (reset, UInt<10>(0)))
    ^
a_top_mod.fir:6:5: note: see current operation: %tmp42 = ""firrtl.regreset""(%clock, %reset, %c0_ui10) {annotations = [], name = ""tmp42""} : (!firrtl.clock, !firrtl.uint<1>, !firrtl.uint<10>) -> !firrtl.uint<10>
```

Compiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:

```verilog
module top_mod(
  input   clock,
  input   reset
);
endmodule
```
","circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    reg tmp42: UInt<10>, clock with: (reset => (reset, UInt<10>(0)))","a_top_mod.fir:6:5: error: sink not fully initialized.
    reg tmp42: UInt<10>, clock with: (reset => (reset, UInt<10>(0)))
    ^
a_top_mod.fir:6:5: note: see current operation: %tmp42 = ""firrtl.regreset""(%clock, %reset, %c0_ui10) {annotations = [], name = ""tmp42""} : (!firrtl.clock, !firrtl.uint<1>, !firrtl.uint<10>) -> !firrtl.uint<10>","module top_mod(
  input   clock,
  input   reset
);
endmodule",,,,,,,
955,65 bit constant gets changed,2021-04-24T02:36:35Z,closed,bug,"LowerToRTL negates this unsigned constant (ui65 : 0x10000000000000000) leading to canonicalize thinking it is zero.

```module  {
  firrtl.circuit ""foo""  {
    firrtl.module @foo(%io_in_valid: !firrtl.uint<1>, %foo: !firrtl.flip<uint<65>>) {
      %c18446744073709551616_ui65 = firrtl.constant(18446744073709551616 : ui65) : !firrtl.uint<65>
      %c0_ui65 = firrtl.constant(0 : ui65) : !firrtl.uint<65>
      %0 = firrtl.mux(%io_in_valid, %c18446744073709551616_ui65, %c0_ui65) : (!firrtl.uint<1>, !firrtl.uint<65>, !firrtl.uint<65>) -> !firrtl.uint<65>
      firrtl.connect %foo, %0 : !firrtl.flip<uint<65>>, !firrtl.uint<65>
    }
  }
}
```","module  {
  firrtl.circuit ""foo""  {
    firrtl.module @foo(%io_in_valid: !firrtl.uint<1>, %foo: !firrtl.flip<uint<65>>) {
      %c18446744073709551616_ui65 = firrtl.constant(18446744073709551616 : ui65) : !firrtl.uint<65>
      %c0_ui65 = firrtl.constant(0 : ui65) : !firrtl.uint<65>
      %0 = firrtl.mux(%io_in_valid, %c18446744073709551616_ui65, %c0_ui65) : (!firrtl.uint<1>, !firrtl.uint<65>, !firrtl.uint<65>) -> !firrtl.uint<65>
      firrtl.connect %foo, %0 : !firrtl.flip<uint<65>>, !firrtl.uint<65>
    }
  }
}",,,,,,,,,
952,[FIRRTL] Fix use-after-free in connect canonicalization,2021-04-22T22:18:12Z,closed,"bug, FIRRTL",Fixes #951,,,,,,,,,,
947,[firtool] crash in parser when modify the file from another process,2021-04-22T16:54:19Z,closed,"bug, FIRRTL","I am getting random crashes like this:

This might be related to FIR file abruptly cut at  random point.

```
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --lower-types --lowering-options=noAlwaysFF --pass-timing --verilog -o=a_top_mod_new.v
 #0 0x000000000043d2dd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x43d2dd)
 #1 0x000000000043b134 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x43b134)
 #2 0x000000000043b293 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x43b293)
 #3 0x00007faf0eb14a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #4 0x000000000042254e llvm::StringRef::find_last_of(llvm::StringRef, unsigned long) const (../../llvm/circt/build/bin/firtool+0x42254e)
 #5 0x0000000000420a6d llvm::SourceMgr::getLineAndColumn(llvm::SMLoc, unsigned int) const (../../llvm/circt/build/bin/firtool+0x420a6d)
 #6 0x000000000047eff4 circt::firrtl::FIRLexer::translateLocation(llvm::SMLoc) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRLexer.cpp:119:66
 #7 0x000000000046b7b2 (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRTokenKinds.def:165:1
 #8 0x00000000004700fb (anonymous namespace)::FIRStmtParser::parseExpImpl(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&, bool) (.constprop.0) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1161:5
 #9 0x0000000000471c7b (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1373:9
#10 0x0000000000471d5c std::_Function_handler<mlir::ParseResult (), (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()>::_M_invoke(std::_Any_data const&) /usr/include/c++/10/bits/std_function.h:293:7
#11 0x0000000000461225 (anonymous namespace)::FIRParser::parseListUntil(circt::firrtl::FIRToken::Kind, std::function<mlir::ParseResult ()> const&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:313:5
#12 0x0000000000468fb8 (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1383:8
#13 0x00000000004700fb (anonymous namespace)::FIRStmtParser::parseExpImpl(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&, bool) (.constprop.0) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1161:5
#14 0x0000000000471c7b (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1373:9
#15 0x0000000000471d5c std::_Function_handler<mlir::ParseResult (), (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()>::_M_invoke(std::_Any_data const&) /usr/include/c++/10/bits/std_function.h:293:7
#16 0x0000000000461225 (anonymous namespace)::FIRParser::parseListUntil(circt::firrtl::FIRToken::Kind, std::function<mlir::ParseResult ()> const&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:313:5
#17 0x0000000000468fb8 (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1383:8
#18 0x00000000004700fb (anonymous namespace)::FIRStmtParser::parseExpImpl(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&, bool) (.constprop.0) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1161:5
#19 0x0000000000470d9b (anonymous namespace)::FIRStmtParser::parseLeadingExpStmt(mlir::Value, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2099:62
#20 0x0000000000477d15 llvm::SmallVectorTemplateCommon<mlir::Operation*, void>::begin() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:253:45
#21 0x0000000000477d15 llvm::SmallVectorTemplateCommon<mlir::Operation*, void>::end() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:255:32
#22 0x0000000000477d15 llvm::SmallVector<mlir::Operation*, 8u>::~SmallVector() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:1175:24
#23 0x0000000000477d15 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1680:33
#24 0x000000000047aa04 (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1630:5
#25 0x000000000047cc03 llvm::DenseMap<std::pair<mlir::Attribute, mlir::Type>, mlir::Value, llvm::DenseMapInfo<std::pair<mlir::Attribute, mlir::Type> >, llvm::detail::DenseMapPair<std::pair<mlir::Attribute, mlir::Type>, mlir::Value> >::~DenseMap() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/DenseMap.h:755:50
#26 0x000000000047cc03 ~FIRModuleContext /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1023:8
#27 0x000000000047cc03 parseModule /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2823:20
#28 0x000000000047cc03 parseCircuit /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2927:75
#29 0x000000000047cc03 circt::firrtl::importFIRRTL(llvm::SourceMgr&, mlir::MLIRContext*, circt::firrtl::FIRParserOptions) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2957:53
#30 0x000000000040c620 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:162:5
#31 0x000000000040866f processBufferIntoSingleStream /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:253:8
#32 0x000000000040866f main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:323:15
#33 0x00007faf0e582b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#34 0x0000000000409fbe _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 15: 14926 Bus error               (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --lower-types --lowering-options=noAlwaysFF --pass-timing --verilog -o=$VFILE2
[2]+  Done                    ./bin/cli.js -n -I 200 -O 10000 --verif false --ordered true fir -o a_top_mod.fir
drom@linux-sydi:~/work/github/drom/circt-fuzzer> ./bin/cli.js -s 528570 -n -I 200 -O 10000 --verif false --ordered true fir -o a_top_mod.fir & ./process1.sh 
```","PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --lower-types --lowering-options=noAlwaysFF --pass-timing --verilog -o=a_top_mod_new.v
 #0 0x000000000043d2dd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x43d2dd)
 #1 0x000000000043b134 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x43b134)
 #2 0x000000000043b293 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x43b293)
 #3 0x00007faf0eb14a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #4 0x000000000042254e llvm::StringRef::find_last_of(llvm::StringRef, unsigned long) const (../../llvm/circt/build/bin/firtool+0x42254e)
 #5 0x0000000000420a6d llvm::SourceMgr::getLineAndColumn(llvm::SMLoc, unsigned int) const (../../llvm/circt/build/bin/firtool+0x420a6d)
 #6 0x000000000047eff4 circt::firrtl::FIRLexer::translateLocation(llvm::SMLoc) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRLexer.cpp:119:66
 #7 0x000000000046b7b2 (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRTokenKinds.def:165:1
 #8 0x00000000004700fb (anonymous namespace)::FIRStmtParser::parseExpImpl(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&, bool) (.constprop.0) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1161:5
 #9 0x0000000000471c7b (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1373:9
#10 0x0000000000471d5c std::_Function_handler<mlir::ParseResult (), (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()>::_M_invoke(std::_Any_data const&) /usr/include/c++/10/bits/std_function.h:293:7
#11 0x0000000000461225 (anonymous namespace)::FIRParser::parseListUntil(circt::firrtl::FIRToken::Kind, std::function<mlir::ParseResult ()> const&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:313:5
#12 0x0000000000468fb8 (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1383:8
#13 0x00000000004700fb (anonymous namespace)::FIRStmtParser::parseExpImpl(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&, bool) (.constprop.0) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1161:5
#14 0x0000000000471c7b (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1373:9
#15 0x0000000000471d5c std::_Function_handler<mlir::ParseResult (), (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()>::_M_invoke(std::_Any_data const&) /usr/include/c++/10/bits/std_function.h:293:7
#16 0x0000000000461225 (anonymous namespace)::FIRParser::parseListUntil(circt::firrtl::FIRToken::Kind, std::function<mlir::ParseResult ()> const&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:313:5
#17 0x0000000000468fb8 (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1383:8
#18 0x00000000004700fb (anonymous namespace)::FIRStmtParser::parseExpImpl(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&, bool) (.constprop.0) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1161:5
#19 0x0000000000470d9b (anonymous namespace)::FIRStmtParser::parseLeadingExpStmt(mlir::Value, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2099:62
#20 0x0000000000477d15 llvm::SmallVectorTemplateCommon<mlir::Operation*, void>::begin() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:253:45
#21 0x0000000000477d15 llvm::SmallVectorTemplateCommon<mlir::Operation*, void>::end() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:255:32
#22 0x0000000000477d15 llvm::SmallVector<mlir::Operation*, 8u>::~SmallVector() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:1175:24
#23 0x0000000000477d15 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1680:33
#24 0x000000000047aa04 (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1630:5
#25 0x000000000047cc03 llvm::DenseMap<std::pair<mlir::Attribute, mlir::Type>, mlir::Value, llvm::DenseMapInfo<std::pair<mlir::Attribute, mlir::Type> >, llvm::detail::DenseMapPair<std::pair<mlir::Attribute, mlir::Type>, mlir::Value> >::~DenseMap() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/DenseMap.h:755:50
#26 0x000000000047cc03 ~FIRModuleContext /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1023:8
#27 0x000000000047cc03 parseModule /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2823:20
#28 0x000000000047cc03 parseCircuit /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2927:75
#29 0x000000000047cc03 circt::firrtl::importFIRRTL(llvm::SourceMgr&, mlir::MLIRContext*, circt::firrtl::FIRParserOptions) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2957:53
#30 0x000000000040c620 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:162:5
#31 0x000000000040866f processBufferIntoSingleStream /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:253:8
#32 0x000000000040866f main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:323:15
#33 0x00007faf0e582b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#34 0x0000000000409fbe _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 15: 14926 Bus error               (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --lower-types --lowering-options=noAlwaysFF --pass-timing --verilog -o=$VFILE2
[2]+  Done                    ./bin/cli.js -n -I 200 -O 10000 --verif false --ordered true fir -o a_top_mod.fir
drom@linux-sydi:~/work/github/drom/circt-fuzzer> ./bin/cli.js -s 528570 -n -I 200 -O 10000 --verif false --ordered true fir -o a_top_mod.fir & ./process1.sh",,,,,,,,,
942,[FIRRTL]`is invalid` not working for registers in the parser,2021-04-21T07:36:32Z,closed,"bug, FIRRTL","Setting registers to invalid is not working correctly in the parser.  
```firrtl
; ./bin/circt-translate --import-firrtl  ./test.fir
circuit F :
  module F :
    input clock : Clock
    
    ; output port works as expected
    output out : UInt<1>
    out is invalid
    
    ; register is never set to invalid
    reg r : UInt<1>, clock
    r is invalid
```

```mlir
firrtl.circuit ""F""  {
  firrtl.module @F(%clock: !firrtl.clock, %out: !firrtl.flip<uint<1>>) {
    %0 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %out, %0 : !firrtl.flip<uint<1>>, !firrtl.uint<1>
    %r = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>
    %1 = firrtl.invalidvalue : !firrtl.uint<1>
  }
}
```

This is because the register value has a passive type, and we do not emit connects to invalid when the LHS is passive.  Switching the parser to emit a connect when the LHS is passive makes the following test fail. This test is represented in the repo [here](https://github.com/llvm/circt/blob/main/test/Dialect/FIRRTL/parse-basic.fir#L112).

```firrtl
circuit F:
  module F:
    input a : UInt<1>
    a is invalid
```
```
./test2.fir:4:7: error: 'firrtl.connect' op connection destination must be a non-passive type or a duplex value
    a is invalid
      ^
./test2.fir:4:7: note: see current operation: ""firrtl.connect""(%a, %0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
```

Could this be fixed with the coming changes to flip canonicalization?","; ./bin/circt-translate --import-firrtl  ./test.fir
circuit F :
  module F :
    input clock : Clock
    
    ; output port works as expected
    output out : UInt<1>
    out is invalid
    
    ; register is never set to invalid
    reg r : UInt<1>, clock
    r is invalid","firrtl.circuit ""F""  {
  firrtl.module @F(%clock: !firrtl.clock, %out: !firrtl.flip<uint<1>>) {
    %0 = firrtl.invalidvalue : !firrtl.uint<1>
    firrtl.connect %out, %0 : !firrtl.flip<uint<1>>, !firrtl.uint<1>
    %r = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>
    %1 = firrtl.invalidvalue : !firrtl.uint<1>
  }
}","circuit F:
  module F:
    input a : UInt<1>
    a is invalid","./test2.fir:4:7: error: 'firrtl.connect' op connection destination must be a non-passive type or a duplex value
    a is invalid
      ^
./test2.fir:4:7: note: see current operation: ""firrtl.connect""(%a, %0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()",,,,,,
919,[FIRRTL] Type Canonicalization Considered Harmful,2021-04-14T15:58:36Z,closed,"bug, FIRRTL","FIRRTL Dialect type canonicalization is destroying information that is needed to preserve connection semantics.

Consider the following circuit which has three different connections.
```scala
circuit Foo:
  module Foo:

    wire a: {flip a: {flip a: UInt<1>}}
    wire b: {flip a: {flip a: UInt<1>}}
    
    b <- a
    b.a <- a.a
    b.a.a <- a.a.a
```

If you run each of these through the SFC, you will get:

1. `b <- a` => `b.a.a <- a.a.a`
2. `b.a <- a.a` => `a.a.a <- b.a.a` (_The connection is reversed._)
3. `b.a.a <- a.a.a` => `b.a.a <- a.a.a`

However, the above circuit will type canonicalize into:
```scala
    wire a: {a: {a: UInt<1>}}
    wire b: {a: {a: UInt<1>}}
```

In this situation, the behavior of connection (2) is _incorrectly_ changed into `b.a <- a.a`.

I _think_ that wires are the only operation that have this behavior, but I'm not sure. The problem may show up anywhere that the SFC is relying on flip information that canonicalization is removing.

I think we can get around this by adding information to wires (and anything else that needs it) that stores the original, un-canonicalized type, and uses this information as an aid to resolve connection semantics.

### Explanation

In the SFC, connection semantics for _duplex flow_ are purely evaluated based on the type of the expression. This means that the expression `b.a` has type `!firrtl.bundle<a: flip<UInt<1>>`. A connection using this subfield will come out flipped because it has an odd number of flips going down to the leaf.","circuit Foo:
  module Foo:

    wire a: {flip a: {flip a: UInt<1>}}
    wire b: {flip a: {flip a: UInt<1>}}
    
    b <- a
    b.a <- a.a
    b.a.a <- a.a.a","wire a: {a: {a: UInt<1>}}
    wire b: {a: {a: UInt<1>}}",,,,,,,,
917,[FIRRTL] Use operand type to determine sign for const folding,2021-04-14T08:39:28Z,closed,"bug, FIRRTL","Use the operand types instead of the operation's result type when deciding whether to perform sign or zero extension of constants for folding. This is important for comparison operators, where the result type is always `uint<1>`, yet signed operands should be sign-extended. Fixes #912.",,,,,,,,,,
914,[FIRRTL] (neg) mismatch,2021-04-13T03:49:49Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 162
circuit top_mod :
  module top_mod :
    output tmp21: SInt<6>
    tmp21 <= validif(UInt<1>(""b0""), SInt<6>(""b1111""))
```

Compiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:

```verilog
// Standard header to adapt well known macros to our needs.

module top_mod(
  output [5:0] tmp21);

  assign tmp21 = 6'h0;	// a_top_mod.fir:3:3, :5:14
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:

```verilog
module top_mod(
  output [5:0] tmp21
);
  assign tmp21 = 6'shf;
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
ERROR: Found 4 unproven $equiv cells in 'equiv_status -assert'.
```
","; seed: 162
circuit top_mod :
  module top_mod :
    output tmp21: SInt<6>
    tmp21 <= validif(UInt<1>(""b0""), SInt<6>(""b1111""))","// Standard header to adapt well known macros to our needs.

module top_mod(
  output [5:0] tmp21);

  assign tmp21 = 6'h0;	// a_top_mod.fir:3:3, :5:14
endmodule","module top_mod(
  output [5:0] tmp21
);
  assign tmp21 = 6'shf;
endmodule",ERROR: Found 4 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
907,Parsing Instance Connects Broken,2021-04-09T15:45:51Z,open,"bug, FIRRTL","Connections involving instances fail to parse, but work in the Scala FIRRTL Compiler.

The following currently fails:
```scala
circuit Instance:
  module Sub:
    output a: UInt<1>
    a <= UInt<1>(0)

  module Instance:
    output a: {a: UInt<1>}

    inst sub of Sub
    a <= sub
    a <- sub
```

The error is: 

```
# circt-translate --import-firrtl new/Instance.fir
new/Instance.fir:11:5: error: expected '.' in field reference
    a <- sub
    ^
```

Glancing at the parser, it looks like it expects `sub` to be in the value table, but it isn't. [There is special logic to handle `sub is invalid`](https://github.com/llvm/circt/blob/main/lib/Dialect/FIRRTL/Import/FIRParser.cpp#L1187), but that needs to be extended to handle connections to submodules. If this isn't a `sub is invalid` situation, then the parser expects to see a subfield.","circuit Instance:
  module Sub:
    output a: UInt<1>
    a <= UInt<1>(0)

  module Instance:
    output a: {a: UInt<1>}

    inst sub of Sub
    a <= sub
    a <- sub","# circt-translate --import-firrtl new/Instance.fir
new/Instance.fir:11:5: error: expected '.' in field reference
    a <- sub
    ^",,,,,,,,
900,Lack of mux folding causes unreachable code which tools complain about,2021-04-08T20:48:32Z,closed,bug,"```
circuit MuxTree :
  module MuxTree :
    input clock : Clock
    input reset : UInt<1>
    input c1 : UInt<1>
    input c2 : UInt<1>
    input d1 : UInt<5>
    input d2 : UInt<5>
    input d3 : UInt<5>
    output foo : UInt<5>
    

    node baz = mux(c1,d2, d3) 
    node bar = mux(c1, d1, baz) 
    foo <= bar 
```
Gives
```
module MuxTree(
  input        clock, reset, c1, c2,
  input  [4:0] d1, d2, d3,
  output [4:0] foo);

  assign foo = c1 ? d1 : c1 ? d2 : d3; 
endmodule
```
assigning d2 to foo is unreachable and generates warnings.","circuit MuxTree :
  module MuxTree :
    input clock : Clock
    input reset : UInt<1>
    input c1 : UInt<1>
    input c2 : UInt<1>
    input d1 : UInt<5>
    input d2 : UInt<5>
    input d3 : UInt<5>
    output foo : UInt<5>
    

    node baz = mux(c1,d2, d3) 
    node bar = mux(c1, d1, baz) 
    foo <= bar","module MuxTree(
  input        clock, reset, c1, c2,
  input  [4:0] d1, d2, d3,
  output [4:0] foo);

  assign foo = c1 ? d1 : c1 ? d2 : d3; 
endmodule",,,,,,,,
894,[ExportVerilog] Emit constants as localparam,2021-04-07T13:55:31Z,closed,"bug, ExportVerilog","Emit `rtl.constant` operations as `localparam` when we decide to print them as out-of-line expressions. This requires additional special treatment since the localparam cannot be reassigned and the value must be provided already at the declaration site.

When `rtl.constant` operations are used before defined, move the definition up to the beginning of the block, similar to wire/reg. This avoids introducing a temporary dynamic wire and emits the constant as a localparam.

This fixes #884 by moving the constant reset values of always_ff statements into localparams.",,,,,,,,,,
889,[Python] RTL support library broken port names,2021-04-05T21:22:09Z,closed,bug,"The recent change to port names https://github.com/llvm/circt/commit/b6b3cb9f9fe7746f5646b66bfa5a2f31812fc6bd broke the RTLModuleOp python wrapper. I've managed to fix it partially, but the autowrapping stuff is still broken.",,,,,,,,,,
887,error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.,2021-04-05T18:37:33Z,closed,"bug, ExportVerilog","A bunch of the integration tests are broken with error messages like this:

```
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:10:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @B(%a: i1 { rtl.inout }) -> (i1 {rtl.name = ""b""}, i1 {rtl.name = ""c""}) {
^
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:10:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @B(%a: i1 { rtl.inout }) -> (i1 {rtl.name = ""b""}, i1 {rtl.name = ""c""}) {
^
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:16:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @A(%d: i1, %e: i1) -> (i1 {rtl.name = ""f""}) {
^
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:21:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @AAA(%d: i1, %e: i1) -> (i1 {rtl.name = ""f""}) {
^
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:26:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @AB(%w: i1, %x: i1) -> (i1 {rtl.name = ""y""}, i1 {rtl.name = ""z""}) {
^
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:26:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @AB(%w: i1, %x: i1) -> (i1 {rtl.name = ""y""}, i1 {rtl.name = ""z""}) {
^
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:32:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @shl(%a: i1) -> (i1 {rtl.name = ""b""}) {
^

--
```","/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:10:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @B(%a: i1 { rtl.inout }) -> (i1 {rtl.name = ""b""}, i1 {rtl.name = ""c""}) {
^
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:10:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @B(%a: i1 { rtl.inout }) -> (i1 {rtl.name = ""b""}, i1 {rtl.name = ""c""}) {
^
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:16:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @A(%d: i1, %e: i1) -> (i1 {rtl.name = ""f""}) {
^
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:21:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @AAA(%d: i1, %e: i1) -> (i1 {rtl.name = ""f""}) {
^
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:26:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @AB(%w: i1, %x: i1) -> (i1 {rtl.name = ""y""}, i1 {rtl.name = ""z""}) {
^
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:26:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @AB(%w: i1, %x: i1) -> (i1 {rtl.name = ""y""}, i1 {rtl.name = ""z""}) {
^
/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:32:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.

rtl.module @shl(%a: i1) -> (i1 {rtl.name = ""b""}) {
^

--",,,,,,,,,
884,Warning that Verilog may cause mismatches between simulation and synthesis,2021-04-03T13:53:29Z,closed,"bug, ExportVerilog","The formal verification tool flags this as a warning (not error).  I have attached the MLIR output and a corrected version below.

Warning: Variable(s) is(are) being read asynchronously. This may cause simulation-synthesis mismatches. (Signal: _T_0 Block: testcase_mfc.sv Line: 43) 
The problem with this description is that the simulation model does not react to changes in reset_data while reset_enable is held high.
In Verilog, you can't add _T_0 to the sensitivity list without breaking the model. You must verify that your model does not rely on the fact that during reset, the simulator holds tmp50 steady even though _TMP_50 changes. The synthesized register will be transparent during reset.

Or change the RTL, to have constant driving reset line.

_The FIR file_circuit top_mod :
```verilog
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input arst: AsyncReset
    input inp_i: SInt<170>
    output out_i: SInt<170>
    reg tmp50: SInt<2>, clock with: (reset => (arst, SInt<2>(0)))
    tmp50 <= inp_i
    out_i <= tmp50
```

**The output that produces the warning (just the relevant section):
```verilog
 always_ff @(posedge clock or posedge arst**) begin      // testcase.fir:9:5
    if (arst)   // testcase.fir:9:5
      **tmp50 <= _T_0;    // testcase.fir:9:5**
    else        // testcase.fir:9:5
      tmp50 <= _T;      // testcase.fir:10:11
  end // always_ff @(posedge or posedge)
```

**The structure that is read without warnings:**
```verilog
module top_mod(
  input          clock,
  input          reset,
  input          arst,
  input  [169:0] inp_i,
  output [169:0] out_i
);
`ifdef RANDOMIZE_REG_INIT
  reg [31:0] _RAND_0;
`endif // RANDOMIZE_REG_INIT
  reg [1:0] tmp50;
  assign out_i = {{168{tmp50[1]}},tmp50};
  always @(posedge clock or posedge arst) begin
    if (arst) begin
      **tmp50 <= 2'sh0;**
    end else begin
      tmp50 <= inp_i[1:0];
    end
  end
```
","module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input arst: AsyncReset
    input inp_i: SInt<170>
    output out_i: SInt<170>
    reg tmp50: SInt<2>, clock with: (reset => (arst, SInt<2>(0)))
    tmp50 <= inp_i
    out_i <= tmp50","always_ff @(posedge clock or posedge arst**) begin      // testcase.fir:9:5
    if (arst)   // testcase.fir:9:5
      **tmp50 <= _T_0;    // testcase.fir:9:5**
    else        // testcase.fir:9:5
      tmp50 <= _T;      // testcase.fir:10:11
  end // always_ff @(posedge or posedge)","module top_mod(
  input          clock,
  input          reset,
  input          arst,
  input  [169:0] inp_i,
  output [169:0] out_i
);
`ifdef RANDOMIZE_REG_INIT
  reg [31:0] _RAND_0;
`endif // RANDOMIZE_REG_INIT
  reg [1:0] tmp50;
  assign out_i = {{168{tmp50[1]}},tmp50};
  always @(posedge clock or posedge arst) begin
    if (arst) begin
      **tmp50 <= 2'sh0;**
    end else begin
      tmp50 <= inp_i[1:0];
    end
  end",,,,,,,
865,ifdef isn't a statement for purposes of begin/end,2021-03-31T22:27:24Z,closed,"bug, ExportVerilog","```andrew@narya:~/src/circt/build$ ./bin/firtool foo.mlir 
module  {
  rtl.module @M1(%clock: i1, %cond: i1, %val: i8) {
    sv.always posedge %clock  {
      sv.ifdef.procedural ""SYNTHESIS""  {
      }
    }
    %wire42 = sv.wire  : !rtl.inout<i42>
    rtl.output
  }
}
andrew@narya:~/src/circt/build$ ./bin/firtool foo.mlir  -verilog
module M1(
  input       clock, cond,
  input [7:0] val);

  always @(posedge clock)       // foo.mlir:2:3
    `ifndef SYNTHESIS   // foo.mlir:3:5
    `endif
endmodule```
That always block needs begin/end so that following real statements are parsed as in the always","andrew@narya:~/src/circt/build$ ./bin/firtool foo.mlir 
module  {
  rtl.module @M1(%clock: i1, %cond: i1, %val: i8) {
    sv.always posedge %clock  {
      sv.ifdef.procedural ""SYNTHESIS""  {
      }
    }
    %wire42 = sv.wire  : !rtl.inout<i42>
    rtl.output
  }
}
andrew@narya:~/src/circt/build$ ./bin/firtool foo.mlir  -verilog
module M1(
  input       clock, cond,
  input [7:0] val);

  always @(posedge clock)       // foo.mlir:2:3
    `ifndef SYNTHESIS   // foo.mlir:3:5
    `endif
endmodule",,,,,,,,,
863,[ExportVerilog] [Integration Tests] Naming broken and crashes,2021-03-31T21:31:04Z,closed,"bug, ExportVerilog","One (or more) of today's verilog emission commits broke the integration tests. This showed up in the ESI integration tests, but I think that's only because they are the most comprehensive and/or use ExportVerilog differently than FIRRTL. It broke 4 tests total (one unit test, 3 integration tests), but I'm only including the lit output from two which are representative of the other failures.

```
FAIL: CIRCT :: ESI/system/basic.mlir (1 of 14)
******************** TEST 'CIRCT :: ESI/system/basic.mlir' FAILED ********************
Script:
--
: 'RUN: at line 2';   /home/jodemme/circt/build/bin/circt-opt /home/jodemme/circt/integration_test/ESI/system/basic.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-rtl -verify-diagnostics > /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp1.mlir
: 'RUN: at line 3';   /home/jodemme/circt/build/bin/circt-translate /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp1.mlir -export-verilog -verify-diagnostics > /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv
: 'RUN: at line 4';   /home/jodemme/circt/build/bin/circt-rtl-sim.py /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv /home/jodemme/circt/include/circt/Dialect/ESI/ESIPrimitives.sv /home/jodemme/circt/integration_test/ESI/system/../supplements/integers.sv --cycles 150 | /home/jodemme/circt/llvm/build/bin/FileCheck /home/jodemme/circt/integration_test/ESI/system/basic.mlir
--
Exit Code: 2

Command Output (stderr):
--
%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:55:15: Operator ASSIGNW expects 32 bits on the Assign RHS, but Assign RHS's VARREF '_T_5' generates 1 bits.
                                                                                                     : ... In instance top
   55 |   assign _T_4 = _T_5;
      |               ^
                ... Use ""/* verilator lint_off WIDTH */"" and lint_on around source to disable this message.
%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:56:15: Operator ASSIGNW expects 1 bits on the Assign RHS, but Assign RHS's VARREF '_T_4' generates 32 bits.
                                                                                                     : ... In instance top
   56 |   assign _T_3 = _T_4;
      |               ^
%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:62:6: Input port connection 'a' expects 32 bits on the pin connection, but pin connection's VARREF '_T_3' generates 1 bits.
                                                                                                    : ... In instance top
   62 |     .a       (_T_3),
      |      ^
%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:70:15: Operator ASSIGNW expects 32 bits on the Assign RHS, but Assign RHS's VARREF '_T_2' generates 1 bits.
                                                                                                     : ... In instance top
   70 |   assign _T_1 = _T_2;
      |               ^
%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:71:15: Operator ASSIGNW expects 1 bits on the Assign RHS, but Assign RHS's VARREF '_T_1' generates 32 bits.
                                                                                                     : ... In instance top
   71 |   assign _T_0 = _T_1;
      |               ^
%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:74:20: Operator ASSIGNW expects 32 bits on the Assign RHS, but Assign RHS's VARREF '_T_0' generates 1 bits.
                                                                                                     : ... In instance top
   74 |   assign _T_7.data = _T_0;
      |                    ^
%Error: Exiting due to 6 warning(s)
CompletedProcess(args=['/home/jodemme/circt/ext/bin/verilator', '--cc', '--top-module', 'top', '-sv', '--build', '--exe', '--Mdir', 'basic.mlir.tmp2.sv.obj_dir', '--assert', '/home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv', '/home/jodemme/circt/include/circt/Dialect/ESI/ESIPrimitives.sv', '/home/jodemme/circt/integration_test/ESI/system/../supplements/integers.sv', '/home/jodemme/circt/build/bin/driver.cpp'], returncode=1)
FileCheck error: '<stdin>' is empty.
FileCheck command line:  /home/jodemme/circt/llvm/build/bin/FileCheck /home/jodemme/circt/integration_test/ESI/system/basic.mlir

--
```

```
********************
FAIL: CIRCT :: ESI/cosim/basic.mlir (7 of 14)
******************** TEST 'CIRCT :: ESI/cosim/basic.mlir' FAILED ********************
Script:
--
: 'RUN: at line 2';   /home/jodemme/circt/build/bin/circt-opt /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-rtl | /home/jodemme/circt/build/bin/circt-translate --export-verilog > /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp1.sv
: 'RUN: at line 3';   /home/jodemme/circt/build/bin/circt-translate /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir -export-esi-capnp -verify-diagnostics > /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp2.capnp
: 'RUN: at line 4';   /home/jodemme/circt/build/bin/esi-cosim-runner.py --schema /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp2.capnp /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp1.sv /home/jodemme/circt/integration_test/ESI/cosim/../supplements/integers.sv
--
Exit Code: 134

Command Output (stderr):
--
<unknown>:0: error: invalid element for rtl.inout type
circt-translate: /home/jodemme/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:96: static ConcreteT mlir::detail::StorageUserBase<ConcreteT, BaseT, StorageT, UniquerT, Traits>::get(mlir::MLIRContext*, Args ...) [with Args = {mlir::Type}; ConcreteT = circt::rtl::InOutType; BaseT = mlir::Type; StorageT = circt::rtl::detail::InOutTypeStorage; UniquerT = mlir::detail::TypeUniquer; Traits = {}]: Assertion `succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: /home/jodemme/circt/build/bin/circt-translate --export-verilog
 #0 0x00007fe1524db6ea llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/jodemme/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:11
 #1 0x00007fe1524db8bb PrintStackTraceSignalHandler(void*) /home/jodemme/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00007fe1524d9e8b llvm::sys::RunSignalHandlers() /home/jodemme/circt/llvm/llvm/lib/Support/Signals.cpp:70:5
 #3 0x00007fe1524dc031 SignalHandler(int) /home/jodemme/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007fe151d75d60 (/lib/x86_64-linux-gnu/libc.so.6+0x3bd60)
 #5 0x00007fe151d75ce1 raise ./signal/../sysdeps/unix/sysv/linux/raise.c:51:1
 #6 0x00007fe151d5f537 abort ./stdlib/abort.c:81:7
 #7 0x00007fe151d5f40f get_sysdep_segment_value ./intl/loadmsgcat.c:509:8
 #8 0x00007fe151d5f40f _nl_load_domain ./intl/loadmsgcat.c:970:34
 #9 0x00007fe151d6e662 (/lib/x86_64-linux-gnu/libc.so.6+0x34662)
#10 0x00007fe151a64f29 circt::rtl::InOutType mlir::detail::StorageUserBase<circt::rtl::InOutType, mlir::Type, circt::rtl::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get<mlir::Type>(mlir::MLIRContext*, mlir::Type) /home/jodemme/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:96:5
#11 0x00007fe151a606c3 circt::rtl::InOutType::get(mlir::MLIRContext*, mlir::Type) /home/jodemme/circt/build/include/circt/Dialect/RTL/RTLTypes.cpp.inc:147:1
#12 0x00007fe151d10532 circt::rtl::InOutType::get(mlir::Type) /home/jodemme/circt/build/include/circt/Dialect/RTL/RTLTypes.h.inc:66:5
#13 0x00007fe151ce744d circt::sv::WireOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Type, mlir::StringAttr) /home/jodemme/circt/lib/Dialect/SV/SVOps.cpp:835:47
#14 0x00007fe1525a8d79 circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type>(mlir::Location, mlir::Type&&) /home/jodemme/circt/llvm/mlir/include/mlir/IR/Builders.h:399:31
#15 0x00007fe1525a3dcb circt::sv::WireOp mlir::ImplicitLocOpBuilder::create<circt::sv::WireOp, mlir::Type>(mlir::Type&&) /home/jodemme/circt/llvm/mlir/include/mlir/IR/ImplicitLocOpBuilder.h:68:3
#16 0x00007fe15258b6ca lowerUsersToTemporaryWire(mlir::Operation&) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2503:59
#17 0x00007fe15258bd64 (anonymous namespace)::ModuleEmitter::prepareRTLModule(mlir::Block&) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2598:32
#18 0x00007fe15258be9a (anonymous namespace)::ModuleEmitter::emitRTLModule(circt::rtl::RTLModuleOp) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2608:58
#19 0x00007fe15258c9ed (anonymous namespace)::UnifiedEmitter::emitMLIRModule() /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2777:7
#20 0x00007fe15258d669 circt::exportVerilog(mlir::ModuleOp, llvm::raw_ostream&) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2911:42
#21 0x00007fe1527683c5 mlir::LogicalResult std::__invoke_impl<mlir::LogicalResult, mlir::LogicalResult (*&)(mlir::ModuleOp, llvm::raw_ostream&), mlir::ModuleOp, llvm::raw_ostream&>(std::__invoke_other, mlir::LogicalResult (*&)(mlir::ModuleOp, llvm::raw_ostream&), mlir::ModuleOp&&, llvm::raw_ostream&) /usr/include/c++/10/bits/invoke.h:60:70
#22 0x00007fe152767e30 _ZSt10__invoke_rIN4mlir13LogicalResultERPFS1_NS0_8ModuleOpERN4llvm11raw_ostreamEEJS2_S5_EENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt7is_voidIT_EESt14is_convertibleINSt15__invoke_resultIT0_JDpT1_EE4typeESD_EEE5valueESD_E4typeEOSI_DpOSJ_ /usr/include/c++/10/bits/invoke.h:143:5
#23 0x00007fe1527677f9 std::_Function_handler<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&), mlir::LogicalResult (*)(mlir::ModuleOp, llvm::raw_ostream&)>::_M_invoke(std::_Any_data const&, mlir::ModuleOp&&, llvm::raw_ostream&) /usr/include/c++/10/bits/std_function.h:293:7
#24 0x00007fe152531090 std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)>::operator()(mlir::ModuleOp, llvm::raw_ostream&) const /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:622:14
#25 0x00007fe15252ab00 mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1::operator()(llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*) const /home/jodemme/circt/llvm/mlir/lib/Translation/Translation.cpp:107:12
#26 0x00007fe15252aa1c mlir::LogicalResult std::__invoke_impl<mlir::LogicalResult, mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*>(std::__invoke_other, mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:60:14
#27 0x00007fe15252a98c std::enable_if<__and_<std::__not_<std::is_void<mlir::LogicalResult> >, std::is_convertible<std::__invoke_result<mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*>::type, mlir::LogicalResult> >::value, mlir::LogicalResult>::type std::__invoke_r<mlir::LogicalResult, mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*>(mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:141:14
#28 0x00007fe15252a7ec std::_Function_handler<mlir::LogicalResult (llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*), mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1>::_M_invoke(std::_Any_data const&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:291:9
#29 0x00007fe15252dbf5 std::function<mlir::LogicalResult (llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*)>::operator()(llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*) const /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:622:14
#30 0x00007fe152529a2f mlir::mlirTranslateMain(int, char**, llvm::StringRef)::$_3::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/jodemme/circt/llvm/mlir/lib/Translation/Translation.cpp:188:14
#31 0x00007fe15252980d mlir::mlirTranslateMain(int, char**, llvm::StringRef) /home/jodemme/circt/llvm/mlir/lib/Translation/Translation.cpp:203:21
#32 0x000055ad5c7b1f66 main /home/jodemme/circt/tools/circt-translate/circt-translate.cpp:20:22
#33 0x00007fe151d60d0a __libc_start_main ./csu/../csu/libc-start.c:308:16
#34 0x000055ad5c7b1e6a _start (/home/jodemme/circt/build/bin/circt-translate+0x1e6a)
/home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.script: line 3: 27275 Done                    /home/jodemme/circt/build/bin/circt-opt /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-rtl
     27277 Aborted                 | /home/jodemme/circt/build/bin/circt-translate --export-verilog > /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp1.sv

--
```
","FAIL: CIRCT :: ESI/system/basic.mlir (1 of 14)
******************** TEST 'CIRCT :: ESI/system/basic.mlir' FAILED ********************
Script:
--
: 'RUN: at line 2';   /home/jodemme/circt/build/bin/circt-opt /home/jodemme/circt/integration_test/ESI/system/basic.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-rtl -verify-diagnostics > /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp1.mlir
: 'RUN: at line 3';   /home/jodemme/circt/build/bin/circt-translate /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp1.mlir -export-verilog -verify-diagnostics > /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv
: 'RUN: at line 4';   /home/jodemme/circt/build/bin/circt-rtl-sim.py /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv /home/jodemme/circt/include/circt/Dialect/ESI/ESIPrimitives.sv /home/jodemme/circt/integration_test/ESI/system/../supplements/integers.sv --cycles 150 | /home/jodemme/circt/llvm/build/bin/FileCheck /home/jodemme/circt/integration_test/ESI/system/basic.mlir
--
Exit Code: 2

Command Output (stderr):
--
%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:55:15: Operator ASSIGNW expects 32 bits on the Assign RHS, but Assign RHS's VARREF '_T_5' generates 1 bits.
                                                                                                     : ... In instance top
   55 |   assign _T_4 = _T_5;
      |               ^
                ... Use ""/* verilator lint_off WIDTH */"" and lint_on around source to disable this message.
%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:56:15: Operator ASSIGNW expects 1 bits on the Assign RHS, but Assign RHS's VARREF '_T_4' generates 32 bits.
                                                                                                     : ... In instance top
   56 |   assign _T_3 = _T_4;
      |               ^
%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:62:6: Input port connection 'a' expects 32 bits on the pin connection, but pin connection's VARREF '_T_3' generates 1 bits.
                                                                                                    : ... In instance top
   62 |     .a       (_T_3),
      |      ^
%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:70:15: Operator ASSIGNW expects 32 bits on the Assign RHS, but Assign RHS's VARREF '_T_2' generates 1 bits.
                                                                                                     : ... In instance top
   70 |   assign _T_1 = _T_2;
      |               ^
%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:71:15: Operator ASSIGNW expects 1 bits on the Assign RHS, but Assign RHS's VARREF '_T_1' generates 32 bits.
                                                                                                     : ... In instance top
   71 |   assign _T_0 = _T_1;
      |               ^
%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:74:20: Operator ASSIGNW expects 32 bits on the Assign RHS, but Assign RHS's VARREF '_T_0' generates 1 bits.
                                                                                                     : ... In instance top
   74 |   assign _T_7.data = _T_0;
      |                    ^
%Error: Exiting due to 6 warning(s)
CompletedProcess(args=['/home/jodemme/circt/ext/bin/verilator', '--cc', '--top-module', 'top', '-sv', '--build', '--exe', '--Mdir', 'basic.mlir.tmp2.sv.obj_dir', '--assert', '/home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv', '/home/jodemme/circt/include/circt/Dialect/ESI/ESIPrimitives.sv', '/home/jodemme/circt/integration_test/ESI/system/../supplements/integers.sv', '/home/jodemme/circt/build/bin/driver.cpp'], returncode=1)
FileCheck error: '<stdin>' is empty.
FileCheck command line:  /home/jodemme/circt/llvm/build/bin/FileCheck /home/jodemme/circt/integration_test/ESI/system/basic.mlir

--","********************
FAIL: CIRCT :: ESI/cosim/basic.mlir (7 of 14)
******************** TEST 'CIRCT :: ESI/cosim/basic.mlir' FAILED ********************
Script:
--
: 'RUN: at line 2';   /home/jodemme/circt/build/bin/circt-opt /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-rtl | /home/jodemme/circt/build/bin/circt-translate --export-verilog > /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp1.sv
: 'RUN: at line 3';   /home/jodemme/circt/build/bin/circt-translate /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir -export-esi-capnp -verify-diagnostics > /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp2.capnp
: 'RUN: at line 4';   /home/jodemme/circt/build/bin/esi-cosim-runner.py --schema /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp2.capnp /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp1.sv /home/jodemme/circt/integration_test/ESI/cosim/../supplements/integers.sv
--
Exit Code: 134

Command Output (stderr):
--
<unknown>:0: error: invalid element for rtl.inout type
circt-translate: /home/jodemme/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:96: static ConcreteT mlir::detail::StorageUserBase<ConcreteT, BaseT, StorageT, UniquerT, Traits>::get(mlir::MLIRContext*, Args ...) [with Args = {mlir::Type}; ConcreteT = circt::rtl::InOutType; BaseT = mlir::Type; StorageT = circt::rtl::detail::InOutTypeStorage; UniquerT = mlir::detail::TypeUniquer; Traits = {}]: Assertion `succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: /home/jodemme/circt/build/bin/circt-translate --export-verilog
 #0 0x00007fe1524db6ea llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/jodemme/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:11
 #1 0x00007fe1524db8bb PrintStackTraceSignalHandler(void*) /home/jodemme/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00007fe1524d9e8b llvm::sys::RunSignalHandlers() /home/jodemme/circt/llvm/llvm/lib/Support/Signals.cpp:70:5
 #3 0x00007fe1524dc031 SignalHandler(int) /home/jodemme/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007fe151d75d60 (/lib/x86_64-linux-gnu/libc.so.6+0x3bd60)
 #5 0x00007fe151d75ce1 raise ./signal/../sysdeps/unix/sysv/linux/raise.c:51:1
 #6 0x00007fe151d5f537 abort ./stdlib/abort.c:81:7
 #7 0x00007fe151d5f40f get_sysdep_segment_value ./intl/loadmsgcat.c:509:8
 #8 0x00007fe151d5f40f _nl_load_domain ./intl/loadmsgcat.c:970:34
 #9 0x00007fe151d6e662 (/lib/x86_64-linux-gnu/libc.so.6+0x34662)
#10 0x00007fe151a64f29 circt::rtl::InOutType mlir::detail::StorageUserBase<circt::rtl::InOutType, mlir::Type, circt::rtl::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get<mlir::Type>(mlir::MLIRContext*, mlir::Type) /home/jodemme/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:96:5
#11 0x00007fe151a606c3 circt::rtl::InOutType::get(mlir::MLIRContext*, mlir::Type) /home/jodemme/circt/build/include/circt/Dialect/RTL/RTLTypes.cpp.inc:147:1
#12 0x00007fe151d10532 circt::rtl::InOutType::get(mlir::Type) /home/jodemme/circt/build/include/circt/Dialect/RTL/RTLTypes.h.inc:66:5
#13 0x00007fe151ce744d circt::sv::WireOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Type, mlir::StringAttr) /home/jodemme/circt/lib/Dialect/SV/SVOps.cpp:835:47
#14 0x00007fe1525a8d79 circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type>(mlir::Location, mlir::Type&&) /home/jodemme/circt/llvm/mlir/include/mlir/IR/Builders.h:399:31
#15 0x00007fe1525a3dcb circt::sv::WireOp mlir::ImplicitLocOpBuilder::create<circt::sv::WireOp, mlir::Type>(mlir::Type&&) /home/jodemme/circt/llvm/mlir/include/mlir/IR/ImplicitLocOpBuilder.h:68:3
#16 0x00007fe15258b6ca lowerUsersToTemporaryWire(mlir::Operation&) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2503:59
#17 0x00007fe15258bd64 (anonymous namespace)::ModuleEmitter::prepareRTLModule(mlir::Block&) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2598:32
#18 0x00007fe15258be9a (anonymous namespace)::ModuleEmitter::emitRTLModule(circt::rtl::RTLModuleOp) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2608:58
#19 0x00007fe15258c9ed (anonymous namespace)::UnifiedEmitter::emitMLIRModule() /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2777:7
#20 0x00007fe15258d669 circt::exportVerilog(mlir::ModuleOp, llvm::raw_ostream&) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2911:42
#21 0x00007fe1527683c5 mlir::LogicalResult std::__invoke_impl<mlir::LogicalResult, mlir::LogicalResult (*&)(mlir::ModuleOp, llvm::raw_ostream&), mlir::ModuleOp, llvm::raw_ostream&>(std::__invoke_other, mlir::LogicalResult (*&)(mlir::ModuleOp, llvm::raw_ostream&), mlir::ModuleOp&&, llvm::raw_ostream&) /usr/include/c++/10/bits/invoke.h:60:70
#22 0x00007fe152767e30 _ZSt10__invoke_rIN4mlir13LogicalResultERPFS1_NS0_8ModuleOpERN4llvm11raw_ostreamEEJS2_S5_EENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt7is_voidIT_EESt14is_convertibleINSt15__invoke_resultIT0_JDpT1_EE4typeESD_EEE5valueESD_E4typeEOSI_DpOSJ_ /usr/include/c++/10/bits/invoke.h:143:5
#23 0x00007fe1527677f9 std::_Function_handler<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&), mlir::LogicalResult (*)(mlir::ModuleOp, llvm::raw_ostream&)>::_M_invoke(std::_Any_data const&, mlir::ModuleOp&&, llvm::raw_ostream&) /usr/include/c++/10/bits/std_function.h:293:7
#24 0x00007fe152531090 std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)>::operator()(mlir::ModuleOp, llvm::raw_ostream&) const /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:622:14
#25 0x00007fe15252ab00 mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1::operator()(llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*) const /home/jodemme/circt/llvm/mlir/lib/Translation/Translation.cpp:107:12
#26 0x00007fe15252aa1c mlir::LogicalResult std::__invoke_impl<mlir::LogicalResult, mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*>(std::__invoke_other, mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:60:14
#27 0x00007fe15252a98c std::enable_if<__and_<std::__not_<std::is_void<mlir::LogicalResult> >, std::is_convertible<std::__invoke_result<mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*>::type, mlir::LogicalResult> >::value, mlir::LogicalResult>::type std::__invoke_r<mlir::LogicalResult, mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*>(mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:141:14
#28 0x00007fe15252a7ec std::_Function_handler<mlir::LogicalResult (llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*), mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1>::_M_invoke(std::_Any_data const&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:291:9
#29 0x00007fe15252dbf5 std::function<mlir::LogicalResult (llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*)>::operator()(llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*) const /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:622:14
#30 0x00007fe152529a2f mlir::mlirTranslateMain(int, char**, llvm::StringRef)::$_3::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/jodemme/circt/llvm/mlir/lib/Translation/Translation.cpp:188:14
#31 0x00007fe15252980d mlir::mlirTranslateMain(int, char**, llvm::StringRef) /home/jodemme/circt/llvm/mlir/lib/Translation/Translation.cpp:203:21
#32 0x000055ad5c7b1f66 main /home/jodemme/circt/tools/circt-translate/circt-translate.cpp:20:22
#33 0x00007fe151d60d0a __libc_start_main ./csu/../csu/libc-start.c:308:16
#34 0x000055ad5c7b1e6a _start (/home/jodemme/circt/build/bin/circt-translate+0x1e6a)
/home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.script: line 3: 27275 Done                    /home/jodemme/circt/build/bin/circt-opt /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-rtl
     27277 Aborted                 | /home/jodemme/circt/build/bin/circt-translate --export-verilog > /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp1.sv

--",,,,,,,,
860,[FIRRTL] crash in ExportVerilog: use-before-def creating a wire with incorrect type,2021-03-31T17:59:16Z,closed,"bug, FIRRTL","```mlir
// ./bin/firtool ./crash-inout.mlir --verilog
rtl.module @ArrayLHS(%clock: i1) -> () {
  %false = rtl.constant false
  sv.alwaysff(posedge %clock)  {
    sv.passign %reg, %false : i1
  }
  %reg = sv.reg  : !rtl.inout<i1>
}
```
Since `%reg` is used before its defined, the code is attempting to create a wire for it.  This is resulting in a wire of type `rtl.inout<inout<i1>>`:
```
<unknown>:0: error: invalid element for rtl.inout type

    frame #3: 0x00007fff203f29d6 libsystem_c.dylib`__assert_rtn + 314
  * frame #4: 0x00000001036a2904 libCIRCTRTL.dylib`circt::rtl::InOutType mlir::detail::StorageUserBase<circt::rtl::InOutType, mlir::Type, circt::rtl::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get<mlir::Type>(ctx=0x00007ffeefbff470, args=Type @ 0x00007ffeefbfdce0) at StorageUniquerSupport.h:96:5
    frame #5: 0x00000001036a2865 libCIRCTRTL.dylib`circt::rtl::InOutType::get(context=0x00007ffeefbff470, elementType=Type @ 0x00007ffeefbfdd10) at RTLTypes.cpp.inc:146:10
    frame #6: 0x00000001032695f9 libCIRCTSV.dylib`circt::rtl::InOutType::get(elementType=Type @ 0x00007ffeefbfdd40) at RTLTypes.h.inc:65:14
    frame #7: 0x000000010326d525 libCIRCTSV.dylib`circt::sv::WireOp::build(odsBuilder=0x00007ffeefbfe108, odsState=0x00007ffeefbfded0, elementType=Type @ 0x00007ffeefbfddc8, name=StringAttr @ 0x00007ffeefbfddc0) at SVOps.cpp:833:21
    frame #8: 0x0000000100228e5c libCIRCTExportVerilog.dylib`circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type>(this=0x00007ffeefbfe108, location=Location @ 0x00007ffeefbfdec0, args=0x00007ffeefbfe0b0) at Builders.h:398:5
    frame #9: 0x0000000100228aec libCIRCTExportVerilog.dylib`circt::sv::WireOp mlir::ImplicitLocOpBuilder::create<circt::sv::WireOp, mlir::Type>(this=0x00007ffeefbfe108, args=0x00007ffeefbfe0b0) at ImplicitLocOpBuilder.h:67:23
    frame #10: 0x000000010021f34a libCIRCTExportVerilog.dylib`lowerUsersToTemporaryWire(op=0x000000010fc36300) at ExportVerilog.cpp:2505:28
```","// ./bin/firtool ./crash-inout.mlir --verilog
rtl.module @ArrayLHS(%clock: i1) -> () {
  %false = rtl.constant false
  sv.alwaysff(posedge %clock)  {
    sv.passign %reg, %false : i1
  }
  %reg = sv.reg  : !rtl.inout<i1>
}","<unknown>:0: error: invalid element for rtl.inout type

    frame #3: 0x00007fff203f29d6 libsystem_c.dylib`__assert_rtn + 314
  * frame #4: 0x00000001036a2904 libCIRCTRTL.dylib`circt::rtl::InOutType mlir::detail::StorageUserBase<circt::rtl::InOutType, mlir::Type, circt::rtl::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get<mlir::Type>(ctx=0x00007ffeefbff470, args=Type @ 0x00007ffeefbfdce0) at StorageUniquerSupport.h:96:5
    frame #5: 0x00000001036a2865 libCIRCTRTL.dylib`circt::rtl::InOutType::get(context=0x00007ffeefbff470, elementType=Type @ 0x00007ffeefbfdd10) at RTLTypes.cpp.inc:146:10
    frame #6: 0x00000001032695f9 libCIRCTSV.dylib`circt::rtl::InOutType::get(elementType=Type @ 0x00007ffeefbfdd40) at RTLTypes.h.inc:65:14
    frame #7: 0x000000010326d525 libCIRCTSV.dylib`circt::sv::WireOp::build(odsBuilder=0x00007ffeefbfe108, odsState=0x00007ffeefbfded0, elementType=Type @ 0x00007ffeefbfddc8, name=StringAttr @ 0x00007ffeefbfddc0) at SVOps.cpp:833:21
    frame #8: 0x0000000100228e5c libCIRCTExportVerilog.dylib`circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type>(this=0x00007ffeefbfe108, location=Location @ 0x00007ffeefbfdec0, args=0x00007ffeefbfe0b0) at Builders.h:398:5
    frame #9: 0x0000000100228aec libCIRCTExportVerilog.dylib`circt::sv::WireOp mlir::ImplicitLocOpBuilder::create<circt::sv::WireOp, mlir::Type>(this=0x00007ffeefbfe108, args=0x00007ffeefbfe0b0) at ImplicitLocOpBuilder.h:67:23
    frame #10: 0x000000010021f34a libCIRCTExportVerilog.dylib`lowerUsersToTemporaryWire(op=0x000000010fc36300) at ExportVerilog.cpp:2505:28",,,,,,,,
859,VerilogEmitter crashes on out of order use of sv.reg,2021-03-31T17:32:44Z,closed,"bug, ExportVerilog","The changes I put in to handle out of order references to values in a graph region don't handle inout types correctly.

Will fix.

",,,,,,,,,,
855,-rtl-legalize-names crashes on nameless reg,2021-03-31T05:31:43Z,closed,bug,"Names are optional on regs and wires, but `-rtl-legalize-names` isn't handling this.  Instead of being optional, we should make these attributes always required but possibly empty.

I'll work on it.",,,,,,,,,,
854,circt-translate crashes with small testcase,2021-03-31T01:08:17Z,closed,bug,"I think this is either an MLIR bug or a bug in how we're using it, but this works fine:

```
$ cat x1.mlir
rtl.module @cyclic(%a: i1) -> (%b: i1) {
  %ASB = sv.wire : !rtl.inout<i1>
  %1 = comb.add %0, %0 : i1
  %0 = comb.shl %a, %a : i1
  %2 = comb.add %1, %1 : i1
  rtl.output %2 : i1
}

$ circt-translate x1.mlir -export-verilog 
```

However if you delete the ASB wire, we get:

```
$ cat x1.mlir 
rtl.module @cyclic(%a: i1) -> (%b: i1) {
  %1 = comb.add %0, %0 : i1
  %0 = comb.shl %a, %a : i1
  %2 = comb.add %1, %1 : i1
  rtl.output %2 : i1
}
$ circt-translate x1.mlir -export-verilog 
LLVM ERROR: Building op `sv.wire` but it isn't registered in this MLIRContext
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.	Program arguments: circt-translate x1.mlir -export-verilog
... crash
```
","$ cat x1.mlir
rtl.module @cyclic(%a: i1) -> (%b: i1) {
  %ASB = sv.wire : !rtl.inout<i1>
  %1 = comb.add %0, %0 : i1
  %0 = comb.shl %a, %a : i1
  %2 = comb.add %1, %1 : i1
  rtl.output %2 : i1
}

$ circt-translate x1.mlir -export-verilog","$ cat x1.mlir 
rtl.module @cyclic(%a: i1) -> (%b: i1) {
  %1 = comb.add %0, %0 : i1
  %0 = comb.shl %a, %a : i1
  %2 = comb.add %1, %1 : i1
  rtl.output %2 : i1
}
$ circt-translate x1.mlir -export-verilog 
LLVM ERROR: Building op `sv.wire` but it isn't registered in this MLIRContext
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.	Program arguments: circt-translate x1.mlir -export-verilog
... crash",,,,,,,,
850,[FIRRTL] Handle folding of 0-width LEQ/LT/GEQ/GT,2021-03-30T11:59:41Z,closed,"bug, FIRRTL",* Fix an issue in comparison folding in case the left-hand argument is a non-constant value of width 0. Fixes #847.,,,,,,,,,,
847,[FIRRTL] (geq) (core dump),2021-03-30T03:59:02Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 12
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input inp_h: UInt<0>
    wire tmp10: SInt<0>
    wire tmp25: SInt<29>
    wire tmp28: UInt<1>
    tmp10 <= asSInt(inp_h)
    tmp25 <= SInt<29>(-1)
    tmp28 <= geq(tmp10, tmp25)
```

Compiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:

```mlir
firtool
firtool: ../llvm/llvm/include/llvm/ADT/APInt.h:280: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && ""bitwidth too small""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
1.      2.       #0 0x00000000004be4f7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004be5ae PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004bc5a4 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bdf4a SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f8b67bbaa30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #5 0x00007f8b6763e4a5 raise (/lib64/libc.so.6+0x3d4a5)
 #6 0x00007f8b67627864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f8b67627749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f8b676369b6 (/lib64/libc.so.6+0x359b6)
 #9 0x0000000000727d4b circt::firrtl::GEQPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) (../../llvm/circt/build/bin/firtool+0x727d4b)
#10 0x000000000071cda4 mlir::LogicalResult mlir::Op<circt::firrtl::GEQPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::GEQPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) (../../llvm/circt/build/bin/firtool+0x71cda4)
#11 0x00000000006bbdb6 mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:128:3
#12 0x00000000006b4f12 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:553:30
#13 0x000000000078be1f mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13
#14 0x000000000078b7a4 mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13
#15 0x00000000007718cb (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:192:21
#16 0x0000000000771bee mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:256:35
#17 0x0000000000771ada mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:236:1
#18 0x0000000000703ca4 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:36:3
#19 0x00000000008ed8bb mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:407:36
#20 0x00000000008edae7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:448:15
#21 0x00000000008ee7c2 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:624:68
#22 0x00000000008f1a0b mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7
#23 0x00000000008f19ac void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:143:16
#24 0x00000000008f0ed3 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40
#25 0x00000000008eecd7 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:601:24
#26 0x00000000008ee203 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:526:1
#27 0x00000000008ed89c mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:404:28
#28 0x00000000008edae7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:448:15
#29 0x00000000008ee7c2 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:624:68
#30 0x00000000008f1a0b mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7
#31 0x00000000008f19ac void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:143:16
#32 0x00000000008f0ed3 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40
#33 0x00000000008eecd7 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:601:24
#34 0x00000000008ee203 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:526:1
#35 0x00000000008ed89c mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:404:28
#36 0x00000000008edae7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:448:15
#37 0x00000000008efc27 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:901:74
#38 0x000000000040e193 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40e193)
#39 0x000000000040b3d1 main (../../llvm/circt/build/bin/firtool+0x40b3d1)
#40 0x00007f8b67628b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#41 0x000000000040b76e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: строка 26: 13260 Aborted                 (стек памяти сброшен на диск) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2
```
Compiled with firrtl-1.5-SNAPSHOT --dont-fold div produces this Verilog:

```
module top_mod(
  input   clock,
  input   reset
);
endmodule
```
Expected behavior: not to crash
","; seed: 12
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input inp_h: UInt<0>
    wire tmp10: SInt<0>
    wire tmp25: SInt<29>
    wire tmp28: UInt<1>
    tmp10 <= asSInt(inp_h)
    tmp25 <= SInt<29>(-1)
    tmp28 <= geq(tmp10, tmp25)","firtool
firtool: ../llvm/llvm/include/llvm/ADT/APInt.h:280: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && ""bitwidth too small""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
1.      2.       #0 0x00000000004be4f7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004be5ae PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004bc5a4 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bdf4a SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f8b67bbaa30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #5 0x00007f8b6763e4a5 raise (/lib64/libc.so.6+0x3d4a5)
 #6 0x00007f8b67627864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f8b67627749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f8b676369b6 (/lib64/libc.so.6+0x359b6)
 #9 0x0000000000727d4b circt::firrtl::GEQPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) (../../llvm/circt/build/bin/firtool+0x727d4b)
#10 0x000000000071cda4 mlir::LogicalResult mlir::Op<circt::firrtl::GEQPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::GEQPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) (../../llvm/circt/build/bin/firtool+0x71cda4)
#11 0x00000000006bbdb6 mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:128:3
#12 0x00000000006b4f12 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:553:30
#13 0x000000000078be1f mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13
#14 0x000000000078b7a4 mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13
#15 0x00000000007718cb (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:192:21
#16 0x0000000000771bee mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:256:35
#17 0x0000000000771ada mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:236:1
#18 0x0000000000703ca4 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:36:3
#19 0x00000000008ed8bb mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:407:36
#20 0x00000000008edae7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:448:15
#21 0x00000000008ee7c2 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:624:68
#22 0x00000000008f1a0b mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7
#23 0x00000000008f19ac void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:143:16
#24 0x00000000008f0ed3 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40
#25 0x00000000008eecd7 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:601:24
#26 0x00000000008ee203 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:526:1
#27 0x00000000008ed89c mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:404:28
#28 0x00000000008edae7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:448:15
#29 0x00000000008ee7c2 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:624:68
#30 0x00000000008f1a0b mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7
#31 0x00000000008f19ac void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:143:16
#32 0x00000000008f0ed3 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40
#33 0x00000000008eecd7 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:601:24
#34 0x00000000008ee203 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:526:1
#35 0x00000000008ed89c mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:404:28
#36 0x00000000008edae7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:448:15
#37 0x00000000008efc27 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:901:74
#38 0x000000000040e193 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40e193)
#39 0x000000000040b3d1 main (../../llvm/circt/build/bin/firtool+0x40b3d1)
#40 0x00007f8b67628b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#41 0x000000000040b76e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: строка 26: 13260 Aborted                 (стек памяти сброшен на диск) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2","module top_mod(
  input   clock,
  input   reset
);
endmodule",,,,,,,
846,"Respect Procedural/Non-procedural Regions when Unwinding Inlined, Long Line Expressions",2021-03-30T00:11:58Z,closed,"bug, ExportVerilog","Two fixes:

1) Pass around the current statement when doing Verilog emission of expressions and sub-expressions. This avoids problems where inlining an expression, defined in a non-procedural region, into a procedural region was then unwound due to the emitted Verilog line being too long. The type of region (procedural vs. non-procedural) in which the inlined expression was *defined* was then incorrectly used to generate a temporary. This changes this to compute the region based on the type of the statement.

2) Reset `outOfLineExpressions` pointer set if these have already been emitted. Without doing this, later use/def of something in the pointer set would cause duplicate emission. (I'm much less confident that this modification is sound. I had a difficult time following all the `ExportVerilog` logic and may have missed something.)

Regardless, the test cases are sound and can be re-used if there's a better solution here.

Fixes #838.",,,,,,,,,,
844,[FIRRTL] mem (mismatch),2021-03-29T19:09:38Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 56
circuit top_mod :
  module top_mod :
    input clock: Clock
    input en: UInt<1>
    input addr1: UInt<17>
    input wdata: SInt<19>
    output tmp16: SInt<10>
    mem tmp14:
      data-type => SInt<10>
      depth => 16
      read-latency => 1
      write-latency => 1
      read-under-write => undefined
      reader => r1
      writer => w0
    tmp14.r1.clk <= clock
    tmp14.r1.en <= en
    tmp14.r1.addr <= addr1
    tmp14.w0.clk <= clock
    tmp14.w0.en <= en
    tmp14.w0.addr <= asUInt(SInt<7>(""h-28""))
    tmp14.w0.data <= wdata
    tmp14.w0.mask <= UInt<25>(""hffffff"")
    tmp16 <= tmp14.r1.data
```

Compiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:

```verilog
...
module top_mod(
  input         clock, en,
  input  [16:0] addr1,
  input  [18:0] wdata,
  output [9:0]  tmp16);

  reg  [9:0] tmp14[0:15];	// a_top_mod.fir:9:5
  reg        tmp14_r1_en_pipe[0:0];	// a_top_mod.fir:9:5
  reg  [3:0] tmp14_r1_addr_pipe[0:0];	// a_top_mod.fir:9:5
  wire [3:0] tmp14_r1_addr;	// a_top_mod.fir:9:5
  wire [3:0] _T;	// a_top_mod.fir:9:5
  wire [9:0] _T_0;	// a_top_mod.fir:23:19

  always_ff @(posedge clock) begin	// a_top_mod.fir:9:5
    tmp14_r1_en_pipe[1'h0] <= en;	// a_top_mod.fir:9:5
    if (en)	// a_top_mod.fir:9:5
      tmp14_r1_addr_pipe[1'h0] <= _T;	// a_top_mod.fir:9:5
    if (en)	// a_top_mod.fir:9:5
      tmp14[4'h8] <= _T_0;	// a_top_mod.fir:9:5, :22:19
  end // always_ff @(posedge)
...
  assign _T = tmp14_r1_addr;	// a_top_mod.fir:9:5
  assign tmp14_r1_addr = addr1[3:0];	// a_top_mod.fir:19:19
  assign _T_0 = wdata[9:0];	// a_top_mod.fir:23:19
  assign tmp16 = tmp14[tmp14_r1_addr_pipe[1'h0]];	// a_top_mod.fir:3:3, :9:5
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:

```verilog
module top_mod(
  input         clock,
  input         en,
  input  [16:0] addr1,
  input  [18:0] wdata,
  output [9:0]  tmp16
);
...
  reg [9:0] tmp14 [0:15];
  wire [9:0] tmp14_r1_data;
  wire [3:0] tmp14_r1_addr;
  wire [9:0] tmp14_w0_data;
  wire [3:0] tmp14_w0_addr;
  wire  tmp14_w0_mask;
  wire  tmp14_w0_en;
  reg  tmp14_r1_en_pipe_0;
  reg [3:0] tmp14_r1_addr_pipe_0;
  assign tmp14_r1_addr = tmp14_r1_addr_pipe_0;
  assign tmp14_r1_data = tmp14[tmp14_r1_addr];
  assign tmp14_w0_data = wdata[9:0];
  assign tmp14_w0_addr = 4'h8;
  assign tmp14_w0_mask = 1'h1;
  assign tmp14_w0_en = en;
  assign tmp16 = tmp14_r1_data;
  always @(posedge clock) begin
    if (tmp14_w0_en & tmp14_w0_mask) begin
      tmp14[tmp14_w0_addr] <= tmp14_w0_data;
    end
    tmp14_r1_en_pipe_0 <= en;
    if (en) begin
      tmp14_r1_addr_pipe_0 <= addr1[3:0];
    end
  end
// Register and memory initialization
...
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
yosys 0
Warning: Replacing memory \tmp14 with list of registers. See a_top_mod_new.sv:53
Warning: Replacing memory \tmp14_r1_addr_pipe with list of registers. See a_top_mod_new.sv:51
Warning: Replacing memory \tmp14_r1_en_pipe with list of registers. See a_top_mod_new.sv:49
ERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.
yosys 1
Warning: Replacing memory \tmp14 with list of registers. See a_top_mod_new.sv:53
Warning: Replacing memory \tmp14_r1_addr_pipe with list of registers. See a_top_mod_new.sv:51
Warning: Replacing memory \tmp14_r1_en_pipe with list of registers. See a_top_mod_new.sv:49
ERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.
yosys 2
Warning: Replacing memory \tmp14 with list of registers. See a_top_mod_new.sv:53
Warning: Replacing memory \tmp14_r1_addr_pipe with list of registers. See a_top_mod_new.sv:51
Warning: Replacing memory \tmp14_r1_en_pipe with list of registers. See a_top_mod_new.sv:49
ERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.
```
","; seed: 56
circuit top_mod :
  module top_mod :
    input clock: Clock
    input en: UInt<1>
    input addr1: UInt<17>
    input wdata: SInt<19>
    output tmp16: SInt<10>
    mem tmp14:
      data-type => SInt<10>
      depth => 16
      read-latency => 1
      write-latency => 1
      read-under-write => undefined
      reader => r1
      writer => w0
    tmp14.r1.clk <= clock
    tmp14.r1.en <= en
    tmp14.r1.addr <= addr1
    tmp14.w0.clk <= clock
    tmp14.w0.en <= en
    tmp14.w0.addr <= asUInt(SInt<7>(""h-28""))
    tmp14.w0.data <= wdata
    tmp14.w0.mask <= UInt<25>(""hffffff"")
    tmp16 <= tmp14.r1.data","...
module top_mod(
  input         clock, en,
  input  [16:0] addr1,
  input  [18:0] wdata,
  output [9:0]  tmp16);

  reg  [9:0] tmp14[0:15];	// a_top_mod.fir:9:5
  reg        tmp14_r1_en_pipe[0:0];	// a_top_mod.fir:9:5
  reg  [3:0] tmp14_r1_addr_pipe[0:0];	// a_top_mod.fir:9:5
  wire [3:0] tmp14_r1_addr;	// a_top_mod.fir:9:5
  wire [3:0] _T;	// a_top_mod.fir:9:5
  wire [9:0] _T_0;	// a_top_mod.fir:23:19

  always_ff @(posedge clock) begin	// a_top_mod.fir:9:5
    tmp14_r1_en_pipe[1'h0] <= en;	// a_top_mod.fir:9:5
    if (en)	// a_top_mod.fir:9:5
      tmp14_r1_addr_pipe[1'h0] <= _T;	// a_top_mod.fir:9:5
    if (en)	// a_top_mod.fir:9:5
      tmp14[4'h8] <= _T_0;	// a_top_mod.fir:9:5, :22:19
  end // always_ff @(posedge)
...
  assign _T = tmp14_r1_addr;	// a_top_mod.fir:9:5
  assign tmp14_r1_addr = addr1[3:0];	// a_top_mod.fir:19:19
  assign _T_0 = wdata[9:0];	// a_top_mod.fir:23:19
  assign tmp16 = tmp14[tmp14_r1_addr_pipe[1'h0]];	// a_top_mod.fir:3:3, :9:5
endmodule","module top_mod(
  input         clock,
  input         en,
  input  [16:0] addr1,
  input  [18:0] wdata,
  output [9:0]  tmp16
);
...
  reg [9:0] tmp14 [0:15];
  wire [9:0] tmp14_r1_data;
  wire [3:0] tmp14_r1_addr;
  wire [9:0] tmp14_w0_data;
  wire [3:0] tmp14_w0_addr;
  wire  tmp14_w0_mask;
  wire  tmp14_w0_en;
  reg  tmp14_r1_en_pipe_0;
  reg [3:0] tmp14_r1_addr_pipe_0;
  assign tmp14_r1_addr = tmp14_r1_addr_pipe_0;
  assign tmp14_r1_data = tmp14[tmp14_r1_addr];
  assign tmp14_w0_data = wdata[9:0];
  assign tmp14_w0_addr = 4'h8;
  assign tmp14_w0_mask = 1'h1;
  assign tmp14_w0_en = en;
  assign tmp16 = tmp14_r1_data;
  always @(posedge clock) begin
    if (tmp14_w0_en & tmp14_w0_mask) begin
      tmp14[tmp14_w0_addr] <= tmp14_w0_data;
    end
    tmp14_r1_en_pipe_0 <= en;
    if (en) begin
      tmp14_r1_addr_pipe_0 <= addr1[3:0];
    end
  end
// Register and memory initialization
...
endmodule","yosys 0
Warning: Replacing memory \tmp14 with list of registers. See a_top_mod_new.sv:53
Warning: Replacing memory \tmp14_r1_addr_pipe with list of registers. See a_top_mod_new.sv:51
Warning: Replacing memory \tmp14_r1_en_pipe with list of registers. See a_top_mod_new.sv:49
ERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.
yosys 1
Warning: Replacing memory \tmp14 with list of registers. See a_top_mod_new.sv:53
Warning: Replacing memory \tmp14_r1_addr_pipe with list of registers. See a_top_mod_new.sv:51
Warning: Replacing memory \tmp14_r1_en_pipe with list of registers. See a_top_mod_new.sv:49
ERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.
yosys 2
Warning: Replacing memory \tmp14 with list of registers. See a_top_mod_new.sv:53
Warning: Replacing memory \tmp14_r1_addr_pipe with list of registers. See a_top_mod_new.sv:51
Warning: Replacing memory \tmp14_r1_en_pipe with list of registers. See a_top_mod_new.sv:49
ERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.",,,,,,
842,[FIRRTL] Yosys integration test failing,2021-03-29T18:12:52Z,closed,"bug, FIRRTL","https://github.com/llvm/circt/runs/2218231196?check_suite_focus=true

```
FAIL: CIRCT :: EmitVerilog/verilog_equiv.fir (11 of 14)
******************** TEST 'CIRCT :: EmitVerilog/verilog_equiv.fir' FAILED ********************
Script:
--
: 'RUN: at line 2';   split-file /__w/circt/circt/integration_test/EmitVerilog/verilog_equiv.fir /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp
: 'RUN: at line 3';   /__w/circt/circt/build/bin/firtool /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir --format=fir --lower-to-rtl -verilog -o /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir.v
: 'RUN: at line 4';   /__w/circt/circt/build/bin/firtool /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir --format=fir --lower-to-rtl -verilog -o /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v
: 'RUN: at line 5';   /__w/circt/circt/build/bin/firtool /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.fir --format=fir --lower-to-rtl -verilog -o /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.fir.v
: 'RUN: at line 6';   /__w/circt/circt/integration_test/EmitVerilog/../../utils/equiv-rtl.sh /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir.v /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.v test_mod
: 'RUN: at line 7';   /__w/circt/circt/integration_test/EmitVerilog/../../utils/equiv-rtl.sh /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.v test_unary
: 'RUN: at line 8';   /__w/circt/circt/integration_test/EmitVerilog/../../utils/equiv-rtl.sh /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.fir.v /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.v test_prim
--
Exit Code: 1

Command Output (stdout):
--
Comparing /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir.v and /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.v with test_mod Missing Dir .
PASS,INDUCT
Comparing /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v and /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.v with test_unary Missing Dir .
Trying SAT /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v and /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.v with test_unary Missing Dir .
FAIL

--
Command Output (stderr):
--
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
ERROR: Called with -verify and proof did fail!

--
```","FAIL: CIRCT :: EmitVerilog/verilog_equiv.fir (11 of 14)
******************** TEST 'CIRCT :: EmitVerilog/verilog_equiv.fir' FAILED ********************
Script:
--
: 'RUN: at line 2';   split-file /__w/circt/circt/integration_test/EmitVerilog/verilog_equiv.fir /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp
: 'RUN: at line 3';   /__w/circt/circt/build/bin/firtool /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir --format=fir --lower-to-rtl -verilog -o /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir.v
: 'RUN: at line 4';   /__w/circt/circt/build/bin/firtool /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir --format=fir --lower-to-rtl -verilog -o /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v
: 'RUN: at line 5';   /__w/circt/circt/build/bin/firtool /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.fir --format=fir --lower-to-rtl -verilog -o /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.fir.v
: 'RUN: at line 6';   /__w/circt/circt/integration_test/EmitVerilog/../../utils/equiv-rtl.sh /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir.v /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.v test_mod
: 'RUN: at line 7';   /__w/circt/circt/integration_test/EmitVerilog/../../utils/equiv-rtl.sh /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.v test_unary
: 'RUN: at line 8';   /__w/circt/circt/integration_test/EmitVerilog/../../utils/equiv-rtl.sh /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.fir.v /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.v test_prim
--
Exit Code: 1

Command Output (stdout):
--
Comparing /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir.v and /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.v with test_mod Missing Dir .
PASS,INDUCT
Comparing /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v and /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.v with test_unary Missing Dir .
Trying SAT /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v and /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.v with test_unary Missing Dir .
FAIL

--
Command Output (stderr):
--
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
ERROR: Called with -verify and proof did fail!

--",,,,,,,,,
841,[FIRRTL] counter mismatch,2021-03-29T17:33:42Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 22
circuit top_mod :
  module top_mod :
    input clock: Clock
    input arst: AsyncReset
    output _tmp16: UInt<10>
    reg state_9: UInt<10>, clock with: (reset => (arst, UInt<1>(0)))
    wire next_9: UInt<10>
    state_9 <= next_9
    next_9 <= add(state_9, UInt<1>(1))
    _tmp16 <= state_9
```

Compiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:

```verilog
...
module top_mod(
  input        clock, arst,
  output [9:0] _tmp16);

  reg  [9:0] state_9;	// a_top_mod.fir:7:5
  wire [9:0] next_9;	// a_top_mod.fir:8:5
  wire [9:0] _T;	// a_top_mod.fir:9:13

  always_ff @(posedge clock or posedge arst) begin	// a_top_mod.fir:7:5
    if (arst)	// a_top_mod.fir:7:5
      state_9 <= 10'h0;	// a_top_mod.fir:7:5
    else	// a_top_mod.fir:7:5
      state_9 <= _T;	// a_top_mod.fir:9:13
  end // always_ff @(posedge or posedge)
...
  assign _T = next_9;	// a_top_mod.fir:9:13
  wire [10:0] _T_0 = {1'h0, state_9} + 11'h1;	// a_top_mod.fir:7:57, :10:15
  assign next_9 = _T_0[9:0];	// a_top_mod.fir:10:12
  assign _tmp16 = state_9;	// a_top_mod.fir:3:3
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:

```verilog
module top_mod(
  input        clock,
  input        arst,
  output [9:0] _tmp16
);
...
  reg [9:0] state_9;
  wire [10:0] _GEN_0 = state_9 + 10'h1;
  assign _tmp16 = state_9;
  always @(posedge clock or posedge arst) begin
    if (arst) begin
      state_9 <= 10'h0;
    end else begin
      state_9 <= _GEN_0[9:0];
    end
  end
...
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
yosys 1
Warning: No SAT model available for cell $procdff$3_gold ($adff).
Warning: No SAT model available for cell $procdff$6_gate ($adff).
ERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.
```

That is maybe because of `ADFF` not found by YoSyS (investigating)
","; seed: 22
circuit top_mod :
  module top_mod :
    input clock: Clock
    input arst: AsyncReset
    output _tmp16: UInt<10>
    reg state_9: UInt<10>, clock with: (reset => (arst, UInt<1>(0)))
    wire next_9: UInt<10>
    state_9 <= next_9
    next_9 <= add(state_9, UInt<1>(1))
    _tmp16 <= state_9","...
module top_mod(
  input        clock, arst,
  output [9:0] _tmp16);

  reg  [9:0] state_9;	// a_top_mod.fir:7:5
  wire [9:0] next_9;	// a_top_mod.fir:8:5
  wire [9:0] _T;	// a_top_mod.fir:9:13

  always_ff @(posedge clock or posedge arst) begin	// a_top_mod.fir:7:5
    if (arst)	// a_top_mod.fir:7:5
      state_9 <= 10'h0;	// a_top_mod.fir:7:5
    else	// a_top_mod.fir:7:5
      state_9 <= _T;	// a_top_mod.fir:9:13
  end // always_ff @(posedge or posedge)
...
  assign _T = next_9;	// a_top_mod.fir:9:13
  wire [10:0] _T_0 = {1'h0, state_9} + 11'h1;	// a_top_mod.fir:7:57, :10:15
  assign next_9 = _T_0[9:0];	// a_top_mod.fir:10:12
  assign _tmp16 = state_9;	// a_top_mod.fir:3:3
endmodule","module top_mod(
  input        clock,
  input        arst,
  output [9:0] _tmp16
);
...
  reg [9:0] state_9;
  wire [10:0] _GEN_0 = state_9 + 10'h1;
  assign _tmp16 = state_9;
  always @(posedge clock or posedge arst) begin
    if (arst) begin
      state_9 <= 10'h0;
    end else begin
      state_9 <= _GEN_0[9:0];
    end
  end
...
endmodule","yosys 1
Warning: No SAT model available for cell $procdff$3_gold ($adff).
Warning: No SAT model available for cell $procdff$6_gate ($adff).
ERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.",,,,,,
839,multi-port memories can cause writes in different always blocks,2021-03-29T16:56:17Z,closed,"bug, FIRRTL","due to the clocks being assigned to wires and the wires not deliminated, the always blocks aren't merged.",,,,,,,,,,
838,wire generated in always block,2021-03-29T16:55:00Z,closed,"bug, ExportVerilog","Probably long name spilling.

```
circuit testcase :
  module testcase :
    input clock : Clock
    input reset : UInt<1>
    input io_enq_bits_prediction_branch_base_prediction : UInt<1>
    input io_deq_ready : UInt<1>
    output io_deq_bits_prediction_branch_prediction : UInt<1>
    output io_count : UInt<1>

    mem ram_prediction_branch_base_prediction : @[Decoupled.scala 218:16]
      data-type => UInt<1>
      depth => 1
      read-latency => 0
      write-latency => 1
      reader => io_deq_bits_MPORT
      writer => MPORT
      read-under-write => undefined
```

","circuit testcase :
  module testcase :
    input clock : Clock
    input reset : UInt<1>
    input io_enq_bits_prediction_branch_base_prediction : UInt<1>
    input io_deq_ready : UInt<1>
    output io_deq_bits_prediction_branch_prediction : UInt<1>
    output io_count : UInt<1>

    mem ram_prediction_branch_base_prediction : @[Decoupled.scala 218:16]
      data-type => UInt<1>
      depth => 1
      read-latency => 0
      write-latency => 1
      reader => io_deq_bits_MPORT
      writer => MPORT
      read-under-write => undefined",,,,,,,,,
832,[FIRRTL] vector (core dump),2021-03-26T19:13:47Z,closed,"bug, enhancement, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
 module top_mod :
   input addr: UInt<8>
   input wdata: UInt<8>
   output rdata: UInt<8>
   wire vec0: UInt<8>[4]
   vec0[addr] <= wdata
   rdata <= vec0[addr]
```

Compiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:

```mlir
firtool
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
1.       #0 0x000000000043d1cd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x43d1cd)
 #1 0x000000000043afd4 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x43afd4)
 #2 0x000000000043b133 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x43b133)
 #3 0x00007f765eb03a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #4 0x00000000005644c6 mlir::Type::getDialect() const (../../llvm/circt/build/bin/firtool+0x5644c6)
 #5 0x00000000005890a9 circt::firrtl::__mlir_ods_local_type_constraint_FIRRTL12(mlir::Operation*, mlir::Type, llvm::StringRef, unsigned int) /home/drom/work/github/llvm/circt/build/include/circt/Dialect/FIRRTL/FIRRTL.cpp.inc:143:3
 #6 0x00000000005a14ec circt::firrtl::SubaccessOp::verify() /home/drom/work/github/llvm/circt/build/include/circt/Dialect/FIRRTL/FIRRTL.cpp.inc:12308:7
 #7 0x000000000057599f mlir::Op<circt::firrtl::SubaccessOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::FIRRTLType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1713:3
 #8 0x0000000000566d74 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) (../../llvm/circt/build/bin/firtool+0x566d74)
 #9 0x00000000005671f8 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) (../../llvm/circt/build/bin/firtool+0x5671f8)
#10 0x00000000005671f8 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) (../../llvm/circt/build/bin/firtool+0x5671f8)
#11 0x0000000000568387 mlir::verify(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x568387)
#12 0x00000000006a7eea mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x6a7eea)
#13 0x00000000006a80c0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x6a80c0)
#14 0x00000000006a74e2 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x6a74e2)
#15 0x00000000006a7d26 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x6a7d26)
#16 0x00000000006a80c0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x6a80c0)
#17 0x00000000006ab144 mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x6ab144)
#18 0x000000000040c10c processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:210:3
#19 0x00000000004084ba processBufferIntoSingleStream /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:235:8
#20 0x00000000004084ba main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:304:15
#21 0x00007f765e571b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#22 0x0000000000409cee _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 26:  7889 Segmentation fault      (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2
```
Expected behavior: not to crash
","circuit top_mod :
 module top_mod :
   input addr: UInt<8>
   input wdata: UInt<8>
   output rdata: UInt<8>
   wire vec0: UInt<8>[4]
   vec0[addr] <= wdata
   rdata <= vec0[addr]","firtool
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
1.       #0 0x000000000043d1cd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x43d1cd)
 #1 0x000000000043afd4 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x43afd4)
 #2 0x000000000043b133 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x43b133)
 #3 0x00007f765eb03a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #4 0x00000000005644c6 mlir::Type::getDialect() const (../../llvm/circt/build/bin/firtool+0x5644c6)
 #5 0x00000000005890a9 circt::firrtl::__mlir_ods_local_type_constraint_FIRRTL12(mlir::Operation*, mlir::Type, llvm::StringRef, unsigned int) /home/drom/work/github/llvm/circt/build/include/circt/Dialect/FIRRTL/FIRRTL.cpp.inc:143:3
 #6 0x00000000005a14ec circt::firrtl::SubaccessOp::verify() /home/drom/work/github/llvm/circt/build/include/circt/Dialect/FIRRTL/FIRRTL.cpp.inc:12308:7
 #7 0x000000000057599f mlir::Op<circt::firrtl::SubaccessOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::FIRRTLType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1713:3
 #8 0x0000000000566d74 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) (../../llvm/circt/build/bin/firtool+0x566d74)
 #9 0x00000000005671f8 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) (../../llvm/circt/build/bin/firtool+0x5671f8)
#10 0x00000000005671f8 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) (../../llvm/circt/build/bin/firtool+0x5671f8)
#11 0x0000000000568387 mlir::verify(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x568387)
#12 0x00000000006a7eea mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x6a7eea)
#13 0x00000000006a80c0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x6a80c0)
#14 0x00000000006a74e2 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x6a74e2)
#15 0x00000000006a7d26 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x6a7d26)
#16 0x00000000006a80c0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x6a80c0)
#17 0x00000000006ab144 mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x6ab144)
#18 0x000000000040c10c processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:210:3
#19 0x00000000004084ba processBufferIntoSingleStream /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:235:8
#20 0x00000000004084ba main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:304:15
#21 0x00007f765e571b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#22 0x0000000000409cee _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 26:  7889 Segmentation fault      (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2",,,,,,,,
821,[FIRRTL] (neg) mismatch,2021-03-24T21:41:54Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 9902
circuit top_mod :
  module top_mod :
    input inp_f: UInt<2>
    output tmp32: SInt<3>
    tmp32 <= neg(inp_f)
```

Compiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:

```verilog
// Standard header to adapt well known macros to our needs.

module top_mod(
  input  [1:0] inp_f,
  output [2:0] tmp32);

  assign tmp32 = 3'h0 - {inp_f[1], inp_f};	// a_top_mod.fir:3:3, :6:14
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:

```verilog
module top_mod(
  input  [1:0] inp_f,
  output [2:0] tmp32
);
  assign tmp32 = 2'h0 - inp_f;
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
yosys 0
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 1
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 2
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
```
","; seed: 9902
circuit top_mod :
  module top_mod :
    input inp_f: UInt<2>
    output tmp32: SInt<3>
    tmp32 <= neg(inp_f)","// Standard header to adapt well known macros to our needs.

module top_mod(
  input  [1:0] inp_f,
  output [2:0] tmp32);

  assign tmp32 = 3'h0 - {inp_f[1], inp_f};	// a_top_mod.fir:3:3, :6:14
endmodule","module top_mod(
  input  [1:0] inp_f,
  output [2:0] tmp32
);
  assign tmp32 = 2'h0 - inp_f;
endmodule","yosys 0
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 1
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 2
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.",,,,,,
819,[MLIR] CSE pass doesn't work on graph regions,2021-03-24T18:23:37Z,closed,"bug, FIRRTL","The following FIRRTL program (Sorry it is quite long :( )

```python
; seed: 1184
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input arst: AsyncReset
    input inp_b: SInt<14>
    input inp_d: SInt<18>
    input inp_e: SInt<19>
    input inp_f: UInt<13>
    input inp_h: SInt<4>
    input inp_i: UInt<20>
    input inp_j: UInt<2>
    output tmp14: SInt<17>
    output _tmp15: UInt<16>
    output _tmp22: UInt<25>
    output tmp23: SInt<62>
    output _tmp32: UInt<24>
    output tmp36: UInt<1>
    wire tmp11: SInt<9>
    reg tmp12: SInt<9>, clock
    wire tmp13: SInt<9>
    reg tmp16: UInt<52>, clock
    wire tmp18: SInt<53>
    reg tmp19: UInt<7>, clock
    reg tmp21: SInt<10>, clock with: (reset => (arst, SInt<10>(0)))
    reg tmp24: SInt<48>, clock
    wire tmp26: SInt<3>
    reg tmp27: SInt<3>, clock with: (reset => (reset, SInt<3>(0)))
    wire tmp28: UInt<3>
    reg tmp29: SInt<136>, clock with: (reset => (reset, SInt<136>(0)))
    wire _tmp33: UInt<35>
    wire _tmp41: UInt<61>
    reg tmp44: SInt<8>, clock with: (reset => (reset, SInt<8>(0)))
    mem tmp10:
      data-type => SInt<9>
      depth => 5
      read-latency => 3
      write-latency => 1
      read-under-write => undefined
      reader => r0
      reader => r1
      reader => r2
      writer => w0
      writer => w1
    tmp10.r0.clk <= clock
    tmp10.r0.en <= head(UInt<20>(""hed052""), 1)
    tmp10.r0.addr <= inp_f
    tmp10.r1.clk <= clock
    tmp10.r1.en <= head(asUInt(inp_h), 1)
    tmp10.r1.addr <= UInt<4>(""h3"")
    tmp10.r2.clk <= clock
    tmp10.r2.en <= head(asUInt(inp_b), 1)
    tmp10.r2.addr <= UInt<9>(407)
    tmp10.w0.clk <= clock
    tmp10.w0.en <= head(asUInt(SInt<28>(""o-677523445"")), 1)
    tmp10.w0.addr <= inp_i
    tmp10.w0.data <= inp_d
    tmp10.w0.mask <= asUInt(inp_h)
    tmp10.w1.clk <= clock
    tmp10.w1.en <= head(asUInt(SInt<24>(-2844022)), 1)
    tmp10.w1.addr <= inp_j
    tmp10.w1.data <= asSInt(inp_f)
    tmp10.w1.mask <= asUInt(inp_e)
    tmp11 <= tmp10.r0.data
    tmp12 <= tmp10.r1.data
    tmp13 <= tmp10.r2.data
    tmp14 <= cvt(UInt<16>(""b1010110101101010""))
    _tmp15 <= xor(UInt<16>(25416), asUInt(tmp11))
    tmp16 <= cat(UInt<29>(""b1101001100011010100110110""), UInt<23>(""o23563727""))
    tmp18 <= neg(tmp16)
    tmp19 <= bits(UInt<16>(""h80db""), 14, 8)
    assume(clock, xorr(tmp19), xorr(tmp19), ""assume20"")
    tmp21 <= cvt(UInt<9>(472))
    _tmp22 <= div(UInt<25>(""o62507467""), UInt<30>(""h277f039a""))
    tmp23 <= mul(tmp18, tmp13)
    tmp24 <= shl(SInt<27>(""o24631356""), 21)
    mem tmp25:
      data-type => SInt<3>
      depth => 6
      read-latency => 2
      write-latency => 2
      read-under-write => undefined
      reader => r0
      reader => r1
      writer => w0
      writer => w1
    tmp25.r0.clk <= clock
    tmp25.r0.en <= asUInt(SInt<1>(""o0""))
    tmp25.r0.addr <= UInt<26>(49066379)
    tmp25.r1.clk <= clock
    tmp25.r1.en <= head(UInt<25>(19922223), 1)
    tmp25.r1.addr <= UInt<28>(140227115)
    tmp25.w0.clk <= clock
    tmp25.w0.en <= head(asUInt(SInt<18>(""b11010110111000011"")), 1)
    tmp25.w0.addr <= UInt<12>(""b111111000011"")
    tmp25.w0.data <= asSInt(inp_j)
    tmp25.w0.mask <= tmp19
    tmp25.w1.clk <= clock
    tmp25.w1.en <= head(asUInt(inp_d), 1)
    tmp25.w1.addr <= asUInt(SInt<16>(-8793))
    tmp25.w1.data <= asSInt(tmp19)
    tmp25.w1.mask <= asUInt(tmp24)
    tmp26 <= tmp25.r0.data
    tmp27 <= tmp25.r1.data
    tmp28 <= asUInt(UInt<3>(""o5""))
    tmp29 <= dshl(SInt<9>(""b-101000""), tail(UInt<13>(3084), 6))
    skip
    _tmp32 <= xor(inp_f, UInt<24>(848336))
    _tmp33 <= mul(UInt<17>(""o261646""), asUInt(inp_d))
    mem tmp34:
      data-type => SInt<8>
      depth => 6
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
      writer => w1
    tmp34.r0.clk <= clock
    tmp34.r0.en <= head(asUInt(tmp13), 1)
    tmp34.r0.addr <= UInt<21>(1533690)
    tmp34.w0.clk <= clock
    tmp34.w0.en <= head(tmp28, 1)
    tmp34.w0.addr <= UInt<10>(631)
    tmp34.w0.data <= SInt<6>(""o-25"")
    tmp34.w0.mask <= asUInt(inp_e)
    tmp34.w1.clk <= clock
    tmp34.w1.en <= asUInt(SInt<1>(""b-1""))
    tmp34.w1.addr <= inp_f
    tmp34.w1.data <= tmp26
    tmp34.w1.mask <= UInt<5>(""h18"")
    tmp36 <= neq(asSInt(inp_j), SInt<16>(""h8a0""))
    _tmp41 <= mul(asUInt(tmp24), inp_f)
    mem tmp42:
      data-type => SInt<8>
      depth => 15
      read-latency => 1
      write-latency => 2
      read-under-write => undefined
      reader => r0
      reader => r1
      writer => w0
    tmp42.r0.clk <= clock
    tmp42.r0.en <= head(UInt<10>(966), 1)
    tmp42.r0.addr <= asUInt(SInt<20>(""h-3d191""))
    tmp42.r1.clk <= clock
    tmp42.r1.en <= head(asUInt(SInt<7>(""h2e"")), 1)
    tmp42.r1.addr <= UInt<12>(""he84"")
    tmp42.w0.clk <= clock
    tmp42.w0.en <= head(asUInt(SInt<5>(""o15"")), 1)
    tmp42.w0.addr <= asUInt(inp_e)
    tmp42.w0.data <= asSInt(_tmp33)
    tmp42.w0.mask <= UInt<12>(1246)
    tmp44 <= tmp42.r1.data
```

Compiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:

```mlir
firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:408: void llvm::DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT>::moveFromOldBuckets(BucketT*, BucketT*) [with DerivedT = llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, {anonymous}::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >; KeyT = mlir::Operation*; ValueT = llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*; KeyInfoT = {anonymous}::SimpleOperationInfo; BucketT = llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>]: Assertion `!FoundVal && ""Key already in new map?""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
 #0 0x00000000004bc7a7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004bc85e PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004ba85e llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bc1fa SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f3e9eb69a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #5 0x00007f3e9e5ed4a5 raise (/lib64/libc.so.6+0x3d4a5)
 #6 0x00007f3e9e5d6864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f3e9e5d6749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f3e9e5e59b6 (/lib64/libc.so.6+0x359b6)
 #9 0x00000000006f9dca llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::moveFromOldBuckets(llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:409:43
#10 0x00000000006f9bd3 llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::grow(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:816:53
#11 0x00000000006f9888 llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::grow(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:538:3
#12 0x00000000006f9265 llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>* llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::InsertIntoBucketImpl<mlir::Operation*>(mlir::Operation* const&, mlir::Operation* const&, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:582:22
#13 0x00000000006f8813 llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>* llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::InsertIntoBucket<mlir::Operation* const&>(llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*, mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:547:37
#14 0x00000000006f7b0e llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::FindAndConstruct(mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:326:44
#15 0x00000000006f6d6b llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::operator[](mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:330:34
#16 0x00000000006f7002 llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >::insertIntoScope(llvm::ScopedHashTableScope<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >*, mlir::Operation* const&, mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:218:54
#17 0x00000000006f6670 llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >::insert(mlir::Operation* const&, mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:196:3
#18 0x00000000006f5cf3 (anonymous namespace)::CSE::simplifyOperation(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:135:18
#19 0x00000000006f5dd6 (anonymous namespace)::CSE::simplifyBlock(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Block*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:142:18
#20 0x00000000006f6009 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43
#21 0x00000000006f5e77 (anonymous namespace)::CSE::simplifyBlock(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Block*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:150:7
#22 0x00000000006f6009 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43
#23 0x00000000006f62b1 (anonymous namespace)::CSE::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:219:3
#24 0x00000000008cd9b5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36
#25 0x00000000008cdbe1 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15
#26 0x00000000008cfd21 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74
#27 0x000000000040dd68 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dd68)
#28 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)
#29 0x00007f3e9e5d7b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#30 0x000000000040b58e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: строка 26: 13458 Aborted                 (стек памяти сброшен на диск) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2
```

firrtl-1.5.0-SNAPSHOT produces Verilog
","; seed: 1184
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input arst: AsyncReset
    input inp_b: SInt<14>
    input inp_d: SInt<18>
    input inp_e: SInt<19>
    input inp_f: UInt<13>
    input inp_h: SInt<4>
    input inp_i: UInt<20>
    input inp_j: UInt<2>
    output tmp14: SInt<17>
    output _tmp15: UInt<16>
    output _tmp22: UInt<25>
    output tmp23: SInt<62>
    output _tmp32: UInt<24>
    output tmp36: UInt<1>
    wire tmp11: SInt<9>
    reg tmp12: SInt<9>, clock
    wire tmp13: SInt<9>
    reg tmp16: UInt<52>, clock
    wire tmp18: SInt<53>
    reg tmp19: UInt<7>, clock
    reg tmp21: SInt<10>, clock with: (reset => (arst, SInt<10>(0)))
    reg tmp24: SInt<48>, clock
    wire tmp26: SInt<3>
    reg tmp27: SInt<3>, clock with: (reset => (reset, SInt<3>(0)))
    wire tmp28: UInt<3>
    reg tmp29: SInt<136>, clock with: (reset => (reset, SInt<136>(0)))
    wire _tmp33: UInt<35>
    wire _tmp41: UInt<61>
    reg tmp44: SInt<8>, clock with: (reset => (reset, SInt<8>(0)))
    mem tmp10:
      data-type => SInt<9>
      depth => 5
      read-latency => 3
      write-latency => 1
      read-under-write => undefined
      reader => r0
      reader => r1
      reader => r2
      writer => w0
      writer => w1
    tmp10.r0.clk <= clock
    tmp10.r0.en <= head(UInt<20>(""hed052""), 1)
    tmp10.r0.addr <= inp_f
    tmp10.r1.clk <= clock
    tmp10.r1.en <= head(asUInt(inp_h), 1)
    tmp10.r1.addr <= UInt<4>(""h3"")
    tmp10.r2.clk <= clock
    tmp10.r2.en <= head(asUInt(inp_b), 1)
    tmp10.r2.addr <= UInt<9>(407)
    tmp10.w0.clk <= clock
    tmp10.w0.en <= head(asUInt(SInt<28>(""o-677523445"")), 1)
    tmp10.w0.addr <= inp_i
    tmp10.w0.data <= inp_d
    tmp10.w0.mask <= asUInt(inp_h)
    tmp10.w1.clk <= clock
    tmp10.w1.en <= head(asUInt(SInt<24>(-2844022)), 1)
    tmp10.w1.addr <= inp_j
    tmp10.w1.data <= asSInt(inp_f)
    tmp10.w1.mask <= asUInt(inp_e)
    tmp11 <= tmp10.r0.data
    tmp12 <= tmp10.r1.data
    tmp13 <= tmp10.r2.data
    tmp14 <= cvt(UInt<16>(""b1010110101101010""))
    _tmp15 <= xor(UInt<16>(25416), asUInt(tmp11))
    tmp16 <= cat(UInt<29>(""b1101001100011010100110110""), UInt<23>(""o23563727""))
    tmp18 <= neg(tmp16)
    tmp19 <= bits(UInt<16>(""h80db""), 14, 8)
    assume(clock, xorr(tmp19), xorr(tmp19), ""assume20"")
    tmp21 <= cvt(UInt<9>(472))
    _tmp22 <= div(UInt<25>(""o62507467""), UInt<30>(""h277f039a""))
    tmp23 <= mul(tmp18, tmp13)
    tmp24 <= shl(SInt<27>(""o24631356""), 21)
    mem tmp25:
      data-type => SInt<3>
      depth => 6
      read-latency => 2
      write-latency => 2
      read-under-write => undefined
      reader => r0
      reader => r1
      writer => w0
      writer => w1
    tmp25.r0.clk <= clock
    tmp25.r0.en <= asUInt(SInt<1>(""o0""))
    tmp25.r0.addr <= UInt<26>(49066379)
    tmp25.r1.clk <= clock
    tmp25.r1.en <= head(UInt<25>(19922223), 1)
    tmp25.r1.addr <= UInt<28>(140227115)
    tmp25.w0.clk <= clock
    tmp25.w0.en <= head(asUInt(SInt<18>(""b11010110111000011"")), 1)
    tmp25.w0.addr <= UInt<12>(""b111111000011"")
    tmp25.w0.data <= asSInt(inp_j)
    tmp25.w0.mask <= tmp19
    tmp25.w1.clk <= clock
    tmp25.w1.en <= head(asUInt(inp_d), 1)
    tmp25.w1.addr <= asUInt(SInt<16>(-8793))
    tmp25.w1.data <= asSInt(tmp19)
    tmp25.w1.mask <= asUInt(tmp24)
    tmp26 <= tmp25.r0.data
    tmp27 <= tmp25.r1.data
    tmp28 <= asUInt(UInt<3>(""o5""))
    tmp29 <= dshl(SInt<9>(""b-101000""), tail(UInt<13>(3084), 6))
    skip
    _tmp32 <= xor(inp_f, UInt<24>(848336))
    _tmp33 <= mul(UInt<17>(""o261646""), asUInt(inp_d))
    mem tmp34:
      data-type => SInt<8>
      depth => 6
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
      writer => w1
    tmp34.r0.clk <= clock
    tmp34.r0.en <= head(asUInt(tmp13), 1)
    tmp34.r0.addr <= UInt<21>(1533690)
    tmp34.w0.clk <= clock
    tmp34.w0.en <= head(tmp28, 1)
    tmp34.w0.addr <= UInt<10>(631)
    tmp34.w0.data <= SInt<6>(""o-25"")
    tmp34.w0.mask <= asUInt(inp_e)
    tmp34.w1.clk <= clock
    tmp34.w1.en <= asUInt(SInt<1>(""b-1""))
    tmp34.w1.addr <= inp_f
    tmp34.w1.data <= tmp26
    tmp34.w1.mask <= UInt<5>(""h18"")
    tmp36 <= neq(asSInt(inp_j), SInt<16>(""h8a0""))
    _tmp41 <= mul(asUInt(tmp24), inp_f)
    mem tmp42:
      data-type => SInt<8>
      depth => 15
      read-latency => 1
      write-latency => 2
      read-under-write => undefined
      reader => r0
      reader => r1
      writer => w0
    tmp42.r0.clk <= clock
    tmp42.r0.en <= head(UInt<10>(966), 1)
    tmp42.r0.addr <= asUInt(SInt<20>(""h-3d191""))
    tmp42.r1.clk <= clock
    tmp42.r1.en <= head(asUInt(SInt<7>(""h2e"")), 1)
    tmp42.r1.addr <= UInt<12>(""he84"")
    tmp42.w0.clk <= clock
    tmp42.w0.en <= head(asUInt(SInt<5>(""o15"")), 1)
    tmp42.w0.addr <= asUInt(inp_e)
    tmp42.w0.data <= asSInt(_tmp33)
    tmp42.w0.mask <= UInt<12>(1246)
    tmp44 <= tmp42.r1.data","firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:408: void llvm::DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT>::moveFromOldBuckets(BucketT*, BucketT*) [with DerivedT = llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, {anonymous}::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >; KeyT = mlir::Operation*; ValueT = llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*; KeyInfoT = {anonymous}::SimpleOperationInfo; BucketT = llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>]: Assertion `!FoundVal && ""Key already in new map?""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
 #0 0x00000000004bc7a7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004bc85e PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004ba85e llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bc1fa SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f3e9eb69a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #5 0x00007f3e9e5ed4a5 raise (/lib64/libc.so.6+0x3d4a5)
 #6 0x00007f3e9e5d6864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f3e9e5d6749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f3e9e5e59b6 (/lib64/libc.so.6+0x359b6)
 #9 0x00000000006f9dca llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::moveFromOldBuckets(llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:409:43
#10 0x00000000006f9bd3 llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::grow(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:816:53
#11 0x00000000006f9888 llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::grow(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:538:3
#12 0x00000000006f9265 llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>* llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::InsertIntoBucketImpl<mlir::Operation*>(mlir::Operation* const&, mlir::Operation* const&, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:582:22
#13 0x00000000006f8813 llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>* llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::InsertIntoBucket<mlir::Operation* const&>(llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*, mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:547:37
#14 0x00000000006f7b0e llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::FindAndConstruct(mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:326:44
#15 0x00000000006f6d6b llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::operator[](mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:330:34
#16 0x00000000006f7002 llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >::insertIntoScope(llvm::ScopedHashTableScope<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >*, mlir::Operation* const&, mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:218:54
#17 0x00000000006f6670 llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >::insert(mlir::Operation* const&, mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:196:3
#18 0x00000000006f5cf3 (anonymous namespace)::CSE::simplifyOperation(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:135:18
#19 0x00000000006f5dd6 (anonymous namespace)::CSE::simplifyBlock(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Block*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:142:18
#20 0x00000000006f6009 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43
#21 0x00000000006f5e77 (anonymous namespace)::CSE::simplifyBlock(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Block*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:150:7
#22 0x00000000006f6009 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43
#23 0x00000000006f62b1 (anonymous namespace)::CSE::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:219:3
#24 0x00000000008cd9b5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36
#25 0x00000000008cdbe1 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15
#26 0x00000000008cfd21 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74
#27 0x000000000040dd68 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dd68)
#28 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)
#29 0x00007f3e9e5d7b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#30 0x000000000040b58e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: строка 26: 13458 Aborted                 (стек памяти сброшен на диск) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2",,,,,,,,
813,"[MLIR] CSE pass: ThisEntry && ""Scope imbalance!""' (core dump)",2021-03-24T03:41:35Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 27
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input inp_b: SInt<1>
    input inp_d: UInt<11>
    input inp_g: UInt<18>
    input inp_h: SInt<3>
    input inp_i: SInt<1>
    reg tmp11: UInt<1>, clock
    reg tmp12: UInt<3>, clock
    wire tmp15: UInt<18>
    reg tmp19: SInt<5>, clock with: (reset => (reset, SInt<5>(0)))
    wire _tmp22: SInt<20>
    wire tmp32: SInt<32>
    tmp11 <= neq(inp_i, inp_h)
    tmp12 <= not(inp_h)
    tmp15 <= div(inp_g, UInt<6>(0))
    _tmp22 <= mul(inp_b, asSInt(UInt<19>(0)))
    tmp32 <= dshl(SInt<1>(""b-1""), head(tmp15, 5))
    mem tmp33:
      data-type => UInt<5>
      depth => 12
      read-latency => 2
      write-latency => 1
      read-under-write => undefined
      reader => r0
      reader => r1
      reader => r2
      writer => w0
      writer => w1
    tmp33.r0.clk <= clock
    tmp33.r0.en <= UInt<1>(1)
    tmp33.r0.addr <= UInt<7>(0)
    tmp33.r1.clk <= clock
    tmp33.r1.en <= UInt<1>(1)
    tmp33.r1.addr <= asUInt(_tmp22)
    tmp33.r2.clk <= clock
    tmp33.r2.en <= UInt<1>(1)
    tmp33.r2.addr <= inp_d
    tmp33.w0.clk <= clock
    tmp33.w0.en <= UInt<1>(1)
    tmp33.w0.addr <= UInt<19>(357565)
    tmp33.w0.data <= UInt<9>(118)
    tmp33.w0.mask <= tmp12
    tmp33.w1.clk <= clock
    tmp33.w1.en <= UInt<1>(1)
    tmp33.w1.addr <= UInt<1>(1)
    tmp33.w1.data <= asUInt(tmp32)
    tmp33.w1.mask <= tmp12
```

Compiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:

```mlir
firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:244: llvm::ScopedHashTableScope<K, V, KInfo, AllocatorTy>::~ScopedHashTableScope() [with K = mlir::Operation*; V = mlir::Operation*; KInfo = {anonymous}::SimpleOperationInfo; AllocatorTy = llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*> >]: Assertion `HT.TopLevelMap[ThisEntry->getKey()] == ThisEntry && ""Scope imbalance!""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
 #0 0x00000000004bc7a7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004bc85e PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004ba85e llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bc1fa SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007efe9a1f2a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #5 0x00007efe99c764a5 raise (/lib64/libc.so.6+0x3d4a5)
 #6 0x00007efe99c5f864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007efe99c5f749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007efe99c6e9b6 (/lib64/libc.so.6+0x359b6)
 #9 0x00000000006f65ce llvm::ScopedHashTableScope<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >::~ScopedHashTableScope() /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:244:7
#10 0x00000000006f60e8 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43
#11 0x00000000006f5f47 (anonymous namespace)::CSE::simplifyBlock(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Block*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:150:7
#12 0x00000000006f60d9 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43
#13 0x00000000006f6381 (anonymous namespace)::CSE::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:219:3
#14 0x00000000008cda85 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36
#15 0x00000000008cdcb1 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15
#16 0x00000000008cfdf1 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74
#17 0x000000000040dd68 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dd68)
#18 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)
#19 0x00007efe99c60b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#20 0x000000000040b58e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: строка 26: 16934 Aborted                 (стек памяти сброшен на диск) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2
```

firrtl-1.5.0-SNAPSHOT produces this Verilog:

```verilog
module top_mod(
  input         clock,
  input         reset,
  input         inp_b,
  input  [10:0] inp_d,
  input  [17:0] inp_g,
  input  [2:0]  inp_h,
  input         inp_i
);
endmodule
```","; seed: 27
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input inp_b: SInt<1>
    input inp_d: UInt<11>
    input inp_g: UInt<18>
    input inp_h: SInt<3>
    input inp_i: SInt<1>
    reg tmp11: UInt<1>, clock
    reg tmp12: UInt<3>, clock
    wire tmp15: UInt<18>
    reg tmp19: SInt<5>, clock with: (reset => (reset, SInt<5>(0)))
    wire _tmp22: SInt<20>
    wire tmp32: SInt<32>
    tmp11 <= neq(inp_i, inp_h)
    tmp12 <= not(inp_h)
    tmp15 <= div(inp_g, UInt<6>(0))
    _tmp22 <= mul(inp_b, asSInt(UInt<19>(0)))
    tmp32 <= dshl(SInt<1>(""b-1""), head(tmp15, 5))
    mem tmp33:
      data-type => UInt<5>
      depth => 12
      read-latency => 2
      write-latency => 1
      read-under-write => undefined
      reader => r0
      reader => r1
      reader => r2
      writer => w0
      writer => w1
    tmp33.r0.clk <= clock
    tmp33.r0.en <= UInt<1>(1)
    tmp33.r0.addr <= UInt<7>(0)
    tmp33.r1.clk <= clock
    tmp33.r1.en <= UInt<1>(1)
    tmp33.r1.addr <= asUInt(_tmp22)
    tmp33.r2.clk <= clock
    tmp33.r2.en <= UInt<1>(1)
    tmp33.r2.addr <= inp_d
    tmp33.w0.clk <= clock
    tmp33.w0.en <= UInt<1>(1)
    tmp33.w0.addr <= UInt<19>(357565)
    tmp33.w0.data <= UInt<9>(118)
    tmp33.w0.mask <= tmp12
    tmp33.w1.clk <= clock
    tmp33.w1.en <= UInt<1>(1)
    tmp33.w1.addr <= UInt<1>(1)
    tmp33.w1.data <= asUInt(tmp32)
    tmp33.w1.mask <= tmp12","firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:244: llvm::ScopedHashTableScope<K, V, KInfo, AllocatorTy>::~ScopedHashTableScope() [with K = mlir::Operation*; V = mlir::Operation*; KInfo = {anonymous}::SimpleOperationInfo; AllocatorTy = llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*> >]: Assertion `HT.TopLevelMap[ThisEntry->getKey()] == ThisEntry && ""Scope imbalance!""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
 #0 0x00000000004bc7a7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004bc85e PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004ba85e llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bc1fa SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007efe9a1f2a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #5 0x00007efe99c764a5 raise (/lib64/libc.so.6+0x3d4a5)
 #6 0x00007efe99c5f864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007efe99c5f749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007efe99c6e9b6 (/lib64/libc.so.6+0x359b6)
 #9 0x00000000006f65ce llvm::ScopedHashTableScope<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >::~ScopedHashTableScope() /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:244:7
#10 0x00000000006f60e8 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43
#11 0x00000000006f5f47 (anonymous namespace)::CSE::simplifyBlock(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Block*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:150:7
#12 0x00000000006f60d9 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43
#13 0x00000000006f6381 (anonymous namespace)::CSE::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:219:3
#14 0x00000000008cda85 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36
#15 0x00000000008cdcb1 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15
#16 0x00000000008cfdf1 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74
#17 0x000000000040dd68 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dd68)
#18 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)
#19 0x00007efe99c60b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#20 0x000000000040b58e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: строка 26: 16934 Aborted                 (стек памяти сброшен на диск) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2","module top_mod(
  input         clock,
  input         reset,
  input         inp_b,
  input  [10:0] inp_d,
  input  [17:0] inp_g,
  input  [2:0]  inp_h,
  input         inp_i
);
endmodule",,,,,,,
812,[FIRRTL] unexpected stdout,2021-03-24T01:14:59Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input r0en: UInt<1>
    mem tmp41:
      data-type => UInt<8>
      depth => 10
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp41.r0.clk <= clock
    tmp41.r0.en <= r0en
    tmp41.r0.addr <= asUInt(SInt<25>(0))
    tmp41.w0.clk <= clock
    tmp41.w0.en <= r0en
    tmp41.w0.addr <= asUInt(SInt<25>(0))
    tmp41.w0.mask <= asUInt(SInt<25>(0))
    tmp41.w0.data <= asUInt(SInt<25>(0))
```

Compiled with `firtool --lower-to-rtl --enable-lower-types --verilog` produces unexpected `stdout` output:

```
%tmp41_r0_addr = sv.wire  : !rtl.inout<i4>
%tmp41_r0_addr = sv.wire  : !rtl.inout<i4>
%tmp41_r0_en = sv.wire  : !rtl.inout<i1>
%tmp41_r0_en = sv.wire  : !rtl.inout<i1>
%tmp41_r0_clk = sv.wire  : !rtl.inout<i1>
%tmp41_r0_clk = sv.wire  : !rtl.inout<i1>
%tmp41_r0_data = sv.wire  : !rtl.inout<i8>
%tmp41_r0_data = sv.wire  : !rtl.inout<i8>
%tmp41_w0_addr = sv.wire  : !rtl.inout<i4>
%tmp41_w0_addr = sv.wire  : !rtl.inout<i4>
%tmp41_w0_en = sv.wire  : !rtl.inout<i1>
%tmp41_w0_en = sv.wire  : !rtl.inout<i1>
%tmp41_w0_clk = sv.wire  : !rtl.inout<i1>
%tmp41_w0_clk = sv.wire  : !rtl.inout<i1>
%tmp41_w0_data = sv.wire  : !rtl.inout<i8>
%tmp41_w0_data = sv.wire  : !rtl.inout<i8>
%tmp41_w0_mask = sv.wire  : !rtl.inout<i1>
%tmp41_w0_mask = sv.wire  : !rtl.inout<i1>
```
","circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input r0en: UInt<1>
    mem tmp41:
      data-type => UInt<8>
      depth => 10
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp41.r0.clk <= clock
    tmp41.r0.en <= r0en
    tmp41.r0.addr <= asUInt(SInt<25>(0))
    tmp41.w0.clk <= clock
    tmp41.w0.en <= r0en
    tmp41.w0.addr <= asUInt(SInt<25>(0))
    tmp41.w0.mask <= asUInt(SInt<25>(0))
    tmp41.w0.data <= asUInt(SInt<25>(0))","%tmp41_r0_addr = sv.wire  : !rtl.inout<i4>
%tmp41_r0_addr = sv.wire  : !rtl.inout<i4>
%tmp41_r0_en = sv.wire  : !rtl.inout<i1>
%tmp41_r0_en = sv.wire  : !rtl.inout<i1>
%tmp41_r0_clk = sv.wire  : !rtl.inout<i1>
%tmp41_r0_clk = sv.wire  : !rtl.inout<i1>
%tmp41_r0_data = sv.wire  : !rtl.inout<i8>
%tmp41_r0_data = sv.wire  : !rtl.inout<i8>
%tmp41_w0_addr = sv.wire  : !rtl.inout<i4>
%tmp41_w0_addr = sv.wire  : !rtl.inout<i4>
%tmp41_w0_en = sv.wire  : !rtl.inout<i1>
%tmp41_w0_en = sv.wire  : !rtl.inout<i1>
%tmp41_w0_clk = sv.wire  : !rtl.inout<i1>
%tmp41_w0_clk = sv.wire  : !rtl.inout<i1>
%tmp41_w0_data = sv.wire  : !rtl.inout<i8>
%tmp41_w0_data = sv.wire  : !rtl.inout<i8>
%tmp41_w0_mask = sv.wire  : !rtl.inout<i1>
%tmp41_w0_mask = sv.wire  : !rtl.inout<i1>",,,,,,,,
806,[LLHD] llhd-sim unable to simulate generated llhd dialect ,2021-03-22T22:30:35Z,open,"bug, LLHD","To simulate below llhd:

```
llhd.entity @adder(%clk: !llhd.sig, %res: !llhd.sig) → (%i5_output: !llhd.sig ) {
%0 = llhd.const #llhd.time<0s, 0d, 1e> : !llhd.time
%1 = llhd.const 16 : i32
llhd.drv %i5_output, %1 after %0 : !llhd.sig
}
```

shows this error:

```
Assertion failed: (idx < size()), function operator[], file …/llvm/llvm/include/llvm/ADT/SmallVector.h, line 277.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0. Program arguments: …/build/bin/llhd-sim addersvllhd.mlir -n 10 -r adder
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var LLVM_SYMBOLIZER_PATH to point to it):
0 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca593d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca5eeb PrintStackTraceSignalHandler(void*) + 27
2 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca3a6b llvm::sys::RunSignalHandlers() + 123
3 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca83f8 SignalHandler(int) + 232
4 libsystem_platform.dylib 0x00007fff6af445fd _sigtramp + 29
5 libdyld.dylib 0x00007fff6ad4a78f dyldGlobalLockRelease() + 0
6 libsystem_c.dylib 0x00007fff6ae1a808 abort + 120
7 libsystem_c.dylib 0x00007fff6ae19ac6 err + 0
8 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4fa48 llvm::SmallVectorTemplateCommon<circt::llhd::sim::Signal, void>::operator[](unsigned long) + 104
9 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4f912 driveSignal + 178
10 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011e1240f1 driveSignal + 6113425
11 llhd-sim 0x000000010acda78e main + 1518
12 libdyld.dylib 0x00007fff6ad4bcc9 start + 1
```

My command to llhd-sim is -n 10 -r adder and I think the expect behaviour should be a constant signal at the output (signal i5_output being constantly at value 16). I was able to trace the code till line 235 of engine.cpp 

(ps: this is not the full code for my sv; I have reduced it to the simplest form to see if I can get an output. Originally my code just aborted when the reaches the adder.adder entity in state.)","llhd.entity @adder(%clk: !llhd.sig, %res: !llhd.sig) → (%i5_output: !llhd.sig ) {
%0 = llhd.const #llhd.time<0s, 0d, 1e> : !llhd.time
%1 = llhd.const 16 : i32
llhd.drv %i5_output, %1 after %0 : !llhd.sig
}","Assertion failed: (idx < size()), function operator[], file …/llvm/llvm/include/llvm/ADT/SmallVector.h, line 277.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0. Program arguments: …/build/bin/llhd-sim addersvllhd.mlir -n 10 -r adder
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var LLVM_SYMBOLIZER_PATH to point to it):
0 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca593d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca5eeb PrintStackTraceSignalHandler(void*) + 27
2 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca3a6b llvm::sys::RunSignalHandlers() + 123
3 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca83f8 SignalHandler(int) + 232
4 libsystem_platform.dylib 0x00007fff6af445fd _sigtramp + 29
5 libdyld.dylib 0x00007fff6ad4a78f dyldGlobalLockRelease() + 0
6 libsystem_c.dylib 0x00007fff6ae1a808 abort + 120
7 libsystem_c.dylib 0x00007fff6ae19ac6 err + 0
8 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4fa48 llvm::SmallVectorTemplateCommon<circt::llhd::sim::Signal, void>::operator[](unsigned long) + 104
9 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4f912 driveSignal + 178
10 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011e1240f1 driveSignal + 6113425
11 llhd-sim 0x000000010acda78e main + 1518
12 libdyld.dylib 0x00007fff6ad4bcc9 start + 1",,,,,,,,
796,"[FIRRTL] Memory leak, possibly from creating bundle types",2021-03-19T18:32:47Z,closed,"bug, FIRRTL","In https://github.com/llvm/circt/issues/775, it looked like there was a memory leak when running fir tool with valgrind: 
```
==7544==    definitely lost: 67,728 bytes in 2 blocks
==7544==    indirectly lost: 0 bytes in 0 blocks
==7544==      possibly lost: 0 bytes in 0 blocks
==7544==    still reachable: 40 bytes in 1 blocks
==7544==         suppressed: 0 bytes in 0 blocks
```

I don't think there is a specific test case needed to reproduce. You can get more information out of valgrind by running `valgrind --leak-check=full --num-callers=50 firtool ...`

I briefly looked at the backtrace and it looked like something from a created bundle type was leaked. I don’t know what the issue is, but this might be relevant: https://github.com/llvm/llvm-project/commit/31bb8efd698304a8385ff79229ffbaa5613efdfb. This MLIR change is soon to be included in circt: https://github.com/llvm/circt/pull/792.","==7544==    definitely lost: 67,728 bytes in 2 blocks
==7544==    indirectly lost: 0 bytes in 0 blocks
==7544==      possibly lost: 0 bytes in 0 blocks
==7544==    still reachable: 40 bytes in 1 blocks
==7544==         suppressed: 0 bytes in 0 blocks",,,,,,,,,
795,[FIRRTL] Type lowering of registers crashes if name attribute not present,2021-03-19T18:28:07Z,closed,bug,"Operation name attribute is accessed without checking if it exists, at several places in LowerTypes, 
https://github.com/llvm/circt/blob/main/lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp#L574

```mlir
module  {
  firrtl.circuit ""Foo"" {
    firrtl.module @Foo(%clock: !firrtl.clock, %a_d: !firrtl.vector<uint<1>, 2>, %a_q: !firrtl.flip<vector<uint<1>, 2>>) {
      %r = firrtl.reg %clock : (!firrtl.clock) -> !firrtl.vector<uint<1>, 2>
      firrtl.connect %r, %a_d : !firrtl.vector<uint<1>, 2>, !firrtl.vector<uint<1>, 2>
      firrtl.connect %a_q, %r : !firrtl.flip<vector<uint<1>, 2>>, !firrtl.vector<uint<1>, 2>
    }
  }
}
```
On running ``` circt-opt -pass-pipeline='firrtl.circuit(firrtl-lower-types)'``` produces the following crash, 
```
0.      Program arguments: circt-opt -pass-pipeline=firrtl.circuit(firrtl-lower-types) crash.mlir
1.      2.       #0 0x00000000013b163e llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:0
 #1 0x00000000013b16f5 PrintStackTraceSignalHandler(void*) /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:0
 #2 0x00000000013af3b3 llvm::sys::RunSignalHandlers() /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Signals.cpp:71:0
 #3 0x00000000013b0fbf SignalHandler(int) /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:0
 #4 0x00007fc273131890 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x12890)
 #5 0x00000000008361d4 mlir::StringAttr::getValue() const /home/prithayan/work/sifive/fork-circt/circt/llvm/build/tools/mlir/include/mlir/IR/BuiltinAttributes.cpp.inc:266:0
 #6 0x000000000043d1b3 (anonymous namespace)::TypeLoweringVisitor::visitDecl(circt::firrtl::RegOp) /home/prithayan/work/sifive/fork-circt/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:574:47
```","module  {
  firrtl.circuit ""Foo"" {
    firrtl.module @Foo(%clock: !firrtl.clock, %a_d: !firrtl.vector<uint<1>, 2>, %a_q: !firrtl.flip<vector<uint<1>, 2>>) {
      %r = firrtl.reg %clock : (!firrtl.clock) -> !firrtl.vector<uint<1>, 2>
      firrtl.connect %r, %a_d : !firrtl.vector<uint<1>, 2>, !firrtl.vector<uint<1>, 2>
      firrtl.connect %a_q, %r : !firrtl.flip<vector<uint<1>, 2>>, !firrtl.vector<uint<1>, 2>
    }
  }
}",circt-opt -pass-pipeline='firrtl.circuit(firrtl-lower-types)',"0.      Program arguments: circt-opt -pass-pipeline=firrtl.circuit(firrtl-lower-types) crash.mlir
1.      2.       #0 0x00000000013b163e llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:0
 #1 0x00000000013b16f5 PrintStackTraceSignalHandler(void*) /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:0
 #2 0x00000000013af3b3 llvm::sys::RunSignalHandlers() /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Signals.cpp:71:0
 #3 0x00000000013b0fbf SignalHandler(int) /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:0
 #4 0x00007fc273131890 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x12890)
 #5 0x00000000008361d4 mlir::StringAttr::getValue() const /home/prithayan/work/sifive/fork-circt/circt/llvm/build/tools/mlir/include/mlir/IR/BuiltinAttributes.cpp.inc:266:0
 #6 0x000000000043d1b3 (anonymous namespace)::TypeLoweringVisitor::visitDecl(circt::firrtl::RegOp) /home/prithayan/work/sifive/fork-circt/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:574:47",,,,,,,
787,[FIRRTL] FIRRTL to RTL Memory Lowering Needs to Handle All Read Under Write Behaviors,2021-03-18T22:30:18Z,open,"bug, FIRRTL","Add support for the ""old"" read-under-write FIRRTL memory behavior. Currently, this is incorrectly emitted as ""new"".

The FIRRTL spec defines three read-under-write behaviors for memories. A read-under-write behavior is what happens if you try to read and write the same address on the same cycle These three behaviors are:

1. New (return the value in the memory when the read was made)
2. Old (return the value when the read was requested)
3. Undefined (technically anything, but the Scala FIRRTL Compiler treats this as ""compiler's choice"" and chooses ""New"")

Note that this only matters for read latencies > 0. These can be treated as equivalent if the ~read latency == 1~ read latency == 0.",,,,,,,,,,
785,[FIRRTL] LowerTypes for Aggregate Register Inits,2021-03-18T20:46:18Z,closed,"bug, FIRRTL","Vector register lowering appears to not work.

Consider the following circuit:

```scala
circuit Foo:
  module Foo:
    input clock: Clock
    input reset: UInt<1>
    input a_d: UInt<1>[2]
    output a_q: UInt<1>[2]

    wire init: UInt<1>[2]
    init[0] <= UInt<1>(0)
    init[1] <= UInt<1>(0)

    reg r: UInt<1>[2], clock with:
      reset => (reset, init)

    r <= a_d
    a_q <= r
```

This is crashing out in lower types:

```bash
firtool -lower-to-rtl -enable-lower-types Foo.fir
# Assertion failed: (entry && ""bundle lowering was not set""), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 794.
```

I would expect this to generate something like what the Scala FIRRTL Compiler does here:

```verilog
module Foo(
  input   clock,
  input   reset,
  input   a_d_0,
  input   a_d_1,
  output  a_q_0,
  output  a_q_1
);
  reg  r_0;
  reg  r_1;
  assign a_q_0 = r_0;
  assign a_q_1 = r_1;
  always @(posedge clock) begin
    if (reset) begin
      r_0 <= 1'h0;
    end else begin
      r_0 <= a_d_0;
    end
    if (reset) begin
      r_1 <= 1'h0;
    end else begin
      r_1 <= a_d_1;
    end
  end
endmodule
```","circuit Foo:
  module Foo:
    input clock: Clock
    input reset: UInt<1>
    input a_d: UInt<1>[2]
    output a_q: UInt<1>[2]

    wire init: UInt<1>[2]
    init[0] <= UInt<1>(0)
    init[1] <= UInt<1>(0)

    reg r: UInt<1>[2], clock with:
      reset => (reset, init)

    r <= a_d
    a_q <= r","firtool -lower-to-rtl -enable-lower-types Foo.fir
# Assertion failed: (entry && ""bundle lowering was not set""), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 794.","module Foo(
  input   clock,
  input   reset,
  input   a_d_0,
  input   a_d_1,
  output  a_q_0,
  output  a_q_1
);
  reg  r_0;
  reg  r_1;
  assign a_q_0 = r_0;
  assign a_q_1 = r_1;
  always @(posedge clock) begin
    if (reset) begin
      r_0 <= 1'h0;
    end else begin
      r_0 <= a_d_0;
    end
    if (reset) begin
      r_1 <= 1'h0;
    end else begin
      r_1 <= a_d_1;
    end
  end
endmodule",,,,,,,
783,[FIRRTL] Handle Large Memories with Depth > 31 bits (Parser) and > 64 bits (IR)?,2021-03-18T16:17:59Z,closed,"bug, good first issue, FIRRTL","FIRRTL IR allows for memories to be arbitrarily deep. There are two limitations that we're setting on this:

1) The FIRParser is using an `int32_t` to parse integers.
2) The actual IR representation of depth is `Confined<I64Attr, [IntMinValue<1>]>:$depth`.

The (1) restriction can be easily bumped to an `int64_t`. 

The (2) restriction is lower priority (do we really need to represent exabyte-sized memories in the IR right now?), but would be good to tackle eventually. I think this could be handled by switching to a hypotehtical `I128Attr`, using a hypothetical big number attribute, or we could switch to a string here.

An example that currently fails in the parser:

```scala
circuit Foo:
  module Foo:
    mem memory:
      data-type => UInt<8>
      depth => 2147483648
      reader => r
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
```

```bash
firtool Foo.fir
# Foo.fir:5:16: error: value is too big to handle
#       depth => 2147483648
#                ^
```","circuit Foo:
  module Foo:
    mem memory:
      data-type => UInt<8>
      depth => 2147483648
      reader => r
      read-latency => 0
      write-latency => 1
      read-under-write => undefined","firtool Foo.fir
# Foo.fir:5:16: error: value is too big to handle
#       depth => 2147483648
#                ^",,,,,,,,
782,"[FIRRTL] Memories can be called ""mem""",2021-03-18T15:53:10Z,closed,"bug, FIRRTL","We currently incorrectly parse memories called `mem`. This is another variant of context-sensitive parsing issues, e.g., https://github.com/llvm/circt/issues/559.

The following should parse:

```scala
circuit Foo:
  module Foo:
    input clock: Clock
    input rAddr: UInt<4>
    input rEn: UInt<1>
    output rData: UInt<8>

    mem mem:
      data-type => UInt<8>
      depth => 16
      reader => r
      read-latency => 2
      write-latency => 1
      read-under-write => undefined

    mem.r.clk <= clock
    mem.r.en <= rEn
    mem.r.addr <= rAddr
    rData <= mem.r.data
```

Currently this fails where the parser gets confused with the `mem.r.clk <= clock` statement:

```bash
firtool Foo.fir                
# Foo.fir:17:10: error: expected '<=', '<-', or 'is' in statement
#     mem.r.clk <= clock
#          ^
```","circuit Foo:
  module Foo:
    input clock: Clock
    input rAddr: UInt<4>
    input rEn: UInt<1>
    output rData: UInt<8>

    mem mem:
      data-type => UInt<8>
      depth => 16
      reader => r
      read-latency => 2
      write-latency => 1
      read-under-write => undefined

    mem.r.clk <= clock
    mem.r.en <= rEn
    mem.r.addr <= rAddr
    rData <= mem.r.data","firtool Foo.fir                
# Foo.fir:17:10: error: expected '<=', '<-', or 'is' in statement
#     mem.r.clk <= clock
#          ^",,,,,,,,
781,[FIRRTL] Parse RawString ExtModule Parameters,2021-03-18T15:39:28Z,closed,"bug, good first issue, FIRRTL","The Scala FIRRTL Compiler supports passing ""raw string"" parameters to blackboxes. These have single quotes as opposed to double quotes.

As an example, the following:

```scala
module BlackBoxTypeParam :
  extmodule BlackBoxTypeParam :                                                                                    
    output out : UInt<1>                                                                                           
    defname = BlackBoxTypeParam                                                                                    
    parameter T = 'bit'                                                                                            
```

Becomes in the Scala FIRRTL Compiler:

```verilog
module Foo(
  output  out
);
  wire  bar_out;
  BlackBoxTypeParam #(.T(bit)) bar (
    .out(bar_out)
  );
  assign out = bar_out;
endmodule
```

We currently barf on the `'` when trying to parse this `.fir` file with `firtool`:

```
BlackBoxTypeParam.fir:5:19: error: unexpected character
    parameter T = 'bit'
```

As far as I can tell, if something is a raw string, it should be reproduced exactly in the Verilog output.","module BlackBoxTypeParam :
  extmodule BlackBoxTypeParam :                                                                                    
    output out : UInt<1>                                                                                           
    defname = BlackBoxTypeParam                                                                                    
    parameter T = 'bit'","module Foo(
  output  out
);
  wire  bar_out;
  BlackBoxTypeParam #(.T(bit)) bar (
    .out(bar_out)
  );
  assign out = bar_out;
endmodule","BlackBoxTypeParam.fir:5:19: error: unexpected character
    parameter T = 'bit'",,,,,,,
779,[FIRRTL] Disallow Top-level Abstract Reset,2021-03-17T20:57:50Z,closed,"bug, good first issue, FIRRTL","The following circuit should be an error. Assumedly, this should be a verification hook added to either a FIRRTL circuit or to a module that is conditioned on it being the top module.

```scala
circuit Foo:
  module Foo:
    input a_d: UInt<1>
    output a_q: UInt<1>
    input r: Reset
    input c: Clock


    reg x: UInt<1>, c with:
      reset => (r, UInt<1>(0))

    x <= a_d
    a_q <= x
```

When running with the Scala FIRRTL Compiler, this errors quickly:

```bash
firrtl -i chiselTests/Reset.fir                     
# Exception in thread ""main"" firrtl.passes.CheckHighFormLike$ResetInputException: : [module Foo] Abstract Reset not allowed as top-level input: r
```

When compiling with CIRCT, this happily goes all the way to Verilog and generates a synchronous reset flip flop.","circuit Foo:
  module Foo:
    input a_d: UInt<1>
    output a_q: UInt<1>
    input r: Reset
    input c: Clock


    reg x: UInt<1>, c with:
      reset => (r, UInt<1>(0))

    x <= a_d
    a_q <= x","firrtl -i chiselTests/Reset.fir                     
# Exception in thread ""main"" firrtl.passes.CheckHighFormLike$ResetInputException: : [module Foo] Abstract Reset not allowed as top-level input: r",,,,,,,,
778,[FIRRTL] mem 0-width (core dump),2021-03-17T20:04:05Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input r0en: UInt<1>
    mem tmp41:
      data-type => UInt<0>
      depth => 10
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp41.r0.clk <= clock
    tmp41.r0.en <= r0en
    tmp41.r0.addr <= asUInt(SInt<25>(0))
    tmp41.w0.clk <= clock
    tmp41.w0.en <= r0en
    tmp41.w0.addr <= asUInt(SInt<25>(0))
    tmp41.w0.mask <= asUInt(SInt<25>(0))
    tmp41.w0.data <= asUInt(SInt<25>(0))
```

Compiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:

```mlir
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
1.       #0 0x000000000043cccd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x43cccd)
 #1 0x000000000043aad4 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x43aad4)
 #2 0x000000000043ac33 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x43ac33)
 #3 0x00007f32ead06a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #4 0x000000000054673a mlir::detail::OperandStorage::OperandStorage(mlir::Operation*, mlir::ValueRange) (../../llvm/circt/build/bin/firtool+0x54673a)
 #5 0x000000000053b3b1 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, unsigned int) (../../llvm/circt/build/bin/firtool+0x53b3b1)
 #6 0x000000000053b479 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, mlir::RegionRange) (../../llvm/circt/build/bin/firtool+0x53b479)
 #7 0x000000000053b653 mlir::Operation::create(mlir::OperationState const&) (../../llvm/circt/build/bin/firtool+0x53b653)
 #8 0x00000000004f93ac mlir::OpBuilder::createOperation(mlir::OperationState const&) (../../llvm/circt/build/bin/firtool+0x4f93ac)
 #9 0x0000000000482ac5 circt::sv::ConnectOp mlir::OpBuilder::create<circt::sv::ConnectOp, mlir::Value&, mlir::Value&>(mlir::Location, mlir::Value&, mlir::Value&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/Builders.h:399:31
#10 0x0000000000495d43 begin /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:253:45
#11 0x0000000000495d43 end /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:255:32
#12 0x0000000000495d43 ~SmallVector /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:1175:24
#13 0x0000000000495d43 (anonymous namespace)::FIRRTLLowering::visitDecl(circt::firrtl::MemOp) /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:1865:36
#14 0x0000000000497b34 operator()<circt::firrtl::MemOp> /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:211:53
#15 0x0000000000497b34 Case<circt::firrtl::MemOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:116:22
#16 0x0000000000497b34 Case<circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:40:40
#17 0x0000000000497b34 Case<circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42
#18 0x0000000000497b34 Case<circt::firrtl::CMemOp, circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42
#19 0x0000000000497b34 dispatchDeclVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:210:43
#20 0x0000000000497b34 visitInvalidStmt /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:270:37
#21 0x0000000000497b34 operator()<mlir::Operation*> /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:165:44
#22 0x0000000000497b34 Default<circt::firrtl::StmtVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchStmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:17)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:125:21
#23 0x0000000000497b34 dispatchStmtVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:164:17
#24 0x0000000000497b34 visitInvalidExpr /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:267:37
#25 0x0000000000497b34 operator()<mlir::Operation*> /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:54:44
#26 0x0000000000497b34 Default<circt::firrtl::ExprVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:15)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:125:21
#27 0x0000000000497b34 dispatchExprVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:53:17
#28 0x0000000000497b34 dispatchVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:262:37
#29 0x0000000000497b34 (anonymous namespace)::FIRRTLLowering::run() /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:1116:18
#30 0x0000000000499246 llvm::SmallVectorTemplateCommon<circt::sv::WireOp, void>::begin() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:253:45
#31 0x0000000000499246 llvm::SmallVectorTemplateCommon<circt::sv::WireOp, void>::end() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:255:32
#32 0x0000000000499246 llvm::SmallVector<circt::sv::WireOp, 6u>::~SmallVector() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:1175:24
#33 0x0000000000499246 ~FIRRTLLowering /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:876:8
#34 0x0000000000499246 lowerModuleOperations /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:1098:3
#35 0x0000000000499246 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:746:24
#36 0x000000000049b1f1 parallel_for_each_n<long unsigned int, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Parallel.h:162:25
#37 0x000000000049b1f1 parallelForEachN<(anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Parallel.h:244:42
#38 0x000000000049b1f1 (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:223:27
#39 0x0000000000682385 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x682385)
#40 0x00000000006824b0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x6824b0)
#41 0x0000000000685594 mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x685594)
#42 0x000000000040b915 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:167:3
#43 0x00000000004080a6 processBufferIntoSingleStream /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:191:4
#44 0x00000000004080a6 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:256:15
#45 0x00007f32ea774b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#46 0x000000000040989e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 26: 20292 Segmentation fault      (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2
```

valgrind reports

```
==20518== 
==20518== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==20518==  Access not within mapped region at address 0x0
==20518==    at 0x54673A: mlir::detail::OperandStorage::OperandStorage(mlir::Operation*, mlir::ValueRange) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==    by 0x53B3B0: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, unsigned int) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==    by 0x53B478: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, mlir::RegionRange) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==    by 0x53B652: mlir::Operation::create(mlir::OperationState const&) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==    by 0x4F93AB: mlir::OpBuilder::createOperation(mlir::OperationState const&) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==    by 0x482AC4: circt::sv::ConnectOp mlir::OpBuilder::create<circt::sv::ConnectOp, mlir::Value&, mlir::Value&>(mlir::Location, mlir::Value&, mlir::Value&) (Builders.h:399)
==20518==    by 0x495D42: create<circt::sv::ConnectOp, mlir::Value&, mlir::Value&> (ImplicitLocOpBuilder.h:83)
==20518==    by 0x495D42: (anonymous namespace)::FIRRTLLowering::visitDecl(circt::firrtl::MemOp) (LowerToRTL.cpp:1908)
==20518==    by 0x497B33: operator()<circt::firrtl::MemOp> (FIRRTLVisitors.h:211)
==20518==    by 0x497B33: Case<circt::firrtl::MemOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> (TypeSwitch.h:116)
==20518==    by 0x497B33: Case<circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> (TypeSwitch.h:40)
==20518==    by 0x497B33: Case<circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> (TypeSwitch.h:41)
==20518==    by 0x497B33: Case<circt::firrtl::CMemOp, circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)> > (TypeSwitch.h:41)
==20518==    by 0x497B33: dispatchDeclVisitor (FIRRTLVisitors.h:210)
==20518==    by 0x497B33: visitInvalidStmt (FIRRTLVisitors.h:270)
==20518==    by 0x497B33: operator()<mlir::Operation*> (FIRRTLVisitors.h:165)
==20518==    by 0x497B33: Default<circt::firrtl::StmtVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchStmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:17)> > (TypeSwitch.h:125)
==20518==    by 0x497B33: dispatchStmtVisitor (FIRRTLVisitors.h:164)
==20518==    by 0x497B33: visitInvalidExpr (FIRRTLVisitors.h:267)
==20518==    by 0x497B33: operator()<mlir::Operation*> (FIRRTLVisitors.h:54)
==20518==    by 0x497B33: Default<circt::firrtl::ExprVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:15)> > (TypeSwitch.h:125)
==20518==    by 0x497B33: dispatchExprVisitor (FIRRTLVisitors.h:53)
==20518==    by 0x497B33: dispatchVisitor (FIRRTLVisitors.h:262)
==20518==    by 0x497B33: (anonymous namespace)::FIRRTLLowering::run() (LowerToRTL.cpp:1116)
==20518==    by 0x499245: lowerModuleOperations (LowerToRTL.cpp:1098)
==20518==    by 0x499245: (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) (LowerToRTL.cpp:746)
==20518==    by 0x49B1F0: operator()<long unsigned int> (LowerToRTL.cpp:224)
==20518==    by 0x49B1F0: parallel_for_each_n<long unsigned int, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > (Parallel.h:163)
==20518==    by 0x49B1F0: parallelForEachN<(anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > (Parallel.h:244)
==20518==    by 0x49B1F0: (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() (LowerToRTL.cpp:223)
==20518==    by 0x682384: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==    by 0x6824AF: mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==  If you believe this happened as a result of a stack
==20518==  overflow in your program's main thread (unlikely but
==20518==  possible), you can try to increase the size of the
==20518==  main thread stack using the --main-stacksize= flag.
==20518==  The main thread stack size used in this run was 8388608.
==20518== 
==20518== HEAP SUMMARY:
==20518==     in use at exit: 518,681 bytes in 1,019 blocks
==20518==   total heap usage: 1,293 allocs, 274 frees, 775,666 bytes allocated
==20518== 
==20518== LEAK SUMMARY:
==20518==    definitely lost: 67,584 bytes in 1 blocks
==20518==    indirectly lost: 0 bytes in 0 blocks
==20518==      possibly lost: 0 bytes in 0 blocks
==20518==    still reachable: 451,097 bytes in 1,018 blocks
==20518==         suppressed: 0 bytes in 0 blocks
==20518== Rerun with --leak-check=full to see details of leaked memory
==20518== 
==20518== For lists of detected and suppressed errors, rerun with: -s
==20518== ERROR SUMMARY: 2 errors from 1 contexts (suppressed: 0 from 0)
```

firrtl-1.5.0-SNAPSHOT also crashes :(","circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input r0en: UInt<1>
    mem tmp41:
      data-type => UInt<0>
      depth => 10
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp41.r0.clk <= clock
    tmp41.r0.en <= r0en
    tmp41.r0.addr <= asUInt(SInt<25>(0))
    tmp41.w0.clk <= clock
    tmp41.w0.en <= r0en
    tmp41.w0.addr <= asUInt(SInt<25>(0))
    tmp41.w0.mask <= asUInt(SInt<25>(0))
    tmp41.w0.data <= asUInt(SInt<25>(0))","PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
1.       #0 0x000000000043cccd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x43cccd)
 #1 0x000000000043aad4 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x43aad4)
 #2 0x000000000043ac33 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x43ac33)
 #3 0x00007f32ead06a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #4 0x000000000054673a mlir::detail::OperandStorage::OperandStorage(mlir::Operation*, mlir::ValueRange) (../../llvm/circt/build/bin/firtool+0x54673a)
 #5 0x000000000053b3b1 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, unsigned int) (../../llvm/circt/build/bin/firtool+0x53b3b1)
 #6 0x000000000053b479 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, mlir::RegionRange) (../../llvm/circt/build/bin/firtool+0x53b479)
 #7 0x000000000053b653 mlir::Operation::create(mlir::OperationState const&) (../../llvm/circt/build/bin/firtool+0x53b653)
 #8 0x00000000004f93ac mlir::OpBuilder::createOperation(mlir::OperationState const&) (../../llvm/circt/build/bin/firtool+0x4f93ac)
 #9 0x0000000000482ac5 circt::sv::ConnectOp mlir::OpBuilder::create<circt::sv::ConnectOp, mlir::Value&, mlir::Value&>(mlir::Location, mlir::Value&, mlir::Value&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/Builders.h:399:31
#10 0x0000000000495d43 begin /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:253:45
#11 0x0000000000495d43 end /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:255:32
#12 0x0000000000495d43 ~SmallVector /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:1175:24
#13 0x0000000000495d43 (anonymous namespace)::FIRRTLLowering::visitDecl(circt::firrtl::MemOp) /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:1865:36
#14 0x0000000000497b34 operator()<circt::firrtl::MemOp> /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:211:53
#15 0x0000000000497b34 Case<circt::firrtl::MemOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:116:22
#16 0x0000000000497b34 Case<circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:40:40
#17 0x0000000000497b34 Case<circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42
#18 0x0000000000497b34 Case<circt::firrtl::CMemOp, circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42
#19 0x0000000000497b34 dispatchDeclVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:210:43
#20 0x0000000000497b34 visitInvalidStmt /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:270:37
#21 0x0000000000497b34 operator()<mlir::Operation*> /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:165:44
#22 0x0000000000497b34 Default<circt::firrtl::StmtVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchStmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:17)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:125:21
#23 0x0000000000497b34 dispatchStmtVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:164:17
#24 0x0000000000497b34 visitInvalidExpr /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:267:37
#25 0x0000000000497b34 operator()<mlir::Operation*> /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:54:44
#26 0x0000000000497b34 Default<circt::firrtl::ExprVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:15)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:125:21
#27 0x0000000000497b34 dispatchExprVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:53:17
#28 0x0000000000497b34 dispatchVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:262:37
#29 0x0000000000497b34 (anonymous namespace)::FIRRTLLowering::run() /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:1116:18
#30 0x0000000000499246 llvm::SmallVectorTemplateCommon<circt::sv::WireOp, void>::begin() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:253:45
#31 0x0000000000499246 llvm::SmallVectorTemplateCommon<circt::sv::WireOp, void>::end() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:255:32
#32 0x0000000000499246 llvm::SmallVector<circt::sv::WireOp, 6u>::~SmallVector() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:1175:24
#33 0x0000000000499246 ~FIRRTLLowering /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:876:8
#34 0x0000000000499246 lowerModuleOperations /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:1098:3
#35 0x0000000000499246 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:746:24
#36 0x000000000049b1f1 parallel_for_each_n<long unsigned int, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Parallel.h:162:25
#37 0x000000000049b1f1 parallelForEachN<(anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Parallel.h:244:42
#38 0x000000000049b1f1 (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:223:27
#39 0x0000000000682385 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x682385)
#40 0x00000000006824b0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x6824b0)
#41 0x0000000000685594 mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x685594)
#42 0x000000000040b915 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:167:3
#43 0x00000000004080a6 processBufferIntoSingleStream /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:191:4
#44 0x00000000004080a6 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:256:15
#45 0x00007f32ea774b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#46 0x000000000040989e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 26: 20292 Segmentation fault      (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2","==20518== 
==20518== Process terminating with default action of signal 11 (SIGSEGV): dumping core
==20518==  Access not within mapped region at address 0x0
==20518==    at 0x54673A: mlir::detail::OperandStorage::OperandStorage(mlir::Operation*, mlir::ValueRange) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==    by 0x53B3B0: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, unsigned int) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==    by 0x53B478: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, mlir::RegionRange) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==    by 0x53B652: mlir::Operation::create(mlir::OperationState const&) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==    by 0x4F93AB: mlir::OpBuilder::createOperation(mlir::OperationState const&) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==    by 0x482AC4: circt::sv::ConnectOp mlir::OpBuilder::create<circt::sv::ConnectOp, mlir::Value&, mlir::Value&>(mlir::Location, mlir::Value&, mlir::Value&) (Builders.h:399)
==20518==    by 0x495D42: create<circt::sv::ConnectOp, mlir::Value&, mlir::Value&> (ImplicitLocOpBuilder.h:83)
==20518==    by 0x495D42: (anonymous namespace)::FIRRTLLowering::visitDecl(circt::firrtl::MemOp) (LowerToRTL.cpp:1908)
==20518==    by 0x497B33: operator()<circt::firrtl::MemOp> (FIRRTLVisitors.h:211)
==20518==    by 0x497B33: Case<circt::firrtl::MemOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> (TypeSwitch.h:116)
==20518==    by 0x497B33: Case<circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> (TypeSwitch.h:40)
==20518==    by 0x497B33: Case<circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> (TypeSwitch.h:41)
==20518==    by 0x497B33: Case<circt::firrtl::CMemOp, circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)> > (TypeSwitch.h:41)
==20518==    by 0x497B33: dispatchDeclVisitor (FIRRTLVisitors.h:210)
==20518==    by 0x497B33: visitInvalidStmt (FIRRTLVisitors.h:270)
==20518==    by 0x497B33: operator()<mlir::Operation*> (FIRRTLVisitors.h:165)
==20518==    by 0x497B33: Default<circt::firrtl::StmtVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchStmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:17)> > (TypeSwitch.h:125)
==20518==    by 0x497B33: dispatchStmtVisitor (FIRRTLVisitors.h:164)
==20518==    by 0x497B33: visitInvalidExpr (FIRRTLVisitors.h:267)
==20518==    by 0x497B33: operator()<mlir::Operation*> (FIRRTLVisitors.h:54)
==20518==    by 0x497B33: Default<circt::firrtl::ExprVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:15)> > (TypeSwitch.h:125)
==20518==    by 0x497B33: dispatchExprVisitor (FIRRTLVisitors.h:53)
==20518==    by 0x497B33: dispatchVisitor (FIRRTLVisitors.h:262)
==20518==    by 0x497B33: (anonymous namespace)::FIRRTLLowering::run() (LowerToRTL.cpp:1116)
==20518==    by 0x499245: lowerModuleOperations (LowerToRTL.cpp:1098)
==20518==    by 0x499245: (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) (LowerToRTL.cpp:746)
==20518==    by 0x49B1F0: operator()<long unsigned int> (LowerToRTL.cpp:224)
==20518==    by 0x49B1F0: parallel_for_each_n<long unsigned int, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > (Parallel.h:163)
==20518==    by 0x49B1F0: parallelForEachN<(anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > (Parallel.h:244)
==20518==    by 0x49B1F0: (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() (LowerToRTL.cpp:223)
==20518==    by 0x682384: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==    by 0x6824AF: mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /home/drom/work/github/llvm/circt/build/bin/firtool)
==20518==  If you believe this happened as a result of a stack
==20518==  overflow in your program's main thread (unlikely but
==20518==  possible), you can try to increase the size of the
==20518==  main thread stack using the --main-stacksize= flag.
==20518==  The main thread stack size used in this run was 8388608.
==20518== 
==20518== HEAP SUMMARY:
==20518==     in use at exit: 518,681 bytes in 1,019 blocks
==20518==   total heap usage: 1,293 allocs, 274 frees, 775,666 bytes allocated
==20518== 
==20518== LEAK SUMMARY:
==20518==    definitely lost: 67,584 bytes in 1 blocks
==20518==    indirectly lost: 0 bytes in 0 blocks
==20518==      possibly lost: 0 bytes in 0 blocks
==20518==    still reachable: 451,097 bytes in 1,018 blocks
==20518==         suppressed: 0 bytes in 0 blocks
==20518== Rerun with --leak-check=full to see details of leaked memory
==20518== 
==20518== For lists of detected and suppressed errors, rerun with: -s
==20518== ERROR SUMMARY: 2 errors from 1 contexts (suppressed: 0 from 0)",,,,,,,
775,[FIRRTL] mem (core dump),2021-03-17T05:22:21Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input r0en: UInt<1>
    mem tmp41:
      data-type => UInt<8>
      depth => 10
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp41.r0.clk <= clock
    tmp41.r0.en <= r0en
    tmp41.r0.addr <= asUInt(SInt<25>(0))
    tmp41.w0.clk <= clock
    tmp41.w0.en <= r0en
    tmp41.w0.addr <= asUInt(SInt<25>(0))
    tmp41.w0.mask <= asUInt(SInt<25>(0))
    tmp41.w0.data <= asUInt(SInt<25>(0))
```

Compiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:

```mlir
firtool
malloc(): unsorted double linked list corrupted
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
malloc(): unsorted double linked list corrupted
./process1.sh: line 25: 29968 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2
```

firrtl-1.5.0-SNAPSHOT produces this Verilog:

```verilog
module top_mod(
  input   clock,
  input   reset,
  input   r0en
);
endmodule
```","circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input r0en: UInt<1>
    mem tmp41:
      data-type => UInt<8>
      depth => 10
      read-latency => 0
      write-latency => 1
      read-under-write => undefined
      reader => r0
      writer => w0
    tmp41.r0.clk <= clock
    tmp41.r0.en <= r0en
    tmp41.r0.addr <= asUInt(SInt<25>(0))
    tmp41.w0.clk <= clock
    tmp41.w0.en <= r0en
    tmp41.w0.addr <= asUInt(SInt<25>(0))
    tmp41.w0.mask <= asUInt(SInt<25>(0))
    tmp41.w0.data <= asUInt(SInt<25>(0))","firtool
malloc(): unsorted double linked list corrupted
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
malloc(): unsorted double linked list corrupted
./process1.sh: line 25: 29968 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2","module top_mod(
  input   clock,
  input   reset,
  input   r0en
);
endmodule",,,,,,,
773,[FIRRTL] crash,2021-03-16T23:44:05Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 497
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input inp_a: UInt<5>
    input inp_b: {inp_c: {inp_j: UInt<5>}, inp_d: {inp_e: SInt<7>, inp_i: SInt<2>}, inp_g: {inp_h: UInt<14>}}
    input inp_f: UInt<13>
    output tmp8: SInt<25>
    reg tmp6: UInt<5>, clock with: (reset => (reset, UInt<5>(0)))
    reg tmp9: UInt<13>, clock
    reg tmp10: SInt<8>, clock
    wire tmp11: SInt<23>
    reg tmp12: SInt<1>, clock with: (reset => (reset, SInt<1>(0)))
    reg tmp13: SInt<11>, clock
    reg tmp15: UInt<8>, clock
    wire _tmp17: UInt<12>
    wire tmp18: SInt<11>
    reg tmp19: UInt<13>, clock with: (reset => (reset, UInt<13>(0)))
    reg tmp23: SInt<11>, clock with: (reset => (reset, SInt<11>(0)))
    tmp6 <= bits(inp_b.inp_g.inp_h, 4, 0)
    tmp8 <= mux(head(tmp6, 1), SInt<23>(""h1d0137""), asSInt(UInt<25>(""b100101111111101010010010"")))
    tmp9 <= xor(inp_f, inp_b.inp_c.inp_j)
    tmp10 <= neg(UInt<7>(""h26""))
    tmp11 <= asSInt(UInt<23>(""o5674546""))
    tmp12 <= validif(head(inp_f, 1), SInt<1>(""b-1""))
    tmp13 <= shr(tmp8, 14)
    tmp15 <= not(tmp10)
    _tmp17 <= add(UInt<11>(""b110001010""), tmp15)
    tmp18 <= rem(tmp13, asSInt(UInt<24>(9972122)))
    tmp19 <= bits(inp_f, 12, 0)
    tmp23 <= validif(head(asUInt(SInt<20>(""o-71634"")), 1), tmp13)
```

Compiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:

```mlir
firtool
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
 #0 0x00000000004bc921 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004bc9d8 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004ba9d8 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bc374 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007fb20ef94a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #5 0x0000000000694d5e llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Dialect*, mlir::MLIRContext*>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Dialect*, mlir::MLIRContext*> > >::getInt() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerIntPair.h:61:57
 #6 0x0000000000695db3 bool llvm::PointerUnion<mlir::Dialect*, mlir::MLIRContext*>::is<mlir::Dialect*>() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:181:34
 #7 0x000000000069113c mlir::Dialect* llvm::PointerUnion<mlir::Dialect*, mlir::MLIRContext*>::dyn_cast<mlir::Dialect*>() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:195:5
 #8 0x0000000000687b59 mlir::Identifier::getDialect() /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/MLIRContext.cpp:801:1
 #9 0x00000000006a96f7 mlir::OperationName::getDialect() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:328:56
#10 0x00000000006a176e mlir::Operation::getDialect() /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:214:67
#11 0x00000000006a27fb mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:557:32
#12 0x00000000007d23e9 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13
#13 0x00000000007d1d6e mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13
#14 0x00000000007b7f09 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#15 0x00000000007b8234 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#16 0x00000000007b8120 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#17 0x00000000006ed6ae (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:3
#18 0x00000000008a4563 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36
#19 0x00000000008a478f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15
#20 0x00000000008a68cf mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74
#21 0x000000000040dbfc processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dbfc)
#22 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)
#23 0x00007fb20ea02b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#24 0x000000000040b56e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: строка 25: 25590 Segmentation fault      (стек памяти сброшен на диск) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2
```

The issue appears at random.
","; seed: 497
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input inp_a: UInt<5>
    input inp_b: {inp_c: {inp_j: UInt<5>}, inp_d: {inp_e: SInt<7>, inp_i: SInt<2>}, inp_g: {inp_h: UInt<14>}}
    input inp_f: UInt<13>
    output tmp8: SInt<25>
    reg tmp6: UInt<5>, clock with: (reset => (reset, UInt<5>(0)))
    reg tmp9: UInt<13>, clock
    reg tmp10: SInt<8>, clock
    wire tmp11: SInt<23>
    reg tmp12: SInt<1>, clock with: (reset => (reset, SInt<1>(0)))
    reg tmp13: SInt<11>, clock
    reg tmp15: UInt<8>, clock
    wire _tmp17: UInt<12>
    wire tmp18: SInt<11>
    reg tmp19: UInt<13>, clock with: (reset => (reset, UInt<13>(0)))
    reg tmp23: SInt<11>, clock with: (reset => (reset, SInt<11>(0)))
    tmp6 <= bits(inp_b.inp_g.inp_h, 4, 0)
    tmp8 <= mux(head(tmp6, 1), SInt<23>(""h1d0137""), asSInt(UInt<25>(""b100101111111101010010010"")))
    tmp9 <= xor(inp_f, inp_b.inp_c.inp_j)
    tmp10 <= neg(UInt<7>(""h26""))
    tmp11 <= asSInt(UInt<23>(""o5674546""))
    tmp12 <= validif(head(inp_f, 1), SInt<1>(""b-1""))
    tmp13 <= shr(tmp8, 14)
    tmp15 <= not(tmp10)
    _tmp17 <= add(UInt<11>(""b110001010""), tmp15)
    tmp18 <= rem(tmp13, asSInt(UInt<24>(9972122)))
    tmp19 <= bits(inp_f, 12, 0)
    tmp23 <= validif(head(asUInt(SInt<20>(""o-71634"")), 1), tmp13)","firtool
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv
 #0 0x00000000004bc921 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004bc9d8 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004ba9d8 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bc374 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007fb20ef94a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)
 #5 0x0000000000694d5e llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Dialect*, mlir::MLIRContext*>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Dialect*, mlir::MLIRContext*> > >::getInt() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerIntPair.h:61:57
 #6 0x0000000000695db3 bool llvm::PointerUnion<mlir::Dialect*, mlir::MLIRContext*>::is<mlir::Dialect*>() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:181:34
 #7 0x000000000069113c mlir::Dialect* llvm::PointerUnion<mlir::Dialect*, mlir::MLIRContext*>::dyn_cast<mlir::Dialect*>() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:195:5
 #8 0x0000000000687b59 mlir::Identifier::getDialect() /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/MLIRContext.cpp:801:1
 #9 0x00000000006a96f7 mlir::OperationName::getDialect() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:328:56
#10 0x00000000006a176e mlir::Operation::getDialect() /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:214:67
#11 0x00000000006a27fb mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:557:32
#12 0x00000000007d23e9 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13
#13 0x00000000007d1d6e mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13
#14 0x00000000007b7f09 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#15 0x00000000007b8234 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#16 0x00000000007b8120 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#17 0x00000000006ed6ae (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:3
#18 0x00000000008a4563 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36
#19 0x00000000008a478f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15
#20 0x00000000008a68cf mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74
#21 0x000000000040dbfc processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dbfc)
#22 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)
#23 0x00007fb20ea02b25 __libc_start_main (/lib64/libc.so.6+0x27b25)
#24 0x000000000040b56e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: строка 25: 25590 Segmentation fault      (стек памяти сброшен на диск) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2",,,,,,,,
755,Verilog Or Reduction Improperly Inlines Nots,2021-03-11T21:23:04Z,closed,"bug, Verilog/SystemVerilog","Verilog emission is generating things like ""or reduction"" ""not"", e.g., `|~foo` which is invalid Verilog.

Consider:

```mlir
module  {
  firrtl.circuit ""Foo"" {
    firrtl.module @Foo(%a: !firrtl.uint<8>, %b: !firrtl.flip<uint<1>>) {
      %0 = firrtl.not %a : (!firrtl.uint<8>) -> !firrtl.uint<8>
      %1 = firrtl.orr %0 : (!firrtl.uint<8>) -> !firrtl.uint<1>
      firrtl.connect %b, %1 : !firrtl.flip<uint<1>>, !firrtl.uint<1>
    }
  }
}
```

This produces:

```verilog
module Foo(
  input  [7:0] a,
  output       b);

  assign b = |~a;	// sunder/Foo.fir:2:3, :6:{10,14}
endmodule
```","module  {
  firrtl.circuit ""Foo"" {
    firrtl.module @Foo(%a: !firrtl.uint<8>, %b: !firrtl.flip<uint<1>>) {
      %0 = firrtl.not %a : (!firrtl.uint<8>) -> !firrtl.uint<8>
      %1 = firrtl.orr %0 : (!firrtl.uint<8>) -> !firrtl.uint<1>
      firrtl.connect %b, %1 : !firrtl.flip<uint<1>>, !firrtl.uint<1>
    }
  }
}","module Foo(
  input  [7:0] a,
  output       b);

  assign b = |~a;	// sunder/Foo.fir:2:3, :6:{10,14}
endmodule",,,,,,,,
751,spilled temporaries in always blocks use continuous assign,2021-03-11T03:53:13Z,closed,bug,"When temporaries are generated inside an always block, they are written to with a continuous assign.  This is wrong.
Getting more milage out of this example:
```mlir
rtl.module @foobar(%clock: i1, %arg1: i1, %arg2: i1, %arg3: i1) {
    sv.always posedge %clock  {
        sv.if %arg1  {
          sv.fatal
        }
        //this forces a common subexpression to be output out-of-line
        %610 = comb.and %arg1, %arg2 : i1
        %611 = comb.and %arg3, %610 : i1
        sv.if %610  {
          sv.fatal
        }
        sv.if %611  {
          sv.fatal
        }
    }
    rtl.output
  }
```
Produces:
```verilog
module foobar(
  input clock, arg1, arg2, arg3);

  always @(posedge clock) begin // bug.mlir:3:5
    automatic logic _T; // bug.mlir:8:16

    if (arg1)   // bug.mlir:4:9
      $fatal;   // bug.mlir:5:11
    assign _T = arg1 & arg2;    // bug.mlir:8:16
    if (_T)     // bug.mlir:10:9
      $fatal;   // bug.mlir:11:11
    if (arg3 & _T)      // bug.mlir:9:16, :13:9
      $fatal;   // bug.mlir:14:11
  end // always @(posedge)
endmodule
```","rtl.module @foobar(%clock: i1, %arg1: i1, %arg2: i1, %arg3: i1) {
    sv.always posedge %clock  {
        sv.if %arg1  {
          sv.fatal
        }
        //this forces a common subexpression to be output out-of-line
        %610 = comb.and %arg1, %arg2 : i1
        %611 = comb.and %arg3, %610 : i1
        sv.if %610  {
          sv.fatal
        }
        sv.if %611  {
          sv.fatal
        }
    }
    rtl.output
  }","module foobar(
  input clock, arg1, arg2, arg3);

  always @(posedge clock) begin // bug.mlir:3:5
    automatic logic _T; // bug.mlir:8:16

    if (arg1)   // bug.mlir:4:9
      $fatal;   // bug.mlir:5:11
    assign _T = arg1 & arg2;    // bug.mlir:8:16
    if (_T)     // bug.mlir:10:9
      $fatal;   // bug.mlir:11:11
    if (arg3 & _T)      // bug.mlir:9:16, :13:9
      $fatal;   // bug.mlir:14:11
  end // always @(posedge)
endmodule",,,,,,,,
750,RTL array_index_inout read vs. write (FIRRTL Memory Lowering Bug),2021-03-11T00:19:36Z,closed,"bug, HW, Verilog/SystemVerilog","Currently, the following RTL (which is a minimum example of a FIRRTL Memory Lowering bug) causes bad Verilog to be emitted:

```mlir
module attributes {firrtl.mainModule = ""Foo""}  {
  rtl.module @Foo(%clock: i1, %a: i1) -> () {
    %false = rtl.constant false
    %memory_r_en_pipe = sv.reg  : !rtl.inout<uarray<1xi1>>
    %3 = sv.array_index_inout %memory_r_en_pipe[%false] : !rtl.inout<uarray<1xi1>>, i1
    sv.alwaysff(posedge %clock)  {
      sv.passign %3, %a : i1
    }
    sv.initial  {
      sv.bpassign %3, %false : i1
    }
  }
}
```

This produces:
```verilog
module Foo(
  input clock, a);
  reg memory_r_en_pipe[0:0];	// Foo.mlir:4:25
  wire _T = 1'h0;	// Foo.mlir:3:14
  wire _T_0 = memory_r_en_pipe[_T];	// Foo.mlir:5:10
  always_ff @(posedge clock)	// Foo.mlir:6:5
    _T_0 <= a;	// Foo.mlir:7:7
  initial	// Foo.mlir:9:5
    _T_0 = _T;	// Foo.mlir:10:7
endmodule
```

The problem is that the `%3 = sv.array_index_inout` is a write accessor here. You don't want the temporary wire to be generated. 

Alternatively, if the accessor is duplicated and placed inside the always and initial blocks:
```mlir
module attributes {firrtl.mainModule = ""Foo""}  {
  rtl.module @Foo(%clock: i1, %a: i1) -> () {
    %false = rtl.constant false
    %memory_r_en_pipe = sv.reg  : !rtl.inout<uarray<1xi1>>
    sv.alwaysff(posedge %clock)  {
      %3 = sv.array_index_inout %memory_r_en_pipe[%false] : !rtl.inout<uarray<1xi1>>, i1
      sv.passign %3, %a : i1
    }
    sv.initial  {
      %4 = sv.array_index_inout %memory_r_en_pipe[%false] : !rtl.inout<uarray<1xi1>>, i1
      sv.bpassign %4, %false : i1
    }
  }
}
```

Everything works fine:
```verilog
module Foo(
  input clock, a);
  reg memory_r_en_pipe[0:0];	// Foo.mlir:4:25
  wire _T = 1'h0;	// Foo.mlir:3:14
  always_ff @(posedge clock)	// Foo.mlir:5:5
    memory_r_en_pipe[_T] <= a;	// Foo.mlir:6:12, :7:7
  initial	// Foo.mlir:9:5
    memory_r_en_pipe[_T] = _T;	// Foo.mlir:10:12, :11:7
endmodule
```

### Background/Discussion

The memory lowering introduced in #585 was generating code like this and it used to work. However, something changed within the past week and I haven't bisected to see where. 

It's not immediately clear to me if the bug is in what #585 is doing (it should put the `array_index_inout` inside the blocks) or if something is broke in the RTL -> Verilog path.

It seems weird to me that `array_index_inout` can seemingly be a read accessor or a write accessor, based on context. I may be misusing this, but we may want to go more towards the `alloca` + `load` + `store` type model to make this explicit. (Or maybe this already exists?)","module attributes {firrtl.mainModule = ""Foo""}  {
  rtl.module @Foo(%clock: i1, %a: i1) -> () {
    %false = rtl.constant false
    %memory_r_en_pipe = sv.reg  : !rtl.inout<uarray<1xi1>>
    %3 = sv.array_index_inout %memory_r_en_pipe[%false] : !rtl.inout<uarray<1xi1>>, i1
    sv.alwaysff(posedge %clock)  {
      sv.passign %3, %a : i1
    }
    sv.initial  {
      sv.bpassign %3, %false : i1
    }
  }
}","module Foo(
  input clock, a);
  reg memory_r_en_pipe[0:0];	// Foo.mlir:4:25
  wire _T = 1'h0;	// Foo.mlir:3:14
  wire _T_0 = memory_r_en_pipe[_T];	// Foo.mlir:5:10
  always_ff @(posedge clock)	// Foo.mlir:6:5
    _T_0 <= a;	// Foo.mlir:7:7
  initial	// Foo.mlir:9:5
    _T_0 = _T;	// Foo.mlir:10:7
endmodule","module attributes {firrtl.mainModule = ""Foo""}  {
  rtl.module @Foo(%clock: i1, %a: i1) -> () {
    %false = rtl.constant false
    %memory_r_en_pipe = sv.reg  : !rtl.inout<uarray<1xi1>>
    sv.alwaysff(posedge %clock)  {
      %3 = sv.array_index_inout %memory_r_en_pipe[%false] : !rtl.inout<uarray<1xi1>>, i1
      sv.passign %3, %a : i1
    }
    sv.initial  {
      %4 = sv.array_index_inout %memory_r_en_pipe[%false] : !rtl.inout<uarray<1xi1>>, i1
      sv.bpassign %4, %false : i1
    }
  }
}","module Foo(
  input clock, a);
  reg memory_r_en_pipe[0:0];	// Foo.mlir:4:25
  wire _T = 1'h0;	// Foo.mlir:3:14
  always_ff @(posedge clock)	// Foo.mlir:5:5
    memory_r_en_pipe[_T] <= a;	// Foo.mlir:6:12, :7:7
  initial	// Foo.mlir:9:5
    memory_r_en_pipe[_T] = _T;	// Foo.mlir:10:12, :11:7
endmodule",,,,,,
746,Memory latency lowering introduces continuous assignments in always block,2021-03-10T16:10:36Z,closed,bug,"You can modify how many bad assignments happen by changing read-latency.
```
circuit TLRAM :
  module TLRAM :
    input clock : Clock

    mem syssram0_3 : @[DescribedSRAM.scala 19:26]
      data-type => UInt<8>
      depth => 8192
      read-latency => 3
      write-latency => 1
      reader => MPORT
      writer => MPORT_1
      read-under-write => undefined
    syssram0_3.MPORT.addr <= UInt<1>(0)
    syssram0_3.MPORT.en <= UInt<1>(0)
    syssram0_3.MPORT.clk <= clock
    syssram0_3.MPORT_1.addr <= UInt<1>(0)
    syssram0_3.MPORT_1.en <= UInt<1>(""h0"")
    syssram0_3.MPORT_1.clk <= clock
    syssram0_3.MPORT_1.data <= UInt<1>(0)
    syssram0_3.MPORT_1.mask <= UInt<1>(0)
```
","circuit TLRAM :
  module TLRAM :
    input clock : Clock

    mem syssram0_3 : @[DescribedSRAM.scala 19:26]
      data-type => UInt<8>
      depth => 8192
      read-latency => 3
      write-latency => 1
      reader => MPORT
      writer => MPORT_1
      read-under-write => undefined
    syssram0_3.MPORT.addr <= UInt<1>(0)
    syssram0_3.MPORT.en <= UInt<1>(0)
    syssram0_3.MPORT.clk <= clock
    syssram0_3.MPORT_1.addr <= UInt<1>(0)
    syssram0_3.MPORT_1.en <= UInt<1>(""h0"")
    syssram0_3.MPORT_1.clk <= clock
    syssram0_3.MPORT_1.data <= UInt<1>(0)
    syssram0_3.MPORT_1.mask <= UInt<1>(0)",,,,,,,,,
736,Conjunction of equality tests generates bad code,2021-03-08T20:47:37Z,closed,bug,"Conjunction of equality tests generates bad code.
```
  rtl.module @LdQEntry(%clock: i1, %reset: i1, %a: i9,
    %b :i1,
    %c :i9
){
    %2 = comb.icmp eq %a, %c : i9
    %4 = comb.icmp eq %b, %2 : i1
    sv.always posedge %clock  {
        sv.if %4  {
          sv.fwrite ""Hi""
        }
    }
    rtl.output
  }
```
Produces:
```
module LdQEntry(
  input       clock, reset,
  input [8:0] a,
  input       b,
  input [8:0] c);

  wire _T = b == a == c;	// tmp/bug.lo.rtl.mlir:5:10, :6:10
  always @(posedge clock) begin	// tmp/bug.lo.rtl.mlir:7:5
    if (reset & _T)	// tmp/bug.lo.rtl.mlir:8:14, :9:9
      $fwrite(32'h80000002, ""Hi"");	// tmp/bug.lo.rtl.mlir:10:11
  end // always @(posedge)
endmodule
```
Verilator rightly complains:
```
%Warning-WIDTH: tmp/bug.lo.mlir.sv:83:20: Operator EQ expects 9 bits on the LHS, but LHS's VARREF '_T_1' generates 1 bits.
                                        : ... In instance LdQEntry
   83 |   wire _T_2 = _T_1 == _T == _T_0;  
      |                    ^~
                ... Use ""/* verilator lint_off WIDTH */"" and lint_on around source to disable this message.
%Warning-WIDTH: tmp/bug.lo.mlir.sv:83:26: Operator EQ expects 9 bits on the LHS, but LHS's EQ generates 1 bits.
                                        : ... In instance LdQEntry
   83 |   wire _T_2 = _T_1 == _T == _T_0;  
      |                          ^~
```","rtl.module @LdQEntry(%clock: i1, %reset: i1, %a: i9,
    %b :i1,
    %c :i9
){
    %2 = comb.icmp eq %a, %c : i9
    %4 = comb.icmp eq %b, %2 : i1
    sv.always posedge %clock  {
        sv.if %4  {
          sv.fwrite ""Hi""
        }
    }
    rtl.output
  }","module LdQEntry(
  input       clock, reset,
  input [8:0] a,
  input       b,
  input [8:0] c);

  wire _T = b == a == c;	// tmp/bug.lo.rtl.mlir:5:10, :6:10
  always @(posedge clock) begin	// tmp/bug.lo.rtl.mlir:7:5
    if (reset & _T)	// tmp/bug.lo.rtl.mlir:8:14, :9:9
      $fwrite(32'h80000002, ""Hi"");	// tmp/bug.lo.rtl.mlir:10:11
  end // always @(posedge)
endmodule","%Warning-WIDTH: tmp/bug.lo.mlir.sv:83:20: Operator EQ expects 9 bits on the LHS, but LHS's VARREF '_T_1' generates 1 bits.
                                        : ... In instance LdQEntry
   83 |   wire _T_2 = _T_1 == _T == _T_0;  
      |                    ^~
                ... Use ""/* verilator lint_off WIDTH */"" and lint_on around source to disable this message.
%Warning-WIDTH: tmp/bug.lo.mlir.sv:83:26: Operator EQ expects 9 bits on the LHS, but LHS's EQ generates 1 bits.
                                        : ... In instance LdQEntry
   83 |   wire _T_2 = _T_1 == _T == _T_0;  
      |                          ^~",,,,,,,
728,splitting variadic expressions in a procedural block makes a temporary at the wrong place,2021-03-05T19:10:14Z,closed,bug,"splitting variadic expressions in a procedural block makes a temporary at the wrong place.  This is a follow-on to #720 
```
rtl.module @foo(%clock: i1, %a: i1 {rtl.name = ""asdfasdfasdfasdfafa""}, %b: i1 {rtl.name = ""gasfdasafwjhijjafija""})  {
    sv.always posedge %clock  {
          sv.fwrite ""force output""
        %cond = comb.and %a, %b, %a, %b, %a, %b : i1
        sv.if %cond  {
          sv.fwrite ""this cond is split""
        }
    }
    rtl.output 
  }
```","rtl.module @foo(%clock: i1, %a: i1 {rtl.name = ""asdfasdfasdfasdfafa""}, %b: i1 {rtl.name = ""gasfdasafwjhijjafija""})  {
    sv.always posedge %clock  {
          sv.fwrite ""force output""
        %cond = comb.and %a, %b, %a, %b, %a, %b : i1
        sv.if %cond  {
          sv.fwrite ""this cond is split""
        }
    }
    rtl.output 
  }",,,,,,,,,
724,"[ExportVerilog] Wire declaration and definition ""_tmp"" output twice",2021-03-05T04:01:37Z,closed,"bug, ExportVerilog","I haven't tracked this down, but in a certain condition this line is emitted twice (identically) in different areas in the same scope:

```
  wire [31:0][7:0] _tmp = {{_T_9}, {_T_10}, {_T_11}, {_T_12}, {_T_13}, {_T_14}, {_T_15}, {_T_16}, {_T_17}, {_T_18}, {_T_19}, {_T_20}, {_T_21}, {_T_22}, {_T_23}, {_T_24}, {_T_25}, {_T_26}, {_T_27}, {_T_28}, {_T_29}, {_T_30}, {_T_31}, {_T_32}, {_T_33}, {_T_34}, {_T_35}, {_T_36}, {_T_37}, {_T_38}, {_T_39}, {_T_40}};
```

The wire name points to https://github.com/llvm/circt/blob/main/lib/Translation/ExportVerilog/ExportVerilog.cpp#L956. I'll look into this further later, but I figured there is a decent chance that would be enough for @lattner to know what's going on.","wire [31:0][7:0] _tmp = {{_T_9}, {_T_10}, {_T_11}, {_T_12}, {_T_13}, {_T_14}, {_T_15}, {_T_16}, {_T_17}, {_T_18}, {_T_19}, {_T_20}, {_T_21}, {_T_22}, {_T_23}, {_T_24}, {_T_25}, {_T_26}, {_T_27}, {_T_28}, {_T_29}, {_T_30}, {_T_31}, {_T_32}, {_T_33}, {_T_34}, {_T_35}, {_T_36}, {_T_37}, {_T_38}, {_T_39}, {_T_40}};",,,,,,,,,
720,temporaries output in the middle of blocks,2021-03-04T16:25:38Z,closed,"bug, ExportVerilog","Consider the test case below.  A temporary is made for 610, which is output after the first if block.  Verilog requires variable declarations to be at the beginning of blocks.

```mlir
module {
  rtl.module @foobar(%clock: i1, %arg1: i1, %arg2: i1, %arg3: i1) {
    sv.always posedge %clock  {
        sv.if %arg1  {
          sv.fatal
        }
        //this forces a common subexpression to be output out-of-line
        %610 = comb.and %arg1, %arg2 : i1
        %611 = comb.and %arg3, %610 : i1
        sv.if %610  {
          sv.fatal
        }
        sv.if %611  {
          sv.fatal
        }
    }
    rtl.output
  }
}
```","module {
  rtl.module @foobar(%clock: i1, %arg1: i1, %arg2: i1, %arg3: i1) {
    sv.always posedge %clock  {
        sv.if %arg1  {
          sv.fatal
        }
        //this forces a common subexpression to be output out-of-line
        %610 = comb.and %arg1, %arg2 : i1
        %611 = comb.and %arg3, %610 : i1
        sv.if %610  {
          sv.fatal
        }
        sv.if %611  {
          sv.fatal
        }
    }
    rtl.output
  }
}",,,,,,,,,
714,long-line splitting breaking begin/end,2021-03-03T23:40:39Z,closed,"bug, ExportVerilog","Another case from #701.  if we split a long line which is the only statement inside an if block and the temporary gets generated inside the some block, then we don't correctly generate the begin/end pair for the now-two-statement block.

It's fair to ask whether we should be putting the temporaries in the if-scope or in the op's original scope.",,,,,,,,,,
713,"Wire in always block, part long line splitting",2021-03-03T23:37:08Z,closed,"bug, ExportVerilog","Possibly the cause of #701.  When long lines are split in EmitExpression, the temporary is later emitted in the always block.  The temporary emitter doesn't know about the correct type of declaration to make this legal (and @drom would say you should never do this as a matter of style).  The reason this particular temporary is emitted there rather than at the rtlmodule scope is that it started life as an sv::ifop which is one of 2 ops we generate inside alwaysff blocks (well, with a a couple changes to the memory lowering).",,,,,,,,,,
709,Fix GCC Warnings,2021-03-02T21:46:17Z,closed,"bug, good first issue","There are currently some warnings when building with GCC, listed below.  Most of these should be pretty easy to fix.

1. Control reaches end of `sv::CaseZOp::getLetter`
```
In file included from /home/runner/work/circt/circt/include/circt/Dialect/SV/SVOps.h:43:0,
                 from /home/runner/work/circt/circt/lib/Dialect/SV/SVOps.cpp:13:
/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc: In static member function ‘static char circt::sv::CaseZOp::getLetter(circt::sv::CaseZOp::PatternBit, bool)’:
/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc:609:5: warning: control reaches end of non-void function [-Wreturn-type]
     }
```

2.  In `firrtl::verifyMemOp()` portNamesSet may be uninitialized

This problem manifests multiple times, possibly everywhere SmallDenseSet is used.

```
In file included from /home/runner/work/circt/circt/llvm/install/include/mlir/Support/InterfaceSupport.h:17:0,
                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/StorageUniquerSupport.h:16,
                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/AttributeSupport.h:17,
                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/Attributes.h:12,
                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/BuiltinAttributes.h:12,
                 from /home/runner/work/circt/circt/include/circt/Dialect/FIRRTL/FIRRTLDialect.h:17,
                 from /home/runner/work/circt/circt/include/circt/Dialect/FIRRTL/FIRRTLOps.h:16,
                 from /home/runner/work/circt/circt/lib/Dialect/FIRRTL/FIRRTLOps.cpp:13:
/home/runner/work/circt/circt/llvm/install/include/llvm/ADT/DenseMap.h: In function ‘mlir::LogicalResult verifyMemOp(circt::firrtl::MemOp)’:
/home/runner/work/circt/circt/llvm/install/include/llvm/ADT/DenseMap.h:1165:18: warning: ‘*((void*)(& portNamesSet)+16).llvm::SmallDenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, 8, llvm::DenseMapInfo<mlir::Attribute>, llvm::detail::DenseSetPair<mlir::Attribute> >::LargeRep::NumBuckets’ may be used uninitialized in this function [-Wmaybe-uninitialized]
     return Small ? InlineBuckets : getLargeRep()->NumBuckets;
            ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/runner/work/circt/circt/llvm/install/include/llvm/ADT/DenseMap.h:1156:18: warning: ‘*((void*)(& portNamesSet)+16).llvm::SmallDenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, 8, llvm::DenseMapInfo<mlir::Attribute>, llvm::detail::DenseSetPair<mlir::Attribute> >::LargeRep::Buckets’ may be used uninitialized in this function [-Wmaybe-uninitialized]
     return Small ? getInlineBuckets() : getLargeRep()->Buckets;
            ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

3. Possibly uninitialized value in `firrtl::parseType()`
```
/home/runner/work/circt/circt/lib/Dialect/FIRRTL/FIRRTLTypes.cpp: In function ‘mlir::ParseResult parseType(circt::firrtl::FIRRTLType&, mlir::DialectAsmParser&)’:
/home/runner/work/circt/circt/lib/Dialect/FIRRTL/FIRRTLTypes.cpp:148:35: warning: ‘fieldIntName’ may be used uninitialized in this function [-Wmaybe-uninitialized]
             nameStr = llvm::utostr(fieldIntName);
```

4. Possibly uninitialized value in `handshake::executeHandshakeFunction()`

```
[ 75%] Building CXX object lib/Dialect/LLHD/Simulator/CMakeFiles/obj.CIRCTLLHDSimEngine.dir/Engine.cpp.o
/home/runner/work/circt/circt/tools/handshake-runner/Simulation.cpp: In function ‘void executeHandshakeFunction(circt::handshake::FuncOp&, llvm::DenseMap<mlir::Value, llvm::Any>&, llvm::DenseMap<mlir::Value, double>&, std::vector<llvm::Any>&, std::vector<double>&, std::vector<std::vector<llvm::Any> >&, std::vector<double>&)’:
/home/runner/work/circt/circt/tools/handshake-runner/Simulation.cpp:568:27: warning: ‘time’ may be used uninitialized in this function [-Wmaybe-uninitialized]
       timeMap[out] = time + 1;
```



5. Control reaches end of `handshake::getFIRRTLType`

```
[ 84%] Building CXX object lib/Conversion/HandshakeToFIRRTL/CMakeFiles/obj.CIRCTHandshakeToFIRRTL.dir/HandshakeToFIRRTL.cpp.o
/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp: In lambda function:
/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp:62:7: warning: control reaches end of non-void function [-Wreturn-type]
       })
```

6. Control reaches end of `handshake::StdExprBuilder::visitStdExpr()`

```
/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp: In member function ‘bool {anonymous}::StdExprBuilder::visitStdExpr(mlir::CmpIOp)’:
/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp:633:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
```
 
7. `ESIRTLBuilder::declareCosimEndpoint()` defined but not used
```
/home/runner/work/circt/circt/lib/Dialect/ESI/ESIPasses.cpp:190:19: warning: ‘circt::rtl::RTLModuleExternOp {anonymous}::ESIRTLBuilder::declareCosimEndpoint()’ defined but not used [-Wunused-function]
 RTLModuleExternOp ESIRTLBuilder::declareCosimEndpoint() {
                   ^~~~~~~~~~~~~
[ 89%] Built target obj.CIRCTFIRRTLTransforms
```

8. `FIRParser::parseGetLocation(mlir::Location&)` defined but not used 

```
/home/runner/work/circt/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:268:13: warning: ‘mlir::ParseResult {anonymous}::FIRParser::parseGetLocation(mlir::Location&)’ defined but not used [-Wunused-function]
 ParseResult FIRParser::parseGetLocation(Location &loc) {
             ^~~~~~~~~
/home/runner/work/circt/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:263:13: warning: ‘mlir::ParseResult {anonymous}::FIRParser::parseGetLocation(llvm::SMLoc&)’ defined but not used [-Wunused-function]
 ParseResult FIRParser::parseGetLocation(SMLoc &loc) {
             ^~~~~~~~~
In file included from /home/runner/work/circt/circt/include/circt/Dialect/SV/SVOps.h:43:0,
                 from /home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:19:
/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc: In static member function ‘static char circt::sv::CaseZOp::getLetter(circt::sv::CaseZOp::PatternBit, bool)’:
/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc:609:5: warning: control reaches end of non-void function [-Wreturn-type]
     }
```

9. Various function in Export verilog not used

```
/home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilogFIRRTL.cpp:961:13: warning: ‘{anonymous}::SubExprInfo {anonymous}::ExprEmitter::emitUnary(mlir::Operation*, const char*, bool)’ defined but not used [-Wunused-function]
 SubExprInfo ExprEmitter::emitUnary(Operation *op, const char *syntax,
             ^~~~~~~~~~~
/home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilogFIRRTL.cpp:940:13: warning: ‘{anonymous}::SubExprInfo {anonymous}::ExprEmitter::emitVariadic(mlir::Operation*, {anonymous}::VerilogPrecedence, const char*)’ defined but not used [-Wunused-function]
 SubExprInfo ExprEmitter::emitVariadic(Operation *op, VerilogPrecedence prec,
             ^~~~~~~~~~~
/home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilogFIRRTL.cpp:875:13: warning: ‘{anonymous}::SubExprInfo {anonymous}::ExprEmitter::emitBinary(mlir::Operation*, {anonymous}::VerilogPrecedence, const char*, bool)’ defined but not used [-Wunused-function]
 SubExprInfo ExprEmitter::emitBinary(Operation *op, VerilogPrecedence prec,
             ^~~~~~~~~~~
```

9.  Control reaches end of firtool's `processBuffer()`

```
/home/runner/work/circt/circt/tools/firtool/firtool.cpp: In function ‘mlir::LogicalResult processBuffer(std::unique_ptr<llvm::MemoryBuffer>, llvm::raw_ostream&)’:
/home/runner/work/circt/circt/tools/firtool/firtool.cpp:173:1: warning: control reaches end of non-void function [-Wreturn-type]
 };
```","In file included from /home/runner/work/circt/circt/include/circt/Dialect/SV/SVOps.h:43:0,
                 from /home/runner/work/circt/circt/lib/Dialect/SV/SVOps.cpp:13:
/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc: In static member function ‘static char circt::sv::CaseZOp::getLetter(circt::sv::CaseZOp::PatternBit, bool)’:
/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc:609:5: warning: control reaches end of non-void function [-Wreturn-type]
     }","In file included from /home/runner/work/circt/circt/llvm/install/include/mlir/Support/InterfaceSupport.h:17:0,
                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/StorageUniquerSupport.h:16,
                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/AttributeSupport.h:17,
                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/Attributes.h:12,
                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/BuiltinAttributes.h:12,
                 from /home/runner/work/circt/circt/include/circt/Dialect/FIRRTL/FIRRTLDialect.h:17,
                 from /home/runner/work/circt/circt/include/circt/Dialect/FIRRTL/FIRRTLOps.h:16,
                 from /home/runner/work/circt/circt/lib/Dialect/FIRRTL/FIRRTLOps.cpp:13:
/home/runner/work/circt/circt/llvm/install/include/llvm/ADT/DenseMap.h: In function ‘mlir::LogicalResult verifyMemOp(circt::firrtl::MemOp)’:
/home/runner/work/circt/circt/llvm/install/include/llvm/ADT/DenseMap.h:1165:18: warning: ‘*((void*)(& portNamesSet)+16).llvm::SmallDenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, 8, llvm::DenseMapInfo<mlir::Attribute>, llvm::detail::DenseSetPair<mlir::Attribute> >::LargeRep::NumBuckets’ may be used uninitialized in this function [-Wmaybe-uninitialized]
     return Small ? InlineBuckets : getLargeRep()->NumBuckets;
            ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/runner/work/circt/circt/llvm/install/include/llvm/ADT/DenseMap.h:1156:18: warning: ‘*((void*)(& portNamesSet)+16).llvm::SmallDenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, 8, llvm::DenseMapInfo<mlir::Attribute>, llvm::detail::DenseSetPair<mlir::Attribute> >::LargeRep::Buckets’ may be used uninitialized in this function [-Wmaybe-uninitialized]
     return Small ? getInlineBuckets() : getLargeRep()->Buckets;
            ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~","/home/runner/work/circt/circt/lib/Dialect/FIRRTL/FIRRTLTypes.cpp: In function ‘mlir::ParseResult parseType(circt::firrtl::FIRRTLType&, mlir::DialectAsmParser&)’:
/home/runner/work/circt/circt/lib/Dialect/FIRRTL/FIRRTLTypes.cpp:148:35: warning: ‘fieldIntName’ may be used uninitialized in this function [-Wmaybe-uninitialized]
             nameStr = llvm::utostr(fieldIntName);","[ 75%] Building CXX object lib/Dialect/LLHD/Simulator/CMakeFiles/obj.CIRCTLLHDSimEngine.dir/Engine.cpp.o
/home/runner/work/circt/circt/tools/handshake-runner/Simulation.cpp: In function ‘void executeHandshakeFunction(circt::handshake::FuncOp&, llvm::DenseMap<mlir::Value, llvm::Any>&, llvm::DenseMap<mlir::Value, double>&, std::vector<llvm::Any>&, std::vector<double>&, std::vector<std::vector<llvm::Any> >&, std::vector<double>&)’:
/home/runner/work/circt/circt/tools/handshake-runner/Simulation.cpp:568:27: warning: ‘time’ may be used uninitialized in this function [-Wmaybe-uninitialized]
       timeMap[out] = time + 1;","[ 84%] Building CXX object lib/Conversion/HandshakeToFIRRTL/CMakeFiles/obj.CIRCTHandshakeToFIRRTL.dir/HandshakeToFIRRTL.cpp.o
/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp: In lambda function:
/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp:62:7: warning: control reaches end of non-void function [-Wreturn-type]
       })","/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp: In member function ‘bool {anonymous}::StdExprBuilder::visitStdExpr(mlir::CmpIOp)’:
/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp:633:1: warning: control reaches end of non-void function [-Wreturn-type]
 }","/home/runner/work/circt/circt/lib/Dialect/ESI/ESIPasses.cpp:190:19: warning: ‘circt::rtl::RTLModuleExternOp {anonymous}::ESIRTLBuilder::declareCosimEndpoint()’ defined but not used [-Wunused-function]
 RTLModuleExternOp ESIRTLBuilder::declareCosimEndpoint() {
                   ^~~~~~~~~~~~~
[ 89%] Built target obj.CIRCTFIRRTLTransforms","/home/runner/work/circt/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:268:13: warning: ‘mlir::ParseResult {anonymous}::FIRParser::parseGetLocation(mlir::Location&)’ defined but not used [-Wunused-function]
 ParseResult FIRParser::parseGetLocation(Location &loc) {
             ^~~~~~~~~
/home/runner/work/circt/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:263:13: warning: ‘mlir::ParseResult {anonymous}::FIRParser::parseGetLocation(llvm::SMLoc&)’ defined but not used [-Wunused-function]
 ParseResult FIRParser::parseGetLocation(SMLoc &loc) {
             ^~~~~~~~~
In file included from /home/runner/work/circt/circt/include/circt/Dialect/SV/SVOps.h:43:0,
                 from /home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:19:
/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc: In static member function ‘static char circt::sv::CaseZOp::getLetter(circt::sv::CaseZOp::PatternBit, bool)’:
/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc:609:5: warning: control reaches end of non-void function [-Wreturn-type]
     }","/home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilogFIRRTL.cpp:961:13: warning: ‘{anonymous}::SubExprInfo {anonymous}::ExprEmitter::emitUnary(mlir::Operation*, const char*, bool)’ defined but not used [-Wunused-function]
 SubExprInfo ExprEmitter::emitUnary(Operation *op, const char *syntax,
             ^~~~~~~~~~~
/home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilogFIRRTL.cpp:940:13: warning: ‘{anonymous}::SubExprInfo {anonymous}::ExprEmitter::emitVariadic(mlir::Operation*, {anonymous}::VerilogPrecedence, const char*)’ defined but not used [-Wunused-function]
 SubExprInfo ExprEmitter::emitVariadic(Operation *op, VerilogPrecedence prec,
             ^~~~~~~~~~~
/home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilogFIRRTL.cpp:875:13: warning: ‘{anonymous}::SubExprInfo {anonymous}::ExprEmitter::emitBinary(mlir::Operation*, {anonymous}::VerilogPrecedence, const char*, bool)’ defined but not used [-Wunused-function]
 SubExprInfo ExprEmitter::emitBinary(Operation *op, VerilogPrecedence prec,
             ^~~~~~~~~~~","/home/runner/work/circt/circt/tools/firtool/firtool.cpp: In function ‘mlir::LogicalResult processBuffer(std::unique_ptr<llvm::MemoryBuffer>, llvm::raw_ostream&)’:
/home/runner/work/circt/circt/tools/firtool/firtool.cpp:173:1: warning: control reaches end of non-void function [-Wreturn-type]
 };"
701,[FIRRTL] wire inside always block,2021-03-02T02:20:09Z,closed,"bug, ExportVerilog","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input inp_a: {inp_b: {inp_j: SInt<11>}, inp_f: SInt<19>}
    reg _tmp6: UInt<25>, clock with: (reset => (reset, UInt<25>(0)))
    _tmp6 <= and(inp_a.inp_b.inp_j, SInt<25>(12345))
```

Compiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:

```verilog
// skipped defines
module top_mod(
  input        clock, reset,
  input [10:0] inp_a_inp_b_inp_j,
  input [18:0] inp_a_inp_f);

  reg [24:0] _tmp6;	// a_top_mod.fir:6:5

  always_ff @(posedge clock) begin	// a_top_mod.fir:6:5
    if (reset)	// a_top_mod.fir:6:5
      _tmp6 <= 25'h0;	// a_top_mod.fir:6:{5,56}
    else	// a_top_mod.fir:6:5
      wire [24:0] _tmp = {{14{inp_a_inp_b_inp_j[10]}}, inp_a_inp_b_inp_j};	// a_top_mod.fir:7:14
      _tmp6 <= _tmp & 25'h3039;	// a_top_mod.fir:7:{11,14,37}
  end // always_ff @(posedge)
  `ifndef SYNTHESIS	// a_top_mod.fir:6:5
    initial begin	// a_top_mod.fir:6:5
      `INIT_RANDOM_PROLOG_	// a_top_mod.fir:6:5
      `ifdef RANDOMIZE_REG_INIT	// a_top_mod.fir:6:5
        if (~reset)	// a_top_mod.fir:6:5
          _tmp6 = `RANDOM;	// a_top_mod.fir:6:5
      `endif
    end // initial
  `endif
  wire [24:0] _tmp = {{14{inp_a_inp_b_inp_j[10]}}, inp_a_inp_b_inp_j};	// a_top_mod.fir:7:14
endmodule
```

An output Verilog has an error, declaring `wire` iside `always_ff` block.

```verilog
%Error: a_top_mod_new.sv:66:7: syntax error, unexpected wire
   66 |       wire [24:0] _tmp = {{14{inp_a_inp_b_inp_j[10]}}, inp_a_inp_b_inp_j};  
      |       ^~~~
```","circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input inp_a: {inp_b: {inp_j: SInt<11>}, inp_f: SInt<19>}
    reg _tmp6: UInt<25>, clock with: (reset => (reset, UInt<25>(0)))
    _tmp6 <= and(inp_a.inp_b.inp_j, SInt<25>(12345))","// skipped defines
module top_mod(
  input        clock, reset,
  input [10:0] inp_a_inp_b_inp_j,
  input [18:0] inp_a_inp_f);

  reg [24:0] _tmp6;	// a_top_mod.fir:6:5

  always_ff @(posedge clock) begin	// a_top_mod.fir:6:5
    if (reset)	// a_top_mod.fir:6:5
      _tmp6 <= 25'h0;	// a_top_mod.fir:6:{5,56}
    else	// a_top_mod.fir:6:5
      wire [24:0] _tmp = {{14{inp_a_inp_b_inp_j[10]}}, inp_a_inp_b_inp_j};	// a_top_mod.fir:7:14
      _tmp6 <= _tmp & 25'h3039;	// a_top_mod.fir:7:{11,14,37}
  end // always_ff @(posedge)
  `ifndef SYNTHESIS	// a_top_mod.fir:6:5
    initial begin	// a_top_mod.fir:6:5
      `INIT_RANDOM_PROLOG_	// a_top_mod.fir:6:5
      `ifdef RANDOMIZE_REG_INIT	// a_top_mod.fir:6:5
        if (~reset)	// a_top_mod.fir:6:5
          _tmp6 = `RANDOM;	// a_top_mod.fir:6:5
      `endif
    end // initial
  `endif
  wire [24:0] _tmp = {{14{inp_a_inp_b_inp_j[10]}}, inp_a_inp_b_inp_j};	// a_top_mod.fir:7:14
endmodule","%Error: a_top_mod_new.sv:66:7: syntax error, unexpected wire
   66 |       wire [24:0] _tmp = {{14{inp_a_inp_b_inp_j[10]}}, inp_a_inp_b_inp_j};  
      |       ^~~~",,,,,,,
699,[FIRRTL] RegReset may have reset values narrower than register,2021-03-01T22:05:54Z,closed,bug,"We aren't handling values narrower than the register being used for reset.  FIRRTL generates these.
```
module  {
  firrtl.circuit ""AQS"" {
    firrtl.module @AQS(%clock: !firrtl.clock, %reset: !firrtl.asyncreset) {
      %c0_ui1 = firrtl.constant(0 : ui1) : !firrtl.uint<1>
      %widx_widx_bin = firrtl.regreset %clock, %reset, %c0_ui1 {name = ""widx_widx_bin""} : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.uint<4>
    }
  }
}
```","module  {
  firrtl.circuit ""AQS"" {
    firrtl.module @AQS(%clock: !firrtl.clock, %reset: !firrtl.asyncreset) {
      %c0_ui1 = firrtl.constant(0 : ui1) : !firrtl.uint<1>
      %widx_widx_bin = firrtl.regreset %clock, %reset, %c0_ui1 {name = ""widx_widx_bin""} : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.uint<4>
    }
  }
}",,,,,,,,,
690,module instance with analog port not lowered correctly,2021-02-26T23:16:43Z,closed,"bug, FIRRTL","lowerTypes(analog) -> integer for instances, but modules expecting an inout<integer>
test case:
```
module  {
  firrtl.circuit ""foo"" {
    firrtl.module @bar(%led_0: !firrtl.analog<1>) {
    }
    firrtl.module @foo() {
      %fpga_led_0 = firrtl.instance @bar {name = ""fpga"", portNames = [""led_0""]} : !firrtl.analog<1>
   }
  }
}
```
Running it:
```
andrew@narya:~/src/examples$  ~/src/circt/build/bin/firtool --mlir-disable-threading --lower-to-rtl --enable-lower-types bug.mlir
bug.mlir:6:21: error: 'rtl.instance' op #0 operand type must be '!rtl.inout<i1>', but got 'i1'
      %fpga_led_0 = firrtl.instance @bar {name = ""fpga"", portNames = [""led_0""]} : !firrtl.analog<1>
                    ^
bug.mlir:6:21: note: see current operation: ""rtl.instance""(%0) {instanceName = ""fpga"", moduleName = @bar} : (i1) -> ()
bug.mlir:3:5: note: original module declared here
    firrtl.module @bar(%led_0: !firrtl.analog<1>) {
    ^
```","module  {
  firrtl.circuit ""foo"" {
    firrtl.module @bar(%led_0: !firrtl.analog<1>) {
    }
    firrtl.module @foo() {
      %fpga_led_0 = firrtl.instance @bar {name = ""fpga"", portNames = [""led_0""]} : !firrtl.analog<1>
   }
  }
}","andrew@narya:~/src/examples$  ~/src/circt/build/bin/firtool --mlir-disable-threading --lower-to-rtl --enable-lower-types bug.mlir
bug.mlir:6:21: error: 'rtl.instance' op #0 operand type must be '!rtl.inout<i1>', but got 'i1'
      %fpga_led_0 = firrtl.instance @bar {name = ""fpga"", portNames = [""led_0""]} : !firrtl.analog<1>
                    ^
bug.mlir:6:21: note: see current operation: ""rtl.instance""(%0) {instanceName = ""fpga"", moduleName = @bar} : (i1) -> ()
bug.mlir:3:5: note: original module declared here
    firrtl.module @bar(%led_0: !firrtl.analog<1>) {
    ^",,,,,,,,
682,Handle Registers in LowerTypes,2021-02-25T20:55:07Z,closed,"bug, FIRRTL","Aggregate *registers* are currently not being lowering in FIRRTL Dialect's type lowering pass. I think this is a straightforward addition of a visitor for wire ops in the pass.

Consider:
```scala
circuit Bar :
  module Bar:
    input a: {a: UInt<1>}
    input clk: Clock
    output b: {a: UInt<1>}

    reg x: {a: UInt<1>}, clk

    x.a <= a.a
    b.a <= x.a
```

This is currently crashing when running:

```bash
circt-translate -import-firrtl Bar.fir | circt-opt -pass-pipeline='firrtl.circuit(firrtl.module(firrtl-lower-types))'
```

With:

```
Assertion failed: (entry && ""bundle lowering was not set""), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 524.
```

This is basically the same thing as #680, just split out to potentially expose more parallel work.","circuit Bar :
  module Bar:
    input a: {a: UInt<1>}
    input clk: Clock
    output b: {a: UInt<1>}

    reg x: {a: UInt<1>}, clk

    x.a <= a.a
    b.a <= x.a",circt-translate -import-firrtl Bar.fir | circt-opt -pass-pipeline='firrtl.circuit(firrtl.module(firrtl-lower-types))',"Assertion failed: (entry && ""bundle lowering was not set""), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 524.",,,,,,,
681,module names with keywords aren't renamed in export,2021-02-25T20:45:02Z,closed,"bug, good first issue","for example, rtl-dialect.mlir has a module ""inout"" which isn't allowed.",,,,,,,,,,
680,Handle wires in LowerTypes,2021-02-25T20:41:34Z,closed,"bug, FIRRTL","Aggregate wires are currently not being lowering in FIRRTL Dialect's type lowering pass. I think this is a straightforward addition of a visitor for wire ops in the pass.

Consider:
```scala
circuit Foo :
  module Foo:
    input a: {a: UInt<1>}
    output b: {a: UInt<1>}

    wire x: {a: UInt<1>}

    x.a <= a.a
    b.a <= x.a
```

This is currently crashing when running:

```bash
circt-translate -import-firrtl Foo.fir | circt-opt -pass-pipeline='firrtl.circuit(firrtl.module(firrtl-lower-types))'
```

With:

```
Assertion failed: (entry && ""bundle lowering was not set""), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 524.
```","circuit Foo :
  module Foo:
    input a: {a: UInt<1>}
    output b: {a: UInt<1>}

    wire x: {a: UInt<1>}

    x.a <= a.a
    b.a <= x.a",circt-translate -import-firrtl Foo.fir | circt-opt -pass-pipeline='firrtl.circuit(firrtl.module(firrtl-lower-types))',"Assertion failed: (entry && ""bundle lowering was not set""), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 524.",,,,,,,
679,[FIRRTL] (cat / gt) mismatch,2021-02-25T20:09:00Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 4046
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input inp_h: SInt<0>
    input inp_e: UInt<11>
    output tmp15: UInt<1>
    reg tmp6: UInt<28>, clock
    reg _tmp10: UInt<1>, clock with: (reset => (reset, UInt<1>(0)))
    tmp6 <= cat(SInt<28>(""h-6de5f19""), inp_h)
    _tmp10 <= gt(UInt<11>(0), tmp6)
    tmp15 <= _tmp10
```

Compiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:

```verilog
// skipped defines
module top_mod(
  input         clock, reset,
  input  [10:0] inp_e,
  output        tmp15);

  reg [27:0] tmp6;	// a_top_mod.fir:9:5
  reg        _tmp10;	// a_top_mod.fir:10:5
// skipped ifdefs
  always_ff @(posedge clock)	// a_top_mod.fir:11:10
    tmp6 <= 28'h921A0E7;	// a_top_mod.fir:11:{10,17}
  always_ff @(posedge clock) begin	// a_top_mod.fir:12:12
    if (reset)	// a_top_mod.fir:12:12
      _tmp10 <= 1'h0;	// a_top_mod.fir:10:5, :12:15
    else	// a_top_mod.fir:12:12
      _tmp10 <= 1'h0;	// a_top_mod.fir:12:{12,15}
  end // always_ff @(posedge)
  assign tmp15 = _tmp10;	// a_top_mod.fir:3:3
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:

```verilog
module top_mod(
  input         clock,
  input         reset,
  input  [10:0] inp_e,
  output        tmp15
);
// skipped ifdefs
  reg  _tmp10;
  assign tmp15 = _tmp10;
  always @(posedge clock) begin
    if (reset) begin
      _tmp10 <= 1'h0;
    end else begin
      _tmp10 <= 1'h1;
    end
  end
// skipped ifdefs
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
yosys 0
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 1
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 2
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
```

Looks like `_tmp10` optimized to the different constant?
","; seed: 4046
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input inp_h: SInt<0>
    input inp_e: UInt<11>
    output tmp15: UInt<1>
    reg tmp6: UInt<28>, clock
    reg _tmp10: UInt<1>, clock with: (reset => (reset, UInt<1>(0)))
    tmp6 <= cat(SInt<28>(""h-6de5f19""), inp_h)
    _tmp10 <= gt(UInt<11>(0), tmp6)
    tmp15 <= _tmp10","// skipped defines
module top_mod(
  input         clock, reset,
  input  [10:0] inp_e,
  output        tmp15);

  reg [27:0] tmp6;	// a_top_mod.fir:9:5
  reg        _tmp10;	// a_top_mod.fir:10:5
// skipped ifdefs
  always_ff @(posedge clock)	// a_top_mod.fir:11:10
    tmp6 <= 28'h921A0E7;	// a_top_mod.fir:11:{10,17}
  always_ff @(posedge clock) begin	// a_top_mod.fir:12:12
    if (reset)	// a_top_mod.fir:12:12
      _tmp10 <= 1'h0;	// a_top_mod.fir:10:5, :12:15
    else	// a_top_mod.fir:12:12
      _tmp10 <= 1'h0;	// a_top_mod.fir:12:{12,15}
  end // always_ff @(posedge)
  assign tmp15 = _tmp10;	// a_top_mod.fir:3:3
endmodule","module top_mod(
  input         clock,
  input         reset,
  input  [10:0] inp_e,
  output        tmp15
);
// skipped ifdefs
  reg  _tmp10;
  assign tmp15 = _tmp10;
  always @(posedge clock) begin
    if (reset) begin
      _tmp10 <= 1'h0;
    end else begin
      _tmp10 <= 1'h1;
    end
  end
// skipped ifdefs
endmodule","yosys 0
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 1
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 2
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.",,,,,,
678,[FIRRTL] (div / reg / add) mismatch,2021-02-25T19:37:30Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
; seed: 3727
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    output tmp22: SInt<8>
    output _tmp30: UInt<1>
    input tmp6: SInt<1>
    wire tmp7: UInt<1>
    reg _tmp17: UInt<7>, clock
    reg tmp21: UInt<1>, clock with: (reset => (reset, UInt<1>(0)))
    tmp7 <= UInt<1>(0)
    _tmp17 <= div(UInt<7>(""b1101111""), tmp7)
    tmp21 <= orr(_tmp17)
    tmp22 <= add(tmp6, asSInt(_tmp17))
    _tmp30 <= tmp21
```

Compiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:

```verilog
// skipped defines
module top_mod(
  input        clock, reset, tmp6,
  output [7:0] tmp22,
  output       _tmp30);

  wire       tmp7;	// a_top_mod.fir:9:5
  reg  [6:0] _tmp17;	// a_top_mod.fir:10:5
  reg        tmp21;	// a_top_mod.fir:11:5

// skipped ifdefs
  assign tmp7 = 1'h0;	// a_top_mod.fir:11:55, :12:10
  always_ff @(posedge clock)	// a_top_mod.fir:13:12
    _tmp17 <= 7'h6F / {6'h0, tmp7};	// a_top_mod.fir:13:{12,15,19}
  wire [6:0] _T = _tmp17;	// a_top_mod.fir:14:14
  always_ff @(posedge clock) begin	// a_top_mod.fir:14:11
    if (reset)	// a_top_mod.fir:14:11
      tmp21 <= 1'h0;	// a_top_mod.fir:11:{5,55}
    else	// a_top_mod.fir:14:11
      tmp21 <= |_T;	// a_top_mod.fir:14:{11,14}
  end // always_ff @(posedge)
  assign tmp22 = {8{tmp6}} + {{1{_T[6]}}, _T};	// a_top_mod.fir:3:3, :15:14
  assign _tmp30 = tmp21;	// a_top_mod.fir:3:3
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:

```verilog
module top_mod(
  input        clock,
  input        reset,
  output [7:0] tmp22,
  output       _tmp30,
  input        tmp6
);
// skipped ifdefs
  reg [6:0] _tmp17;
  reg  tmp21;
  wire [6:0] _GEN_0 = {7{tmp6}};
  assign tmp22 = $signed(_GEN_0) + $signed(_tmp17);
  assign _tmp30 = tmp21;
  always @(posedge clock) begin
    _tmp17 <= 7'h6f / 1'h0;
    if (reset) begin
      tmp21 <= 1'h0;
    end else begin
      tmp21 <= |_tmp17;
    end
  end
// skipped ifdefs
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
yosys 0
ERROR: Found 9 unproven $equiv cells in 'equiv_status -assert'.
yosys 1
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
```
","; seed: 3727
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    output tmp22: SInt<8>
    output _tmp30: UInt<1>
    input tmp6: SInt<1>
    wire tmp7: UInt<1>
    reg _tmp17: UInt<7>, clock
    reg tmp21: UInt<1>, clock with: (reset => (reset, UInt<1>(0)))
    tmp7 <= UInt<1>(0)
    _tmp17 <= div(UInt<7>(""b1101111""), tmp7)
    tmp21 <= orr(_tmp17)
    tmp22 <= add(tmp6, asSInt(_tmp17))
    _tmp30 <= tmp21","// skipped defines
module top_mod(
  input        clock, reset, tmp6,
  output [7:0] tmp22,
  output       _tmp30);

  wire       tmp7;	// a_top_mod.fir:9:5
  reg  [6:0] _tmp17;	// a_top_mod.fir:10:5
  reg        tmp21;	// a_top_mod.fir:11:5

// skipped ifdefs
  assign tmp7 = 1'h0;	// a_top_mod.fir:11:55, :12:10
  always_ff @(posedge clock)	// a_top_mod.fir:13:12
    _tmp17 <= 7'h6F / {6'h0, tmp7};	// a_top_mod.fir:13:{12,15,19}
  wire [6:0] _T = _tmp17;	// a_top_mod.fir:14:14
  always_ff @(posedge clock) begin	// a_top_mod.fir:14:11
    if (reset)	// a_top_mod.fir:14:11
      tmp21 <= 1'h0;	// a_top_mod.fir:11:{5,55}
    else	// a_top_mod.fir:14:11
      tmp21 <= |_T;	// a_top_mod.fir:14:{11,14}
  end // always_ff @(posedge)
  assign tmp22 = {8{tmp6}} + {{1{_T[6]}}, _T};	// a_top_mod.fir:3:3, :15:14
  assign _tmp30 = tmp21;	// a_top_mod.fir:3:3
endmodule","module top_mod(
  input        clock,
  input        reset,
  output [7:0] tmp22,
  output       _tmp30,
  input        tmp6
);
// skipped ifdefs
  reg [6:0] _tmp17;
  reg  tmp21;
  wire [6:0] _GEN_0 = {7{tmp6}};
  assign tmp22 = $signed(_GEN_0) + $signed(_tmp17);
  assign _tmp30 = tmp21;
  always @(posedge clock) begin
    _tmp17 <= 7'h6f / 1'h0;
    if (reset) begin
      tmp21 <= 1'h0;
    end else begin
      tmp21 <= |_tmp17;
    end
  end
// skipped ifdefs
endmodule","yosys 0
ERROR: Found 9 unproven $equiv cells in 'equiv_status -assert'.
yosys 1
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.",,,,,,
672,[FIRRTL] (rem / eq) mismatch,2021-02-25T06:55:18Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input tmp22: UInt<5>
    output _tmp23: UInt<1>
    wire tmp16: SInt<2>
    tmp16 <= rem(SInt<2>(""o-1""), SInt<14>(""o16271""))
    _tmp23 <= eq(tmp22, asUInt(tmp16))
```

Compiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:

```verilog
// skipped defines
module top_mod(
  input  [4:0] tmp22,
  output       _tmp23);

  wire [1:0] tmp16;	// a_top_mod.fir:6:5

  wire [13:0] _T = -14'sh1 % 14'sh1CB9;	// a_top_mod.fir:7:{14,34}
  assign tmp16 = _T[1:0];	// a_top_mod.fir:7:{11,14}
  assign _tmp23 = tmp22 == {3'h0, tmp16};	// a_top_mod.fir:3:3, :8:15
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:

```verilog
module top_mod(
  input  [4:0] tmp22,
  output       _tmp23
);
  wire [13:0] _GEN_0 = -14'sh1 % 14'sh1cb9;
  wire [13:0] _GEN_1 = _GEN_0;
  assign _tmp23 = tmp22 == _GEN_1;
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
yosys 0
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 1
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 2
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 3
ERROR: Called with -verify and proof did fail!
yosys 4
ERROR: Called with -verify and proof did fail!
```
","circuit top_mod :
  module top_mod :
    input tmp22: UInt<5>
    output _tmp23: UInt<1>
    wire tmp16: SInt<2>
    tmp16 <= rem(SInt<2>(""o-1""), SInt<14>(""o16271""))
    _tmp23 <= eq(tmp22, asUInt(tmp16))","// skipped defines
module top_mod(
  input  [4:0] tmp22,
  output       _tmp23);

  wire [1:0] tmp16;	// a_top_mod.fir:6:5

  wire [13:0] _T = -14'sh1 % 14'sh1CB9;	// a_top_mod.fir:7:{14,34}
  assign tmp16 = _T[1:0];	// a_top_mod.fir:7:{11,14}
  assign _tmp23 = tmp22 == {3'h0, tmp16};	// a_top_mod.fir:3:3, :8:15
endmodule","module top_mod(
  input  [4:0] tmp22,
  output       _tmp23
);
  wire [13:0] _GEN_0 = -14'sh1 % 14'sh1cb9;
  wire [13:0] _GEN_1 = _GEN_0;
  assign _tmp23 = tmp22 == _GEN_1;
endmodule","yosys 0
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 1
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 2
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
yosys 3
ERROR: Called with -verify and proof did fail!
yosys 4
ERROR: Called with -verify and proof did fail!",,,,,,
671,[FIRRTL] (rem / mux) mismatch,2021-02-25T05:17:47Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input tmp13: SInt<11>
    output tmp28: UInt<26>
    input _tmp24: UInt<1>
    input tmp25: UInt<26>
    wire tmp18: SInt<11>
    tmp18 <= rem(tmp13, asSInt(UInt<24>(9972122)))
    tmp28 <= mux(tail(asUInt(tmp18), 10), tmp25, _tmp24)
```

Compiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:

```verilog
// skipped defines
module top_mod(
  input  [10:0] tmp13,
  input         _tmp24,
  input  [25:0] tmp25,
  output [25:0] tmp28);

  wire [10:0] tmp18;	// a_top_mod.fir:7:5

  wire [23:0] _T = $signed({{13{tmp13[10]}}, tmp13}) % -24'sh67D666;	// a_top_mod.fir:8:{14,25}
  assign tmp18 = _T[10:0];	// a_top_mod.fir:8:{11,14}
  wire [10:0] _T_0 = tmp18;	// a_top_mod.fir:9:18
  assign tmp28 = _T_0[0] ? tmp25 : {25'h0, _tmp24};	// a_top_mod.fir:2:3, :9:{14,18}
endmodule
```

Compiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:

```verilog
module top_mod(
  input  [10:0] tmp13,
  output [25:0] tmp28,
  input         _tmp24,
  input  [25:0] tmp25
);
  wire [23:0] _GEN_0 = {{13{tmp13[10]}},tmp13};
  wire [23:0] _GEN_1 = $signed(_GEN_0) % -24'sh67d666;
  assign tmp28 = _GEN_1[13:0] ? tmp25 : {{25'd0}, _tmp24};
endmodule
```

`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:

```
yosys 0
ERROR: Found 26 unproven $equiv cells in 'equiv_status -assert'.
yosys 1
ERROR: Found 26 unproven $equiv cells in 'equiv_status -assert'.
yosys 2
ERROR: Found 26 unproven $equiv cells in 'equiv_status -assert'.
yosys 3
ERROR: Called with -verify and proof did fail!
yosys 4
ERROR: Called with -verify and proof did fail!
```
","circuit top_mod :
  module top_mod :
    input tmp13: SInt<11>
    output tmp28: UInt<26>
    input _tmp24: UInt<1>
    input tmp25: UInt<26>
    wire tmp18: SInt<11>
    tmp18 <= rem(tmp13, asSInt(UInt<24>(9972122)))
    tmp28 <= mux(tail(asUInt(tmp18), 10), tmp25, _tmp24)","// skipped defines
module top_mod(
  input  [10:0] tmp13,
  input         _tmp24,
  input  [25:0] tmp25,
  output [25:0] tmp28);

  wire [10:0] tmp18;	// a_top_mod.fir:7:5

  wire [23:0] _T = $signed({{13{tmp13[10]}}, tmp13}) % -24'sh67D666;	// a_top_mod.fir:8:{14,25}
  assign tmp18 = _T[10:0];	// a_top_mod.fir:8:{11,14}
  wire [10:0] _T_0 = tmp18;	// a_top_mod.fir:9:18
  assign tmp28 = _T_0[0] ? tmp25 : {25'h0, _tmp24};	// a_top_mod.fir:2:3, :9:{14,18}
endmodule","module top_mod(
  input  [10:0] tmp13,
  output [25:0] tmp28,
  input         _tmp24,
  input  [25:0] tmp25
);
  wire [23:0] _GEN_0 = {{13{tmp13[10]}},tmp13};
  wire [23:0] _GEN_1 = $signed(_GEN_0) % -24'sh67d666;
  assign tmp28 = _GEN_1[13:0] ? tmp25 : {{25'd0}, _tmp24};
endmodule","yosys 0
ERROR: Found 26 unproven $equiv cells in 'equiv_status -assert'.
yosys 1
ERROR: Found 26 unproven $equiv cells in 'equiv_status -assert'.
yosys 2
ERROR: Found 26 unproven $equiv cells in 'equiv_status -assert'.
yosys 3
ERROR: Called with -verify and proof did fail!
yosys 4
ERROR: Called with -verify and proof did fail!",,,,,,
669,MemOp with readwrite ports not lowered,2021-02-24T22:31:11Z,closed,"bug, FIRRTL","from firtool:
```
foo.mlir:1759866:79: error: 'firrtl.mem' op readwrite ports should be lowered into separate read and write ports by previous passes
```",foo.mlir:1759866:79: error: 'firrtl.mem' op readwrite ports should be lowered into separate read and write ports by previous passes,,,,,,,,,
668,ExportVerilog not splitting line for long variadic ops,2021-02-24T22:17:37Z,closed,"bug, ExportVerilog","Not splitting single expressions which are long.
```
    %3844 = comb.or %3233, %3234, %3235, %3236, %3237, %3238, %3240, %3241, %3242, %3243, %3244, %3245, %3246, %3247, %3248, %3249, %3250, %3251, %3252, %3253, %3254, %3255, %3256, %3257, %3258, %3259, %3260, %3261, %3263, %3264, %3265, %3267, %3268, %3269, %3270, %3271, %3272, %3273, %3274, %3275, %3276, %3277, %3278, %3279, %3280, %3281, %3282, %3283, %3284, %3285, %3286, %3288, %3290, %3291, %3292, %3293, %3294, %3295, %3296, %3297, %3298, %3299, %3300, %3301, %3302, %3303, %3304, %3305, %3306, %3307, %3308, %3309, %3310, %3311, %3312, %3313, %3314, %3315, %3316, %3317, %3319, %3320, %3321, %3322, %3323, %3324, %3325, %3326, %3327, %3328, %3329, %3330, %3331, %3332, %3333, %3334, %3335, %3336, %3338, %3339, %3340, %3341, %3342, %3343, %3344, %3345, %3346, %3347, %3349, %3350, %3351, %3352, %3353, %3354, %3355, %3356, %3357, %3358, %3359, %3360, %3362, %3363, %3364, %3365, %3366, %3367, %3368, %3369, %3370, %3371, %3372, %3373, %3374, %3375, %3376, %3377, %3378, %3379, %3380, %3381, %3382, %3383, %3384, %3385, %3386, %3387, %3388, %3390, %3391, %3392, %3393, %3394, %3395, %3396, %3397, %3398, %3399, %3400, %3401, %3402, %3403, %3404, %3405, %3406, %3407, %3408, %3409, %3411, %3412, %3413, %3414, %3415, %3416, %3417, %3418, %3419, %3420, %3421, %3422, %3423, %3424, %3425, %3426, %3427, %3428, %3429, %3430, %3431, %3432, %3433, %3434, %3435, %3436, %3437, %3438, %3439, %3440, %3441, %3442, %3444, %3446, %3447, %3448, %3449, %3450, %3451, %3452, %3453, %3455, %3456, %3457, %3458, %3459, %3460, %3461, %3462, %3463, %3464, %3465, %3466, %3467, %3468, %3469, %3470, %3471, %3472, %3473, %3474, %3475, %3476, %3477, %3478, %3479, %3480, %3481, %3482, %3483, %3484, %3485, %3486, %3487, %3488, %3489, %3490, %3491, %3492, %3493, %3494, %3495, %3496, %3497, %3498, %3499, %3500, %3501, %3502, %3503, %3504, %3505, %3506, %3507, %3508, %3509, %3510, %3511, %3512, %3513, %3514, %3515, %3516, %3517, %3518, %3519, %3520, %3521, %3522, %3523, %3524, %3525, %3526, %3527, %3528, %3529, %3530, %3531, %3532, %3533, %3534, %3535, %3536, %3537, %3538, %3539, %3540, %3541, %3542, %3543, %3544, %3545, %3546, %3547, %3548, %3549, %3550, %3551, %3552, %3553, %3554, %3555, %3556, %3557, %3558, %3559, %3560, %3561, %3562, %3563, %3564, %3565, %3566, %3567, %3568, %3569, %3570, %3571, %3572, %3573, %3574, %3575, %3576, %3577, %3578, %3579, %3580, %3581, %3583, %3584, %3585, %3586, %3588, %3589, %3590, %3591, %3592, %3593, %3594, %3595, %3596, %3597, %3598, %3599, %3600, %3601, %3602, %3603, %3604, %3605, %3606, %3607, %3608, %3609, %3610, %3611, %3612, %3613, %3614, %3615, %3616, %3617, %3618, %3619, %3620, %3621, %3622, %3623, %3624, %3625, %3626, %3627, %3628, %3629, %3630, %3631, %3632, %3633, %3634, %3635, %3636, %3637, %3638, %3639, %3640, %3641, %3642, %3643, %3644, %3645, %3646, %3647, %3648, %3649, %3650, %3651, %3652, %3653, %3654, %3655, %3656, %3657, %3658, %3659, %3660, %3661, %3662, %3663, %3664, %3665, %3666, %3667, %3668, %3669, %3670, %3671, %3672, %3673, %3674, %3675, %3676, %3677, %3678, %3679, %3680, %3681, %3682, %3683, %3684, %3685, %3686, %3687, %3688, %3689, %3690, %3691, %3692, %3693, %3694, %3695, %3696, %3697, %3698, %3699, %3700, %3701, %3702, %3703, %3704, %3705, %3706, %3707, %3708, %3709, %3710, %3711, %3712, %3713, %3714, %3715, %3716, %3717, %3718, %3719, %3720, %3721, %3722, %3723, %3724, %3725, %3726, %3727, %3728, %3729, %3730, %3731, %3732, %3733, %3734, %3735, %3736, %3737, %3738, %3739, %3740, %3741, %3742, %3743, %3744, %3745, %3746, %3747, %3748, %3749, %3750, %3751, %3752, %3753, %3754, %3755, %3756, %3757, %3758, %3759, %3760, %3761, %3762, %3763, %3764, %3765, %3766, %3767, %3768, %3769, %3770, %3771, %3772, %3773, %3774, %3775, %3776, %3777, %3778, %3779, %3780, %3781, %3782, %3783, %3784, %3785, %3786, %3787, %3788, %3789, %3790, %3791, %3792, %3793, %3794, %3795, %3796, %3797, %3798, %3799, %3800, %3801, %3802, %3803, %3804, %3805, %3806, %3807, %3808, %3809, %3810, %3811, %3812, %3813, %3814, %3815, %3816, %3817, %3818, %3819, %3820, %3821, %3822, %3823, %3824, %3825, %3826, %3827, %3828, %3829, %3830, %3831, %3832, %3833, %3834, %3835, %3836, %3837, %3838, %3840, %3841, %3842, %3843 : i1
```
Makes something like:

```
  wire _T_361 = _T_180 ? _T_181 == 64'h63
| _T_181 == 64'h1063
| _T_181 == 64'h4063
| _T_181 == 64'h6063
| _T_181 == 64'h5063
| _T_181 == 64'h7063
| _T_182 == 64'h6F
| _T_181 == 64'h67
| _T_181 == 64'h3
| _T_181 == 64'h4003
| _T_181 == 64'h1003
| _T_181 == 64'h5003
| _T_181 == 64'h2003
| _T_181 == 64'h6003
| _T_181 == 64'h3003
| _T_181 == 64'h23
| _T_181 == 64'h1023
| _T_181 == 64'h2023
| _T_181 == 64'h3023
| _T_182 == 64'h37
| _T_182 == 64'h17
| _T_181 == 64'h13
| _T_181 == 64'h2013
| _T_181 == 64'h3013
| _T_181 == 64'h7013
| _T_181 == 64'h6013
| _T_181 == 64'h4013
| _T_181 == 64'h1B
| _T_183 == 64'h101B
| _T_183 == 64'h501B
| _T_183 == 64'h4000501B
| _T_184 == 64'h1013
| _T_184 == 64'h5013
| _T_184 == 64'h40005013
| _T_183 == 64'h33
| _T_183 == 64'h40000033
| _T_183 == 64'h2033
| _T_183 == 64'h3033
| _T_183 == 64'h7033
| _T_183 == 64'h6033
| _T_183 == 64'h4033
| _T_183 == 64'h1033
| _T_183 == 64'h5033
| _T_183 == 64'h40005033
| _T_183 == 64'h3B
| _T_183 == 64'h4000003B
| _T_183 == 64'h103B
| _T_183 == 64'h503B
| _T_183 == 64'h4000503B
| _T_181 == 64'hF
| _T_181 == 64'h100F
| (io_fetch_bits_data & 64'hFE007FFF) == 64'h12000073
| _T_185 == 64'hFC000073
| _T_185 == 64'hFC200073
| _T_181 == 64'h5073
| _T_181 == 64'h6073
| _T_181 == 64'h7073
| _T_185 == 64'h73
| _T_185 == 64'h100073
| _T_185 == 64'h30200073
| _T_185 == 64'h10500073
| _T_185 == 64'h30500073
| _T_181 == 64'h1073
| _T_181 == 64'h2073
| _T_181 == 64'h3073
| _T_185 == 64'h10200073
| _T_185 == 64'h7B200073
| _T_183 == 64'h2000033
| _T_183 == 64'h2001033
| _T_183 == 64'h2003033
| _T_183 == 64'h2002033
| _T_183 == 64'h200003B
| _T_183 == 64'h2004033
| _T_183 == 64'h2005033
| _T_183 == 64'h2006033
| _T_183 == 64'h2007033
| _T_183 == 64'h200403B
| _T_183 == 64'h200503B
| _T_183 == 64'h200603B
| _T_183 == 64'h200703B
| _T_186 == 64'h202F
| _T_186 == 64'h6000202F
| _T_186 == 64'h4000202F
| _T_186 == 64'h2000202F
| _T_186 == 64'h8000202F
| _T_186 == 64'hA000202F
| _T_186 == 64'hC000202F
| _T_186 == 64'hE000202F
| _T_186 == 64'h800202F
| _T_186 == 64'h302F
| _T_186 == 64'h6000302F
| _T_186 == 64'h4000302F
| _T_186 == 64'h2000302F
| _T_186 == 64'h8000302F
| _T_186 == 64'hA000302F
| _T_186 == 64'hC000302F
| _T_186 == 64'hE000302F
| _T_186 == 64'h800302F
| _T_187 == 64'h1000202F
| _T_186 == 64'h1800202F
| _T_187 == 64'h1000302F
| _T_186 == 64'h1800302F
| _T_181 == 64'h1027
| _T_181 == 64'h2027
| _T_181 == 64'h3027
| _T_181 == 64'h1007
| _T_181 == 64'h2007
| _T_181 == 64'h3007
| _T_188 == 64'h4000043
| _T_188 == 64'h4000047
| _T_188 == 64'h400004B
| _T_188 == 64'h400004F
| _T_188 == 64'h43
| _T_188 == 64'h47
| _T_188 == 64'h4B
| _T_188 == 64'h4F
| _T_188 == 64'h2000043
| _T_188 == 64'h2000047
| _T_188 == 64'h200004B
| _T_188 == 64'h200004F
| _T_189 == 64'h4000053
| _T_189 == 64'hC000053
| _T_189 == 64'h14000053
| _T_189 == 64'h1C000053
| _T_183 == 64'h24000053
| _T_183 == 64'h24001053
| _T_183 == 64'h24002053
| _T_183 == 64'h2C000053
| _T_183 == 64'h2C001053
| _T_189 == 64'h53
| _T_189 == 64'h8000053
| _T_189 == 64'h10000053
| _T_189 == 64'h18000053
| _T_183 == 64'h20000053
| _T_183 == 64'h20001053
| _T_183 == 64'h20002053
| _T_183 == 64'h28000053
| _T_183 == 64'h28001053
| _T_189 == 64'h2000053
| _T_189 == 64'hA000053
| _T_189 == 64'h12000053
| _T_189 == 64'h1A000053
| _T_183 == 64'h22000053
| _T_183 == 64'h22001053
| _T_183 == 64'h22002053
| _T_183 == 64'h2A000053
| _T_183 == 64'h2A001053
| _T_190 == 64'h5C000053
| _T_190 == 64'h44000053
| _T_190 == 64'h40200053
| _T_190 == 64'h58000053
| _T_190 == 64'h5A000053
| _T_190 == 64'h40100053
| _T_190 == 64'h42000053
| _T_190 == 64'h44100053
| _T_190 == 64'h42200053
| _T_183 == 64'hA4002053
| _T_183 == 64'hA4001053
| _T_183 == 64'hA4000053
| _T_183 == 64'hA0002053
| _T_183 == 64'hA0001053
| _T_183 == 64'hA0000053
| _T_183 == 64'hA2002053
| _T_183 == 64'hA2001053
| _T_183 == 64'hA2000053
| _T_190 == 64'hC4000053
| _T_190 == 64'hC4100053
| _T_191 == 64'hE4001053
| _T_190 == 64'hC4200053
| _T_190 == 64'hC4300053
| _T_190 == 64'hC0000053
| _T_190 == 64'hC0100053
| _T_191 == 64'hE0001053
| _T_190 == 64'hC0200053
| _T_190 == 64'hC0300053
| _T_190 == 64'hC2000053
| _T_190 == 64'hC2100053
| _T_191 == 64'hE2001053
| _T_190 == 64'hC2200053
| _T_190 == 64'hC2300053
| _T_191 == 64'hE4000053
| _T_191 == 64'hE0000053
| _T_191 == 64'hE2000053
| _T_191 == 64'hF4000053
| _T_191 == 64'hF0000053
| _T_191 == 64'hF2000053
| _T_190 == 64'hD4000053
| _T_190 == 64'hD4100053
| _T_190 == 64'hD4200053
| _T_190 == 64'hD4300053
| _T_190 == 64'hD0000053
| _T_190 == 64'hD0100053
| _T_190 == 64'hD0200053
| _T_190 == 64'hD0300053
| _T_190 == 64'hD2000053
| _T_190 == 64'hD2100053
| _T_190 == 64'hD2200053
| _T_190 == 64'hD2300053
| _T_183 == 64'h80007057
| (io_fetch_bits_data & 64'h8000707F) == 64'h7057
| _T_192 == 64'h7
| _T_192 == 64'h5007
| _T_192 == 64'h6007
| _T_192 == 64'h7007
| _T_192 == 64'h1000007
| _T_192 == 64'h1005007
| _T_192 == 64'h1006007
| _T_192 == 64'h1007007
| _T_193 == 64'hC000007
| _T_193 == 64'hC005007
| _T_193 == 64'hC006007
| _T_191 == 64'h2800007
| _T_191 == 64'h2805007
| _T_191 == 64'h2806007
| _T_191 == 64'h2807007
| _T_191 == 64'h22800007
| _T_191 == 64'h22805007
| _T_191 == 64'h22806007
| _T_191 == 64'h22807007
| _T_191 == 64'h62800007
| _T_191 == 64'h62805007
| _T_191 == 64'h62806007
| _T_191 == 64'h62807007
| _T_191 == 64'hE2800007
| _T_191 == 64'hE2805007
| _T_191 == 64'hE2806007
| _T_191 == 64'hE2807007
| _T_193 == 64'hC007007
| _T_192 == 64'h27
| _T_192 == 64'h5027
| _T_192 == 64'h6027
| _T_192 == 64'h7027
| _T_193 == 64'hC000027
| _T_193 == 64'hC005027
| _T_193 == 64'hC006027
| _T_184 == 64'h4000027
| _T_184 == 64'h4005027
| _T_184 == 64'h4006027
| _T_191 == 64'h2800027
| _T_191 == 64'h22800027
| _T_191 == 64'h62800027
| _T_191 == 64'hE2800027
| _T_193 == 64'hC007027
| _T_184 == 64'h4007027
| _T_186 == 64'h800002F
| _T_186 == 64'h2F
| _T_186 == 64'h2000002F
| _T_186 == 64'h6000002F
| _T_186 == 64'h4000002F
| _T_186 == 64'h8000002F
| _T_186 == 64'hA000002F
| _T_186 == 64'hC000002F
| _T_186 == 64'hE000002F
| _T_186 == 64'h800502F
| _T_186 == 64'h502F
| _T_186 == 64'h2000502F
| _T_186 == 64'h6000502F
| _T_186 == 64'h4000502F
| _T_186 == 64'h8000502F
| _T_186 == 64'hA000502F
| _T_186 == 64'hC000502F
| _T_186 == 64'hE000502F
| _T_186 == 64'h800602F
| _T_186 == 64'h602F
| _T_186 == 64'h2000602F
| _T_186 == 64'h6000602F
| _T_186 == 64'h4000602F
| _T_186 == 64'h8000602F
| _T_186 == 64'hA000602F
| _T_186 == 64'hC000602F
| _T_186 == 64'hE000602F
| _T_186 == 64'h800702F
| _T_186 == 64'h702F
| _T_186 == 64'h2000702F
| _T_186 == 64'h6000702F
| _T_186 == 64'h4000702F
| _T_186 == 64'h8000702F
| _T_186 == 64'hA000702F
| _T_186 == 64'hC000702F
| _T_186 == 64'hE000702F
| _T_193 == 64'h8000007
| _T_193 == 64'h8005007
| _T_193 == 64'h8006007
| _T_193 == 64'h8007007
| _T_193 == 64'h8000027
| _T_193 == 64'h8005027
| _T_193 == 64'h8006027
| _T_193 == 64'h8007027
| _T_184 == 64'h2057
| _T_184 == 64'hC4000057
| _T_184 == 64'hC0000057
| _T_184 == 64'h4002057
| _T_184 == 64'h8002057
| _T_184 == 64'hC002057
| _T_184 == 64'h10002057
| _T_184 == 64'h14002057
| _T_184 == 64'h18002057
| _T_184 == 64'h1C002057
| _T_184 == 64'h57
| _T_184 == 64'h8000057
| _T_183 == 64'h40000057
| _T_184 == 64'h44000057
| _T_183 == 64'h48000057
| _T_184 == 64'h4C000057
| _T_184 == 64'h94000057
| _T_184 == 64'hA0000057
| _T_184 == 64'hA4000057
| _T_184 == 64'hB0000057
| _T_184 == 64'hB4000057
| _T_184 == 64'h24000057
| _T_184 == 64'h28000057
| _T_184 == 64'h2C000057
| _T_184 == 64'h60000057
| _T_184 == 64'h64000057
| _T_184 == 64'h6C000057
| _T_184 == 64'h68000057
| _T_184 == 64'h70000057
| _T_184 == 64'h74000057
| _T_184 == 64'h10000057
| _T_184 == 64'h14000057
| _T_184 == 64'h18000057
| _T_184 == 64'h1C000057
| _T_184 == 64'h30000057
| _T_184 == 64'h38000057
| _T_183 == 64'h5E002057
| _T_183 == 64'h5C000057
| _T_191 == 64'h5E000057
| _T_184 == 64'h60002057
| _T_184 == 64'h64002057
| _T_184 == 64'h68002057
| _T_184 == 64'h6C002057
| _T_184 == 64'h70002057
| _T_184 == 64'h74002057
| _T_184 == 64'h78002057
| _T_184 == 64'h7C002057
| _T_194 == 64'h5000A057
| _T_194 == 64'h50012057
| _T_194 == 64'h5001A057
| _T_194 == 64'h50082057
| (io_fetch_bits_data & 64'hFDFFF07F) == 64'h5008A057
| _T_194 == 64'h48032057
| _T_194 == 64'h4803A057
| _T_194 == 64'h48022057
| _T_194 == 64'h4802A057
| _T_194 == 64'h48012057
| _T_194 == 64'h4801A057
| _T_184 == 64'hC4002057
| _T_184 == 64'hC0002057
| _T_184 == 64'hCC002057
| _T_184 == 64'hC8002057
| _T_184 == 64'hD4002057
| _T_184 == 64'hD0002057
| _T_184 == 64'hDC002057
| _T_184 == 64'hD8002057
| _T_184 == 64'hEC002057
| _T_184 == 64'hE0002057
| _T_184 == 64'hE8002057
| _T_184 == 64'hF0002057
| _T_184 == 64'hF4002057
| _T_184 == 64'hFC002057
| _T_184 == 64'h94002057
| _T_184 == 64'h9C002057
| _T_184 == 64'h90002057
| _T_184 == 64'h98002057
| _T_184 == 64'h84002057
| _T_184 == 64'h80002057
| _T_184 == 64'h8C002057
| _T_184 == 64'h88002057
| _T_184 == 64'hA4002057
| _T_184 == 64'hAC002057
| _T_184 == 64'hB4002057
| _T_184 == 64'hBC002057
| _T_184 == 64'h24002057
| _T_184 == 64'h2C002057
| _T_184 == 64'h20002057
| _T_184 == 64'h28002057
| _T_184 == 64'h84000057
| _T_184 == 64'h8C000057
| _T_184 == 64'h80000057
| _T_184 == 64'h88000057
| _T_184 == 64'h9C000057
| _T_184 == 64'hA8000057
| _T_184 == 64'hAC000057
| _T_184 == 64'hBC000057
| _T_184 == 64'hB8000057
| _T_184 == 64'h4001057
| _T_184 == 64'hC4001057
| _T_184 == 64'hC001057
| _T_184 == 64'hCC001057
| _T_184 == 64'h14001057
| _T_184 == 64'h1C001057
| _T_194 == 64'h4C081057
| _T_184 == 64'h10001057
| _T_184 == 64'h18001057
| _T_184 == 64'h60001057
| _T_184 == 64'h64001057
| _T_184 == 64'h6C001057
| _T_184 == 64'h70001057
| _T_194 == 64'h48011057
| _T_194 == 64'h48019057
| _T_194 == 64'h48091057
| _T_194 == 64'h48099057
| _T_194 == 64'h480B1057
| _T_194 == 64'h480B9057
| _T_194 == 64'h48081057
| _T_194 == 64'h48089057
| _T_194 == 64'h48051057
| _T_194 == 64'h48059057
| _T_194 == 64'h48071057
| _T_194 == 64'h48079057
| _T_194 == 64'h48041057
| _T_194 == 64'h48049057
| _T_194 == 64'h48031057
| _T_194 == 64'h48039057
| _T_194 == 64'h48001057
| _T_194 == 64'h48009057
| _T_184 == 64'h90001057
| _T_184 == 64'h1057
| _T_184 == 64'h8001057
| _T_194 == 64'h4C001057
| _T_184 == 64'h80001057
| _T_194 == 64'h4C021057
| _T_194 == 64'h4C029057
| _T_184 == 64'hB0001057
| _T_184 == 64'hB4001057
| _T_184 == 64'hB8001057
| _T_184 == 64'hBC001057
| _T_184 == 64'hA0001057
| _T_184 == 64'hA4001057
| _T_184 == 64'hA8001057
| _T_184 == 64'hAC001057
| _T_184 == 64'h20001057
| _T_184 == 64'h24001057
| _T_184 == 64'h28001057
| _T_194 == 64'h480A1057
| _T_194 == 64'h480A9057
| _T_194 == 64'h48061057
| _T_184 == 64'hC0001057
| _T_184 == 64'hC8001057
| _T_184 == 64'hE0001057
| _T_184 == 64'hD0001057
| _T_184 == 64'hD8001057
| _T_184 == 64'hF0001057
| _T_184 == 64'hF4001057
| _T_184 == 64'hF8001057
| _T_184 == 64'hFC001057
| _T_184 == 64'h3057
| _T_183 == 64'h40003057
| _T_184 == 64'h44003057
| _T_184 == 64'hC003057
| _T_184 == 64'h94003057
| _T_184 == 64'hA0003057
| _T_184 == 64'hA4003057
| _T_184 == 64'hB0003057
| _T_184 == 64'hB4003057
| _T_184 == 64'h24003057
| _T_184 == 64'h28003057
| _T_184 == 64'h2C003057
| _T_183 == 64'h9E003057
| _T_184 == 64'h38003057
| _T_184 == 64'h3C003057
| _T_184 == 64'h60003057
| _T_184 == 64'h64003057
| _T_184 == 64'h70003057
| _T_184 == 64'h74003057
| _T_184 == 64'h78003057
| _T_184 == 64'h7C003057
| _T_184 == 64'h30003057
| _T_183 == 64'h5C003057
| _T_191 == 64'h5E003057
| _T_184 == 64'h84003057
| _T_184 == 64'h80003057
| _T_184 == 64'hA8003057
| _T_184 == 64'hAC003057
| _T_184 == 64'hBC003057
| _T_184 == 64'hB8003057
| _T_184 == 64'h4057
| _T_184 == 64'h8004057
| _T_183 == 64'h40004057
| _T_184 == 64'h44004057
| _T_183 == 64'h48004057
| _T_184 == 64'h4C004057
| _T_184 == 64'hC004057
| _T_184 == 64'h94004057
| _T_184 == 64'hA0004057
| _T_184 == 64'hA4004057
| _T_184 == 64'hB0004057
| _T_184 == 64'hB4004057
| _T_184 == 64'h24004057
| _T_184 == 64'h28004057
| _T_184 == 64'h2C004057
| _T_184 == 64'h38004057
| _T_184 == 64'h3C004057
| _T_184 == 64'h38006057
| _T_184 == 64'h3C006057
| _T_184 == 64'h60004057
| _T_184 == 64'h64004057
| _T_184 == 64'h6C004057
| _T_184 == 64'h68004057
| _T_184 == 64'h70004057
| _T_184 == 64'h74004057
| _T_184 == 64'h78004057
| _T_184 == 64'h7C004057
| _T_184 == 64'h10004057
| _T_184 == 64'h14004057
| _T_184 == 64'h18004057
| _T_184 == 64'h1C004057
| _T_184 == 64'h30004057
| _T_183 == 64'h5C004057
| _T_191 == 64'h5E004057
| _T_184 == 64'hC4006057
| _T_184 == 64'hC0006057
| _T_184 == 64'hCC006057
| _T_184 == 64'hC8006057
| _T_184 == 64'hD4006057
| _T_184 == 64'hD0006057
| _T_184 == 64'hDC006057
| _T_184 == 64'hD8006057
| _T_184 == 64'hEC006057
| _T_184 == 64'hE0006057
| _T_184 == 64'hE8006057
| _T_184 == 64'hF0006057
| _T_184 == 64'hF4006057
| _T_184 == 64'hFC006057
| _T_184 == 64'hF8006057
| _T_184 == 64'h94006057
| _T_184 == 64'h9C006057
| _T_184 == 64'h90006057
| _T_184 == 64'h98006057
| _T_184 == 64'h84006057
| _T_184 == 64'h80006057
| _T_184 == 64'h8C006057
| _T_184 == 64'h88006057
| _T_184 == 64'hA4006057
| _T_184 == 64'hAC006057
| _T_184 == 64'hB4006057
| _T_184 == 64'hBC006057
| _T_191 == 64'h42006057
| _T_184 == 64'h24006057
| _T_184 == 64'h2C006057
| _T_184 == 64'h20006057
| _T_184 == 64'h28006057
| _T_184 == 64'h84004057
| _T_184 == 64'h8C004057
| _T_184 == 64'h80004057
| _T_184 == 64'h88004057
| _T_184 == 64'h9C004057
| _T_184 == 64'hA8004057
| _T_184 == 64'hAC004057
| _T_184 == 64'hBC004057
| _T_184 == 64'hB8004057
| _T_184 == 64'h38005057
| _T_184 == 64'h3C005057
| _T_184 == 64'h20005057
| _T_184 == 64'h24005057
| _T_184 == 64'h28005057
| _T_184 == 64'h10005057
| _T_184 == 64'h18005057
| _T_184 == 64'h60005057
| _T_184 == 64'h64005057
| _T_184 == 64'h6C005057
| _T_184 == 64'h70005057
| _T_184 == 64'h74005057
| _T_184 == 64'h7C005057
| _T_183 == 64'h5C005057
| _T_191 == 64'h5E005057
| _T_184 == 64'h90005057
| _T_184 == 64'h5057
| _T_184 == 64'h8005057
| _T_184 == 64'h9C005057
| _T_184 == 64'h80005057
| _T_184 == 64'h84005057
| _T_184 == 64'hB0005057
| _T_184 == 64'hB4005057
| _T_184 == 64'hB8005057
| _T_184 == 64'hBC005057
| _T_184 == 64'hA0005057
| _T_184 == 64'hA4005057
| _T_184 == 64'hA8005057
| _T_184 == 64'hAC005057
| _T_191 == 64'h42005057
| _T_184 == 64'hC0005057
| _T_184 == 64'hC8005057
| _T_184 == 64'hE0005057
| _T_184 == 64'hD0005057
| _T_184 == 64'hD8005057
| _T_184 == 64'hF0005057
| _T_184 == 64'hF4005057
| _T_184 == 64'hF8005057
| _T_184 == 64'hFC005057
| _T_195 == 64'h42002057
| _T_194 == 64'h40082057
| _T_194 == 64'h4008A057
| _T_195 == 64'h42001057 : _T_180 ? _T_343 : _T_345 ? _T_343 : _T_344 ? ((_T_249 ? 1'h1 : _T_248 ? 1'h1 : _T_247 ? 1'h1 : _T_246 ? 1'h1 : _T_245 ? |{_T_223, _T_207} : _T_244 ? 1'h1 : _T_243 ? _T_209 : 1'h1) == 1'h0 ? 1'h0 : _T_277 == 32'h63
| _T_277 == 32'h1063
| _T_277 == 32'h4063
| _T_277 == 32'h6063
| _T_277 == 32'h5063
| _T_277 == 32'h7063
| _T_278 == 32'h6F
| _T_277 == 32'h67
| _T_277 == 32'h3
| _T_277 == 32'h4003
| _T_277 == 32'h1003
| _T_277 == 32'h5003
| _T_277 == 32'h2003
| _T_277 == 32'h6003
| _T_277 == 32'h3003
| _T_277 == 32'h23
| _T_277 == 32'h1023
| _T_277 == 32'h2023
| _T_277 == 32'h3023
| _T_278 == 32'h37
| _T_278 == 32'h17
| _T_277 == 32'h13
| _T_277 == 32'h2013
| _T_277 == 32'h3013
| _T_277 == 32'h7013
| _T_277 == 32'h6013
| _T_277 == 32'h4013
| _T_277 == 32'h1B
| _T_279 == 32'h101B
| _T_279 == 32'h501B
| _T_279 == 32'h4000501B
| _T_280 == 32'h1013
| _T_280 == 32'h5013
| _T_280 == 32'h40005013
| _T_279 == 32'h33
| _T_279 == 32'h40000033
| _T_279 == 32'h2033
| _T_279 == 32'h3033
| _T_279 == 32'h7033
| _T_279 == 32'h6033
| _T_279 == 32'h4033
| _T_279 == 32'h1033
| _T_279 == 32'h5033
| _T_279 == 32'h40005033
| _T_279 == 32'h3B
| _T_279 == 32'h4000003B
| _T_279 == 32'h103B
| _T_279 == 32'h503B
| _T_279 == 32'h4000503B
| _T_277 == 32'hF
| _T_277 == 32'h100F
| (_T_276 & 32'hFE007FFF) == 32'h12000073
| _T_276 == 32'hFC000073
| _T_276 == 32'hFC200073
| _T_277 == 32'h5073
| _T_277 == 32'h6073
| _T_277 == 32'h7073
| _T_276 == 32'h73
| _T_276 == 32'h100073
| _T_276 == 32'h30200073
| _T_276 == 32'h10500073
| _T_276 == 32'h30500073
| _T_277 == 32'h1073
| _T_277 == 32'h2073
| _T_277 == 32'h3073
| _T_276 == 32'h10200073
| _T_276 == 32'h7B200073
| _T_279 == 32'h2000033
| _T_279 == 32'h2001033
| _T_279 == 32'h2003033
| _T_279 == 32'h2002033
| _T_279 == 32'h200003B
| _T_279 == 32'h2004033
| _T_279 == 32'h2005033
| _T_279 == 32'h2006033
| _T_279 == 32'h2007033
| _T_279 == 32'h200403B
| _T_279 == 32'h200503B
| _T_279 == 32'h200603B
| _T_279 == 32'h200703B
| _T_281 == 32'h202F
| _T_281 == 32'h6000202F
| _T_281 == 32'h4000202F
| _T_281 == 32'h2000202F
| _T_281 == 32'h8000202F
| _T_281 == 32'hA000202F
| _T_281 == 32'hC000202F
| _T_281 == 32'hE000202F
| _T_281 == 32'h800202F
| _T_281 == 32'h302F
| _T_281 == 32'h6000302F
| _T_281 == 32'h4000302F
| _T_281 == 32'h2000302F
| _T_281 == 32'h8000302F
| _T_281 == 32'hA000302F
| _T_281 == 32'hC000302F
| _T_281 == 32'hE000302F
| _T_281 == 32'h800302F
| _T_282 == 32'h1000202F
| _T_281 == 32'h1800202F
| _T_282 == 32'h1000302F
| _T_281 == 32'h1800302F
| _T_277 == 32'h1027
| _T_277 == 32'h2027
| _T_277 == 32'h3027
| _T_277 == 32'h1007
| _T_277 == 32'h2007
| _T_277 == 32'h3007
| _T_283 == 32'h4000043
| _T_283 == 32'h4000047
| _T_283 == 32'h400004B
| _T_283 == 32'h400004F
| _T_283 == 32'h43
| _T_283 == 32'h47
| _T_283 == 32'h4B
| _T_283 == 32'h4F
| _T_283 == 32'h2000043
| _T_283 == 32'h2000047
| _T_283 == 32'h200004B
| _T_283 == 32'h200004F
| _T_284 == 32'h4000053
| _T_284 == 32'hC000053
| _T_284 == 32'h14000053
| _T_284 == 32'h1C000053
| _T_279 == 32'h24000053
| _T_279 == 32'h24001053
| _T_279 == 32'h24002053
| _T_279 == 32'h2C000053
| _T_279 == 32'h2C001053
| _T_284 == 32'h53
| _T_284 == 32'h8000053
| _T_284 == 32'h10000053
| _T_284 == 32'h18000053
| _T_279 == 32'h20000053
| _T_279 == 32'h20001053
| _T_279 == 32'h20002053
| _T_279 == 32'h28000053
| _T_279 == 32'h28001053
| _T_284 == 32'h2000053
| _T_284 == 32'hA000053
| _T_284 == 32'h12000053
| _T_284 == 32'h1A000053
| _T_279 == 32'h22000053
| _T_279 == 32'h22001053
| _T_279 == 32'h22002053
| _T_279 == 32'h2A000053
| _T_279 == 32'h2A001053
| _T_285 == 32'h5C000053
| _T_285 == 32'h44000053
| _T_285 == 32'h40200053
| _T_285 == 32'h58000053
| _T_285 == 32'h5A000053
| _T_285 == 32'h40100053
| _T_285 == 32'h42000053
| _T_285 == 32'h44100053
| _T_285 == 32'h42200053
| _T_279 == 32'hA4002053
| _T_279 == 32'hA4001053
| _T_279 == 32'hA4000053
| _T_279 == 32'hA0002053
| _T_279 == 32'hA0001053
| _T_279 == 32'hA0000053
| _T_279 == 32'hA2002053
| _T_279 == 32'hA2001053
| _T_279 == 32'hA2000053
| _T_285 == 32'hC4000053
| _T_285 == 32'hC4100053
| _T_286 == 32'hE4001053
| _T_285 == 32'hC4200053
| _T_285 == 32'hC4300053
| _T_285 == 32'hC0000053
| _T_285 == 32'hC0100053
| _T_286 == 32'hE0001053
| _T_285 == 32'hC0200053
| _T_285 == 32'hC0300053
| _T_285 == 32'hC2000053
| _T_285 == 32'hC2100053
| _T_286 == 32'hE2001053
| _T_285 == 32'hC2200053
| _T_285 == 32'hC2300053
| _T_286 == 32'hE4000053
| _T_286 == 32'hE0000053
| _T_286 == 32'hE2000053
| _T_286 == 32'hF4000053
| _T_286 == 32'hF0000053
| _T_286 == 32'hF2000053
| _T_285 == 32'hD4000053
| _T_285 == 32'hD4100053
| _T_285 == 32'hD4200053
| _T_285 == 32'hD4300053
| _T_285 == 32'hD0000053
| _T_285 == 32'hD0100053
| _T_285 == 32'hD0200053
| _T_285 == 32'hD0300053
| _T_285 == 32'hD2000053
| _T_285 == 32'hD2100053
| _T_285 == 32'hD2200053
| _T_285 == 32'hD2300053
| _T_279 == 32'h80007057
| (_T_276 & 32'h8000707F) == 32'h7057
| _T_287 == 32'h7
| _T_287 == 32'h5007
| _T_287 == 32'h6007
| _T_287 == 32'h7007
| _T_287 == 32'h1000007
| _T_287 == 32'h1005007
| _T_287 == 32'h1006007
| _T_287 == 32'h1007007
| _T_288 == 32'hC000007
| _T_288 == 32'hC005007
| _T_288 == 32'hC006007
| _T_286 == 32'h2800007
| _T_286 == 32'h2805007
| _T_286 == 32'h2806007
| _T_286 == 32'h2807007
| _T_286 == 32'h22800007
| _T_286 == 32'h22805007
| _T_286 == 32'h22806007
| _T_286 == 32'h22807007
| _T_286 == 32'h62800007
| _T_286 == 32'h62805007
| _T_286 == 32'h62806007
| _T_286 == 32'h62807007
| _T_286 == 32'hE2800007
| _T_286 == 32'hE2805007
| _T_286 == 32'hE2806007
| _T_286 == 32'hE2807007
| _T_288 == 32'hC007007
| _T_287 == 32'h27
| _T_287 == 32'h5027
| _T_287 == 32'h6027
| _T_287 == 32'h7027
| _T_288 == 32'hC000027
| _T_288 == 32'hC005027
| _T_288 == 32'hC006027
| _T_280 == 32'h4000027
| _T_280 == 32'h4005027
| _T_280 == 32'h4006027
| _T_286 == 32'h2800027
| _T_286 == 32'h22800027
| _T_286 == 32'h62800027
| _T_286 == 32'hE2800027
| _T_288 == 32'hC007027
| _T_280 == 32'h4007027
| _T_281 == 32'h800002F
| _T_281 == 32'h2F
| _T_281 == 32'h2000002F
| _T_281 == 32'h6000002F
| _T_281 == 32'h4000002F
| _T_281 == 32'h8000002F
| _T_281 == 32'hA000002F
| _T_281 == 32'hC000002F
| _T_281 == 32'hE000002F
| _T_281 == 32'h800502F
| _T_281 == 32'h502F
| _T_281 == 32'h2000502F
| _T_281 == 32'h6000502F
| _T_281 == 32'h4000502F
| _T_281 == 32'h8000502F
| _T_281 == 32'hA000502F
| _T_281 == 32'hC000502F
| _T_281 == 32'hE000502F
| _T_281 == 32'h800602F
| _T_281 == 32'h602F
| _T_281 == 32'h2000602F
| _T_281 == 32'h6000602F
| _T_281 == 32'h4000602F
| _T_281 == 32'h8000602F
| _T_281 == 32'hA000602F
| _T_281 == 32'hC000602F
| _T_281 == 32'hE000602F
| _T_281 == 32'h800702F
| _T_281 == 32'h702F
| _T_281 == 32'h2000702F
| _T_281 == 32'h6000702F
| _T_281 == 32'h4000702F
| _T_281 == 32'h8000702F
| _T_281 == 32'hA000702F
| _T_281 == 32'hC000702F
| _T_281 == 32'hE000702F
| _T_288 == 32'h8000007
| _T_288 == 32'h8005007
| _T_288 == 32'h8006007
| _T_288 == 32'h8007007
| _T_288 == 32'h8000027
| _T_288 == 32'h8005027
| _T_288 == 32'h8006027
| _T_288 == 32'h8007027
| _T_280 == 32'h2057
| _T_280 == 32'hC4000057
| _T_280 == 32'hC0000057
| _T_280 == 32'h4002057
| _T_280 == 32'h8002057
| _T_280 == 32'hC002057
| _T_280 == 32'h10002057
| _T_280 == 32'h14002057
| _T_280 == 32'h18002057
| _T_280 == 32'h1C002057
| _T_280 == 32'h57
| _T_280 == 32'h8000057
| _T_279 == 32'h40000057
| _T_280 == 32'h44000057
| _T_279 == 32'h48000057
| _T_280 == 32'h4C000057
| _T_280 == 32'h94000057
| _T_280 == 32'hA0000057
| _T_280 == 32'hA4000057
| _T_280 == 32'hB0000057
| _T_280 == 32'hB4000057
| _T_280 == 32'h24000057
| _T_280 == 32'h28000057
| _T_280 == 32'h2C000057
| _T_280 == 32'h60000057
| _T_280 == 32'h64000057
| _T_280 == 32'h6C000057
| _T_280 == 32'h68000057
| _T_280 == 32'h70000057
| _T_280 == 32'h74000057
| _T_280 == 32'h10000057
| _T_280 == 32'h14000057
| _T_280 == 32'h18000057
| _T_280 == 32'h1C000057
| _T_280 == 32'h30000057
| _T_280 == 32'h38000057
| _T_279 == 32'h5E002057
| _T_279 == 32'h5C000057
| _T_286 == 32'h5E000057
| _T_280 == 32'h60002057
| _T_280 == 32'h64002057
| _T_280 == 32'h68002057
| _T_280 == 32'h6C002057
| _T_280 == 32'h70002057
| _T_280 == 32'h74002057
| _T_280 == 32'h78002057
| _T_280 == 32'h7C002057
| _T_289 == 32'h5000A057
| _T_289 == 32'h50012057
| _T_289 == 32'h5001A057
| _T_289 == 32'h50082057
| (_T_276 & 32'hFDFFF07F) == 32'h5008A057
| _T_289 == 32'h48032057
| _T_289 == 32'h4803A057
| _T_289 == 32'h48022057
| _T_289 == 32'h4802A057
| _T_289 == 32'h48012057
| _T_289 == 32'h4801A057
| _T_280 == 32'hC4002057
| _T_280 == 32'hC0002057
| _T_280 == 32'hCC002057
| _T_280 == 32'hC8002057
| _T_280 == 32'hD4002057
| _T_280 == 32'hD0002057
| _T_280 == 32'hDC002057
| _T_280 == 32'hD8002057
| _T_280 == 32'hEC002057
| _T_280 == 32'hE0002057
| _T_280 == 32'hE8002057
| _T_280 == 32'hF0002057
| _T_280 == 32'hF4002057
| _T_280 == 32'hFC002057
| _T_280 == 32'h94002057
| _T_280 == 32'h9C002057
| _T_280 == 32'h90002057
| _T_280 == 32'h98002057
| _T_280 == 32'h84002057
| _T_280 == 32'h80002057
| _T_280 == 32'h8C002057
| _T_280 == 32'h88002057
| _T_280 == 32'hA4002057
| _T_280 == 32'hAC002057
| _T_280 == 32'hB4002057
| _T_280 == 32'hBC002057
| _T_280 == 32'h24002057
| _T_280 == 32'h2C002057
| _T_280 == 32'h20002057
| _T_280 == 32'h28002057
| _T_280 == 32'h84000057
| _T_280 == 32'h8C000057
| _T_280 == 32'h80000057
| _T_280 == 32'h88000057
| _T_280 == 32'h9C000057
| _T_280 == 32'hA8000057
| _T_280 == 32'hAC000057
| _T_280 == 32'hBC000057
| _T_280 == 32'hB8000057
| _T_280 == 32'h4001057
| _T_280 == 32'hC4001057
| _T_280 == 32'hC001057
| _T_280 == 32'hCC001057
| _T_280 == 32'h14001057
| _T_280 == 32'h1C001057
| _T_289 == 32'h4C081057
| _T_280 == 32'h10001057
| _T_280 == 32'h18001057
| _T_280 == 32'h60001057
| _T_280 == 32'h64001057
| _T_280 == 32'h6C001057
| _T_280 == 32'h70001057
| _T_289 == 32'h48011057
| _T_289 == 32'h48019057
| _T_289 == 32'h48091057
| _T_289 == 32'h48099057
| _T_289 == 32'h480B1057
| _T_289 == 32'h480B9057
| _T_289 == 32'h48081057
| _T_289 == 32'h48089057
| _T_289 == 32'h48051057
| _T_289 == 32'h48059057
| _T_289 == 32'h48071057
| _T_289 == 32'h48079057
| _T_289 == 32'h48041057
| _T_289 == 32'h48049057
| _T_289 == 32'h48031057
| _T_289 == 32'h48039057
| _T_289 == 32'h48001057
| _T_289 == 32'h48009057
| _T_280 == 32'h90001057
| _T_280 == 32'h1057
| _T_280 == 32'h8001057
| _T_289 == 32'h4C001057
| _T_280 == 32'h80001057
| _T_289 == 32'h4C021057
| _T_289 == 32'h4C029057
| _T_280 == 32'hB0001057
| _T_280 == 32'hB4001057
| _T_280 == 32'hB8001057
| _T_280 == 32'hBC001057
| _T_280 == 32'hA0001057
| _T_280 == 32'hA4001057
| _T_280 == 32'hA8001057
| _T_280 == 32'hAC001057
| _T_280 == 32'h20001057
| _T_280 == 32'h24001057
| _T_280 == 32'h28001057
| _T_289 == 32'h480A1057
| _T_289 == 32'h480A9057
| _T_289 == 32'h48061057
| _T_280 == 32'hC0001057
| _T_280 == 32'hC8001057
| _T_280 == 32'hE0001057
| _T_280 == 32'hD0001057
| _T_280 == 32'hD8001057
| _T_280 == 32'hF0001057
| _T_280 == 32'hF4001057
| _T_280 == 32'hF8001057
| _T_280 == 32'hFC001057
| _T_280 == 32'h3057
| _T_279 == 32'h40003057
| _T_280 == 32'h44003057
| _T_280 == 32'hC003057
| _T_280 == 32'h94003057
| _T_280 == 32'hA0003057
| _T_280 == 32'hA4003057
| _T_280 == 32'hB0003057
| _T_280 == 32'hB4003057
| _T_280 == 32'h24003057
| _T_280 == 32'h28003057
| _T_280 == 32'h2C003057
| _T_279 == 32'h9E003057
| _T_280 == 32'h38003057
| _T_280 == 32'h3C003057
| _T_280 == 32'h60003057
| _T_280 == 32'h64003057
| _T_280 == 32'h70003057
| _T_280 == 32'h74003057
| _T_280 == 32'h78003057
| _T_280 == 32'h7C003057
| _T_280 == 32'h30003057
| _T_279 == 32'h5C003057
| _T_286 == 32'h5E003057
| _T_280 == 32'h84003057
| _T_280 == 32'h80003057
| _T_280 == 32'hA8003057
| _T_280 == 32'hAC003057
| _T_280 == 32'hBC003057
| _T_280 == 32'hB8003057
| _T_280 == 32'h4057
| _T_280 == 32'h8004057
| _T_279 == 32'h40004057
| _T_280 == 32'h44004057
| _T_279 == 32'h48004057
| _T_280 == 32'h4C004057
| _T_280 == 32'hC004057
| _T_280 == 32'h94004057
| _T_280 == 32'hA0004057
| _T_280 == 32'hA4004057
| _T_280 == 32'hB0004057
| _T_280 == 32'hB4004057
| _T_280 == 32'h24004057
| _T_280 == 32'h28004057
| _T_280 == 32'h2C004057
| _T_280 == 32'h38004057
| _T_280 == 32'h3C004057
| _T_280 == 32'h38006057
| _T_280 == 32'h3C006057
| _T_280 == 32'h60004057
| _T_280 == 32'h64004057
| _T_280 == 32'h6C004057
| _T_280 == 32'h68004057
| _T_280 == 32'h70004057
| _T_280 == 32'h74004057
| _T_280 == 32'h78004057
| _T_280 == 32'h7C004057
| _T_280 == 32'h10004057
| _T_280 == 32'h14004057
| _T_280 == 32'h18004057
| _T_280 == 32'h1C004057
| _T_280 == 32'h30004057
| _T_279 == 32'h5C004057
| _T_286 == 32'h5E004057
| _T_280 == 32'hC4006057
| _T_280 == 32'hC0006057
| _T_280 == 32'hCC006057
| _T_280 == 32'hC8006057
| _T_280 == 32'hD4006057
| _T_280 == 32'hD0006057
| _T_280 == 32'hDC006057
| _T_280 == 32'hD8006057
| _T_280 == 32'hEC006057
| _T_280 == 32'hE0006057
| _T_280 == 32'hE8006057
| _T_280 == 32'hF0006057
| _T_280 == 32'hF4006057
| _T_280 == 32'hFC006057
| _T_280 == 32'hF8006057
| _T_280 == 32'h94006057
| _T_280 == 32'h9C006057
| _T_280 == 32'h90006057
| _T_280 == 32'h98006057
| _T_280 == 32'h84006057
| _T_280 == 32'h80006057
| _T_280 == 32'h8C006057
| _T_280 == 32'h88006057
| _T_280 == 32'hA4006057
| _T_280 == 32'hAC006057
| _T_280 == 32'hB4006057
| _T_280 == 32'hBC006057
| _T_286 == 32'h42006057
| _T_280 == 32'h24006057
| _T_280 == 32'h2C006057
| _T_280 == 32'h20006057
| _T_280 == 32'h28006057
| _T_280 == 32'h84004057
| _T_280 == 32'h8C004057
| _T_280 == 32'h80004057
| _T_280 == 32'h88004057
| _T_280 == 32'h9C004057
| _T_280 == 32'hA8004057
| _T_280 == 32'hAC004057
| _T_280 == 32'hBC004057
| _T_280 == 32'hB8004057
| _T_280 == 32'h38005057
| _T_280 == 32'h3C005057
| _T_280 == 32'h20005057
| _T_280 == 32'h24005057
| _T_280 == 32'h28005057
| _T_280 == 32'h10005057
| _T_280 == 32'h18005057
| _T_280 == 32'h60005057
| _T_280 == 32'h64005057
| _T_280 == 32'h6C005057
| _T_280 == 32'h70005057
| _T_280 == 32'h74005057
| _T_280 == 32'h7C005057
| _T_279 == 32'h5C005057
| _T_286 == 32'h5E005057
| _T_280 == 32'h90005057
| _T_280 == 32'h5057
| _T_280 == 32'h8005057
| _T_280 == 32'h9C005057
| _T_280 == 32'h80005057
| _T_280 == 32'h84005057
| _T_280 == 32'hB0005057
| _T_280 == 32'hB4005057
| _T_280 == 32'hB8005057
| _T_280 == 32'hBC005057
| _T_280 == 32'hA0005057
| _T_280 == 32'hA4005057
| _T_280 == 32'hA8005057
| _T_280 == 32'hAC005057
| _T_286 == 32'h42005057
| _T_280 == 32'hC0005057
| _T_280 == 32'hC8005057
| _T_280 == 32'hE0005057
| _T_280 == 32'hD0005057
| _T_280 == 32'hD8005057
| _T_280 == 32'hF0005057
| _T_280 == 32'hF4005057
| _T_280 == 32'hF8005057
| _T_280 == 32'hFC005057
| _T_290 == 32'h42002057
| _T_289 == 32'h40082057
| _T_289 == 32'h4008A057
| _T_290 == 32'h42001057) : (_T_249 ? 1'h1 : _T_248 ? 1'h1 : _T_247 ? 1'h1 : _T_246 ? 1'h1 : _T_245 ? 1'h1 : _T_244 ? 1'h1 : _T_243 ? 1'h1 : |io_fetch_bits_data[12:5]) == 1'h0 ? 1'h0 : _T_251 == 32'h63
| _T_251 == 32'h1063
| _T_251 == 32'h4063
| _T_251 == 32'h6063
| _T_251 == 32'h5063
| _T_251 == 32'h7063
| _T_252 == 32'h6F
| _T_251 == 32'h67
| _T_251 == 32'h3
| _T_251 == 32'h4003
| _T_251 == 32'h1003
| _T_251 == 32'h5003
| _T_251 == 32'h2003
| _T_251 == 32'h6003
| _T_251 == 32'h3003
| _T_251 == 32'h23
| _T_251 == 32'h1023
| _T_251 == 32'h2023
| _T_251 == 32'h3023
| _T_252 == 32'h37
| _T_252 == 32'h17
| _T_251 == 32'h13
| _T_251 == 32'h2013
| _T_251 == 32'h3013
| _T_251 == 32'h7013
| _T_251 == 32'h6013
| _T_251 == 32'h4013
| _T_251 == 32'h1B
| _T_253 == 32'h101B
| _T_253 == 32'h501B
| _T_253 == 32'h4000501B
| _T_254 == 32'h1013
| _T_254 == 32'h5013
| _T_254 == 32'h40005013
| _T_253 == 32'h33
| _T_253 == 32'h40000033
| _T_253 == 32'h2033
| _T_253 == 32'h3033
| _T_253 == 32'h7033
| _T_253 == 32'h6033
| _T_253 == 32'h4033
| _T_253 == 32'h1033
| _T_253 == 32'h5033
| _T_253 == 32'h40005033
| _T_253 == 32'h3B
| _T_253 == 32'h4000003B
| _T_253 == 32'h103B
| _T_253 == 32'h503B
| _T_253 == 32'h4000503B
| _T_251 == 32'hF
| _T_251 == 32'h100F
| (_T_250 & 32'hFE007FFF) == 32'h12000073
| _T_250 == 32'hFC000073
| _T_250 == 32'hFC200073
| _T_251 == 32'h5073
| _T_251 == 32'h6073
| _T_251 == 32'h7073
| _T_250 == 32'h73
| _T_250 == 32'h100073
| _T_250 == 32'h30200073
| _T_250 == 32'h10500073
| _T_250 == 32'h30500073
| _T_251 == 32'h1073
| _T_251 == 32'h2073
| _T_251 == 32'h3073
| _T_250 == 32'h10200073
| _T_250 == 32'h7B200073
| _T_253 == 32'h2000033
| _T_253 == 32'h2001033
| _T_253 == 32'h2003033
| _T_253 == 32'h2002033
| _T_253 == 32'h200003B
| _T_253 == 32'h2004033
| _T_253 == 32'h2005033
| _T_253 == 32'h2006033
| _T_253 == 32'h2007033
| _T_253 == 32'h200403B
| _T_253 == 32'h200503B
| _T_253 == 32'h200603B
| _T_253 == 32'h200703B
| _T_255 == 32'h202F
| _T_255 == 32'h6000202F
| _T_255 == 32'h4000202F
| _T_255 == 32'h2000202F
| _T_255 == 32'h8000202F
| _T_255 == 32'hA000202F
| _T_255 == 32'hC000202F
| _T_255 == 32'hE000202F
| _T_255 == 32'h800202F
| _T_255 == 32'h302F
| _T_255 == 32'h6000302F
| _T_255 == 32'h4000302F
| _T_255 == 32'h2000302F
| _T_255 == 32'h8000302F
| _T_255 == 32'hA000302F
| _T_255 == 32'hC000302F
| _T_255 == 32'hE000302F
| _T_255 == 32'h800302F
| _T_256 == 32'h1000202F
| _T_255 == 32'h1800202F
| _T_256 == 32'h1000302F
| _T_255 == 32'h1800302F
| _T_251 == 32'h1027
| _T_251 == 32'h2027
| _T_251 == 32'h3027
| _T_251 == 32'h1007
| _T_251 == 32'h2007
| _T_251 == 32'h3007
| _T_257 == 32'h4000043
| _T_257 == 32'h4000047
| _T_257 == 32'h400004B
| _T_257 == 32'h400004F
| _T_257 == 32'h43
| _T_257 == 32'h47
| _T_257 == 32'h4B
| _T_257 == 32'h4F
| _T_257 == 32'h2000043
| _T_257 == 32'h2000047
| _T_257 == 32'h200004B
| _T_257 == 32'h200004F
| _T_258 == 32'h4000053
| _T_258 == 32'hC000053
| _T_258 == 32'h14000053
| _T_258 == 32'h1C000053
| _T_253 == 32'h24000053
| _T_253 == 32'h24001053
| _T_253 == 32'h24002053
| _T_253 == 32'h2C000053
| _T_253 == 32'h2C001053
| _T_258 == 32'h53
| _T_258 == 32'h8000053
| _T_258 == 32'h10000053
| _T_258 == 32'h18000053
| _T_253 == 32'h20000053
| _T_253 == 32'h20001053
| _T_253 == 32'h20002053
| _T_253 == 32'h28000053
| _T_253 == 32'h28001053
| _T_258 == 32'h2000053
| _T_258 == 32'hA000053
| _T_258 == 32'h12000053
| _T_258 == 32'h1A000053
| _T_253 == 32'h22000053
| _T_253 == 32'h22001053
| _T_253 == 32'h22002053
| _T_253 == 32'h2A000053
| _T_253 == 32'h2A001053
| _T_259 == 32'h5C000053
| _T_259 == 32'h44000053
| _T_259 == 32'h40200053
| _T_259 == 32'h58000053
| _T_259 == 32'h5A000053
| _T_259 == 32'h40100053
| _T_259 == 32'h42000053
| _T_259 == 32'h44100053
| _T_259 == 32'h42200053
| _T_253 == 32'hA4002053
| _T_253 == 32'hA4001053
| _T_253 == 32'hA4000053
| _T_253 == 32'hA0002053
| _T_253 == 32'hA0001053
| _T_253 == 32'hA0000053
| _T_253 == 32'hA2002053
| _T_253 == 32'hA2001053
| _T_253 == 32'hA2000053
| _T_259 == 32'hC4000053
| _T_259 == 32'hC4100053
| _T_260 == 32'hE4001053
| _T_259 == 32'hC4200053
| _T_259 == 32'hC4300053
| _T_259 == 32'hC0000053
| _T_259 == 32'hC0100053
| _T_260 == 32'hE0001053
| _T_259 == 32'hC0200053
| _T_259 == 32'hC0300053
| _T_259 == 32'hC2000053
| _T_259 == 32'hC2100053
| _T_260 == 32'hE2001053
| _T_259 == 32'hC2200053
| _T_259 == 32'hC2300053
| _T_260 == 32'hE4000053
| _T_260 == 32'hE0000053
| _T_260 == 32'hE2000053
| _T_260 == 32'hF4000053
| _T_260 == 32'hF0000053
| _T_260 == 32'hF2000053
| _T_259 == 32'hD4000053
| _T_259 == 32'hD4100053
| _T_259 == 32'hD4200053
| _T_259 == 32'hD4300053
| _T_259 == 32'hD0000053
| _T_259 == 32'hD0100053
| _T_259 == 32'hD0200053
| _T_259 == 32'hD0300053
| _T_259 == 32'hD2000053
| _T_259 == 32'hD2100053
| _T_259 == 32'hD2200053
| _T_259 == 32'hD2300053
| _T_253 == 32'h80007057
| (_T_250 & 32'h8000707F) == 32'h7057
| _T_261 == 32'h7
| _T_261 == 32'h5007
| _T_261 == 32'h6007
| _T_261 == 32'h7007
| _T_261 == 32'h1000007
| _T_261 == 32'h1005007
| _T_261 == 32'h1006007
| _T_261 == 32'h1007007
| _T_262 == 32'hC000007
| _T_262 == 32'hC005007
| _T_262 == 32'hC006007
| _T_260 == 32'h2800007
| _T_260 == 32'h2805007
| _T_260 == 32'h2806007
| _T_260 == 32'h2807007
| _T_260 == 32'h22800007
| _T_260 == 32'h22805007
| _T_260 == 32'h22806007
| _T_260 == 32'h22807007
| _T_260 == 32'h62800007
| _T_260 == 32'h62805007
| _T_260 == 32'h62806007
| _T_260 == 32'h62807007
| _T_260 == 32'hE2800007
| _T_260 == 32'hE2805007
| _T_260 == 32'hE2806007
| _T_260 == 32'hE2807007
| _T_262 == 32'hC007007
| _T_261 == 32'h27
| _T_261 == 32'h5027
| _T_261 == 32'h6027
| _T_261 == 32'h7027
| _T_262 == 32'hC000027
| _T_262 == 32'hC005027
| _T_262 == 32'hC006027
| _T_254 == 32'h4000027
| _T_254 == 32'h4005027
| _T_254 == 32'h4006027
| _T_260 == 32'h2800027
| _T_260 == 32'h22800027
| _T_260 == 32'h62800027
| _T_260 == 32'hE2800027
| _T_262 == 32'hC007027
| _T_254 == 32'h4007027
| _T_255 == 32'h800002F
| _T_255 == 32'h2F
| _T_255 == 32'h2000002F
| _T_255 == 32'h6000002F
| _T_255 == 32'h4000002F
| _T_255 == 32'h8000002F
| _T_255 == 32'hA000002F
| _T_255 == 32'hC000002F
| _T_255 == 32'hE000002F
| _T_255 == 32'h800502F
| _T_255 == 32'h502F
| _T_255 == 32'h2000502F
| _T_255 == 32'h6000502F
| _T_255 == 32'h4000502F
| _T_255 == 32'h8000502F
| _T_255 == 32'hA000502F
| _T_255 == 32'hC000502F
| _T_255 == 32'hE000502F
| _T_255 == 32'h800602F
| _T_255 == 32'h602F
| _T_255 == 32'h2000602F
| _T_255 == 32'h6000602F
| _T_255 == 32'h4000602F
| _T_255 == 32'h8000602F
| _T_255 == 32'hA000602F
| _T_255 == 32'hC000602F
| _T_255 == 32'hE000602F
| _T_255 == 32'h800702F
| _T_255 == 32'h702F
| _T_255 == 32'h2000702F
| _T_255 == 32'h6000702F
| _T_255 == 32'h4000702F
| _T_255 == 32'h8000702F
| _T_255 == 32'hA000702F
| _T_255 == 32'hC000702F
| _T_255 == 32'hE000702F
| _T_262 == 32'h8000007
| _T_262 == 32'h8005007
| _T_262 == 32'h8006007
| _T_262 == 32'h8007007
| _T_262 == 32'h8000027
| _T_262 == 32'h8005027
| _T_262 == 32'h8006027
| _T_262 == 32'h8007027
| _T_254 == 32'h2057
| _T_254 == 32'hC4000057
| _T_254 == 32'hC0000057
| _T_254 == 32'h4002057
| _T_254 == 32'h8002057
| _T_254 == 32'hC002057
| _T_254 == 32'h10002057
| _T_254 == 32'h14002057
| _T_254 == 32'h18002057
| _T_254 == 32'h1C002057
| _T_254 == 32'h57
| _T_254 == 32'h8000057
| _T_253 == 32'h40000057
| _T_254 == 32'h44000057
| _T_253 == 32'h48000057
| _T_254 == 32'h4C000057
| _T_254 == 32'h94000057
| _T_254 == 32'hA0000057
| _T_254 == 32'hA4000057
| _T_254 == 32'hB0000057
| _T_254 == 32'hB4000057
| _T_254 == 32'h24000057
| _T_254 == 32'h28000057
| _T_254 == 32'h2C000057
| _T_254 == 32'h60000057
| _T_254 == 32'h64000057
| _T_254 == 32'h6C000057
| _T_254 == 32'h68000057
| _T_254 == 32'h70000057
| _T_254 == 32'h74000057
| _T_254 == 32'h10000057
| _T_254 == 32'h14000057
| _T_254 == 32'h18000057
| _T_254 == 32'h1C000057
| _T_254 == 32'h30000057
| _T_254 == 32'h38000057
| _T_253 == 32'h5E002057
| _T_253 == 32'h5C000057
| _T_260 == 32'h5E000057
| _T_254 == 32'h60002057
| _T_254 == 32'h64002057
| _T_254 == 32'h68002057
| _T_254 == 32'h6C002057
| _T_254 == 32'h70002057
| _T_254 == 32'h74002057
| _T_254 == 32'h78002057
| _T_254 == 32'h7C002057
| _T_263 == 32'h5000A057
| _T_263 == 32'h50012057
| _T_263 == 32'h5001A057
| _T_263 == 32'h50082057
| (_T_250 & 32'hFDFFF07F) == 32'h5008A057
| _T_263 == 32'h48032057
| _T_263 == 32'h4803A057
| _T_263 == 32'h48022057
| _T_263 == 32'h4802A057
| _T_263 == 32'h48012057
| _T_263 == 32'h4801A057
| _T_254 == 32'hC4002057
| _T_254 == 32'hC0002057
| _T_254 == 32'hCC002057
| _T_254 == 32'hC8002057
| _T_254 == 32'hD4002057
| _T_254 == 32'hD0002057
| _T_254 == 32'hDC002057
| _T_254 == 32'hD8002057
| _T_254 == 32'hEC002057
| _T_254 == 32'hE0002057
| _T_254 == 32'hE8002057
| _T_254 == 32'hF0002057
| _T_254 == 32'hF4002057
| _T_254 == 32'hFC002057
| _T_254 == 32'h94002057
| _T_254 == 32'h9C002057
| _T_254 == 32'h90002057
| _T_254 == 32'h98002057
| _T_254 == 32'h84002057
| _T_254 == 32'h80002057
| _T_254 == 32'h8C002057
| _T_254 == 32'h88002057
| _T_254 == 32'hA4002057
| _T_254 == 32'hAC002057
| _T_254 == 32'hB4002057
| _T_254 == 32'hBC002057
| _T_254 == 32'h24002057
| _T_254 == 32'h2C002057
| _T_254 == 32'h20002057
| _T_254 == 32'h28002057
| _T_254 == 32'h84000057
| _T_254 == 32'h8C000057
| _T_254 == 32'h80000057
| _T_254 == 32'h88000057
| _T_254 == 32'h9C000057
| _T_254 == 32'hA8000057
| _T_254 == 32'hAC000057
| _T_254 == 32'hBC000057
| _T_254 == 32'hB8000057
| _T_254 == 32'h4001057
| _T_254 == 32'hC4001057
| _T_254 == 32'hC001057
| _T_254 == 32'hCC001057
| _T_254 == 32'h14001057
| _T_254 == 32'h1C001057
| _T_263 == 32'h4C081057
| _T_254 == 32'h10001057
| _T_254 == 32'h18001057
| _T_254 == 32'h60001057
| _T_254 == 32'h64001057
| _T_254 == 32'h6C001057
| _T_254 == 32'h70001057
| _T_263 == 32'h48011057
| _T_263 == 32'h48019057
| _T_263 == 32'h48091057
| _T_263 == 32'h48099057
| _T_263 == 32'h480B1057
| _T_263 == 32'h480B9057
| _T_263 == 32'h48081057
| _T_263 == 32'h48089057
| _T_263 == 32'h48051057
| _T_263 == 32'h48059057
| _T_263 == 32'h48071057
| _T_263 == 32'h48079057
| _T_263 == 32'h48041057
| _T_263 == 32'h48049057
| _T_263 == 32'h48031057
| _T_263 == 32'h48039057
| _T_263 == 32'h48001057
| _T_263 == 32'h48009057
| _T_254 == 32'h90001057
| _T_254 == 32'h1057
| _T_254 == 32'h8001057
| _T_263 == 32'h4C001057
| _T_254 == 32'h80001057
| _T_263 == 32'h4C021057
| _T_263 == 32'h4C029057
| _T_254 == 32'hB0001057
| _T_254 == 32'hB4001057
| _T_254 == 32'hB8001057
| _T_254 == 32'hBC001057
| _T_254 == 32'hA0001057
| _T_254 == 32'hA4001057
| _T_254 == 32'hA8001057
| _T_254 == 32'hAC001057
| _T_254 == 32'h20001057
| _T_254 == 32'h24001057
| _T_254 == 32'h28001057
| _T_263 == 32'h480A1057
| _T_263 == 32'h480A9057
| _T_263 == 32'h48061057
| _T_254 == 32'hC0001057
| _T_254 == 32'hC8001057
| _T_254 == 32'hE0001057
| _T_254 == 32'hD0001057
| _T_254 == 32'hD8001057
| _T_254 == 32'hF0001057
| _T_254 == 32'hF4001057
| _T_254 == 32'hF8001057
| _T_254 == 32'hFC001057
| _T_254 == 32'h3057
| _T_253 == 32'h40003057
| _T_254 == 32'h44003057
| _T_254 == 32'hC003057
| _T_254 == 32'h94003057
| _T_254 == 32'hA0003057
| _T_254 == 32'hA4003057
| _T_254 == 32'hB0003057
| _T_254 == 32'hB4003057
| _T_254 == 32'h24003057
| _T_254 == 32'h28003057
| _T_254 == 32'h2C003057
| _T_253 == 32'h9E003057
| _T_254 == 32'h38003057
| _T_254 == 32'h3C003057
| _T_254 == 32'h60003057
| _T_254 == 32'h64003057
| _T_254 == 32'h70003057
| _T_254 == 32'h74003057
| _T_254 == 32'h78003057
| _T_254 == 32'h7C003057
| _T_254 == 32'h30003057
| _T_253 == 32'h5C003057
| _T_260 == 32'h5E003057
| _T_254 == 32'h84003057
| _T_254 == 32'h80003057
| _T_254 == 32'hA8003057
| _T_254 == 32'hAC003057
| _T_254 == 32'hBC003057
| _T_254 == 32'hB8003057
| _T_254 == 32'h4057
| _T_254 == 32'h8004057
| _T_253 == 32'h40004057
| _T_254 == 32'h44004057
| _T_253 == 32'h48004057
| _T_254 == 32'h4C004057
| _T_254 == 32'hC004057
| _T_254 == 32'h94004057
| _T_254 == 32'hA0004057
| _T_254 == 32'hA4004057
| _T_254 == 32'hB0004057
| _T_254 == 32'hB4004057
| _T_254 == 32'h24004057
| _T_254 == 32'h28004057
| _T_254 == 32'h2C004057
| _T_254 == 32'h38004057
| _T_254 == 32'h3C004057
| _T_254 == 32'h38006057
| _T_254 == 32'h3C006057
| _T_254 == 32'h60004057
| _T_254 == 32'h64004057
| _T_254 == 32'h6C004057
| _T_254 == 32'h68004057
| _T_254 == 32'h70004057
| _T_254 == 32'h74004057
| _T_254 == 32'h78004057
| _T_254 == 32'h7C004057
| _T_254 == 32'h10004057
| _T_254 == 32'h14004057
| _T_254 == 32'h18004057
| _T_254 == 32'h1C004057
| _T_254 == 32'h30004057
| _T_253 == 32'h5C004057
| _T_260 == 32'h5E004057
| _T_254 == 32'hC4006057
| _T_254 == 32'hC0006057
| _T_254 == 32'hCC006057
| _T_254 == 32'hC8006057
| _T_254 == 32'hD4006057
| _T_254 == 32'hD0006057
| _T_254 == 32'hDC006057
| _T_254 == 32'hD8006057
| _T_254 == 32'hEC006057
| _T_254 == 32'hE0006057
| _T_254 == 32'hE8006057
| _T_254 == 32'hF0006057
| _T_254 == 32'hF4006057
| _T_254 == 32'hFC006057
| _T_254 == 32'hF8006057
| _T_254 == 32'h94006057
| _T_254 == 32'h9C006057
| _T_254 == 32'h90006057
| _T_254 == 32'h98006057
| _T_254 == 32'h84006057
| _T_254 == 32'h80006057
| _T_254 == 32'h8C006057
| _T_254 == 32'h88006057
| _T_254 == 32'hA4006057
| _T_254 == 32'hAC006057
| _T_254 == 32'hB4006057
| _T_254 == 32'hBC006057
| _T_260 == 32'h42006057
| _T_254 == 32'h24006057
| _T_254 == 32'h2C006057
| _T_254 == 32'h20006057
| _T_254 == 32'h28006057
| _T_254 == 32'h84004057
| _T_254 == 32'h8C004057
| _T_254 == 32'h80004057
| _T_254 == 32'h88004057
| _T_254 == 32'h9C004057
| _T_254 == 32'hA8004057
| _T_254 == 32'hAC004057
| _T_254 == 32'hBC004057
| _T_254 == 32'hB8004057
| _T_254 == 32'h38005057
| _T_254 == 32'h3C005057
| _T_254 == 32'h20005057
| _T_254 == 32'h24005057
| _T_254 == 32'h28005057
| _T_254 == 32'h10005057
| _T_254 == 32'h18005057
| _T_254 == 32'h60005057
| _T_254 == 32'h64005057
| _T_254 == 32'h6C005057
| _T_254 == 32'h70005057
| _T_254 == 32'h74005057
| _T_254 == 32'h7C005057
| _T_253 == 32'h5C005057
| _T_260 == 32'h5E005057
| _T_254 == 32'h90005057
| _T_254 == 32'h5057
| _T_254 == 32'h8005057
| _T_254 == 32'h9C005057
| _T_254 == 32'h80005057
| _T_254 == 32'h84005057
| _T_254 == 32'hB0005057
| _T_254 == 32'hB4005057
| _T_254 == 32'hB8005057
| _T_254 == 32'hBC005057
| _T_254 == 32'hA0005057
| _T_254 == 32'hA4005057
| _T_254 == 32'hA8005057
| _T_254 == 32'hAC005057
| _T_260 == 32'h42005057
| _T_254 == 32'hC0005057
| _T_254 == 32'hC8005057
| _T_254 == 32'hE0005057
| _T_254 == 32'hD0005057
| _T_254 == 32'hD8005057
| _T_254 == 32'hF0005057
| _T_254 == 32'hF4005057
| _T_254 == 32'hF8005057
| _T_254 == 32'hFC005057
| _T_264 == 32'h42002057
| _T_263 == 32'h40082057
| _T_263 == 32'h4008A057
| _T_264 == 32'h42001057;	// foo.lo.fir.mlir:493257:17, :493315:27, :493318:27, :493319:27, :493351:27, :493352:27, :493353:27, :493354:27, :493360:27, :493361:27, :493362:27, :493363:27, :493427:27, :493428:27, :493429:27, :493430:27, :493431:27, :493432:27, :493433:27, :493434:27, :493435:27, :493436:27, :493437:27, :493439:27, :493440:27, :493441:27, :493442:27, :493443:27, :493444:27, :493445:27, :493446:27, :493447:27, :493448:27, :493449:27, :493450:27, :493451:27, :493452:27, :493453:27, :493454:27, :493455:27, :493456:27, :493457:27, :493458:27, :493459:27, :493460:27, :493461:27, :493462:27, :493463:27, :493464:27, :493465:27, :493466:27, :493467:27, :493468:27, :493469:27, :493470:27, :493471:27, :493498:27, :493499:27, :493500:27, :493501:27, :493516:27, :493524:27, :493525:27, :493526:27, :493527:27, :493533:27, :493534:27, :493535:27, :493536:27, :493542:27, :493543:27, :493544:27, :493545:27, :493551:27, :493552:27, :493553:27, :493554:27, :493564:27, :493565:27, :493579:27, :493580:27, :493581:27, :493582:27, :493583:27, :493615:27, :493623:27, :493624:27, :493625:27, :493626:27, :493627:27, :493628:27, :493629:27, :493630:27, :493631:27, :493632:27, :493633:27, :493634:27, :493635:27, :493636:27, :493637:27, :493638:27, :493639:27, :493640:27, :493641:27, :493642:27, :493643:27, :493644:27, :493645:27, :493646:27, :493647:27, :493648:27, :493653:27, :493654:27, :493655:27, :493656:27, :493657:27, :493658:27, :493659:27, :493660:27, :493661:27, :493663:27, :493665:27, :493693:27, :493697:27, :493700:27, :493701:27, :493702:27, :493703:27, :493704:27, :493705:27, :493706:27, :493707:27, :493714:27, :493715:27, :493716:27, :493717:27, :493718:27, :493719:27, :493720:27, :493721:27, :493722:27, :493727:27, :493728:27, :493729:27, :493730:27, :493731:27, :493735:27, :493747:27, :493748:27, :493749:27, :493750:27, :493751:27, :493752:27, :493760:27, :493761:27, :493762:27, :493763:27, :493764:27, :493787:27, :493788:27, :493789:27, :493790:27, :493791:27, :493792:27, :493793:27, :493794:27, :493795:27, :493796:27, :493797:27, :493798:27, :493799:27, :493800:27, :493801:27, :493802:27, :493803:27, :493804:27, :493805:27, :493806:27, :493807:27, :493808:27, :493809:27, :493810:27, :493811:27, :493812:27, :493813:27, :493819:27, :493820:27, :493821:27, :493822:27, :493823:27, :493824:27, :493825:27, :493826:27, :493827:27, :493843:27, :493846:27, :493847:27, :493848:27, :493849:27, :493850:27, :493851:27, :493852:27, :493853:27, :493854:27, :493855:27, :493856:27, :493858:27, :493859:27, :493860:27, :493861:27, :493862:27, :493863:27, :493864:27, :493865:27, :493866:27, :494059:13, :498312:15, :498315:15, :498318:15, :498321:15, :498324:15, :498327:15, :498331:15, :498334:15, :498337:15, :498340:15, :498343:15, :498346:15, :498349:15, :498352:15, :498355:15, :498358:15, :498361:15, :498364:15, :498367:15, :498370:15, :498373:15, :498376:15, :498379:15, :498382:15, :498385:15, :498388:15, :498391:15, :498394:15, :498398:15, :498401:15, :498404:15, :498408:15, :498411:15, :498414:15, :498417:15, :498420:15, :498423:15, :498426:15, :498429:15, :498432:15, :498435:15, :498438:15, :498441:15, :498444:15, :498447:15, :498450:15, :498453:15, :498456:15, :498459:15, :498462:15, :498465:15, :498469:15, :498478:15, :498481:15, :498484:15, :498487:15, :498490:15, :498493:15, :498496:15, :498499:15, :498502:15, :498505:15, :498508:15, :498511:15, :498514:15, :498517:15, :498520:15, :498523:15, :498526:15, :498529:15, :498532:15, :498535:15, :498538:15, :498541:15, :498544:15, :498547:15, :498550:15, :498553:15, :498557:15, :498560:15, :498563:15, :498566:15, :498581:15, :498584:15, :498587:15, :498590:15, :498593:15, :498608:15, :498612:15, :498615:15, :498618:15, :498621:15, :498624:15, :498627:15, :498630:15, :498633:15, :498636:15, :498639:15, :498643:15, :498646:15, :498649:15, :498652:15, :498655:15, :498658:15, :498661:15, :498664:15, :498667:15, :498670:15, :498673:15, :498676:15, :498680:15, :498683:15, :498686:15, :498689:15, :498692:15, :498695:15, :498698:15, :498701:15, :498704:15, :498707:15, :498710:15, :498713:15, :498716:15, :498719:15, :498722:15, :498725:15, :498728:15, :498731:15, :498734:15, :498737:15, :498740:15, :498743:15, :498746:15, :498749:15, :498752:15, :498755:15, :498758:15, :498762:15, :498765:15, :498768:15, :498771:15, :498774:15, :498777:15, :498780:15, :498783:15, :498786:15, :498920:15, :498924:15, :498927:15, :498930:15, :498933:15, :498936:15, :498939:15, :498942:15, :498945:15, :498949:15, :498952:15, :498955:15, :498958:15, :498961:15, :498964:15, :498967:15, :498970:15, :498973:15, :498976:15, :498979:15, :498982:15, :498985:15, :498988:15, :498991:15, :499006:15, :499009:15, :499012:15, :499015:15, :499018:15, :499021:15, :499024:15, :499027:15, :499030:15, :499033:15, :499036:15, :499039:15, :499042:15, :499045:15, :499051:15, :499054:15, :499057:15, :499060:15, :499063:15, :499066:15, :499069:15, :499084:15, :499087:15, :499090:15, :499093:15, :499096:15, :499111:15, :499114:15, :499117:15, :499120:15, :499123:15, :499138:15, :499141:15, :499144:15, :499147:15, :499150:15, :499165:15, :499168:15, :499171:15, :499174:15, :499177:15, :499180:15, :499183:15, :499186:15, :499189:15, :499198:15, :499201:15, :499204:15, :499207:15, :499210:15, :499213:15, :499216:15, :499219:15, :499222:15, :499225:15, :499228:15, :499231:15, :499234:15, :499252:15, :499255:15, :499258:15, :499261:15, :499264:15, :499267:15, :499270:15, :499273:15, :499276:15, :499279:15, :499282:15, :499285:15, :499288:15, :499291:15, :499294:15, :499297:15, :499300:15, :499303:15, :499306:15, :499309:15, :499312:15, :499315:15, :499318:15, :499321:15, :499324:15, :499327:15, :499331:15, :499334:15, :499337:15, :499340:15, :499344:15, :499347:15, :499350:15, :499353:15, :499356:15, :499359:15, :499362:15, :499443:15, :499446:15, :499449:15, :499452:15, :499482:15, :499488:15, :499494:15, :499497:15, :499500:15, :499503:15, :499506:15, :499509:15, :499512:15, :499515:15, :499518:15, :499521:15, :499524:15, :499527:15, :499530:15, :499533:15, :499536:15, :499539:15, :499542:15, :499545:15, :499548:15, :499551:15, :499554:15, :499557:15, :499560:15, :499563:15, :499566:15, :499569:15, :499572:15, :499578:15, :499581:15, :499584:15, :499590:15, :499593:15, :499620:15, :499623:15, :499626:15, :499629:15, :499632:15, :499635:15, :499665:15, :499668:15, :499671:15, :499674:15, :499692:15, :499695:15, :499698:15, :499704:15, :499707:15, :499710:15, :499713:15, :499716:15, :499719:15, :499722:15, :499725:15, :499728:15, :499731:15, :499734:15, :499755:15, :499758:15, :499761:15, :499764:15, :499767:15, :499770:15, :499773:15, :499791:15, :499794:15, :499797:15, :499800:15, :499803:15, :499806:15, :499809:15, :499812:15, :499815:15, :499818:15, :499821:15, :499824:15, :499827:15, :499830:15, :499833:15, :499836:15, :499839:15, :499842:15, :499845:15, :499848:15, :499851:15, :499854:15, :499938:15, :499941:15, :499944:15, :499947:15, :499950:15, :499980:15, :499983:15, :499986:15, :499989:15, :499992:15, :499995:15, :499998:15, :500001:15, :500004:15, :500007:15, :500010:15, :500013:15, :500016:15, :500019:15, :500022:15, :500028:15, :500031:15, :500067:15, :500098:15, :500101:15, :500104:15, :500107:15, :508678:15, :508681:15, :508684:15, :508687:15, :508690:15, :508693:15, :508697:15, :508700:15, :508703:15, :508706:15, :508709:15, :508712:15, :508715:15, :508718:15, :508721:15, :508724:15, :508727:15, :508730:15, :508733:15, :508736:15, :508739:15, :508742:15, :508745:15, :508748:15, :508751:15, :508754:15, :508757:15, :508760:15, :508764:15, :508767:15, :508770:15, :508774:15, :508777:15, :508780:15, :508783:15, :508786:15, :508789:15, :508792:15, :508795:15, :508798:15, :508801:15, :508804:15, :508807:15, :508810:15, :508813:15, :508816:15, :508819:15, :508822:15, :508825:15, :508828:15, :508831:15, :508833:15, :508835:15, :508839:15, :508842:15, :508845:15, :508848:15, :508851:15, :508854:15, :508857:15, :508860:15, :508863:15, :508866:15, :508869:15, :508872:15, :508875:15, :508878:15, :508881:15, :508884:15, :508887:15, :508890:15, :508893:15, :508896:15, :508899:15, :508902:15, :508905:15, :508908:15, :508911:15, :508914:15, :508917:15, :508920:15, :508924:15, :508927:15, :508930:15, :508933:15, :508936:15, :508939:15, :508942:15, :508945:15, :508948:15, :508951:15, :508954:15, :508957:15, :508960:15, :508963:15, :508966:15, :508969:15, :508972:15, :508975:15, :508979:15, :508982:15, :508985:15, :508988:15, :508991:15, :508994:15, :508997:15, :509000:15, :509003:15, :509006:15, :509010:15, :509013:15, :509016:15, :509019:15, :509022:15, :509025:15, :509028:15, :509031:15, :509034:15, :509037:15, :509040:15, :509043:15, :509047:15, :509050:15, :509053:15, :509056:15, :509059:15, :509062:15, :509065:15, :509068:15, :509071:15, :509074:15, :509077:15, :509080:15, :509083:15, :509086:15, :509089:15, :509092:15, :509095:15, :509098:15, :509101:15, :509104:15, :509107:15, :509110:15, :509113:15, :509116:15, :509119:15, :509122:15, :509125:15, :509129:15, :509132:15, :509135:15, :509138:15, :509141:15, :509144:15, :509147:15, :509150:15, :509153:15, :509156:15, :509159:15, :509162:15, :509165:15, :509168:15, :509171:15, :509174:15, :509177:15, :509180:15, :509183:15, :509186:15, :509190:15, :509193:15, :509196:15, :509199:15, :509202:15, :509205:15, :509208:15, :509211:15, :509214:15, :509217:15, :509220:15, :509223:15, :509226:15, :509229:15, :509232:15, :509235:15, :509238:15, :509241:15, :509244:15, :509247:15, :509250:15, :509253:15, :509256:15, :509259:15, :509262:15, :509265:15, :509268:15, :509271:15, :509274:15, :509277:15, :509280:15, :509283:15, :509285:15, :509287:15, :509291:15, :509294:15, :509297:15, :509300:15, :509303:15, :509306:15, :509309:15, :509312:15, :509316:15, :509319:15, :509322:15, :509325:15, :509328:15, :509331:15, :509334:15, :509337:15, :509340:15, :509343:15, :509346:15, :509349:15, :509352:15, :509355:15, :509358:15, :509361:15, :509364:15, :509367:15, :509370:15, :509373:15, :509376:15, :509379:15, :509382:15, :509385:15, :509388:15, :509391:15, :509394:15, :509397:15, :509400:15, :509403:15, :509406:15, :509409:15, :509412:15, :509415:15, :509418:15, :509421:15, :509424:15, :509427:15, :509430:15, :509433:15, :509436:15, :509439:15, :509442:15, :509445:15, :509448:15, :509451:15, :509454:15, :509457:15, :509460:15, :509463:15, :509466:15, :509469:15, :509472:15, :509475:15, :509478:15, :509481:15, :509484:15, :509487:15, :509490:15, :509493:15, :509496:15, :509499:15, :509502:15, :509505:15, :509508:15, :509511:15, :509514:15, :509517:15, :509520:15, :509523:15, :509526:15, :509529:15, :509532:15, :509535:15, :509538:15, :509541:15, :509544:15, :509547:15, :509550:15, :509553:15, :509556:15, :509559:15, :509562:15, :509565:15, :509568:15, :509571:15, :509574:15, :509577:15, :509580:15, :509583:15, :509586:15, :509589:15, :509592:15, :509595:15, :509598:15, :509601:15, :509604:15, :509607:15, :509610:15, :509613:15, :509616:15, :509619:15, :509622:15, :509625:15, :509628:15, :509631:15, :509634:15, :509637:15, :509640:15, :509643:15, :509646:15, :509649:15, :509652:15, :509655:15, :509658:15, :509661:15, :509664:15, :509667:15, :509670:15, :509673:15, :509676:15, :509679:15, :509682:15, :509685:15, :509688:15, :509691:15, :509694:15, :509698:15, :509701:15, :509704:15, :509707:15, :509709:15, :509711:15, :509714:15, :509717:15, :509720:15, :509723:15, :509726:15, :509729:15, :509732:15, :509735:15, :509738:15, :509741:15, :509744:15, :509747:15, :509750:15, :509753:15, :509756:15, :509759:15, :509762:15, :509765:15, :509768:15, :509771:15, :509774:15, :509777:15, :509780:15, :509783:15, :509786:15, :509789:15, :509792:15, :509795:15, :509798:15, :509801:15, :509804:15, :509807:15, :509810:15, :509813:15, :509816:15, :509819:15, :509822:15, :509825:15, :509828:15, :509831:15, :509834:15, :509837:15, :509840:15, :509843:15, :509846:15, :509849:15, :509852:15, :509855:15, :509858:15, :509861:15, :509864:15, :509867:15, :509870:15, :509873:15, :509876:15, :509879:15, :509882:15, :509885:15, :509888:15, :509891:15, :509894:15, :509897:15, :509900:15, :509903:15, :509906:15, :509909:15, :509912:15, :509915:15, :509918:15, :509921:15, :509924:15, :509927:15, :509930:15, :509933:15, :509936:15, :509939:15, :509942:15, :509945:15, :509948:15, :509951:15, :509954:15, :509957:15, :509960:15, :509963:15, :509966:15, :509969:15, :509972:15, :509975:15, :509978:15, :509981:15, :509984:15, :509987:15, :509990:15, :509993:15, :509996:15, :509999:15, :510002:15, :510005:15, :510008:15, :510011:15, :510014:15, :510017:15, :510020:15, :510023:15, :510026:15, :510029:15, :510032:15, :510035:15, :510038:15, :510041:15, :510044:15, :510047:15, :510050:15, :510053:15, :510056:15, :510059:15, :510062:15, :510065:15, :510068:15, :510071:15, :510074:15, :510077:15, :510080:15, :510083:15, :510086:15, :510089:15, :510092:15, :510095:15, :510098:15, :510101:15, :510104:15, :510107:15, :510110:15, :510113:15, :510116:15, :510119:15, :510122:15, :510125:15, :510128:15, :510131:15, :510134:15, :510137:15, :510140:15, :510143:15, :510146:15, :510149:15, :510152:15, :510155:15, :510158:15, :510161:15, :510164:15, :510167:15, :510170:15, :510173:15, :510176:15, :510179:15, :510182:15, :510185:15, :510188:15, :510191:15, :510194:15, :510197:15, :510200:15, :510203:15, :510206:15, :510209:15, :510212:15, :510215:15, :510218:15, :510221:15, :510224:15, :510227:15, :510230:15, :510233:15, :510236:15, :510239:15, :510242:15, :510245:15, :510248:15, :510251:15, :510254:15, :510257:15, :510260:15, :510263:15, :510266:15, :510269:15, :510272:15, :510275:15, :510278:15, :510281:15, :510284:15, :510287:15, :510290:15, :510293:15, :510296:15, :510299:15, :510302:15, :510305:15, :510308:15, :510311:15, :510314:15, :510317:15, :510320:15, :510323:15, :510326:15, :510329:15, :510332:15, :510335:15, :510338:15, :510341:15, :510344:15, :510347:15, :510350:15, :510353:15, :510356:15, :510359:15, :510362:15, :510365:15, :510368:15, :510371:15, :510374:15, :510377:15, :510380:15, :510383:15, :510386:15, :510389:15, :510392:15, :510395:15, :510398:15, :510401:15, :510404:15, :510407:15, :510410:15, :510413:15, :510416:15, :510419:15, :510422:15, :510425:15, :510428:15, :510431:15, :510434:15, :510437:15, :510440:15, :510443:15, :510446:15, :510449:15, :510452:15, :510455:15, :510458:15, :510461:15, :510465:15, :510468:15, :510471:15, :510474:15, :511660:15, :511839:15, :511841:15, :512083:15, :512138:15, :512908:15, :512911:15, :512914:15, :512917:15, :512920:15, :512923:15, :512927:15, :512930:15, :512933:15, :512936:15, :512939:15, :512942:15, :512945:15, :512948:15, :512951:15, :512954:15, :512957:15, :512960:15, :512963:15, :512966:15, :512969:15, :512972:15, :512975:15, :512978:15, :512981:15, :512984:15, :512987:15, :512990:15, :512994:15, :512997:15, :513000:15, :513004:15, :513007:15, :513010:15, :513013:15, :513016:15, :513019:15, :513022:15, :513025:15, :513028:15, :513031:15, :513034:15, :513037:15, :513040:15, :513043:15, :513046:15, :513049:15, :513052:15, :513055:15, :513058:15, :513061:15, :513063:15, :513065:15, :513068:15, :513071:15, :513074:15, :513077:15, :513080:15, :513083:15, :513086:15, :513089:15, :513092:15, :513095:15, :513098:15, :513101:15, :513104:15, :513107:15, :513110:15, :513113:15, :513116:15, :513119:15, :513122:15, :513125:15, :513128:15, :513131:15, :513134:15, :513137:15, :513140:15, :513143:15, :513146:15, :513149:15, :513153:15, :513156:15, :513159:15, :513162:15, :513165:15, :513168:15, :513171:15, :513174:15, :513177:15, :513180:15, :513183:15, :513186:15, :513189:15, :513192:15, :513195:15, :513198:15, :513201:15, :513204:15, :513208:15, :513211:15, :513214:15, :513217:15, :513220:15, :513223:15, :513226:15, :513229:15, :513232:15, :513235:15, :513239:15, :513242:15, :513245:15, :513248:15, :513251:15, :513254:15, :513257:15, :513260:15, :513263:15, :513266:15, :513269:15, :513272:15, :513276:15, :513279:15, :513282:15, :513285:15, :513288:15, :513291:15, :513294:15, :513297:15, :513300:15, :513303:15, :513306:15, :513309:15, :513312:15, :513315:15, :513318:15, :513321:15, :513324:15, :513327:15, :513330:15, :513333:15, :513336:15, :513339:15, :513342:15, :513345:15, :513348:15, :513351:15, :513354:15, :513358:15, :513361:15, :513364:15, :513367:15, :513370:15, :513373:15, :513376:15, :513379:15, :513382:15, :513385:15, :513388:15, :513391:15, :513394:15, :513397:15, :513400:15, :513403:15, :513406:15, :513409:15, :513412:15, :513415:15, :513419:15, :513422:15, :513425:15, :513428:15, :513431:15, :513434:15, :513437:15, :513440:15, :513443:15, :513446:15, :513449:15, :513452:15, :513455:15, :513458:15, :513461:15, :513464:15, :513467:15, :513470:15, :513473:15, :513476:15, :513479:15, :513482:15, :513485:15, :513488:15, :513491:15, :513494:15, :513497:15, :513500:15, :513503:15, :513506:15, :513509:15, :513512:15, :513514:15, :513516:15, :513520:15, :513523:15, :513526:15, :513529:15, :513532:15, :513535:15, :513538:15, :513541:15, :513545:15, :513548:15, :513551:15, :513554:15, :513557:15, :513560:15, :513563:15, :513566:15, :513569:15, :513572:15, :513575:15, :513578:15, :513581:15, :513584:15, :513587:15, :513590:15, :513593:15, :513596:15, :513599:15, :513602:15, :513605:15, :513608:15, :513611:15, :513614:15, :513617:15, :513620:15, :513623:15, :513626:15, :513629:15, :513632:15, :513635:15, :513638:15, :513641:15, :513644:15, :513647:15, :513650:15, :513653:15, :513656:15, :513659:15, :513662:15, :513665:15, :513668:15, :513671:15, :513674:15, :513677:15, :513680:15, :513683:15, :513686:15, :513689:15, :513692:15, :513695:15, :513698:15, :513701:15, :513704:15, :513707:15, :513710:15, :513713:15, :513716:15, :513719:15, :513722:15, :513725:15, :513728:15, :513731:15, :513734:15, :513737:15, :513740:15, :513743:15, :513746:15, :513749:15, :513752:15, :513755:15, :513758:15, :513761:15, :513764:15, :513767:15, :513770:15, :513773:15, :513776:15, :513779:15, :513782:15, :513785:15, :513788:15, :513791:15, :513794:15, :513797:15, :513800:15, :513803:15, :513806:15, :513809:15, :513812:15, :513815:15, :513818:15, :513821:15, :513824:15, :513827:15, :513830:15, :513833:15, :513836:15, :513839:15, :513842:15, :513845:15, :513848:15, :513851:15, :513854:15, :513857:15, :513860:15, :513863:15, :513866:15, :513869:15, :513872:15, :513875:15, :513878:15, :513881:15, :513884:15, :513887:15, :513890:15, :513893:15, :513896:15, :513899:15, :513902:15, :513905:15, :513908:15, :513911:15, :513914:15, :513917:15, :513920:15, :513923:15, :513927:15, :513930:15, :513933:15, :513936:15, :513938:15, :513940:15, :513943:15, :513946:15, :513949:15, :513952:15, :513955:15, :513958:15, :513961:15, :513964:15, :513967:15, :513970:15, :513973:15, :513976:15, :513979:15, :513982:15, :513985:15, :513988:15, :513991:15, :513994:15, :513997:15, :514000:15, :514003:15, :514006:15, :514009:15, :514012:15, :514015:15, :514018:15, :514021:15, :514024:15, :514027:15, :514030:15, :514033:15, :514036:15, :514039:15, :514042:15, :514045:15, :514048:15, :514051:15, :514054:15, :514057:15, :514060:15, :514063:15, :514066:15, :514069:15, :514072:15, :514075:15, :514078:15, :514081:15, :514084:15, :514087:15, :514090:15, :514093:15, :514096:15, :514099:15, :514102:15, :514105:15, :514108:15, :514111:15, :514114:15, :514117:15, :514120:15, :514123:15, :514126:15, :514129:15, :514132:15, :514135:15, :514138:15, :514141:15, :514144:15, :514147:15, :514150:15, :514153:15, :514156:15, :514159:15, :514162:15, :514165:15, :514168:15, :514171:15, :514174:15, :514177:15, :514180:15, :514183:15, :514186:15, :514189:15, :514192:15, :514195:15, :514198:15, :514201:15, :514204:15, :514207:15, :514210:15, :514213:15, :514216:15, :514219:15, :514222:15, :514225:15, :514228:15, :514231:15, :514234:15, :514237:15, :514240:15, :514243:15, :514246:15, :514249:15, :514252:15, :514255:15, :514258:15, :514261:15, :514264:15, :514267:15, :514270:15, :514273:15, :514276:15, :514279:15, :514282:15, :514285:15, :514288:15, :514291:15, :514294:15, :514297:15, :514300:15, :514303:15, :514306:15, :514309:15, :514312:15, :514315:15, :514318:15, :514321:15, :514324:15, :514327:15, :514330:15, :514333:15, :514336:15, :514339:15, :514342:15, :514345:15, :514348:15, :514351:15, :514354:15, :514357:15, :514360:15, :514363:15, :514366:15, :514369:15, :514372:15, :514375:15, :514378:15, :514381:15, :514384:15, :514387:15, :514390:15, :514393:15, :514396:15, :514399:15, :514402:15, :514405:15, :514408:15, :514411:15, :514414:15, :514417:15, :514420:15, :514423:15, :514426:15, :514429:15, :514432:15, :514435:15, :514438:15, :514441:15, :514444:15, :514447:15, :514450:15, :514453:15, :514456:15, :514459:15, :514462:15, :514465:15, :514468:15, :514471:15, :514474:15, :514477:15, :514480:15, :514483:15, :514486:15, :514489:15, :514492:15, :514495:15, :514498:15, :514501:15, :514504:15, :514507:15, :514510:15, :514513:15, :514516:15, :514519:15, :514522:15, :514525:15, :514528:15, :514531:15, :514534:15, :514537:15, :514540:15, :514543:15, :514546:15, :514549:15, :514552:15, :514555:15, :514558:15, :514561:15, :514564:15, :514567:15, :514570:15, :514573:15, :514576:15, :514579:15, :514582:15, :514585:15, :514588:15, :514591:15, :514594:15, :514597:15, :514600:15, :514603:15, :514606:15, :514609:15, :514612:15, :514615:15, :514618:15, :514621:15, :514624:15, :514627:15, :514630:15, :514633:15, :514636:15, :514639:15, :514642:15, :514645:15, :514648:15, :514651:15, :514654:15, :514657:15, :514660:15, :514663:15, :514666:15, :514669:15, :514672:15, :514675:15, :514678:15, :514681:15, :514684:15, :514687:15, :514690:15, :514694:15, :514697:15, :514700:15, :514703:15, :515889:15, :516241:15, :516245:15, :516249:15, :516253:15, :516257:15, :516261:15, :516265:15, :516267:15, :516269:15, :516303:15, :516306:15, :516309:15, :516312:15, :516315:15, :516318:15, :516322:15, :516325:15, :516328:15, :516331:15, :516334:15, :516337:15, :516340:15, :516343:15, :516346:15, :516349:15, :516352:15, :516355:15, :516358:15, :516361:15, :516364:15, :516367:15, :516370:15, :516373:15, :516376:15, :516379:15, :516382:15, :516385:15, :516389:15, :516392:15, :516395:15, :516399:15, :516402:15, :516405:15, :516408:15, :516411:15, :516414:15, :516417:15, :516420:15, :516423:15, :516426:15, :516429:15, :516432:15, :516435:15, :516438:15, :516441:15, :516444:15, :516447:15, :516450:15, :516453:15, :516456:15, :516458:15, :516460:15, :516463:15, :516466:15, :516469:15, :516472:15, :516475:15, :516478:15, :516481:15, :516484:15, :516487:15, :516490:15, :516493:15, :516496:15, :516499:15, :516502:15, :516505:15, :516508:15, :516511:15, :516514:15, :516517:15, :516520:15, :516523:15, :516526:15, :516529:15, :516532:15, :516535:15, :516538:15, :516541:15, :516544:15, :516548:15, :516551:15, :516554:15, :516557:15, :516560:15, :516563:15, :516566:15, :516569:15, :516572:15, :516575:15, :516578:15, :516581:15, :516584:15, :516587:15, :516590:15, :516593:15, :516596:15, :516599:15, :516603:15, :516606:15, :516609:15, :516612:15, :516615:15, :516618:15, :516621:15, :516624:15, :516627:15, :516630:15, :516634:15, :516637:15, :516640:15, :516643:15, :516646:15, :516649:15, :516652:15, :516655:15, :516658:15, :516661:15, :516664:15, :516667:15, :516671:15, :516674:15, :516677:15, :516680:15, :516683:15, :516686:15, :516689:15, :516692:15, :516695:15, :516698:15, :516701:15, :516704:15, :516707:15, :516710:15, :516713:15, :516716:15, :516719:15, :516722:15, :516725:15, :516728:15, :516731:15, :516734:15, :516737:15, :516740:15, :516743:15, :516746:15, :516749:15, :516753:15, :516756:15, :516759:15, :516762:15, :516765:15, :516768:15, :516771:15, :516774:15, :516777:15, :516780:15, :516783:15, :516786:15, :516789:15, :516792:15, :516795:15, :516798:15, :516801:15, :516804:15, :516807:15, :516810:15, :516814:15, :516817:15, :516820:15, :516823:15, :516826:15, :516829:15, :516832:15, :516835:15, :516838:15, :516841:15, :516844:15, :516847:15, :516850:15, :516853:15, :516856:15, :516859:15, :516862:15, :516865:15, :516868:15, :516871:15, :516874:15, :516877:15, :516880:15, :516883:15, :516886:15, :516889:15, :516892:15, :516895:15, :516898:15, :516901:15, :516904:15, :516907:15, :516909:15, :516911:15, :516915:15, :516918:15, :516921:15, :516924:15, :516927:15, :516930:15, :516933:15, :516936:15, :516940:15, :516943:15, :516946:15, :516949:15, :516952:15, :516955:15, :516958:15, :516961:15, :516964:15, :516967:15, :516970:15, :516973:15, :516976:15, :516979:15, :516982:15, :516985:15, :516988:15, :516991:15, :516994:15, :516997:15, :517000:15, :517003:15, :517006:15, :517009:15, :517012:15, :517015:15, :517018:15, :517021:15, :517024:15, :517027:15, :517030:15, :517033:15, :517036:15, :517039:15, :517042:15, :517045:15, :517048:15, :517051:15, :517054:15, :517057:15, :517060:15, :517063:15, :517066:15, :517069:15, :517072:15, :517075:15, :517078:15, :517081:15, :517084:15, :517087:15, :517090:15, :517093:15, :517096:15, :517099:15, :517102:15, :517105:15, :517108:15, :517111:15, :517114:15, :517117:15, :517120:15, :517123:15, :517126:15, :517129:15, :517132:15, :517135:15, :517138:15, :517141:15, :517144:15, :517147:15, :517150:15, :517153:15, :517156:15, :517159:15, :517162:15, :517165:15, :517168:15, :517171:15, :517174:15, :517177:15, :517180:15, :517183:15, :517186:15, :517189:15, :517192:15, :517195:15, :517198:15, :517201:15, :517204:15, :517207:15, :517210:15, :517213:15, :517216:15, :517219:15, :517222:15, :517225:15, :517228:15, :517231:15, :517234:15, :517237:15, :517240:15, :517243:15, :517246:15, :517249:15, :517252:15, :517255:15, :517258:15, :517261:15, :517264:15, :517267:15, :517270:15, :517273:15, :517276:15, :517279:15, :517282:15, :517285:15, :517288:15, :517291:15, :517294:15, :517297:15, :517300:15, :517303:15, :517306:15, :517309:15, :517312:15, :517315:15, :517318:15, :517322:15, :517325:15, :517328:15, :517331:15, :517333:15, :517335:15, :517338:15, :517341:15, :517344:15, :517347:15, :517350:15, :517353:15, :517356:15, :517359:15, :517362:15, :517365:15, :517368:15, :517371:15, :517374:15, :517377:15, :517380:15, :517383:15, :517386:15, :517389:15, :517392:15, :517395:15, :517398:15, :517401:15, :517404:15, :517407:15, :517410:15, :517413:15, :517416:15, :517419:15, :517422:15, :517425:15, :517428:15, :517431:15, :517434:15, :517437:15, :517440:15, :517443:15, :517446:15, :517449:15, :517452:15, :517455:15, :517458:15, :517461:15, :517464:15, :517467:15, :517470:15, :517473:15, :517476:15, :517479:15, :517482:15, :517485:15, :517488:15, :517491:15, :517494:15, :517497:15, :517500:15, :517503:15, :517506:15, :517509:15, :517512:15, :517515:15, :517518:15, :517521:15, :517524:15, :517527:15, :517530:15, :517533:15, :517536:15, :517539:15, :517542:15, :517545:15, :517548:15, :517551:15, :517554:15, :517557:15, :517560:15, :517563:15, :517566:15, :517569:15, :517572:15, :517575:15, :517578:15, :517581:15, :517584:15, :517587:15, :517590:15, :517593:15, :517596:15, :517599:15, :517602:15, :517605:15, :517608:15, :517611:15, :517614:15, :517617:15, :517620:15, :517623:15, :517626:15, :517629:15, :517632:15, :517635:15, :517638:15, :517641:15, :517644:15, :517647:15, :517650:15, :517653:15, :517656:15, :517659:15, :517662:15, :517665:15, :517668:15, :517671:15, :517674:15, :517677:15, :517680:15, :517683:15, :517686:15, :517689:15, :517692:15, :517695:15, :517698:15, :517701:15, :517704:15, :517707:15, :517710:15, :517713:15, :517716:15, :517719:15, :517722:15, :517725:15, :517728:15, :517731:15, :517734:15, :517737:15, :517740:15, :517743:15, :517746:15, :517749:15, :517752:15, :517755:15, :517758:15, :517761:15, :517764:15, :517767:15, :517770:15, :517773:15, :517776:15, :517779:15, :517782:15, :517785:15, :517788:15, :517791:15, :517794:15, :517797:15, :517800:15, :517803:15, :517806:15, :517809:15, :517812:15, :517815:15, :517818:15, :517821:15, :517824:15, :517827:15, :517830:15, :517833:15, :517836:15, :517839:15, :517842:15, :517845:15, :517848:15, :517851:15, :517854:15, :517857:15, :517860:15, :517863:15, :517866:15, :517869:15, :517872:15, :517875:15, :517878:15, :517881:15, :517884:15, :517887:15, :517890:15, :517893:15, :517896:15, :517899:15, :517902:15, :517905:15, :517908:15, :517911:15, :517914:15, :517917:15, :517920:15, :517923:15, :517926:15, :517929:15, :517932:15, :517935:15, :517938:15, :517941:15, :517944:15, :517947:15, :517950:15, :517953:15, :517956:15, :517959:15, :517962:15, :517965:15, :517968:15, :517971:15, :517974:15, :517977:15, :517980:15, :517983:15, :517986:15, :517989:15, :517992:15, :517995:15, :517998:15, :518001:15, :518004:15, :518007:15, :518010:15, :518013:15, :518016:15, :518019:15, :518022:15, :518025:15, :518028:15, :518031:15, :518034:15, :518037:15, :518040:15, :518043:15, :518046:15, :518049:15, :518052:15, :518055:15, :518058:15, :518061:15, :518064:15, :518067:15, :518070:15, :518073:15, :518076:15, :518079:15, :518082:15, :518085:15, :518089:15, :518092:15, :518095:15, :518098:15, :519284:16, :519636:16, :519640:16, :519644:16, :519648:16, :519652:16, :519656:16, :519660:16, :519662:16, :519664:16, :523111:16, :523158:16, :523184:16, :523238:16
```","%3844 = comb.or %3233, %3234, %3235, %3236, %3237, %3238, %3240, %3241, %3242, %3243, %3244, %3245, %3246, %3247, %3248, %3249, %3250, %3251, %3252, %3253, %3254, %3255, %3256, %3257, %3258, %3259, %3260, %3261, %3263, %3264, %3265, %3267, %3268, %3269, %3270, %3271, %3272, %3273, %3274, %3275, %3276, %3277, %3278, %3279, %3280, %3281, %3282, %3283, %3284, %3285, %3286, %3288, %3290, %3291, %3292, %3293, %3294, %3295, %3296, %3297, %3298, %3299, %3300, %3301, %3302, %3303, %3304, %3305, %3306, %3307, %3308, %3309, %3310, %3311, %3312, %3313, %3314, %3315, %3316, %3317, %3319, %3320, %3321, %3322, %3323, %3324, %3325, %3326, %3327, %3328, %3329, %3330, %3331, %3332, %3333, %3334, %3335, %3336, %3338, %3339, %3340, %3341, %3342, %3343, %3344, %3345, %3346, %3347, %3349, %3350, %3351, %3352, %3353, %3354, %3355, %3356, %3357, %3358, %3359, %3360, %3362, %3363, %3364, %3365, %3366, %3367, %3368, %3369, %3370, %3371, %3372, %3373, %3374, %3375, %3376, %3377, %3378, %3379, %3380, %3381, %3382, %3383, %3384, %3385, %3386, %3387, %3388, %3390, %3391, %3392, %3393, %3394, %3395, %3396, %3397, %3398, %3399, %3400, %3401, %3402, %3403, %3404, %3405, %3406, %3407, %3408, %3409, %3411, %3412, %3413, %3414, %3415, %3416, %3417, %3418, %3419, %3420, %3421, %3422, %3423, %3424, %3425, %3426, %3427, %3428, %3429, %3430, %3431, %3432, %3433, %3434, %3435, %3436, %3437, %3438, %3439, %3440, %3441, %3442, %3444, %3446, %3447, %3448, %3449, %3450, %3451, %3452, %3453, %3455, %3456, %3457, %3458, %3459, %3460, %3461, %3462, %3463, %3464, %3465, %3466, %3467, %3468, %3469, %3470, %3471, %3472, %3473, %3474, %3475, %3476, %3477, %3478, %3479, %3480, %3481, %3482, %3483, %3484, %3485, %3486, %3487, %3488, %3489, %3490, %3491, %3492, %3493, %3494, %3495, %3496, %3497, %3498, %3499, %3500, %3501, %3502, %3503, %3504, %3505, %3506, %3507, %3508, %3509, %3510, %3511, %3512, %3513, %3514, %3515, %3516, %3517, %3518, %3519, %3520, %3521, %3522, %3523, %3524, %3525, %3526, %3527, %3528, %3529, %3530, %3531, %3532, %3533, %3534, %3535, %3536, %3537, %3538, %3539, %3540, %3541, %3542, %3543, %3544, %3545, %3546, %3547, %3548, %3549, %3550, %3551, %3552, %3553, %3554, %3555, %3556, %3557, %3558, %3559, %3560, %3561, %3562, %3563, %3564, %3565, %3566, %3567, %3568, %3569, %3570, %3571, %3572, %3573, %3574, %3575, %3576, %3577, %3578, %3579, %3580, %3581, %3583, %3584, %3585, %3586, %3588, %3589, %3590, %3591, %3592, %3593, %3594, %3595, %3596, %3597, %3598, %3599, %3600, %3601, %3602, %3603, %3604, %3605, %3606, %3607, %3608, %3609, %3610, %3611, %3612, %3613, %3614, %3615, %3616, %3617, %3618, %3619, %3620, %3621, %3622, %3623, %3624, %3625, %3626, %3627, %3628, %3629, %3630, %3631, %3632, %3633, %3634, %3635, %3636, %3637, %3638, %3639, %3640, %3641, %3642, %3643, %3644, %3645, %3646, %3647, %3648, %3649, %3650, %3651, %3652, %3653, %3654, %3655, %3656, %3657, %3658, %3659, %3660, %3661, %3662, %3663, %3664, %3665, %3666, %3667, %3668, %3669, %3670, %3671, %3672, %3673, %3674, %3675, %3676, %3677, %3678, %3679, %3680, %3681, %3682, %3683, %3684, %3685, %3686, %3687, %3688, %3689, %3690, %3691, %3692, %3693, %3694, %3695, %3696, %3697, %3698, %3699, %3700, %3701, %3702, %3703, %3704, %3705, %3706, %3707, %3708, %3709, %3710, %3711, %3712, %3713, %3714, %3715, %3716, %3717, %3718, %3719, %3720, %3721, %3722, %3723, %3724, %3725, %3726, %3727, %3728, %3729, %3730, %3731, %3732, %3733, %3734, %3735, %3736, %3737, %3738, %3739, %3740, %3741, %3742, %3743, %3744, %3745, %3746, %3747, %3748, %3749, %3750, %3751, %3752, %3753, %3754, %3755, %3756, %3757, %3758, %3759, %3760, %3761, %3762, %3763, %3764, %3765, %3766, %3767, %3768, %3769, %3770, %3771, %3772, %3773, %3774, %3775, %3776, %3777, %3778, %3779, %3780, %3781, %3782, %3783, %3784, %3785, %3786, %3787, %3788, %3789, %3790, %3791, %3792, %3793, %3794, %3795, %3796, %3797, %3798, %3799, %3800, %3801, %3802, %3803, %3804, %3805, %3806, %3807, %3808, %3809, %3810, %3811, %3812, %3813, %3814, %3815, %3816, %3817, %3818, %3819, %3820, %3821, %3822, %3823, %3824, %3825, %3826, %3827, %3828, %3829, %3830, %3831, %3832, %3833, %3834, %3835, %3836, %3837, %3838, %3840, %3841, %3842, %3843 : i1","wire _T_361 = _T_180 ? _T_181 == 64'h63
| _T_181 == 64'h1063
| _T_181 == 64'h4063
| _T_181 == 64'h6063
| _T_181 == 64'h5063
| _T_181 == 64'h7063
| _T_182 == 64'h6F
| _T_181 == 64'h67
| _T_181 == 64'h3
| _T_181 == 64'h4003
| _T_181 == 64'h1003
| _T_181 == 64'h5003
| _T_181 == 64'h2003
| _T_181 == 64'h6003
| _T_181 == 64'h3003
| _T_181 == 64'h23
| _T_181 == 64'h1023
| _T_181 == 64'h2023
| _T_181 == 64'h3023
| _T_182 == 64'h37
| _T_182 == 64'h17
| _T_181 == 64'h13
| _T_181 == 64'h2013
| _T_181 == 64'h3013
| _T_181 == 64'h7013
| _T_181 == 64'h6013
| _T_181 == 64'h4013
| _T_181 == 64'h1B
| _T_183 == 64'h101B
| _T_183 == 64'h501B
| _T_183 == 64'h4000501B
| _T_184 == 64'h1013
| _T_184 == 64'h5013
| _T_184 == 64'h40005013
| _T_183 == 64'h33
| _T_183 == 64'h40000033
| _T_183 == 64'h2033
| _T_183 == 64'h3033
| _T_183 == 64'h7033
| _T_183 == 64'h6033
| _T_183 == 64'h4033
| _T_183 == 64'h1033
| _T_183 == 64'h5033
| _T_183 == 64'h40005033
| _T_183 == 64'h3B
| _T_183 == 64'h4000003B
| _T_183 == 64'h103B
| _T_183 == 64'h503B
| _T_183 == 64'h4000503B
| _T_181 == 64'hF
| _T_181 == 64'h100F
| (io_fetch_bits_data & 64'hFE007FFF) == 64'h12000073
| _T_185 == 64'hFC000073
| _T_185 == 64'hFC200073
| _T_181 == 64'h5073
| _T_181 == 64'h6073
| _T_181 == 64'h7073
| _T_185 == 64'h73
| _T_185 == 64'h100073
| _T_185 == 64'h30200073
| _T_185 == 64'h10500073
| _T_185 == 64'h30500073
| _T_181 == 64'h1073
| _T_181 == 64'h2073
| _T_181 == 64'h3073
| _T_185 == 64'h10200073
| _T_185 == 64'h7B200073
| _T_183 == 64'h2000033
| _T_183 == 64'h2001033
| _T_183 == 64'h2003033
| _T_183 == 64'h2002033
| _T_183 == 64'h200003B
| _T_183 == 64'h2004033
| _T_183 == 64'h2005033
| _T_183 == 64'h2006033
| _T_183 == 64'h2007033
| _T_183 == 64'h200403B
| _T_183 == 64'h200503B
| _T_183 == 64'h200603B
| _T_183 == 64'h200703B
| _T_186 == 64'h202F
| _T_186 == 64'h6000202F
| _T_186 == 64'h4000202F
| _T_186 == 64'h2000202F
| _T_186 == 64'h8000202F
| _T_186 == 64'hA000202F
| _T_186 == 64'hC000202F
| _T_186 == 64'hE000202F
| _T_186 == 64'h800202F
| _T_186 == 64'h302F
| _T_186 == 64'h6000302F
| _T_186 == 64'h4000302F
| _T_186 == 64'h2000302F
| _T_186 == 64'h8000302F
| _T_186 == 64'hA000302F
| _T_186 == 64'hC000302F
| _T_186 == 64'hE000302F
| _T_186 == 64'h800302F
| _T_187 == 64'h1000202F
| _T_186 == 64'h1800202F
| _T_187 == 64'h1000302F
| _T_186 == 64'h1800302F
| _T_181 == 64'h1027
| _T_181 == 64'h2027
| _T_181 == 64'h3027
| _T_181 == 64'h1007
| _T_181 == 64'h2007
| _T_181 == 64'h3007
| _T_188 == 64'h4000043
| _T_188 == 64'h4000047
| _T_188 == 64'h400004B
| _T_188 == 64'h400004F
| _T_188 == 64'h43
| _T_188 == 64'h47
| _T_188 == 64'h4B
| _T_188 == 64'h4F
| _T_188 == 64'h2000043
| _T_188 == 64'h2000047
| _T_188 == 64'h200004B
| _T_188 == 64'h200004F
| _T_189 == 64'h4000053
| _T_189 == 64'hC000053
| _T_189 == 64'h14000053
| _T_189 == 64'h1C000053
| _T_183 == 64'h24000053
| _T_183 == 64'h24001053
| _T_183 == 64'h24002053
| _T_183 == 64'h2C000053
| _T_183 == 64'h2C001053
| _T_189 == 64'h53
| _T_189 == 64'h8000053
| _T_189 == 64'h10000053
| _T_189 == 64'h18000053
| _T_183 == 64'h20000053
| _T_183 == 64'h20001053
| _T_183 == 64'h20002053
| _T_183 == 64'h28000053
| _T_183 == 64'h28001053
| _T_189 == 64'h2000053
| _T_189 == 64'hA000053
| _T_189 == 64'h12000053
| _T_189 == 64'h1A000053
| _T_183 == 64'h22000053
| _T_183 == 64'h22001053
| _T_183 == 64'h22002053
| _T_183 == 64'h2A000053
| _T_183 == 64'h2A001053
| _T_190 == 64'h5C000053
| _T_190 == 64'h44000053
| _T_190 == 64'h40200053
| _T_190 == 64'h58000053
| _T_190 == 64'h5A000053
| _T_190 == 64'h40100053
| _T_190 == 64'h42000053
| _T_190 == 64'h44100053
| _T_190 == 64'h42200053
| _T_183 == 64'hA4002053
| _T_183 == 64'hA4001053
| _T_183 == 64'hA4000053
| _T_183 == 64'hA0002053
| _T_183 == 64'hA0001053
| _T_183 == 64'hA0000053
| _T_183 == 64'hA2002053
| _T_183 == 64'hA2001053
| _T_183 == 64'hA2000053
| _T_190 == 64'hC4000053
| _T_190 == 64'hC4100053
| _T_191 == 64'hE4001053
| _T_190 == 64'hC4200053
| _T_190 == 64'hC4300053
| _T_190 == 64'hC0000053
| _T_190 == 64'hC0100053
| _T_191 == 64'hE0001053
| _T_190 == 64'hC0200053
| _T_190 == 64'hC0300053
| _T_190 == 64'hC2000053
| _T_190 == 64'hC2100053
| _T_191 == 64'hE2001053
| _T_190 == 64'hC2200053
| _T_190 == 64'hC2300053
| _T_191 == 64'hE4000053
| _T_191 == 64'hE0000053
| _T_191 == 64'hE2000053
| _T_191 == 64'hF4000053
| _T_191 == 64'hF0000053
| _T_191 == 64'hF2000053
| _T_190 == 64'hD4000053
| _T_190 == 64'hD4100053
| _T_190 == 64'hD4200053
| _T_190 == 64'hD4300053
| _T_190 == 64'hD0000053
| _T_190 == 64'hD0100053
| _T_190 == 64'hD0200053
| _T_190 == 64'hD0300053
| _T_190 == 64'hD2000053
| _T_190 == 64'hD2100053
| _T_190 == 64'hD2200053
| _T_190 == 64'hD2300053
| _T_183 == 64'h80007057
| (io_fetch_bits_data & 64'h8000707F) == 64'h7057
| _T_192 == 64'h7
| _T_192 == 64'h5007
| _T_192 == 64'h6007
| _T_192 == 64'h7007
| _T_192 == 64'h1000007
| _T_192 == 64'h1005007
| _T_192 == 64'h1006007
| _T_192 == 64'h1007007
| _T_193 == 64'hC000007
| _T_193 == 64'hC005007
| _T_193 == 64'hC006007
| _T_191 == 64'h2800007
| _T_191 == 64'h2805007
| _T_191 == 64'h2806007
| _T_191 == 64'h2807007
| _T_191 == 64'h22800007
| _T_191 == 64'h22805007
| _T_191 == 64'h22806007
| _T_191 == 64'h22807007
| _T_191 == 64'h62800007
| _T_191 == 64'h62805007
| _T_191 == 64'h62806007
| _T_191 == 64'h62807007
| _T_191 == 64'hE2800007
| _T_191 == 64'hE2805007
| _T_191 == 64'hE2806007
| _T_191 == 64'hE2807007
| _T_193 == 64'hC007007
| _T_192 == 64'h27
| _T_192 == 64'h5027
| _T_192 == 64'h6027
| _T_192 == 64'h7027
| _T_193 == 64'hC000027
| _T_193 == 64'hC005027
| _T_193 == 64'hC006027
| _T_184 == 64'h4000027
| _T_184 == 64'h4005027
| _T_184 == 64'h4006027
| _T_191 == 64'h2800027
| _T_191 == 64'h22800027
| _T_191 == 64'h62800027
| _T_191 == 64'hE2800027
| _T_193 == 64'hC007027
| _T_184 == 64'h4007027
| _T_186 == 64'h800002F
| _T_186 == 64'h2F
| _T_186 == 64'h2000002F
| _T_186 == 64'h6000002F
| _T_186 == 64'h4000002F
| _T_186 == 64'h8000002F
| _T_186 == 64'hA000002F
| _T_186 == 64'hC000002F
| _T_186 == 64'hE000002F
| _T_186 == 64'h800502F
| _T_186 == 64'h502F
| _T_186 == 64'h2000502F
| _T_186 == 64'h6000502F
| _T_186 == 64'h4000502F
| _T_186 == 64'h8000502F
| _T_186 == 64'hA000502F
| _T_186 == 64'hC000502F
| _T_186 == 64'hE000502F
| _T_186 == 64'h800602F
| _T_186 == 64'h602F
| _T_186 == 64'h2000602F
| _T_186 == 64'h6000602F
| _T_186 == 64'h4000602F
| _T_186 == 64'h8000602F
| _T_186 == 64'hA000602F
| _T_186 == 64'hC000602F
| _T_186 == 64'hE000602F
| _T_186 == 64'h800702F
| _T_186 == 64'h702F
| _T_186 == 64'h2000702F
| _T_186 == 64'h6000702F
| _T_186 == 64'h4000702F
| _T_186 == 64'h8000702F
| _T_186 == 64'hA000702F
| _T_186 == 64'hC000702F
| _T_186 == 64'hE000702F
| _T_193 == 64'h8000007
| _T_193 == 64'h8005007
| _T_193 == 64'h8006007
| _T_193 == 64'h8007007
| _T_193 == 64'h8000027
| _T_193 == 64'h8005027
| _T_193 == 64'h8006027
| _T_193 == 64'h8007027
| _T_184 == 64'h2057
| _T_184 == 64'hC4000057
| _T_184 == 64'hC0000057
| _T_184 == 64'h4002057
| _T_184 == 64'h8002057
| _T_184 == 64'hC002057
| _T_184 == 64'h10002057
| _T_184 == 64'h14002057
| _T_184 == 64'h18002057
| _T_184 == 64'h1C002057
| _T_184 == 64'h57
| _T_184 == 64'h8000057
| _T_183 == 64'h40000057
| _T_184 == 64'h44000057
| _T_183 == 64'h48000057
| _T_184 == 64'h4C000057
| _T_184 == 64'h94000057
| _T_184 == 64'hA0000057
| _T_184 == 64'hA4000057
| _T_184 == 64'hB0000057
| _T_184 == 64'hB4000057
| _T_184 == 64'h24000057
| _T_184 == 64'h28000057
| _T_184 == 64'h2C000057
| _T_184 == 64'h60000057
| _T_184 == 64'h64000057
| _T_184 == 64'h6C000057
| _T_184 == 64'h68000057
| _T_184 == 64'h70000057
| _T_184 == 64'h74000057
| _T_184 == 64'h10000057
| _T_184 == 64'h14000057
| _T_184 == 64'h18000057
| _T_184 == 64'h1C000057
| _T_184 == 64'h30000057
| _T_184 == 64'h38000057
| _T_183 == 64'h5E002057
| _T_183 == 64'h5C000057
| _T_191 == 64'h5E000057
| _T_184 == 64'h60002057
| _T_184 == 64'h64002057
| _T_184 == 64'h68002057
| _T_184 == 64'h6C002057
| _T_184 == 64'h70002057
| _T_184 == 64'h74002057
| _T_184 == 64'h78002057
| _T_184 == 64'h7C002057
| _T_194 == 64'h5000A057
| _T_194 == 64'h50012057
| _T_194 == 64'h5001A057
| _T_194 == 64'h50082057
| (io_fetch_bits_data & 64'hFDFFF07F) == 64'h5008A057
| _T_194 == 64'h48032057
| _T_194 == 64'h4803A057
| _T_194 == 64'h48022057
| _T_194 == 64'h4802A057
| _T_194 == 64'h48012057
| _T_194 == 64'h4801A057
| _T_184 == 64'hC4002057
| _T_184 == 64'hC0002057
| _T_184 == 64'hCC002057
| _T_184 == 64'hC8002057
| _T_184 == 64'hD4002057
| _T_184 == 64'hD0002057
| _T_184 == 64'hDC002057
| _T_184 == 64'hD8002057
| _T_184 == 64'hEC002057
| _T_184 == 64'hE0002057
| _T_184 == 64'hE8002057
| _T_184 == 64'hF0002057
| _T_184 == 64'hF4002057
| _T_184 == 64'hFC002057
| _T_184 == 64'h94002057
| _T_184 == 64'h9C002057
| _T_184 == 64'h90002057
| _T_184 == 64'h98002057
| _T_184 == 64'h84002057
| _T_184 == 64'h80002057
| _T_184 == 64'h8C002057
| _T_184 == 64'h88002057
| _T_184 == 64'hA4002057
| _T_184 == 64'hAC002057
| _T_184 == 64'hB4002057
| _T_184 == 64'hBC002057
| _T_184 == 64'h24002057
| _T_184 == 64'h2C002057
| _T_184 == 64'h20002057
| _T_184 == 64'h28002057
| _T_184 == 64'h84000057
| _T_184 == 64'h8C000057
| _T_184 == 64'h80000057
| _T_184 == 64'h88000057
| _T_184 == 64'h9C000057
| _T_184 == 64'hA8000057
| _T_184 == 64'hAC000057
| _T_184 == 64'hBC000057
| _T_184 == 64'hB8000057
| _T_184 == 64'h4001057
| _T_184 == 64'hC4001057
| _T_184 == 64'hC001057
| _T_184 == 64'hCC001057
| _T_184 == 64'h14001057
| _T_184 == 64'h1C001057
| _T_194 == 64'h4C081057
| _T_184 == 64'h10001057
| _T_184 == 64'h18001057
| _T_184 == 64'h60001057
| _T_184 == 64'h64001057
| _T_184 == 64'h6C001057
| _T_184 == 64'h70001057
| _T_194 == 64'h48011057
| _T_194 == 64'h48019057
| _T_194 == 64'h48091057
| _T_194 == 64'h48099057
| _T_194 == 64'h480B1057
| _T_194 == 64'h480B9057
| _T_194 == 64'h48081057
| _T_194 == 64'h48089057
| _T_194 == 64'h48051057
| _T_194 == 64'h48059057
| _T_194 == 64'h48071057
| _T_194 == 64'h48079057
| _T_194 == 64'h48041057
| _T_194 == 64'h48049057
| _T_194 == 64'h48031057
| _T_194 == 64'h48039057
| _T_194 == 64'h48001057
| _T_194 == 64'h48009057
| _T_184 == 64'h90001057
| _T_184 == 64'h1057
| _T_184 == 64'h8001057
| _T_194 == 64'h4C001057
| _T_184 == 64'h80001057
| _T_194 == 64'h4C021057
| _T_194 == 64'h4C029057
| _T_184 == 64'hB0001057
| _T_184 == 64'hB4001057
| _T_184 == 64'hB8001057
| _T_184 == 64'hBC001057
| _T_184 == 64'hA0001057
| _T_184 == 64'hA4001057
| _T_184 == 64'hA8001057
| _T_184 == 64'hAC001057
| _T_184 == 64'h20001057
| _T_184 == 64'h24001057
| _T_184 == 64'h28001057
| _T_194 == 64'h480A1057
| _T_194 == 64'h480A9057
| _T_194 == 64'h48061057
| _T_184 == 64'hC0001057
| _T_184 == 64'hC8001057
| _T_184 == 64'hE0001057
| _T_184 == 64'hD0001057
| _T_184 == 64'hD8001057
| _T_184 == 64'hF0001057
| _T_184 == 64'hF4001057
| _T_184 == 64'hF8001057
| _T_184 == 64'hFC001057
| _T_184 == 64'h3057
| _T_183 == 64'h40003057
| _T_184 == 64'h44003057
| _T_184 == 64'hC003057
| _T_184 == 64'h94003057
| _T_184 == 64'hA0003057
| _T_184 == 64'hA4003057
| _T_184 == 64'hB0003057
| _T_184 == 64'hB4003057
| _T_184 == 64'h24003057
| _T_184 == 64'h28003057
| _T_184 == 64'h2C003057
| _T_183 == 64'h9E003057
| _T_184 == 64'h38003057
| _T_184 == 64'h3C003057
| _T_184 == 64'h60003057
| _T_184 == 64'h64003057
| _T_184 == 64'h70003057
| _T_184 == 64'h74003057
| _T_184 == 64'h78003057
| _T_184 == 64'h7C003057
| _T_184 == 64'h30003057
| _T_183 == 64'h5C003057
| _T_191 == 64'h5E003057
| _T_184 == 64'h84003057
| _T_184 == 64'h80003057
| _T_184 == 64'hA8003057
| _T_184 == 64'hAC003057
| _T_184 == 64'hBC003057
| _T_184 == 64'hB8003057
| _T_184 == 64'h4057
| _T_184 == 64'h8004057
| _T_183 == 64'h40004057
| _T_184 == 64'h44004057
| _T_183 == 64'h48004057
| _T_184 == 64'h4C004057
| _T_184 == 64'hC004057
| _T_184 == 64'h94004057
| _T_184 == 64'hA0004057
| _T_184 == 64'hA4004057
| _T_184 == 64'hB0004057
| _T_184 == 64'hB4004057
| _T_184 == 64'h24004057
| _T_184 == 64'h28004057
| _T_184 == 64'h2C004057
| _T_184 == 64'h38004057
| _T_184 == 64'h3C004057
| _T_184 == 64'h38006057
| _T_184 == 64'h3C006057
| _T_184 == 64'h60004057
| _T_184 == 64'h64004057
| _T_184 == 64'h6C004057
| _T_184 == 64'h68004057
| _T_184 == 64'h70004057
| _T_184 == 64'h74004057
| _T_184 == 64'h78004057
| _T_184 == 64'h7C004057
| _T_184 == 64'h10004057
| _T_184 == 64'h14004057
| _T_184 == 64'h18004057
| _T_184 == 64'h1C004057
| _T_184 == 64'h30004057
| _T_183 == 64'h5C004057
| _T_191 == 64'h5E004057
| _T_184 == 64'hC4006057
| _T_184 == 64'hC0006057
| _T_184 == 64'hCC006057
| _T_184 == 64'hC8006057
| _T_184 == 64'hD4006057
| _T_184 == 64'hD0006057
| _T_184 == 64'hDC006057
| _T_184 == 64'hD8006057
| _T_184 == 64'hEC006057
| _T_184 == 64'hE0006057
| _T_184 == 64'hE8006057
| _T_184 == 64'hF0006057
| _T_184 == 64'hF4006057
| _T_184 == 64'hFC006057
| _T_184 == 64'hF8006057
| _T_184 == 64'h94006057
| _T_184 == 64'h9C006057
| _T_184 == 64'h90006057
| _T_184 == 64'h98006057
| _T_184 == 64'h84006057
| _T_184 == 64'h80006057
| _T_184 == 64'h8C006057
| _T_184 == 64'h88006057
| _T_184 == 64'hA4006057
| _T_184 == 64'hAC006057
| _T_184 == 64'hB4006057
| _T_184 == 64'hBC006057
| _T_191 == 64'h42006057
| _T_184 == 64'h24006057
| _T_184 == 64'h2C006057
| _T_184 == 64'h20006057
| _T_184 == 64'h28006057
| _T_184 == 64'h84004057
| _T_184 == 64'h8C004057
| _T_184 == 64'h80004057
| _T_184 == 64'h88004057
| _T_184 == 64'h9C004057
| _T_184 == 64'hA8004057
| _T_184 == 64'hAC004057
| _T_184 == 64'hBC004057
| _T_184 == 64'hB8004057
| _T_184 == 64'h38005057
| _T_184 == 64'h3C005057
| _T_184 == 64'h20005057
| _T_184 == 64'h24005057
| _T_184 == 64'h28005057
| _T_184 == 64'h10005057
| _T_184 == 64'h18005057
| _T_184 == 64'h60005057
| _T_184 == 64'h64005057
| _T_184 == 64'h6C005057
| _T_184 == 64'h70005057
| _T_184 == 64'h74005057
| _T_184 == 64'h7C005057
| _T_183 == 64'h5C005057
| _T_191 == 64'h5E005057
| _T_184 == 64'h90005057
| _T_184 == 64'h5057
| _T_184 == 64'h8005057
| _T_184 == 64'h9C005057
| _T_184 == 64'h80005057
| _T_184 == 64'h84005057
| _T_184 == 64'hB0005057
| _T_184 == 64'hB4005057
| _T_184 == 64'hB8005057
| _T_184 == 64'hBC005057
| _T_184 == 64'hA0005057
| _T_184 == 64'hA4005057
| _T_184 == 64'hA8005057
| _T_184 == 64'hAC005057
| _T_191 == 64'h42005057
| _T_184 == 64'hC0005057
| _T_184 == 64'hC8005057
| _T_184 == 64'hE0005057
| _T_184 == 64'hD0005057
| _T_184 == 64'hD8005057
| _T_184 == 64'hF0005057
| _T_184 == 64'hF4005057
| _T_184 == 64'hF8005057
| _T_184 == 64'hFC005057
| _T_195 == 64'h42002057
| _T_194 == 64'h40082057
| _T_194 == 64'h4008A057
| _T_195 == 64'h42001057 : _T_180 ? _T_343 : _T_345 ? _T_343 : _T_344 ? ((_T_249 ? 1'h1 : _T_248 ? 1'h1 : _T_247 ? 1'h1 : _T_246 ? 1'h1 : _T_245 ? |{_T_223, _T_207} : _T_244 ? 1'h1 : _T_243 ? _T_209 : 1'h1) == 1'h0 ? 1'h0 : _T_277 == 32'h63
| _T_277 == 32'h1063
| _T_277 == 32'h4063
| _T_277 == 32'h6063
| _T_277 == 32'h5063
| _T_277 == 32'h7063
| _T_278 == 32'h6F
| _T_277 == 32'h67
| _T_277 == 32'h3
| _T_277 == 32'h4003
| _T_277 == 32'h1003
| _T_277 == 32'h5003
| _T_277 == 32'h2003
| _T_277 == 32'h6003
| _T_277 == 32'h3003
| _T_277 == 32'h23
| _T_277 == 32'h1023
| _T_277 == 32'h2023
| _T_277 == 32'h3023
| _T_278 == 32'h37
| _T_278 == 32'h17
| _T_277 == 32'h13
| _T_277 == 32'h2013
| _T_277 == 32'h3013
| _T_277 == 32'h7013
| _T_277 == 32'h6013
| _T_277 == 32'h4013
| _T_277 == 32'h1B
| _T_279 == 32'h101B
| _T_279 == 32'h501B
| _T_279 == 32'h4000501B
| _T_280 == 32'h1013
| _T_280 == 32'h5013
| _T_280 == 32'h40005013
| _T_279 == 32'h33
| _T_279 == 32'h40000033
| _T_279 == 32'h2033
| _T_279 == 32'h3033
| _T_279 == 32'h7033
| _T_279 == 32'h6033
| _T_279 == 32'h4033
| _T_279 == 32'h1033
| _T_279 == 32'h5033
| _T_279 == 32'h40005033
| _T_279 == 32'h3B
| _T_279 == 32'h4000003B
| _T_279 == 32'h103B
| _T_279 == 32'h503B
| _T_279 == 32'h4000503B
| _T_277 == 32'hF
| _T_277 == 32'h100F
| (_T_276 & 32'hFE007FFF) == 32'h12000073
| _T_276 == 32'hFC000073
| _T_276 == 32'hFC200073
| _T_277 == 32'h5073
| _T_277 == 32'h6073
| _T_277 == 32'h7073
| _T_276 == 32'h73
| _T_276 == 32'h100073
| _T_276 == 32'h30200073
| _T_276 == 32'h10500073
| _T_276 == 32'h30500073
| _T_277 == 32'h1073
| _T_277 == 32'h2073
| _T_277 == 32'h3073
| _T_276 == 32'h10200073
| _T_276 == 32'h7B200073
| _T_279 == 32'h2000033
| _T_279 == 32'h2001033
| _T_279 == 32'h2003033
| _T_279 == 32'h2002033
| _T_279 == 32'h200003B
| _T_279 == 32'h2004033
| _T_279 == 32'h2005033
| _T_279 == 32'h2006033
| _T_279 == 32'h2007033
| _T_279 == 32'h200403B
| _T_279 == 32'h200503B
| _T_279 == 32'h200603B
| _T_279 == 32'h200703B
| _T_281 == 32'h202F
| _T_281 == 32'h6000202F
| _T_281 == 32'h4000202F
| _T_281 == 32'h2000202F
| _T_281 == 32'h8000202F
| _T_281 == 32'hA000202F
| _T_281 == 32'hC000202F
| _T_281 == 32'hE000202F
| _T_281 == 32'h800202F
| _T_281 == 32'h302F
| _T_281 == 32'h6000302F
| _T_281 == 32'h4000302F
| _T_281 == 32'h2000302F
| _T_281 == 32'h8000302F
| _T_281 == 32'hA000302F
| _T_281 == 32'hC000302F
| _T_281 == 32'hE000302F
| _T_281 == 32'h800302F
| _T_282 == 32'h1000202F
| _T_281 == 32'h1800202F
| _T_282 == 32'h1000302F
| _T_281 == 32'h1800302F
| _T_277 == 32'h1027
| _T_277 == 32'h2027
| _T_277 == 32'h3027
| _T_277 == 32'h1007
| _T_277 == 32'h2007
| _T_277 == 32'h3007
| _T_283 == 32'h4000043
| _T_283 == 32'h4000047
| _T_283 == 32'h400004B
| _T_283 == 32'h400004F
| _T_283 == 32'h43
| _T_283 == 32'h47
| _T_283 == 32'h4B
| _T_283 == 32'h4F
| _T_283 == 32'h2000043
| _T_283 == 32'h2000047
| _T_283 == 32'h200004B
| _T_283 == 32'h200004F
| _T_284 == 32'h4000053
| _T_284 == 32'hC000053
| _T_284 == 32'h14000053
| _T_284 == 32'h1C000053
| _T_279 == 32'h24000053
| _T_279 == 32'h24001053
| _T_279 == 32'h24002053
| _T_279 == 32'h2C000053
| _T_279 == 32'h2C001053
| _T_284 == 32'h53
| _T_284 == 32'h8000053
| _T_284 == 32'h10000053
| _T_284 == 32'h18000053
| _T_279 == 32'h20000053
| _T_279 == 32'h20001053
| _T_279 == 32'h20002053
| _T_279 == 32'h28000053
| _T_279 == 32'h28001053
| _T_284 == 32'h2000053
| _T_284 == 32'hA000053
| _T_284 == 32'h12000053
| _T_284 == 32'h1A000053
| _T_279 == 32'h22000053
| _T_279 == 32'h22001053
| _T_279 == 32'h22002053
| _T_279 == 32'h2A000053
| _T_279 == 32'h2A001053
| _T_285 == 32'h5C000053
| _T_285 == 32'h44000053
| _T_285 == 32'h40200053
| _T_285 == 32'h58000053
| _T_285 == 32'h5A000053
| _T_285 == 32'h40100053
| _T_285 == 32'h42000053
| _T_285 == 32'h44100053
| _T_285 == 32'h42200053
| _T_279 == 32'hA4002053
| _T_279 == 32'hA4001053
| _T_279 == 32'hA4000053
| _T_279 == 32'hA0002053
| _T_279 == 32'hA0001053
| _T_279 == 32'hA0000053
| _T_279 == 32'hA2002053
| _T_279 == 32'hA2001053
| _T_279 == 32'hA2000053
| _T_285 == 32'hC4000053
| _T_285 == 32'hC4100053
| _T_286 == 32'hE4001053
| _T_285 == 32'hC4200053
| _T_285 == 32'hC4300053
| _T_285 == 32'hC0000053
| _T_285 == 32'hC0100053
| _T_286 == 32'hE0001053
| _T_285 == 32'hC0200053
| _T_285 == 32'hC0300053
| _T_285 == 32'hC2000053
| _T_285 == 32'hC2100053
| _T_286 == 32'hE2001053
| _T_285 == 32'hC2200053
| _T_285 == 32'hC2300053
| _T_286 == 32'hE4000053
| _T_286 == 32'hE0000053
| _T_286 == 32'hE2000053
| _T_286 == 32'hF4000053
| _T_286 == 32'hF0000053
| _T_286 == 32'hF2000053
| _T_285 == 32'hD4000053
| _T_285 == 32'hD4100053
| _T_285 == 32'hD4200053
| _T_285 == 32'hD4300053
| _T_285 == 32'hD0000053
| _T_285 == 32'hD0100053
| _T_285 == 32'hD0200053
| _T_285 == 32'hD0300053
| _T_285 == 32'hD2000053
| _T_285 == 32'hD2100053
| _T_285 == 32'hD2200053
| _T_285 == 32'hD2300053
| _T_279 == 32'h80007057
| (_T_276 & 32'h8000707F) == 32'h7057
| _T_287 == 32'h7
| _T_287 == 32'h5007
| _T_287 == 32'h6007
| _T_287 == 32'h7007
| _T_287 == 32'h1000007
| _T_287 == 32'h1005007
| _T_287 == 32'h1006007
| _T_287 == 32'h1007007
| _T_288 == 32'hC000007
| _T_288 == 32'hC005007
| _T_288 == 32'hC006007
| _T_286 == 32'h2800007
| _T_286 == 32'h2805007
| _T_286 == 32'h2806007
| _T_286 == 32'h2807007
| _T_286 == 32'h22800007
| _T_286 == 32'h22805007
| _T_286 == 32'h22806007
| _T_286 == 32'h22807007
| _T_286 == 32'h62800007
| _T_286 == 32'h62805007
| _T_286 == 32'h62806007
| _T_286 == 32'h62807007
| _T_286 == 32'hE2800007
| _T_286 == 32'hE2805007
| _T_286 == 32'hE2806007
| _T_286 == 32'hE2807007
| _T_288 == 32'hC007007
| _T_287 == 32'h27
| _T_287 == 32'h5027
| _T_287 == 32'h6027
| _T_287 == 32'h7027
| _T_288 == 32'hC000027
| _T_288 == 32'hC005027
| _T_288 == 32'hC006027
| _T_280 == 32'h4000027
| _T_280 == 32'h4005027
| _T_280 == 32'h4006027
| _T_286 == 32'h2800027
| _T_286 == 32'h22800027
| _T_286 == 32'h62800027
| _T_286 == 32'hE2800027
| _T_288 == 32'hC007027
| _T_280 == 32'h4007027
| _T_281 == 32'h800002F
| _T_281 == 32'h2F
| _T_281 == 32'h2000002F
| _T_281 == 32'h6000002F
| _T_281 == 32'h4000002F
| _T_281 == 32'h8000002F
| _T_281 == 32'hA000002F
| _T_281 == 32'hC000002F
| _T_281 == 32'hE000002F
| _T_281 == 32'h800502F
| _T_281 == 32'h502F
| _T_281 == 32'h2000502F
| _T_281 == 32'h6000502F
| _T_281 == 32'h4000502F
| _T_281 == 32'h8000502F
| _T_281 == 32'hA000502F
| _T_281 == 32'hC000502F
| _T_281 == 32'hE000502F
| _T_281 == 32'h800602F
| _T_281 == 32'h602F
| _T_281 == 32'h2000602F
| _T_281 == 32'h6000602F
| _T_281 == 32'h4000602F
| _T_281 == 32'h8000602F
| _T_281 == 32'hA000602F
| _T_281 == 32'hC000602F
| _T_281 == 32'hE000602F
| _T_281 == 32'h800702F
| _T_281 == 32'h702F
| _T_281 == 32'h2000702F
| _T_281 == 32'h6000702F
| _T_281 == 32'h4000702F
| _T_281 == 32'h8000702F
| _T_281 == 32'hA000702F
| _T_281 == 32'hC000702F
| _T_281 == 32'hE000702F
| _T_288 == 32'h8000007
| _T_288 == 32'h8005007
| _T_288 == 32'h8006007
| _T_288 == 32'h8007007
| _T_288 == 32'h8000027
| _T_288 == 32'h8005027
| _T_288 == 32'h8006027
| _T_288 == 32'h8007027
| _T_280 == 32'h2057
| _T_280 == 32'hC4000057
| _T_280 == 32'hC0000057
| _T_280 == 32'h4002057
| _T_280 == 32'h8002057
| _T_280 == 32'hC002057
| _T_280 == 32'h10002057
| _T_280 == 32'h14002057
| _T_280 == 32'h18002057
| _T_280 == 32'h1C002057
| _T_280 == 32'h57
| _T_280 == 32'h8000057
| _T_279 == 32'h40000057
| _T_280 == 32'h44000057
| _T_279 == 32'h48000057
| _T_280 == 32'h4C000057
| _T_280 == 32'h94000057
| _T_280 == 32'hA0000057
| _T_280 == 32'hA4000057
| _T_280 == 32'hB0000057
| _T_280 == 32'hB4000057
| _T_280 == 32'h24000057
| _T_280 == 32'h28000057
| _T_280 == 32'h2C000057
| _T_280 == 32'h60000057
| _T_280 == 32'h64000057
| _T_280 == 32'h6C000057
| _T_280 == 32'h68000057
| _T_280 == 32'h70000057
| _T_280 == 32'h74000057
| _T_280 == 32'h10000057
| _T_280 == 32'h14000057
| _T_280 == 32'h18000057
| _T_280 == 32'h1C000057
| _T_280 == 32'h30000057
| _T_280 == 32'h38000057
| _T_279 == 32'h5E002057
| _T_279 == 32'h5C000057
| _T_286 == 32'h5E000057
| _T_280 == 32'h60002057
| _T_280 == 32'h64002057
| _T_280 == 32'h68002057
| _T_280 == 32'h6C002057
| _T_280 == 32'h70002057
| _T_280 == 32'h74002057
| _T_280 == 32'h78002057
| _T_280 == 32'h7C002057
| _T_289 == 32'h5000A057
| _T_289 == 32'h50012057
| _T_289 == 32'h5001A057
| _T_289 == 32'h50082057
| (_T_276 & 32'hFDFFF07F) == 32'h5008A057
| _T_289 == 32'h48032057
| _T_289 == 32'h4803A057
| _T_289 == 32'h48022057
| _T_289 == 32'h4802A057
| _T_289 == 32'h48012057
| _T_289 == 32'h4801A057
| _T_280 == 32'hC4002057
| _T_280 == 32'hC0002057
| _T_280 == 32'hCC002057
| _T_280 == 32'hC8002057
| _T_280 == 32'hD4002057
| _T_280 == 32'hD0002057
| _T_280 == 32'hDC002057
| _T_280 == 32'hD8002057
| _T_280 == 32'hEC002057
| _T_280 == 32'hE0002057
| _T_280 == 32'hE8002057
| _T_280 == 32'hF0002057
| _T_280 == 32'hF4002057
| _T_280 == 32'hFC002057
| _T_280 == 32'h94002057
| _T_280 == 32'h9C002057
| _T_280 == 32'h90002057
| _T_280 == 32'h98002057
| _T_280 == 32'h84002057
| _T_280 == 32'h80002057
| _T_280 == 32'h8C002057
| _T_280 == 32'h88002057
| _T_280 == 32'hA4002057
| _T_280 == 32'hAC002057
| _T_280 == 32'hB4002057
| _T_280 == 32'hBC002057
| _T_280 == 32'h24002057
| _T_280 == 32'h2C002057
| _T_280 == 32'h20002057
| _T_280 == 32'h28002057
| _T_280 == 32'h84000057
| _T_280 == 32'h8C000057
| _T_280 == 32'h80000057
| _T_280 == 32'h88000057
| _T_280 == 32'h9C000057
| _T_280 == 32'hA8000057
| _T_280 == 32'hAC000057
| _T_280 == 32'hBC000057
| _T_280 == 32'hB8000057
| _T_280 == 32'h4001057
| _T_280 == 32'hC4001057
| _T_280 == 32'hC001057
| _T_280 == 32'hCC001057
| _T_280 == 32'h14001057
| _T_280 == 32'h1C001057
| _T_289 == 32'h4C081057
| _T_280 == 32'h10001057
| _T_280 == 32'h18001057
| _T_280 == 32'h60001057
| _T_280 == 32'h64001057
| _T_280 == 32'h6C001057
| _T_280 == 32'h70001057
| _T_289 == 32'h48011057
| _T_289 == 32'h48019057
| _T_289 == 32'h48091057
| _T_289 == 32'h48099057
| _T_289 == 32'h480B1057
| _T_289 == 32'h480B9057
| _T_289 == 32'h48081057
| _T_289 == 32'h48089057
| _T_289 == 32'h48051057
| _T_289 == 32'h48059057
| _T_289 == 32'h48071057
| _T_289 == 32'h48079057
| _T_289 == 32'h48041057
| _T_289 == 32'h48049057
| _T_289 == 32'h48031057
| _T_289 == 32'h48039057
| _T_289 == 32'h48001057
| _T_289 == 32'h48009057
| _T_280 == 32'h90001057
| _T_280 == 32'h1057
| _T_280 == 32'h8001057
| _T_289 == 32'h4C001057
| _T_280 == 32'h80001057
| _T_289 == 32'h4C021057
| _T_289 == 32'h4C029057
| _T_280 == 32'hB0001057
| _T_280 == 32'hB4001057
| _T_280 == 32'hB8001057
| _T_280 == 32'hBC001057
| _T_280 == 32'hA0001057
| _T_280 == 32'hA4001057
| _T_280 == 32'hA8001057
| _T_280 == 32'hAC001057
| _T_280 == 32'h20001057
| _T_280 == 32'h24001057
| _T_280 == 32'h28001057
| _T_289 == 32'h480A1057
| _T_289 == 32'h480A9057
| _T_289 == 32'h48061057
| _T_280 == 32'hC0001057
| _T_280 == 32'hC8001057
| _T_280 == 32'hE0001057
| _T_280 == 32'hD0001057
| _T_280 == 32'hD8001057
| _T_280 == 32'hF0001057
| _T_280 == 32'hF4001057
| _T_280 == 32'hF8001057
| _T_280 == 32'hFC001057
| _T_280 == 32'h3057
| _T_279 == 32'h40003057
| _T_280 == 32'h44003057
| _T_280 == 32'hC003057
| _T_280 == 32'h94003057
| _T_280 == 32'hA0003057
| _T_280 == 32'hA4003057
| _T_280 == 32'hB0003057
| _T_280 == 32'hB4003057
| _T_280 == 32'h24003057
| _T_280 == 32'h28003057
| _T_280 == 32'h2C003057
| _T_279 == 32'h9E003057
| _T_280 == 32'h38003057
| _T_280 == 32'h3C003057
| _T_280 == 32'h60003057
| _T_280 == 32'h64003057
| _T_280 == 32'h70003057
| _T_280 == 32'h74003057
| _T_280 == 32'h78003057
| _T_280 == 32'h7C003057
| _T_280 == 32'h30003057
| _T_279 == 32'h5C003057
| _T_286 == 32'h5E003057
| _T_280 == 32'h84003057
| _T_280 == 32'h80003057
| _T_280 == 32'hA8003057
| _T_280 == 32'hAC003057
| _T_280 == 32'hBC003057
| _T_280 == 32'hB8003057
| _T_280 == 32'h4057
| _T_280 == 32'h8004057
| _T_279 == 32'h40004057
| _T_280 == 32'h44004057
| _T_279 == 32'h48004057
| _T_280 == 32'h4C004057
| _T_280 == 32'hC004057
| _T_280 == 32'h94004057
| _T_280 == 32'hA0004057
| _T_280 == 32'hA4004057
| _T_280 == 32'hB0004057
| _T_280 == 32'hB4004057
| _T_280 == 32'h24004057
| _T_280 == 32'h28004057
| _T_280 == 32'h2C004057
| _T_280 == 32'h38004057
| _T_280 == 32'h3C004057
| _T_280 == 32'h38006057
| _T_280 == 32'h3C006057
| _T_280 == 32'h60004057
| _T_280 == 32'h64004057
| _T_280 == 32'h6C004057
| _T_280 == 32'h68004057
| _T_280 == 32'h70004057
| _T_280 == 32'h74004057
| _T_280 == 32'h78004057
| _T_280 == 32'h7C004057
| _T_280 == 32'h10004057
| _T_280 == 32'h14004057
| _T_280 == 32'h18004057
| _T_280 == 32'h1C004057
| _T_280 == 32'h30004057
| _T_279 == 32'h5C004057
| _T_286 == 32'h5E004057
| _T_280 == 32'hC4006057
| _T_280 == 32'hC0006057
| _T_280 == 32'hCC006057
| _T_280 == 32'hC8006057
| _T_280 == 32'hD4006057
| _T_280 == 32'hD0006057
| _T_280 == 32'hDC006057
| _T_280 == 32'hD8006057
| _T_280 == 32'hEC006057
| _T_280 == 32'hE0006057
| _T_280 == 32'hE8006057
| _T_280 == 32'hF0006057
| _T_280 == 32'hF4006057
| _T_280 == 32'hFC006057
| _T_280 == 32'hF8006057
| _T_280 == 32'h94006057
| _T_280 == 32'h9C006057
| _T_280 == 32'h90006057
| _T_280 == 32'h98006057
| _T_280 == 32'h84006057
| _T_280 == 32'h80006057
| _T_280 == 32'h8C006057
| _T_280 == 32'h88006057
| _T_280 == 32'hA4006057
| _T_280 == 32'hAC006057
| _T_280 == 32'hB4006057
| _T_280 == 32'hBC006057
| _T_286 == 32'h42006057
| _T_280 == 32'h24006057
| _T_280 == 32'h2C006057
| _T_280 == 32'h20006057
| _T_280 == 32'h28006057
| _T_280 == 32'h84004057
| _T_280 == 32'h8C004057
| _T_280 == 32'h80004057
| _T_280 == 32'h88004057
| _T_280 == 32'h9C004057
| _T_280 == 32'hA8004057
| _T_280 == 32'hAC004057
| _T_280 == 32'hBC004057
| _T_280 == 32'hB8004057
| _T_280 == 32'h38005057
| _T_280 == 32'h3C005057
| _T_280 == 32'h20005057
| _T_280 == 32'h24005057
| _T_280 == 32'h28005057
| _T_280 == 32'h10005057
| _T_280 == 32'h18005057
| _T_280 == 32'h60005057
| _T_280 == 32'h64005057
| _T_280 == 32'h6C005057
| _T_280 == 32'h70005057
| _T_280 == 32'h74005057
| _T_280 == 32'h7C005057
| _T_279 == 32'h5C005057
| _T_286 == 32'h5E005057
| _T_280 == 32'h90005057
| _T_280 == 32'h5057
| _T_280 == 32'h8005057
| _T_280 == 32'h9C005057
| _T_280 == 32'h80005057
| _T_280 == 32'h84005057
| _T_280 == 32'hB0005057
| _T_280 == 32'hB4005057
| _T_280 == 32'hB8005057
| _T_280 == 32'hBC005057
| _T_280 == 32'hA0005057
| _T_280 == 32'hA4005057
| _T_280 == 32'hA8005057
| _T_280 == 32'hAC005057
| _T_286 == 32'h42005057
| _T_280 == 32'hC0005057
| _T_280 == 32'hC8005057
| _T_280 == 32'hE0005057
| _T_280 == 32'hD0005057
| _T_280 == 32'hD8005057
| _T_280 == 32'hF0005057
| _T_280 == 32'hF4005057
| _T_280 == 32'hF8005057
| _T_280 == 32'hFC005057
| _T_290 == 32'h42002057
| _T_289 == 32'h40082057
| _T_289 == 32'h4008A057
| _T_290 == 32'h42001057) : (_T_249 ? 1'h1 : _T_248 ? 1'h1 : _T_247 ? 1'h1 : _T_246 ? 1'h1 : _T_245 ? 1'h1 : _T_244 ? 1'h1 : _T_243 ? 1'h1 : |io_fetch_bits_data[12:5]) == 1'h0 ? 1'h0 : _T_251 == 32'h63
| _T_251 == 32'h1063
| _T_251 == 32'h4063
| _T_251 == 32'h6063
| _T_251 == 32'h5063
| _T_251 == 32'h7063
| _T_252 == 32'h6F
| _T_251 == 32'h67
| _T_251 == 32'h3
| _T_251 == 32'h4003
| _T_251 == 32'h1003
| _T_251 == 32'h5003
| _T_251 == 32'h2003
| _T_251 == 32'h6003
| _T_251 == 32'h3003
| _T_251 == 32'h23
| _T_251 == 32'h1023
| _T_251 == 32'h2023
| _T_251 == 32'h3023
| _T_252 == 32'h37
| _T_252 == 32'h17
| _T_251 == 32'h13
| _T_251 == 32'h2013
| _T_251 == 32'h3013
| _T_251 == 32'h7013
| _T_251 == 32'h6013
| _T_251 == 32'h4013
| _T_251 == 32'h1B
| _T_253 == 32'h101B
| _T_253 == 32'h501B
| _T_253 == 32'h4000501B
| _T_254 == 32'h1013
| _T_254 == 32'h5013
| _T_254 == 32'h40005013
| _T_253 == 32'h33
| _T_253 == 32'h40000033
| _T_253 == 32'h2033
| _T_253 == 32'h3033
| _T_253 == 32'h7033
| _T_253 == 32'h6033
| _T_253 == 32'h4033
| _T_253 == 32'h1033
| _T_253 == 32'h5033
| _T_253 == 32'h40005033
| _T_253 == 32'h3B
| _T_253 == 32'h4000003B
| _T_253 == 32'h103B
| _T_253 == 32'h503B
| _T_253 == 32'h4000503B
| _T_251 == 32'hF
| _T_251 == 32'h100F
| (_T_250 & 32'hFE007FFF) == 32'h12000073
| _T_250 == 32'hFC000073
| _T_250 == 32'hFC200073
| _T_251 == 32'h5073
| _T_251 == 32'h6073
| _T_251 == 32'h7073
| _T_250 == 32'h73
| _T_250 == 32'h100073
| _T_250 == 32'h30200073
| _T_250 == 32'h10500073
| _T_250 == 32'h30500073
| _T_251 == 32'h1073
| _T_251 == 32'h2073
| _T_251 == 32'h3073
| _T_250 == 32'h10200073
| _T_250 == 32'h7B200073
| _T_253 == 32'h2000033
| _T_253 == 32'h2001033
| _T_253 == 32'h2003033
| _T_253 == 32'h2002033
| _T_253 == 32'h200003B
| _T_253 == 32'h2004033
| _T_253 == 32'h2005033
| _T_253 == 32'h2006033
| _T_253 == 32'h2007033
| _T_253 == 32'h200403B
| _T_253 == 32'h200503B
| _T_253 == 32'h200603B
| _T_253 == 32'h200703B
| _T_255 == 32'h202F
| _T_255 == 32'h6000202F
| _T_255 == 32'h4000202F
| _T_255 == 32'h2000202F
| _T_255 == 32'h8000202F
| _T_255 == 32'hA000202F
| _T_255 == 32'hC000202F
| _T_255 == 32'hE000202F
| _T_255 == 32'h800202F
| _T_255 == 32'h302F
| _T_255 == 32'h6000302F
| _T_255 == 32'h4000302F
| _T_255 == 32'h2000302F
| _T_255 == 32'h8000302F
| _T_255 == 32'hA000302F
| _T_255 == 32'hC000302F
| _T_255 == 32'hE000302F
| _T_255 == 32'h800302F
| _T_256 == 32'h1000202F
| _T_255 == 32'h1800202F
| _T_256 == 32'h1000302F
| _T_255 == 32'h1800302F
| _T_251 == 32'h1027
| _T_251 == 32'h2027
| _T_251 == 32'h3027
| _T_251 == 32'h1007
| _T_251 == 32'h2007
| _T_251 == 32'h3007
| _T_257 == 32'h4000043
| _T_257 == 32'h4000047
| _T_257 == 32'h400004B
| _T_257 == 32'h400004F
| _T_257 == 32'h43
| _T_257 == 32'h47
| _T_257 == 32'h4B
| _T_257 == 32'h4F
| _T_257 == 32'h2000043
| _T_257 == 32'h2000047
| _T_257 == 32'h200004B
| _T_257 == 32'h200004F
| _T_258 == 32'h4000053
| _T_258 == 32'hC000053
| _T_258 == 32'h14000053
| _T_258 == 32'h1C000053
| _T_253 == 32'h24000053
| _T_253 == 32'h24001053
| _T_253 == 32'h24002053
| _T_253 == 32'h2C000053
| _T_253 == 32'h2C001053
| _T_258 == 32'h53
| _T_258 == 32'h8000053
| _T_258 == 32'h10000053
| _T_258 == 32'h18000053
| _T_253 == 32'h20000053
| _T_253 == 32'h20001053
| _T_253 == 32'h20002053
| _T_253 == 32'h28000053
| _T_253 == 32'h28001053
| _T_258 == 32'h2000053
| _T_258 == 32'hA000053
| _T_258 == 32'h12000053
| _T_258 == 32'h1A000053
| _T_253 == 32'h22000053
| _T_253 == 32'h22001053
| _T_253 == 32'h22002053
| _T_253 == 32'h2A000053
| _T_253 == 32'h2A001053
| _T_259 == 32'h5C000053
| _T_259 == 32'h44000053
| _T_259 == 32'h40200053
| _T_259 == 32'h58000053
| _T_259 == 32'h5A000053
| _T_259 == 32'h40100053
| _T_259 == 32'h42000053
| _T_259 == 32'h44100053
| _T_259 == 32'h42200053
| _T_253 == 32'hA4002053
| _T_253 == 32'hA4001053
| _T_253 == 32'hA4000053
| _T_253 == 32'hA0002053
| _T_253 == 32'hA0001053
| _T_253 == 32'hA0000053
| _T_253 == 32'hA2002053
| _T_253 == 32'hA2001053
| _T_253 == 32'hA2000053
| _T_259 == 32'hC4000053
| _T_259 == 32'hC4100053
| _T_260 == 32'hE4001053
| _T_259 == 32'hC4200053
| _T_259 == 32'hC4300053
| _T_259 == 32'hC0000053
| _T_259 == 32'hC0100053
| _T_260 == 32'hE0001053
| _T_259 == 32'hC0200053
| _T_259 == 32'hC0300053
| _T_259 == 32'hC2000053
| _T_259 == 32'hC2100053
| _T_260 == 32'hE2001053
| _T_259 == 32'hC2200053
| _T_259 == 32'hC2300053
| _T_260 == 32'hE4000053
| _T_260 == 32'hE0000053
| _T_260 == 32'hE2000053
| _T_260 == 32'hF4000053
| _T_260 == 32'hF0000053
| _T_260 == 32'hF2000053
| _T_259 == 32'hD4000053
| _T_259 == 32'hD4100053
| _T_259 == 32'hD4200053
| _T_259 == 32'hD4300053
| _T_259 == 32'hD0000053
| _T_259 == 32'hD0100053
| _T_259 == 32'hD0200053
| _T_259 == 32'hD0300053
| _T_259 == 32'hD2000053
| _T_259 == 32'hD2100053
| _T_259 == 32'hD2200053
| _T_259 == 32'hD2300053
| _T_253 == 32'h80007057
| (_T_250 & 32'h8000707F) == 32'h7057
| _T_261 == 32'h7
| _T_261 == 32'h5007
| _T_261 == 32'h6007
| _T_261 == 32'h7007
| _T_261 == 32'h1000007
| _T_261 == 32'h1005007
| _T_261 == 32'h1006007
| _T_261 == 32'h1007007
| _T_262 == 32'hC000007
| _T_262 == 32'hC005007
| _T_262 == 32'hC006007
| _T_260 == 32'h2800007
| _T_260 == 32'h2805007
| _T_260 == 32'h2806007
| _T_260 == 32'h2807007
| _T_260 == 32'h22800007
| _T_260 == 32'h22805007
| _T_260 == 32'h22806007
| _T_260 == 32'h22807007
| _T_260 == 32'h62800007
| _T_260 == 32'h62805007
| _T_260 == 32'h62806007
| _T_260 == 32'h62807007
| _T_260 == 32'hE2800007
| _T_260 == 32'hE2805007
| _T_260 == 32'hE2806007
| _T_260 == 32'hE2807007
| _T_262 == 32'hC007007
| _T_261 == 32'h27
| _T_261 == 32'h5027
| _T_261 == 32'h6027
| _T_261 == 32'h7027
| _T_262 == 32'hC000027
| _T_262 == 32'hC005027
| _T_262 == 32'hC006027
| _T_254 == 32'h4000027
| _T_254 == 32'h4005027
| _T_254 == 32'h4006027
| _T_260 == 32'h2800027
| _T_260 == 32'h22800027
| _T_260 == 32'h62800027
| _T_260 == 32'hE2800027
| _T_262 == 32'hC007027
| _T_254 == 32'h4007027
| _T_255 == 32'h800002F
| _T_255 == 32'h2F
| _T_255 == 32'h2000002F
| _T_255 == 32'h6000002F
| _T_255 == 32'h4000002F
| _T_255 == 32'h8000002F
| _T_255 == 32'hA000002F
| _T_255 == 32'hC000002F
| _T_255 == 32'hE000002F
| _T_255 == 32'h800502F
| _T_255 == 32'h502F
| _T_255 == 32'h2000502F
| _T_255 == 32'h6000502F
| _T_255 == 32'h4000502F
| _T_255 == 32'h8000502F
| _T_255 == 32'hA000502F
| _T_255 == 32'hC000502F
| _T_255 == 32'hE000502F
| _T_255 == 32'h800602F
| _T_255 == 32'h602F
| _T_255 == 32'h2000602F
| _T_255 == 32'h6000602F
| _T_255 == 32'h4000602F
| _T_255 == 32'h8000602F
| _T_255 == 32'hA000602F
| _T_255 == 32'hC000602F
| _T_255 == 32'hE000602F
| _T_255 == 32'h800702F
| _T_255 == 32'h702F
| _T_255 == 32'h2000702F
| _T_255 == 32'h6000702F
| _T_255 == 32'h4000702F
| _T_255 == 32'h8000702F
| _T_255 == 32'hA000702F
| _T_255 == 32'hC000702F
| _T_255 == 32'hE000702F
| _T_262 == 32'h8000007
| _T_262 == 32'h8005007
| _T_262 == 32'h8006007
| _T_262 == 32'h8007007
| _T_262 == 32'h8000027
| _T_262 == 32'h8005027
| _T_262 == 32'h8006027
| _T_262 == 32'h8007027
| _T_254 == 32'h2057
| _T_254 == 32'hC4000057
| _T_254 == 32'hC0000057
| _T_254 == 32'h4002057
| _T_254 == 32'h8002057
| _T_254 == 32'hC002057
| _T_254 == 32'h10002057
| _T_254 == 32'h14002057
| _T_254 == 32'h18002057
| _T_254 == 32'h1C002057
| _T_254 == 32'h57
| _T_254 == 32'h8000057
| _T_253 == 32'h40000057
| _T_254 == 32'h44000057
| _T_253 == 32'h48000057
| _T_254 == 32'h4C000057
| _T_254 == 32'h94000057
| _T_254 == 32'hA0000057
| _T_254 == 32'hA4000057
| _T_254 == 32'hB0000057
| _T_254 == 32'hB4000057
| _T_254 == 32'h24000057
| _T_254 == 32'h28000057
| _T_254 == 32'h2C000057
| _T_254 == 32'h60000057
| _T_254 == 32'h64000057
| _T_254 == 32'h6C000057
| _T_254 == 32'h68000057
| _T_254 == 32'h70000057
| _T_254 == 32'h74000057
| _T_254 == 32'h10000057
| _T_254 == 32'h14000057
| _T_254 == 32'h18000057
| _T_254 == 32'h1C000057
| _T_254 == 32'h30000057
| _T_254 == 32'h38000057
| _T_253 == 32'h5E002057
| _T_253 == 32'h5C000057
| _T_260 == 32'h5E000057
| _T_254 == 32'h60002057
| _T_254 == 32'h64002057
| _T_254 == 32'h68002057
| _T_254 == 32'h6C002057
| _T_254 == 32'h70002057
| _T_254 == 32'h74002057
| _T_254 == 32'h78002057
| _T_254 == 32'h7C002057
| _T_263 == 32'h5000A057
| _T_263 == 32'h50012057
| _T_263 == 32'h5001A057
| _T_263 == 32'h50082057
| (_T_250 & 32'hFDFFF07F) == 32'h5008A057
| _T_263 == 32'h48032057
| _T_263 == 32'h4803A057
| _T_263 == 32'h48022057
| _T_263 == 32'h4802A057
| _T_263 == 32'h48012057
| _T_263 == 32'h4801A057
| _T_254 == 32'hC4002057
| _T_254 == 32'hC0002057
| _T_254 == 32'hCC002057
| _T_254 == 32'hC8002057
| _T_254 == 32'hD4002057
| _T_254 == 32'hD0002057
| _T_254 == 32'hDC002057
| _T_254 == 32'hD8002057
| _T_254 == 32'hEC002057
| _T_254 == 32'hE0002057
| _T_254 == 32'hE8002057
| _T_254 == 32'hF0002057
| _T_254 == 32'hF4002057
| _T_254 == 32'hFC002057
| _T_254 == 32'h94002057
| _T_254 == 32'h9C002057
| _T_254 == 32'h90002057
| _T_254 == 32'h98002057
| _T_254 == 32'h84002057
| _T_254 == 32'h80002057
| _T_254 == 32'h8C002057
| _T_254 == 32'h88002057
| _T_254 == 32'hA4002057
| _T_254 == 32'hAC002057
| _T_254 == 32'hB4002057
| _T_254 == 32'hBC002057
| _T_254 == 32'h24002057
| _T_254 == 32'h2C002057
| _T_254 == 32'h20002057
| _T_254 == 32'h28002057
| _T_254 == 32'h84000057
| _T_254 == 32'h8C000057
| _T_254 == 32'h80000057
| _T_254 == 32'h88000057
| _T_254 == 32'h9C000057
| _T_254 == 32'hA8000057
| _T_254 == 32'hAC000057
| _T_254 == 32'hBC000057
| _T_254 == 32'hB8000057
| _T_254 == 32'h4001057
| _T_254 == 32'hC4001057
| _T_254 == 32'hC001057
| _T_254 == 32'hCC001057
| _T_254 == 32'h14001057
| _T_254 == 32'h1C001057
| _T_263 == 32'h4C081057
| _T_254 == 32'h10001057
| _T_254 == 32'h18001057
| _T_254 == 32'h60001057
| _T_254 == 32'h64001057
| _T_254 == 32'h6C001057
| _T_254 == 32'h70001057
| _T_263 == 32'h48011057
| _T_263 == 32'h48019057
| _T_263 == 32'h48091057
| _T_263 == 32'h48099057
| _T_263 == 32'h480B1057
| _T_263 == 32'h480B9057
| _T_263 == 32'h48081057
| _T_263 == 32'h48089057
| _T_263 == 32'h48051057
| _T_263 == 32'h48059057
| _T_263 == 32'h48071057
| _T_263 == 32'h48079057
| _T_263 == 32'h48041057
| _T_263 == 32'h48049057
| _T_263 == 32'h48031057
| _T_263 == 32'h48039057
| _T_263 == 32'h48001057
| _T_263 == 32'h48009057
| _T_254 == 32'h90001057
| _T_254 == 32'h1057
| _T_254 == 32'h8001057
| _T_263 == 32'h4C001057
| _T_254 == 32'h80001057
| _T_263 == 32'h4C021057
| _T_263 == 32'h4C029057
| _T_254 == 32'hB0001057
| _T_254 == 32'hB4001057
| _T_254 == 32'hB8001057
| _T_254 == 32'hBC001057
| _T_254 == 32'hA0001057
| _T_254 == 32'hA4001057
| _T_254 == 32'hA8001057
| _T_254 == 32'hAC001057
| _T_254 == 32'h20001057
| _T_254 == 32'h24001057
| _T_254 == 32'h28001057
| _T_263 == 32'h480A1057
| _T_263 == 32'h480A9057
| _T_263 == 32'h48061057
| _T_254 == 32'hC0001057
| _T_254 == 32'hC8001057
| _T_254 == 32'hE0001057
| _T_254 == 32'hD0001057
| _T_254 == 32'hD8001057
| _T_254 == 32'hF0001057
| _T_254 == 32'hF4001057
| _T_254 == 32'hF8001057
| _T_254 == 32'hFC001057
| _T_254 == 32'h3057
| _T_253 == 32'h40003057
| _T_254 == 32'h44003057
| _T_254 == 32'hC003057
| _T_254 == 32'h94003057
| _T_254 == 32'hA0003057
| _T_254 == 32'hA4003057
| _T_254 == 32'hB0003057
| _T_254 == 32'hB4003057
| _T_254 == 32'h24003057
| _T_254 == 32'h28003057
| _T_254 == 32'h2C003057
| _T_253 == 32'h9E003057
| _T_254 == 32'h38003057
| _T_254 == 32'h3C003057
| _T_254 == 32'h60003057
| _T_254 == 32'h64003057
| _T_254 == 32'h70003057
| _T_254 == 32'h74003057
| _T_254 == 32'h78003057
| _T_254 == 32'h7C003057
| _T_254 == 32'h30003057
| _T_253 == 32'h5C003057
| _T_260 == 32'h5E003057
| _T_254 == 32'h84003057
| _T_254 == 32'h80003057
| _T_254 == 32'hA8003057
| _T_254 == 32'hAC003057
| _T_254 == 32'hBC003057
| _T_254 == 32'hB8003057
| _T_254 == 32'h4057
| _T_254 == 32'h8004057
| _T_253 == 32'h40004057
| _T_254 == 32'h44004057
| _T_253 == 32'h48004057
| _T_254 == 32'h4C004057
| _T_254 == 32'hC004057
| _T_254 == 32'h94004057
| _T_254 == 32'hA0004057
| _T_254 == 32'hA4004057
| _T_254 == 32'hB0004057
| _T_254 == 32'hB4004057
| _T_254 == 32'h24004057
| _T_254 == 32'h28004057
| _T_254 == 32'h2C004057
| _T_254 == 32'h38004057
| _T_254 == 32'h3C004057
| _T_254 == 32'h38006057
| _T_254 == 32'h3C006057
| _T_254 == 32'h60004057
| _T_254 == 32'h64004057
| _T_254 == 32'h6C004057
| _T_254 == 32'h68004057
| _T_254 == 32'h70004057
| _T_254 == 32'h74004057
| _T_254 == 32'h78004057
| _T_254 == 32'h7C004057
| _T_254 == 32'h10004057
| _T_254 == 32'h14004057
| _T_254 == 32'h18004057
| _T_254 == 32'h1C004057
| _T_254 == 32'h30004057
| _T_253 == 32'h5C004057
| _T_260 == 32'h5E004057
| _T_254 == 32'hC4006057
| _T_254 == 32'hC0006057
| _T_254 == 32'hCC006057
| _T_254 == 32'hC8006057
| _T_254 == 32'hD4006057
| _T_254 == 32'hD0006057
| _T_254 == 32'hDC006057
| _T_254 == 32'hD8006057
| _T_254 == 32'hEC006057
| _T_254 == 32'hE0006057
| _T_254 == 32'hE8006057
| _T_254 == 32'hF0006057
| _T_254 == 32'hF4006057
| _T_254 == 32'hFC006057
| _T_254 == 32'hF8006057
| _T_254 == 32'h94006057
| _T_254 == 32'h9C006057
| _T_254 == 32'h90006057
| _T_254 == 32'h98006057
| _T_254 == 32'h84006057
| _T_254 == 32'h80006057
| _T_254 == 32'h8C006057
| _T_254 == 32'h88006057
| _T_254 == 32'hA4006057
| _T_254 == 32'hAC006057
| _T_254 == 32'hB4006057
| _T_254 == 32'hBC006057
| _T_260 == 32'h42006057
| _T_254 == 32'h24006057
| _T_254 == 32'h2C006057
| _T_254 == 32'h20006057
| _T_254 == 32'h28006057
| _T_254 == 32'h84004057
| _T_254 == 32'h8C004057
| _T_254 == 32'h80004057
| _T_254 == 32'h88004057
| _T_254 == 32'h9C004057
| _T_254 == 32'hA8004057
| _T_254 == 32'hAC004057
| _T_254 == 32'hBC004057
| _T_254 == 32'hB8004057
| _T_254 == 32'h38005057
| _T_254 == 32'h3C005057
| _T_254 == 32'h20005057
| _T_254 == 32'h24005057
| _T_254 == 32'h28005057
| _T_254 == 32'h10005057
| _T_254 == 32'h18005057
| _T_254 == 32'h60005057
| _T_254 == 32'h64005057
| _T_254 == 32'h6C005057
| _T_254 == 32'h70005057
| _T_254 == 32'h74005057
| _T_254 == 32'h7C005057
| _T_253 == 32'h5C005057
| _T_260 == 32'h5E005057
| _T_254 == 32'h90005057
| _T_254 == 32'h5057
| _T_254 == 32'h8005057
| _T_254 == 32'h9C005057
| _T_254 == 32'h80005057
| _T_254 == 32'h84005057
| _T_254 == 32'hB0005057
| _T_254 == 32'hB4005057
| _T_254 == 32'hB8005057
| _T_254 == 32'hBC005057
| _T_254 == 32'hA0005057
| _T_254 == 32'hA4005057
| _T_254 == 32'hA8005057
| _T_254 == 32'hAC005057
| _T_260 == 32'h42005057
| _T_254 == 32'hC0005057
| _T_254 == 32'hC8005057
| _T_254 == 32'hE0005057
| _T_254 == 32'hD0005057
| _T_254 == 32'hD8005057
| _T_254 == 32'hF0005057
| _T_254 == 32'hF4005057
| _T_254 == 32'hF8005057
| _T_254 == 32'hFC005057
| _T_264 == 32'h42002057
| _T_263 == 32'h40082057
| _T_263 == 32'h4008A057
| _T_264 == 32'h42001057;	// foo.lo.fir.mlir:493257:17, :493315:27, :493318:27, :493319:27, :493351:27, :493352:27, :493353:27, :493354:27, :493360:27, :493361:27, :493362:27, :493363:27, :493427:27, :493428:27, :493429:27, :493430:27, :493431:27, :493432:27, :493433:27, :493434:27, :493435:27, :493436:27, :493437:27, :493439:27, :493440:27, :493441:27, :493442:27, :493443:27, :493444:27, :493445:27, :493446:27, :493447:27, :493448:27, :493449:27, :493450:27, :493451:27, :493452:27, :493453:27, :493454:27, :493455:27, :493456:27, :493457:27, :493458:27, :493459:27, :493460:27, :493461:27, :493462:27, :493463:27, :493464:27, :493465:27, :493466:27, :493467:27, :493468:27, :493469:27, :493470:27, :493471:27, :493498:27, :493499:27, :493500:27, :493501:27, :493516:27, :493524:27, :493525:27, :493526:27, :493527:27, :493533:27, :493534:27, :493535:27, :493536:27, :493542:27, :493543:27, :493544:27, :493545:27, :493551:27, :493552:27, :493553:27, :493554:27, :493564:27, :493565:27, :493579:27, :493580:27, :493581:27, :493582:27, :493583:27, :493615:27, :493623:27, :493624:27, :493625:27, :493626:27, :493627:27, :493628:27, :493629:27, :493630:27, :493631:27, :493632:27, :493633:27, :493634:27, :493635:27, :493636:27, :493637:27, :493638:27, :493639:27, :493640:27, :493641:27, :493642:27, :493643:27, :493644:27, :493645:27, :493646:27, :493647:27, :493648:27, :493653:27, :493654:27, :493655:27, :493656:27, :493657:27, :493658:27, :493659:27, :493660:27, :493661:27, :493663:27, :493665:27, :493693:27, :493697:27, :493700:27, :493701:27, :493702:27, :493703:27, :493704:27, :493705:27, :493706:27, :493707:27, :493714:27, :493715:27, :493716:27, :493717:27, :493718:27, :493719:27, :493720:27, :493721:27, :493722:27, :493727:27, :493728:27, :493729:27, :493730:27, :493731:27, :493735:27, :493747:27, :493748:27, :493749:27, :493750:27, :493751:27, :493752:27, :493760:27, :493761:27, :493762:27, :493763:27, :493764:27, :493787:27, :493788:27, :493789:27, :493790:27, :493791:27, :493792:27, :493793:27, :493794:27, :493795:27, :493796:27, :493797:27, :493798:27, :493799:27, :493800:27, :493801:27, :493802:27, :493803:27, :493804:27, :493805:27, :493806:27, :493807:27, :493808:27, :493809:27, :493810:27, :493811:27, :493812:27, :493813:27, :493819:27, :493820:27, :493821:27, :493822:27, :493823:27, :493824:27, :493825:27, :493826:27, :493827:27, :493843:27, :493846:27, :493847:27, :493848:27, :493849:27, :493850:27, :493851:27, :493852:27, :493853:27, :493854:27, :493855:27, :493856:27, :493858:27, :493859:27, :493860:27, :493861:27, :493862:27, :493863:27, :493864:27, :493865:27, :493866:27, :494059:13, :498312:15, :498315:15, :498318:15, :498321:15, :498324:15, :498327:15, :498331:15, :498334:15, :498337:15, :498340:15, :498343:15, :498346:15, :498349:15, :498352:15, :498355:15, :498358:15, :498361:15, :498364:15, :498367:15, :498370:15, :498373:15, :498376:15, :498379:15, :498382:15, :498385:15, :498388:15, :498391:15, :498394:15, :498398:15, :498401:15, :498404:15, :498408:15, :498411:15, :498414:15, :498417:15, :498420:15, :498423:15, :498426:15, :498429:15, :498432:15, :498435:15, :498438:15, :498441:15, :498444:15, :498447:15, :498450:15, :498453:15, :498456:15, :498459:15, :498462:15, :498465:15, :498469:15, :498478:15, :498481:15, :498484:15, :498487:15, :498490:15, :498493:15, :498496:15, :498499:15, :498502:15, :498505:15, :498508:15, :498511:15, :498514:15, :498517:15, :498520:15, :498523:15, :498526:15, :498529:15, :498532:15, :498535:15, :498538:15, :498541:15, :498544:15, :498547:15, :498550:15, :498553:15, :498557:15, :498560:15, :498563:15, :498566:15, :498581:15, :498584:15, :498587:15, :498590:15, :498593:15, :498608:15, :498612:15, :498615:15, :498618:15, :498621:15, :498624:15, :498627:15, :498630:15, :498633:15, :498636:15, :498639:15, :498643:15, :498646:15, :498649:15, :498652:15, :498655:15, :498658:15, :498661:15, :498664:15, :498667:15, :498670:15, :498673:15, :498676:15, :498680:15, :498683:15, :498686:15, :498689:15, :498692:15, :498695:15, :498698:15, :498701:15, :498704:15, :498707:15, :498710:15, :498713:15, :498716:15, :498719:15, :498722:15, :498725:15, :498728:15, :498731:15, :498734:15, :498737:15, :498740:15, :498743:15, :498746:15, :498749:15, :498752:15, :498755:15, :498758:15, :498762:15, :498765:15, :498768:15, :498771:15, :498774:15, :498777:15, :498780:15, :498783:15, :498786:15, :498920:15, :498924:15, :498927:15, :498930:15, :498933:15, :498936:15, :498939:15, :498942:15, :498945:15, :498949:15, :498952:15, :498955:15, :498958:15, :498961:15, :498964:15, :498967:15, :498970:15, :498973:15, :498976:15, :498979:15, :498982:15, :498985:15, :498988:15, :498991:15, :499006:15, :499009:15, :499012:15, :499015:15, :499018:15, :499021:15, :499024:15, :499027:15, :499030:15, :499033:15, :499036:15, :499039:15, :499042:15, :499045:15, :499051:15, :499054:15, :499057:15, :499060:15, :499063:15, :499066:15, :499069:15, :499084:15, :499087:15, :499090:15, :499093:15, :499096:15, :499111:15, :499114:15, :499117:15, :499120:15, :499123:15, :499138:15, :499141:15, :499144:15, :499147:15, :499150:15, :499165:15, :499168:15, :499171:15, :499174:15, :499177:15, :499180:15, :499183:15, :499186:15, :499189:15, :499198:15, :499201:15, :499204:15, :499207:15, :499210:15, :499213:15, :499216:15, :499219:15, :499222:15, :499225:15, :499228:15, :499231:15, :499234:15, :499252:15, :499255:15, :499258:15, :499261:15, :499264:15, :499267:15, :499270:15, :499273:15, :499276:15, :499279:15, :499282:15, :499285:15, :499288:15, :499291:15, :499294:15, :499297:15, :499300:15, :499303:15, :499306:15, :499309:15, :499312:15, :499315:15, :499318:15, :499321:15, :499324:15, :499327:15, :499331:15, :499334:15, :499337:15, :499340:15, :499344:15, :499347:15, :499350:15, :499353:15, :499356:15, :499359:15, :499362:15, :499443:15, :499446:15, :499449:15, :499452:15, :499482:15, :499488:15, :499494:15, :499497:15, :499500:15, :499503:15, :499506:15, :499509:15, :499512:15, :499515:15, :499518:15, :499521:15, :499524:15, :499527:15, :499530:15, :499533:15, :499536:15, :499539:15, :499542:15, :499545:15, :499548:15, :499551:15, :499554:15, :499557:15, :499560:15, :499563:15, :499566:15, :499569:15, :499572:15, :499578:15, :499581:15, :499584:15, :499590:15, :499593:15, :499620:15, :499623:15, :499626:15, :499629:15, :499632:15, :499635:15, :499665:15, :499668:15, :499671:15, :499674:15, :499692:15, :499695:15, :499698:15, :499704:15, :499707:15, :499710:15, :499713:15, :499716:15, :499719:15, :499722:15, :499725:15, :499728:15, :499731:15, :499734:15, :499755:15, :499758:15, :499761:15, :499764:15, :499767:15, :499770:15, :499773:15, :499791:15, :499794:15, :499797:15, :499800:15, :499803:15, :499806:15, :499809:15, :499812:15, :499815:15, :499818:15, :499821:15, :499824:15, :499827:15, :499830:15, :499833:15, :499836:15, :499839:15, :499842:15, :499845:15, :499848:15, :499851:15, :499854:15, :499938:15, :499941:15, :499944:15, :499947:15, :499950:15, :499980:15, :499983:15, :499986:15, :499989:15, :499992:15, :499995:15, :499998:15, :500001:15, :500004:15, :500007:15, :500010:15, :500013:15, :500016:15, :500019:15, :500022:15, :500028:15, :500031:15, :500067:15, :500098:15, :500101:15, :500104:15, :500107:15, :508678:15, :508681:15, :508684:15, :508687:15, :508690:15, :508693:15, :508697:15, :508700:15, :508703:15, :508706:15, :508709:15, :508712:15, :508715:15, :508718:15, :508721:15, :508724:15, :508727:15, :508730:15, :508733:15, :508736:15, :508739:15, :508742:15, :508745:15, :508748:15, :508751:15, :508754:15, :508757:15, :508760:15, :508764:15, :508767:15, :508770:15, :508774:15, :508777:15, :508780:15, :508783:15, :508786:15, :508789:15, :508792:15, :508795:15, :508798:15, :508801:15, :508804:15, :508807:15, :508810:15, :508813:15, :508816:15, :508819:15, :508822:15, :508825:15, :508828:15, :508831:15, :508833:15, :508835:15, :508839:15, :508842:15, :508845:15, :508848:15, :508851:15, :508854:15, :508857:15, :508860:15, :508863:15, :508866:15, :508869:15, :508872:15, :508875:15, :508878:15, :508881:15, :508884:15, :508887:15, :508890:15, :508893:15, :508896:15, :508899:15, :508902:15, :508905:15, :508908:15, :508911:15, :508914:15, :508917:15, :508920:15, :508924:15, :508927:15, :508930:15, :508933:15, :508936:15, :508939:15, :508942:15, :508945:15, :508948:15, :508951:15, :508954:15, :508957:15, :508960:15, :508963:15, :508966:15, :508969:15, :508972:15, :508975:15, :508979:15, :508982:15, :508985:15, :508988:15, :508991:15, :508994:15, :508997:15, :509000:15, :509003:15, :509006:15, :509010:15, :509013:15, :509016:15, :509019:15, :509022:15, :509025:15, :509028:15, :509031:15, :509034:15, :509037:15, :509040:15, :509043:15, :509047:15, :509050:15, :509053:15, :509056:15, :509059:15, :509062:15, :509065:15, :509068:15, :509071:15, :509074:15, :509077:15, :509080:15, :509083:15, :509086:15, :509089:15, :509092:15, :509095:15, :509098:15, :509101:15, :509104:15, :509107:15, :509110:15, :509113:15, :509116:15, :509119:15, :509122:15, :509125:15, :509129:15, :509132:15, :509135:15, :509138:15, :509141:15, :509144:15, :509147:15, :509150:15, :509153:15, :509156:15, :509159:15, :509162:15, :509165:15, :509168:15, :509171:15, :509174:15, :509177:15, :509180:15, :509183:15, :509186:15, :509190:15, :509193:15, :509196:15, :509199:15, :509202:15, :509205:15, :509208:15, :509211:15, :509214:15, :509217:15, :509220:15, :509223:15, :509226:15, :509229:15, :509232:15, :509235:15, :509238:15, :509241:15, :509244:15, :509247:15, :509250:15, :509253:15, :509256:15, :509259:15, :509262:15, :509265:15, :509268:15, :509271:15, :509274:15, :509277:15, :509280:15, :509283:15, :509285:15, :509287:15, :509291:15, :509294:15, :509297:15, :509300:15, :509303:15, :509306:15, :509309:15, :509312:15, :509316:15, :509319:15, :509322:15, :509325:15, :509328:15, :509331:15, :509334:15, :509337:15, :509340:15, :509343:15, :509346:15, :509349:15, :509352:15, :509355:15, :509358:15, :509361:15, :509364:15, :509367:15, :509370:15, :509373:15, :509376:15, :509379:15, :509382:15, :509385:15, :509388:15, :509391:15, :509394:15, :509397:15, :509400:15, :509403:15, :509406:15, :509409:15, :509412:15, :509415:15, :509418:15, :509421:15, :509424:15, :509427:15, :509430:15, :509433:15, :509436:15, :509439:15, :509442:15, :509445:15, :509448:15, :509451:15, :509454:15, :509457:15, :509460:15, :509463:15, :509466:15, :509469:15, :509472:15, :509475:15, :509478:15, :509481:15, :509484:15, :509487:15, :509490:15, :509493:15, :509496:15, :509499:15, :509502:15, :509505:15, :509508:15, :509511:15, :509514:15, :509517:15, :509520:15, :509523:15, :509526:15, :509529:15, :509532:15, :509535:15, :509538:15, :509541:15, :509544:15, :509547:15, :509550:15, :509553:15, :509556:15, :509559:15, :509562:15, :509565:15, :509568:15, :509571:15, :509574:15, :509577:15, :509580:15, :509583:15, :509586:15, :509589:15, :509592:15, :509595:15, :509598:15, :509601:15, :509604:15, :509607:15, :509610:15, :509613:15, :509616:15, :509619:15, :509622:15, :509625:15, :509628:15, :509631:15, :509634:15, :509637:15, :509640:15, :509643:15, :509646:15, :509649:15, :509652:15, :509655:15, :509658:15, :509661:15, :509664:15, :509667:15, :509670:15, :509673:15, :509676:15, :509679:15, :509682:15, :509685:15, :509688:15, :509691:15, :509694:15, :509698:15, :509701:15, :509704:15, :509707:15, :509709:15, :509711:15, :509714:15, :509717:15, :509720:15, :509723:15, :509726:15, :509729:15, :509732:15, :509735:15, :509738:15, :509741:15, :509744:15, :509747:15, :509750:15, :509753:15, :509756:15, :509759:15, :509762:15, :509765:15, :509768:15, :509771:15, :509774:15, :509777:15, :509780:15, :509783:15, :509786:15, :509789:15, :509792:15, :509795:15, :509798:15, :509801:15, :509804:15, :509807:15, :509810:15, :509813:15, :509816:15, :509819:15, :509822:15, :509825:15, :509828:15, :509831:15, :509834:15, :509837:15, :509840:15, :509843:15, :509846:15, :509849:15, :509852:15, :509855:15, :509858:15, :509861:15, :509864:15, :509867:15, :509870:15, :509873:15, :509876:15, :509879:15, :509882:15, :509885:15, :509888:15, :509891:15, :509894:15, :509897:15, :509900:15, :509903:15, :509906:15, :509909:15, :509912:15, :509915:15, :509918:15, :509921:15, :509924:15, :509927:15, :509930:15, :509933:15, :509936:15, :509939:15, :509942:15, :509945:15, :509948:15, :509951:15, :509954:15, :509957:15, :509960:15, :509963:15, :509966:15, :509969:15, :509972:15, :509975:15, :509978:15, :509981:15, :509984:15, :509987:15, :509990:15, :509993:15, :509996:15, :509999:15, :510002:15, :510005:15, :510008:15, :510011:15, :510014:15, :510017:15, :510020:15, :510023:15, :510026:15, :510029:15, :510032:15, :510035:15, :510038:15, :510041:15, :510044:15, :510047:15, :510050:15, :510053:15, :510056:15, :510059:15, :510062:15, :510065:15, :510068:15, :510071:15, :510074:15, :510077:15, :510080:15, :510083:15, :510086:15, :510089:15, :510092:15, :510095:15, :510098:15, :510101:15, :510104:15, :510107:15, :510110:15, :510113:15, :510116:15, :510119:15, :510122:15, :510125:15, :510128:15, :510131:15, :510134:15, :510137:15, :510140:15, :510143:15, :510146:15, :510149:15, :510152:15, :510155:15, :510158:15, :510161:15, :510164:15, :510167:15, :510170:15, :510173:15, :510176:15, :510179:15, :510182:15, :510185:15, :510188:15, :510191:15, :510194:15, :510197:15, :510200:15, :510203:15, :510206:15, :510209:15, :510212:15, :510215:15, :510218:15, :510221:15, :510224:15, :510227:15, :510230:15, :510233:15, :510236:15, :510239:15, :510242:15, :510245:15, :510248:15, :510251:15, :510254:15, :510257:15, :510260:15, :510263:15, :510266:15, :510269:15, :510272:15, :510275:15, :510278:15, :510281:15, :510284:15, :510287:15, :510290:15, :510293:15, :510296:15, :510299:15, :510302:15, :510305:15, :510308:15, :510311:15, :510314:15, :510317:15, :510320:15, :510323:15, :510326:15, :510329:15, :510332:15, :510335:15, :510338:15, :510341:15, :510344:15, :510347:15, :510350:15, :510353:15, :510356:15, :510359:15, :510362:15, :510365:15, :510368:15, :510371:15, :510374:15, :510377:15, :510380:15, :510383:15, :510386:15, :510389:15, :510392:15, :510395:15, :510398:15, :510401:15, :510404:15, :510407:15, :510410:15, :510413:15, :510416:15, :510419:15, :510422:15, :510425:15, :510428:15, :510431:15, :510434:15, :510437:15, :510440:15, :510443:15, :510446:15, :510449:15, :510452:15, :510455:15, :510458:15, :510461:15, :510465:15, :510468:15, :510471:15, :510474:15, :511660:15, :511839:15, :511841:15, :512083:15, :512138:15, :512908:15, :512911:15, :512914:15, :512917:15, :512920:15, :512923:15, :512927:15, :512930:15, :512933:15, :512936:15, :512939:15, :512942:15, :512945:15, :512948:15, :512951:15, :512954:15, :512957:15, :512960:15, :512963:15, :512966:15, :512969:15, :512972:15, :512975:15, :512978:15, :512981:15, :512984:15, :512987:15, :512990:15, :512994:15, :512997:15, :513000:15, :513004:15, :513007:15, :513010:15, :513013:15, :513016:15, :513019:15, :513022:15, :513025:15, :513028:15, :513031:15, :513034:15, :513037:15, :513040:15, :513043:15, :513046:15, :513049:15, :513052:15, :513055:15, :513058:15, :513061:15, :513063:15, :513065:15, :513068:15, :513071:15, :513074:15, :513077:15, :513080:15, :513083:15, :513086:15, :513089:15, :513092:15, :513095:15, :513098:15, :513101:15, :513104:15, :513107:15, :513110:15, :513113:15, :513116:15, :513119:15, :513122:15, :513125:15, :513128:15, :513131:15, :513134:15, :513137:15, :513140:15, :513143:15, :513146:15, :513149:15, :513153:15, :513156:15, :513159:15, :513162:15, :513165:15, :513168:15, :513171:15, :513174:15, :513177:15, :513180:15, :513183:15, :513186:15, :513189:15, :513192:15, :513195:15, :513198:15, :513201:15, :513204:15, :513208:15, :513211:15, :513214:15, :513217:15, :513220:15, :513223:15, :513226:15, :513229:15, :513232:15, :513235:15, :513239:15, :513242:15, :513245:15, :513248:15, :513251:15, :513254:15, :513257:15, :513260:15, :513263:15, :513266:15, :513269:15, :513272:15, :513276:15, :513279:15, :513282:15, :513285:15, :513288:15, :513291:15, :513294:15, :513297:15, :513300:15, :513303:15, :513306:15, :513309:15, :513312:15, :513315:15, :513318:15, :513321:15, :513324:15, :513327:15, :513330:15, :513333:15, :513336:15, :513339:15, :513342:15, :513345:15, :513348:15, :513351:15, :513354:15, :513358:15, :513361:15, :513364:15, :513367:15, :513370:15, :513373:15, :513376:15, :513379:15, :513382:15, :513385:15, :513388:15, :513391:15, :513394:15, :513397:15, :513400:15, :513403:15, :513406:15, :513409:15, :513412:15, :513415:15, :513419:15, :513422:15, :513425:15, :513428:15, :513431:15, :513434:15, :513437:15, :513440:15, :513443:15, :513446:15, :513449:15, :513452:15, :513455:15, :513458:15, :513461:15, :513464:15, :513467:15, :513470:15, :513473:15, :513476:15, :513479:15, :513482:15, :513485:15, :513488:15, :513491:15, :513494:15, :513497:15, :513500:15, :513503:15, :513506:15, :513509:15, :513512:15, :513514:15, :513516:15, :513520:15, :513523:15, :513526:15, :513529:15, :513532:15, :513535:15, :513538:15, :513541:15, :513545:15, :513548:15, :513551:15, :513554:15, :513557:15, :513560:15, :513563:15, :513566:15, :513569:15, :513572:15, :513575:15, :513578:15, :513581:15, :513584:15, :513587:15, :513590:15, :513593:15, :513596:15, :513599:15, :513602:15, :513605:15, :513608:15, :513611:15, :513614:15, :513617:15, :513620:15, :513623:15, :513626:15, :513629:15, :513632:15, :513635:15, :513638:15, :513641:15, :513644:15, :513647:15, :513650:15, :513653:15, :513656:15, :513659:15, :513662:15, :513665:15, :513668:15, :513671:15, :513674:15, :513677:15, :513680:15, :513683:15, :513686:15, :513689:15, :513692:15, :513695:15, :513698:15, :513701:15, :513704:15, :513707:15, :513710:15, :513713:15, :513716:15, :513719:15, :513722:15, :513725:15, :513728:15, :513731:15, :513734:15, :513737:15, :513740:15, :513743:15, :513746:15, :513749:15, :513752:15, :513755:15, :513758:15, :513761:15, :513764:15, :513767:15, :513770:15, :513773:15, :513776:15, :513779:15, :513782:15, :513785:15, :513788:15, :513791:15, :513794:15, :513797:15, :513800:15, :513803:15, :513806:15, :513809:15, :513812:15, :513815:15, :513818:15, :513821:15, :513824:15, :513827:15, :513830:15, :513833:15, :513836:15, :513839:15, :513842:15, :513845:15, :513848:15, :513851:15, :513854:15, :513857:15, :513860:15, :513863:15, :513866:15, :513869:15, :513872:15, :513875:15, :513878:15, :513881:15, :513884:15, :513887:15, :513890:15, :513893:15, :513896:15, :513899:15, :513902:15, :513905:15, :513908:15, :513911:15, :513914:15, :513917:15, :513920:15, :513923:15, :513927:15, :513930:15, :513933:15, :513936:15, :513938:15, :513940:15, :513943:15, :513946:15, :513949:15, :513952:15, :513955:15, :513958:15, :513961:15, :513964:15, :513967:15, :513970:15, :513973:15, :513976:15, :513979:15, :513982:15, :513985:15, :513988:15, :513991:15, :513994:15, :513997:15, :514000:15, :514003:15, :514006:15, :514009:15, :514012:15, :514015:15, :514018:15, :514021:15, :514024:15, :514027:15, :514030:15, :514033:15, :514036:15, :514039:15, :514042:15, :514045:15, :514048:15, :514051:15, :514054:15, :514057:15, :514060:15, :514063:15, :514066:15, :514069:15, :514072:15, :514075:15, :514078:15, :514081:15, :514084:15, :514087:15, :514090:15, :514093:15, :514096:15, :514099:15, :514102:15, :514105:15, :514108:15, :514111:15, :514114:15, :514117:15, :514120:15, :514123:15, :514126:15, :514129:15, :514132:15, :514135:15, :514138:15, :514141:15, :514144:15, :514147:15, :514150:15, :514153:15, :514156:15, :514159:15, :514162:15, :514165:15, :514168:15, :514171:15, :514174:15, :514177:15, :514180:15, :514183:15, :514186:15, :514189:15, :514192:15, :514195:15, :514198:15, :514201:15, :514204:15, :514207:15, :514210:15, :514213:15, :514216:15, :514219:15, :514222:15, :514225:15, :514228:15, :514231:15, :514234:15, :514237:15, :514240:15, :514243:15, :514246:15, :514249:15, :514252:15, :514255:15, :514258:15, :514261:15, :514264:15, :514267:15, :514270:15, :514273:15, :514276:15, :514279:15, :514282:15, :514285:15, :514288:15, :514291:15, :514294:15, :514297:15, :514300:15, :514303:15, :514306:15, :514309:15, :514312:15, :514315:15, :514318:15, :514321:15, :514324:15, :514327:15, :514330:15, :514333:15, :514336:15, :514339:15, :514342:15, :514345:15, :514348:15, :514351:15, :514354:15, :514357:15, :514360:15, :514363:15, :514366:15, :514369:15, :514372:15, :514375:15, :514378:15, :514381:15, :514384:15, :514387:15, :514390:15, :514393:15, :514396:15, :514399:15, :514402:15, :514405:15, :514408:15, :514411:15, :514414:15, :514417:15, :514420:15, :514423:15, :514426:15, :514429:15, :514432:15, :514435:15, :514438:15, :514441:15, :514444:15, :514447:15, :514450:15, :514453:15, :514456:15, :514459:15, :514462:15, :514465:15, :514468:15, :514471:15, :514474:15, :514477:15, :514480:15, :514483:15, :514486:15, :514489:15, :514492:15, :514495:15, :514498:15, :514501:15, :514504:15, :514507:15, :514510:15, :514513:15, :514516:15, :514519:15, :514522:15, :514525:15, :514528:15, :514531:15, :514534:15, :514537:15, :514540:15, :514543:15, :514546:15, :514549:15, :514552:15, :514555:15, :514558:15, :514561:15, :514564:15, :514567:15, :514570:15, :514573:15, :514576:15, :514579:15, :514582:15, :514585:15, :514588:15, :514591:15, :514594:15, :514597:15, :514600:15, :514603:15, :514606:15, :514609:15, :514612:15, :514615:15, :514618:15, :514621:15, :514624:15, :514627:15, :514630:15, :514633:15, :514636:15, :514639:15, :514642:15, :514645:15, :514648:15, :514651:15, :514654:15, :514657:15, :514660:15, :514663:15, :514666:15, :514669:15, :514672:15, :514675:15, :514678:15, :514681:15, :514684:15, :514687:15, :514690:15, :514694:15, :514697:15, :514700:15, :514703:15, :515889:15, :516241:15, :516245:15, :516249:15, :516253:15, :516257:15, :516261:15, :516265:15, :516267:15, :516269:15, :516303:15, :516306:15, :516309:15, :516312:15, :516315:15, :516318:15, :516322:15, :516325:15, :516328:15, :516331:15, :516334:15, :516337:15, :516340:15, :516343:15, :516346:15, :516349:15, :516352:15, :516355:15, :516358:15, :516361:15, :516364:15, :516367:15, :516370:15, :516373:15, :516376:15, :516379:15, :516382:15, :516385:15, :516389:15, :516392:15, :516395:15, :516399:15, :516402:15, :516405:15, :516408:15, :516411:15, :516414:15, :516417:15, :516420:15, :516423:15, :516426:15, :516429:15, :516432:15, :516435:15, :516438:15, :516441:15, :516444:15, :516447:15, :516450:15, :516453:15, :516456:15, :516458:15, :516460:15, :516463:15, :516466:15, :516469:15, :516472:15, :516475:15, :516478:15, :516481:15, :516484:15, :516487:15, :516490:15, :516493:15, :516496:15, :516499:15, :516502:15, :516505:15, :516508:15, :516511:15, :516514:15, :516517:15, :516520:15, :516523:15, :516526:15, :516529:15, :516532:15, :516535:15, :516538:15, :516541:15, :516544:15, :516548:15, :516551:15, :516554:15, :516557:15, :516560:15, :516563:15, :516566:15, :516569:15, :516572:15, :516575:15, :516578:15, :516581:15, :516584:15, :516587:15, :516590:15, :516593:15, :516596:15, :516599:15, :516603:15, :516606:15, :516609:15, :516612:15, :516615:15, :516618:15, :516621:15, :516624:15, :516627:15, :516630:15, :516634:15, :516637:15, :516640:15, :516643:15, :516646:15, :516649:15, :516652:15, :516655:15, :516658:15, :516661:15, :516664:15, :516667:15, :516671:15, :516674:15, :516677:15, :516680:15, :516683:15, :516686:15, :516689:15, :516692:15, :516695:15, :516698:15, :516701:15, :516704:15, :516707:15, :516710:15, :516713:15, :516716:15, :516719:15, :516722:15, :516725:15, :516728:15, :516731:15, :516734:15, :516737:15, :516740:15, :516743:15, :516746:15, :516749:15, :516753:15, :516756:15, :516759:15, :516762:15, :516765:15, :516768:15, :516771:15, :516774:15, :516777:15, :516780:15, :516783:15, :516786:15, :516789:15, :516792:15, :516795:15, :516798:15, :516801:15, :516804:15, :516807:15, :516810:15, :516814:15, :516817:15, :516820:15, :516823:15, :516826:15, :516829:15, :516832:15, :516835:15, :516838:15, :516841:15, :516844:15, :516847:15, :516850:15, :516853:15, :516856:15, :516859:15, :516862:15, :516865:15, :516868:15, :516871:15, :516874:15, :516877:15, :516880:15, :516883:15, :516886:15, :516889:15, :516892:15, :516895:15, :516898:15, :516901:15, :516904:15, :516907:15, :516909:15, :516911:15, :516915:15, :516918:15, :516921:15, :516924:15, :516927:15, :516930:15, :516933:15, :516936:15, :516940:15, :516943:15, :516946:15, :516949:15, :516952:15, :516955:15, :516958:15, :516961:15, :516964:15, :516967:15, :516970:15, :516973:15, :516976:15, :516979:15, :516982:15, :516985:15, :516988:15, :516991:15, :516994:15, :516997:15, :517000:15, :517003:15, :517006:15, :517009:15, :517012:15, :517015:15, :517018:15, :517021:15, :517024:15, :517027:15, :517030:15, :517033:15, :517036:15, :517039:15, :517042:15, :517045:15, :517048:15, :517051:15, :517054:15, :517057:15, :517060:15, :517063:15, :517066:15, :517069:15, :517072:15, :517075:15, :517078:15, :517081:15, :517084:15, :517087:15, :517090:15, :517093:15, :517096:15, :517099:15, :517102:15, :517105:15, :517108:15, :517111:15, :517114:15, :517117:15, :517120:15, :517123:15, :517126:15, :517129:15, :517132:15, :517135:15, :517138:15, :517141:15, :517144:15, :517147:15, :517150:15, :517153:15, :517156:15, :517159:15, :517162:15, :517165:15, :517168:15, :517171:15, :517174:15, :517177:15, :517180:15, :517183:15, :517186:15, :517189:15, :517192:15, :517195:15, :517198:15, :517201:15, :517204:15, :517207:15, :517210:15, :517213:15, :517216:15, :517219:15, :517222:15, :517225:15, :517228:15, :517231:15, :517234:15, :517237:15, :517240:15, :517243:15, :517246:15, :517249:15, :517252:15, :517255:15, :517258:15, :517261:15, :517264:15, :517267:15, :517270:15, :517273:15, :517276:15, :517279:15, :517282:15, :517285:15, :517288:15, :517291:15, :517294:15, :517297:15, :517300:15, :517303:15, :517306:15, :517309:15, :517312:15, :517315:15, :517318:15, :517322:15, :517325:15, :517328:15, :517331:15, :517333:15, :517335:15, :517338:15, :517341:15, :517344:15, :517347:15, :517350:15, :517353:15, :517356:15, :517359:15, :517362:15, :517365:15, :517368:15, :517371:15, :517374:15, :517377:15, :517380:15, :517383:15, :517386:15, :517389:15, :517392:15, :517395:15, :517398:15, :517401:15, :517404:15, :517407:15, :517410:15, :517413:15, :517416:15, :517419:15, :517422:15, :517425:15, :517428:15, :517431:15, :517434:15, :517437:15, :517440:15, :517443:15, :517446:15, :517449:15, :517452:15, :517455:15, :517458:15, :517461:15, :517464:15, :517467:15, :517470:15, :517473:15, :517476:15, :517479:15, :517482:15, :517485:15, :517488:15, :517491:15, :517494:15, :517497:15, :517500:15, :517503:15, :517506:15, :517509:15, :517512:15, :517515:15, :517518:15, :517521:15, :517524:15, :517527:15, :517530:15, :517533:15, :517536:15, :517539:15, :517542:15, :517545:15, :517548:15, :517551:15, :517554:15, :517557:15, :517560:15, :517563:15, :517566:15, :517569:15, :517572:15, :517575:15, :517578:15, :517581:15, :517584:15, :517587:15, :517590:15, :517593:15, :517596:15, :517599:15, :517602:15, :517605:15, :517608:15, :517611:15, :517614:15, :517617:15, :517620:15, :517623:15, :517626:15, :517629:15, :517632:15, :517635:15, :517638:15, :517641:15, :517644:15, :517647:15, :517650:15, :517653:15, :517656:15, :517659:15, :517662:15, :517665:15, :517668:15, :517671:15, :517674:15, :517677:15, :517680:15, :517683:15, :517686:15, :517689:15, :517692:15, :517695:15, :517698:15, :517701:15, :517704:15, :517707:15, :517710:15, :517713:15, :517716:15, :517719:15, :517722:15, :517725:15, :517728:15, :517731:15, :517734:15, :517737:15, :517740:15, :517743:15, :517746:15, :517749:15, :517752:15, :517755:15, :517758:15, :517761:15, :517764:15, :517767:15, :517770:15, :517773:15, :517776:15, :517779:15, :517782:15, :517785:15, :517788:15, :517791:15, :517794:15, :517797:15, :517800:15, :517803:15, :517806:15, :517809:15, :517812:15, :517815:15, :517818:15, :517821:15, :517824:15, :517827:15, :517830:15, :517833:15, :517836:15, :517839:15, :517842:15, :517845:15, :517848:15, :517851:15, :517854:15, :517857:15, :517860:15, :517863:15, :517866:15, :517869:15, :517872:15, :517875:15, :517878:15, :517881:15, :517884:15, :517887:15, :517890:15, :517893:15, :517896:15, :517899:15, :517902:15, :517905:15, :517908:15, :517911:15, :517914:15, :517917:15, :517920:15, :517923:15, :517926:15, :517929:15, :517932:15, :517935:15, :517938:15, :517941:15, :517944:15, :517947:15, :517950:15, :517953:15, :517956:15, :517959:15, :517962:15, :517965:15, :517968:15, :517971:15, :517974:15, :517977:15, :517980:15, :517983:15, :517986:15, :517989:15, :517992:15, :517995:15, :517998:15, :518001:15, :518004:15, :518007:15, :518010:15, :518013:15, :518016:15, :518019:15, :518022:15, :518025:15, :518028:15, :518031:15, :518034:15, :518037:15, :518040:15, :518043:15, :518046:15, :518049:15, :518052:15, :518055:15, :518058:15, :518061:15, :518064:15, :518067:15, :518070:15, :518073:15, :518076:15, :518079:15, :518082:15, :518085:15, :518089:15, :518092:15, :518095:15, :518098:15, :519284:16, :519636:16, :519640:16, :519644:16, :519648:16, :519652:16, :519656:16, :519660:16, :519662:16, :519664:16, :523111:16, :523158:16, :523184:16, :523238:16",,,,,,,,
666,firrtl.printf losses order,2021-02-24T21:59:53Z,closed,"bug, FIRRTL","multiple printf in the same region are ordered in firrtl, hence they cannot be lowered to independent always blocks which have non-determinstic sideeffect order.

Firrtl spec 5.14.",,,,,,,,,,
661,[LowerTypes] Multiple port memories cause segfault,2021-02-24T15:33:40Z,closed,bug,"memories with multiple ports are not lowered correctly.  This segfaults:
```
module  {
  firrtl.circuit ""foo"" {
    firrtl.module @foo(
      %clock: !firrtl.clock
      ) {
      %head_MPORT_2, %head_MPORT_6 = firrtl.mem Undefined {depth = 20 : i64, name = ""head"", portNames = [""MPORT_2"", ""MPORT_6""], readLatency = 0 : i32, writeLatency = 1 : i32} 
      : !firrtl.flip< bundle<addr: uint<5>, en: uint<1>, clk: clock, data: uint<5>, mask: uint<1> > >,
        !firrtl.flip< bundle<addr: uint<5>, en: uint<1>, clk: clock, data: uint<5>, mask: uint<1> > >
      %127 = firrtl.subfield %head_MPORT_6(""clk"") : (!firrtl.flip<bundle<addr: uint<5>, en: uint<1>, clk: clock, data: uint<5>, mask: uint<1>>>) -> !firrtl.flip<clock>
    }
  }
}
```","module  {
  firrtl.circuit ""foo"" {
    firrtl.module @foo(
      %clock: !firrtl.clock
      ) {
      %head_MPORT_2, %head_MPORT_6 = firrtl.mem Undefined {depth = 20 : i64, name = ""head"", portNames = [""MPORT_2"", ""MPORT_6""], readLatency = 0 : i32, writeLatency = 1 : i32} 
      : !firrtl.flip< bundle<addr: uint<5>, en: uint<1>, clk: clock, data: uint<5>, mask: uint<1> > >,
        !firrtl.flip< bundle<addr: uint<5>, en: uint<1>, clk: clock, data: uint<5>, mask: uint<1> > >
      %127 = firrtl.subfield %head_MPORT_6(""clk"") : (!firrtl.flip<bundle<addr: uint<5>, en: uint<1>, clk: clock, data: uint<5>, mask: uint<1>>>) -> !firrtl.flip<clock>
    }
  }
}",,,,,,,,,
640,FIRRTLToRTL test fails with gcc 10.2 but not with clang 11,2021-02-22T20:53:56Z,closed,"bug, ExportVerilog","```
FAIL: CIRCT :: Conversion/FIRRTLToRTL/lower-to-rtl.mlir (42 of 180)
******************** TEST 'CIRCT :: Conversion/FIRRTLToRTL/lower-to-rtl.mlir' FAILED ********************
Script:
--
: 'RUN: at line 1';   /home/jodemme/circt/build/bin/circt-opt -lower-firrtl-to-rtl /home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir | /home/jodemme/circt/llvm/build/bin/FileCheck /home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir
--
Exit Code: 1

Command Output (stderr):
--
/home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir:801:12: error: CHECK: expected string not found in input
 // CHECK: %[[mask:.+]] = sv.read_inout %[[mask_0]]
           ^
<stdin>:423:25: note: scanning from here
 %15 = sv.read_inout %9 : !rtl.inout<i1>
                        ^
<stdin>:423:25: note: with ""mask_0"" equal to ""11""
 %15 = sv.read_inout %9 : !rtl.inout<i1>
                        ^
<stdin>:426:2: note: possible intended match here
 %17 = sv.read_inout %10 : !rtl.inout<i4>
 ^

Input file: <stdin>
Check file: /home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir

-dump-input=help explains the following input dump.

Input was:
<<<<<<
             .
             .
             .
           418:  sv.passign %12, %17 : i8
           419:  }
           420:  }
           421:  sv.alwaysff(posedge %8) {
           422:  %14 = sv.read_inout %11 : !rtl.inout<i1>
           423:  %15 = sv.read_inout %9 : !rtl.inout<i1>
check:801'0                             X~~~~~~~~~~~~~~~ error: no match found
check:801'1                                              with ""mask_0"" equal to ""11""
           424:  %16 = comb.and %15, %14 : i1
check:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           425:  sv.if %16 {
check:801'0     ~~~~~~~~~~~~
           426:  %17 = sv.read_inout %10 : !rtl.inout<i4>
check:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check:801'2      ?                                        possible intended match
           427:  %18 = sv.array_index_inout %memory[%17] : !rtl.inout<uarray<16xi8>>, i4
check:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           428:  %19 = sv.read_inout %12 : !rtl.inout<i8>
check:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           429:  sv.passign %18, %19 : i8
check:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~
           430:  }
check:801'0     ~~
           431:  }
check:801'0     ~~
             .
             .
             .
>>>>>>

--

********************
********************
Failed Tests (1):
  CIRCT :: Conversion/FIRRTLToRTL/lower-to-rtl.mlir


Testing Time: 1.54s
  Passed: 179
  Failed:   1
```

Seems like the two lines are reverse with gcc. I suspect the recent change to ExportVerilog may have some compiler specific behavior...?","FAIL: CIRCT :: Conversion/FIRRTLToRTL/lower-to-rtl.mlir (42 of 180)
******************** TEST 'CIRCT :: Conversion/FIRRTLToRTL/lower-to-rtl.mlir' FAILED ********************
Script:
--
: 'RUN: at line 1';   /home/jodemme/circt/build/bin/circt-opt -lower-firrtl-to-rtl /home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir | /home/jodemme/circt/llvm/build/bin/FileCheck /home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir
--
Exit Code: 1

Command Output (stderr):
--
/home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir:801:12: error: CHECK: expected string not found in input
 // CHECK: %[[mask:.+]] = sv.read_inout %[[mask_0]]
           ^
<stdin>:423:25: note: scanning from here
 %15 = sv.read_inout %9 : !rtl.inout<i1>
                        ^
<stdin>:423:25: note: with ""mask_0"" equal to ""11""
 %15 = sv.read_inout %9 : !rtl.inout<i1>
                        ^
<stdin>:426:2: note: possible intended match here
 %17 = sv.read_inout %10 : !rtl.inout<i4>
 ^

Input file: <stdin>
Check file: /home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir

-dump-input=help explains the following input dump.

Input was:
<<<<<<
             .
             .
             .
           418:  sv.passign %12, %17 : i8
           419:  }
           420:  }
           421:  sv.alwaysff(posedge %8) {
           422:  %14 = sv.read_inout %11 : !rtl.inout<i1>
           423:  %15 = sv.read_inout %9 : !rtl.inout<i1>
check:801'0                             X~~~~~~~~~~~~~~~ error: no match found
check:801'1                                              with ""mask_0"" equal to ""11""
           424:  %16 = comb.and %15, %14 : i1
check:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           425:  sv.if %16 {
check:801'0     ~~~~~~~~~~~~
           426:  %17 = sv.read_inout %10 : !rtl.inout<i4>
check:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check:801'2      ?                                        possible intended match
           427:  %18 = sv.array_index_inout %memory[%17] : !rtl.inout<uarray<16xi8>>, i4
check:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           428:  %19 = sv.read_inout %12 : !rtl.inout<i8>
check:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           429:  sv.passign %18, %19 : i8
check:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~
           430:  }
check:801'0     ~~
           431:  }
check:801'0     ~~
             .
             .
             .
>>>>>>

--

********************
********************
Failed Tests (1):
  CIRCT :: Conversion/FIRRTLToRTL/lower-to-rtl.mlir


Testing Time: 1.54s
  Passed: 179
  Failed:   1",,,,,,,,,
617,[RTL] Instance should verify that its return types match the Module,2021-02-19T07:09:14Z,closed,"bug, good first issue, HW","RTL does not appear to be checking that the number of arguments returned by InstanceOp match the module it is referencing.  The following does not produce an error:

```mlir
// RUN: circt-opt ./test.mlir

rtl.module @empty() -> () {
  rtl.output
}

rtl.module @test() -> () {
  // too many outputs
  %0, %1, %3 = rtl.instance ""inline-me"" @mem() : () -> (i2, i2, i2)
  rtl.output
}
```
","// RUN: circt-opt ./test.mlir

rtl.module @empty() -> () {
  rtl.output
}

rtl.module @test() -> () {
  // too many outputs
  %0, %1, %3 = rtl.instance ""inline-me"" @mem() : () -> (i2, i2, i2)
  rtl.output
}",,,,,,,,,
593,[FIRRTL] circuit with instance (core dump),2021-02-15T04:10:39Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module mod_2 :
    input clock: Clock
    input reset: UInt<1>
    input inp_a: {inp_d: UInt<14>}
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    inst U0 of mod_2
    U0 is invalid
    U0.reset <= reset
    U0.clock <= clock
```

Compiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:

```mlir
firtool: ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:500: mlir::Value {anonymous}::FIRRTLTypesLowering::getBundleLowering(mlir::Value, llvm::StringRef): Assertion `entry && ""bundle lowering was not set""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.v
1.      2.       #0 0x00000000004c54ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004c55a4 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004c35a4 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004c4f40 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f6f180221d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007f6f17aa9ae5 raise (/lib64/libc.so.6+0x3dae5)
 #6 0x00007f6f17a92864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f6f17a92749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f6f17aa2016 (/lib64/libc.so.6+0x36016)
 #9 0x00000000005b68be (anonymous namespace)::FIRRTLTypesLowering::getBundleLowering(mlir::Value, llvm::StringRef) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:500:3
#10 0x00000000005b6a2f (anonymous namespace)::FIRRTLTypesLowering::getAllBundleLowerings(mlir::Value, llvm::SmallVectorImpl<mlir::Value>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:521:22
#11 0x00000000005b62aa (anonymous namespace)::FIRRTLTypesLowering::visitStmt(circt::firrtl::ConnectOp) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:429:3
#12 0x00000000005b84cf void circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::ConnectOp>(auto) const /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:161:13
#13 0x00000000005b82af llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::ConnectOp, circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&>(void&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:159:18
#14 0x00000000005b8029 llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::ConnectOp, circt::firrtl::DoneOp, circt::firrtl::MemoryPortOp, circt::firrtl::PartialConnectOp, circt::firrtl::PrintFOp, circt::firrtl::SkipOp, circt::firrtl::StopOp, circt::firrtl::WhenOp, circt::firrtl::AssertOp, circt::firrtl::AssumeOp, circt::firrtl::CoverOp, circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42
#15 0x00000000005b7d8f llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::AttachOp, circt::firrtl::ConnectOp, circt::firrtl::DoneOp, circt::firrtl::MemoryPortOp, circt::firrtl::PartialConnectOp, circt::firrtl::PrintFOp, circt::firrtl::SkipOp, circt::firrtl::StopOp, circt::firrtl::WhenOp, circt::firrtl::AssertOp, circt::firrtl::AssumeOp, circt::firrtl::CoverOp, circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)>(circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3
#16 0x00000000005b7bb2 circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:160:52
#17 0x00000000005b79a1 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::visitInvalidExpr(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:267:49
#18 0x00000000005b760c void circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)::operator()<mlir::Operation*>(auto) const /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:54:56
#19 0x00000000005b7359 void llvm::TypeSwitch<mlir::Operation*, void>::Default<circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)>(auto&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:168:3
#20 0x00000000005b7066 circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:55:10
#21 0x00000000005b6d23 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:262:49
#22 0x00000000005b4992 (anonymous namespace)::FIRRTLTypesLowering::runOnOperation() /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:145:39
#23 0x0000000000988303 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:399:36
#24 0x000000000098852f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:440:15
#25 0x000000000098920a mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:68
#26 0x000000000098c371 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7
#27 0x000000000098c1c8 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:140:38
#28 0x000000000098f0b0 llvm::SmallVector<mlir::OpPassManager, 1u>* std::__invoke_impl<void, void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()&>(std::__invoke_other, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)&&, void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()&...) /usr/include/c++/10/bits/invoke.h:60:67
#29 0x000000000098e53c _ZSt10__invoke_rIvRZN4llvm8parallel6detail17parallel_for_eachIPNS0_11SmallVectorIN4mlir13OpPassManagerELj1EEEZNS5_6detail17OpToOpPassAdaptor23runOnOperationAsyncImplEbEUlNS0_15MutableArrayRefIS6_EEE_EEvT_SE_T0_EUlvE_JEENSt9enable_ifIXsrSt6__and_IJSt7is_voidISE_ESt14__is_invocableISF_JDpT1_EEEE5valueESE_E4typeEOSF_DpOSN_ /usr/include/c++/10/bits/invoke.h:155:5
#30 0x000000000098d7c6 std::_Function_handler<void (), void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()>::_M_invoke(std::_Any_data const&) /usr/include/c++/10/bits/std_function.h:292:44
#31 0x00000000007f618a std::function<void ()>::operator()() const /usr/include/c++/10/bits/std_function.h:622:71
#32 0x0000000000af305c llvm::parallel::detail::TaskGroup::spawn(std::function<void ()>) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Parallel.cpp:166:1
#33 0x000000000098c2b1 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:140:13
#34 0x000000000098b837 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40
#35 0x000000000098971f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:593:24
#36 0x0000000000988c4b mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:518:1
#37 0x00000000009882e4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:396:28
#38 0x000000000098852f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:440:15
#39 0x000000000098920a mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:68
#40 0x000000000098c371 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7
#41 0x000000000098c312 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:143:16
#42 0x000000000098b837 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40
#43 0x000000000098971f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:593:24
#44 0x0000000000988c4b mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:518:1
#45 0x00000000009882e4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:396:28
#46 0x000000000098852f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:440:15
#47 0x000000000098a58f mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:889:74
#48 0x000000000040963c processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:143:13
#49 0x0000000000409afb main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:197:13
#50 0x00007f6f17a94152 __libc_start_main (/lib64/libc.so.6+0x28152)
#51 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 24: 10266 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2
```

Compiled with `firrtl-1.5.0` produces this Verilog:

```verilog
module top_mod(
  input   clock,
  input   reset
);
endmodule
```
","circuit top_mod :
  module mod_2 :
    input clock: Clock
    input reset: UInt<1>
    input inp_a: {inp_d: UInt<14>}
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    inst U0 of mod_2
    U0 is invalid
    U0.reset <= reset
    U0.clock <= clock","firtool: ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:500: mlir::Value {anonymous}::FIRRTLTypesLowering::getBundleLowering(mlir::Value, llvm::StringRef): Assertion `entry && ""bundle lowering was not set""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.v
1.      2.       #0 0x00000000004c54ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004c55a4 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004c35a4 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004c4f40 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f6f180221d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007f6f17aa9ae5 raise (/lib64/libc.so.6+0x3dae5)
 #6 0x00007f6f17a92864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f6f17a92749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f6f17aa2016 (/lib64/libc.so.6+0x36016)
 #9 0x00000000005b68be (anonymous namespace)::FIRRTLTypesLowering::getBundleLowering(mlir::Value, llvm::StringRef) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:500:3
#10 0x00000000005b6a2f (anonymous namespace)::FIRRTLTypesLowering::getAllBundleLowerings(mlir::Value, llvm::SmallVectorImpl<mlir::Value>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:521:22
#11 0x00000000005b62aa (anonymous namespace)::FIRRTLTypesLowering::visitStmt(circt::firrtl::ConnectOp) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:429:3
#12 0x00000000005b84cf void circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::ConnectOp>(auto) const /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:161:13
#13 0x00000000005b82af llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::ConnectOp, circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&>(void&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:159:18
#14 0x00000000005b8029 llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::ConnectOp, circt::firrtl::DoneOp, circt::firrtl::MemoryPortOp, circt::firrtl::PartialConnectOp, circt::firrtl::PrintFOp, circt::firrtl::SkipOp, circt::firrtl::StopOp, circt::firrtl::WhenOp, circt::firrtl::AssertOp, circt::firrtl::AssumeOp, circt::firrtl::CoverOp, circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42
#15 0x00000000005b7d8f llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::AttachOp, circt::firrtl::ConnectOp, circt::firrtl::DoneOp, circt::firrtl::MemoryPortOp, circt::firrtl::PartialConnectOp, circt::firrtl::PrintFOp, circt::firrtl::SkipOp, circt::firrtl::StopOp, circt::firrtl::WhenOp, circt::firrtl::AssertOp, circt::firrtl::AssumeOp, circt::firrtl::CoverOp, circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)>(circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3
#16 0x00000000005b7bb2 circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:160:52
#17 0x00000000005b79a1 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::visitInvalidExpr(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:267:49
#18 0x00000000005b760c void circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)::operator()<mlir::Operation*>(auto) const /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:54:56
#19 0x00000000005b7359 void llvm::TypeSwitch<mlir::Operation*, void>::Default<circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)>(auto&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:168:3
#20 0x00000000005b7066 circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:55:10
#21 0x00000000005b6d23 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:262:49
#22 0x00000000005b4992 (anonymous namespace)::FIRRTLTypesLowering::runOnOperation() /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:145:39
#23 0x0000000000988303 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:399:36
#24 0x000000000098852f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:440:15
#25 0x000000000098920a mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:68
#26 0x000000000098c371 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7
#27 0x000000000098c1c8 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:140:38
#28 0x000000000098f0b0 llvm::SmallVector<mlir::OpPassManager, 1u>* std::__invoke_impl<void, void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()&>(std::__invoke_other, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)&&, void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()&...) /usr/include/c++/10/bits/invoke.h:60:67
#29 0x000000000098e53c _ZSt10__invoke_rIvRZN4llvm8parallel6detail17parallel_for_eachIPNS0_11SmallVectorIN4mlir13OpPassManagerELj1EEEZNS5_6detail17OpToOpPassAdaptor23runOnOperationAsyncImplEbEUlNS0_15MutableArrayRefIS6_EEE_EEvT_SE_T0_EUlvE_JEENSt9enable_ifIXsrSt6__and_IJSt7is_voidISE_ESt14__is_invocableISF_JDpT1_EEEE5valueESE_E4typeEOSF_DpOSN_ /usr/include/c++/10/bits/invoke.h:155:5
#30 0x000000000098d7c6 std::_Function_handler<void (), void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()>::_M_invoke(std::_Any_data const&) /usr/include/c++/10/bits/std_function.h:292:44
#31 0x00000000007f618a std::function<void ()>::operator()() const /usr/include/c++/10/bits/std_function.h:622:71
#32 0x0000000000af305c llvm::parallel::detail::TaskGroup::spawn(std::function<void ()>) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Parallel.cpp:166:1
#33 0x000000000098c2b1 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:140:13
#34 0x000000000098b837 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40
#35 0x000000000098971f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:593:24
#36 0x0000000000988c4b mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:518:1
#37 0x00000000009882e4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:396:28
#38 0x000000000098852f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:440:15
#39 0x000000000098920a mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:68
#40 0x000000000098c371 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7
#41 0x000000000098c312 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:143:16
#42 0x000000000098b837 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40
#43 0x000000000098971f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:593:24
#44 0x0000000000988c4b mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:518:1
#45 0x00000000009882e4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:396:28
#46 0x000000000098852f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:440:15
#47 0x000000000098a58f mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:889:74
#48 0x000000000040963c processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:143:13
#49 0x0000000000409afb main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:197:13
#50 0x00007f6f17a94152 __libc_start_main (/lib64/libc.so.6+0x28152)
#51 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 24: 10266 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2","module top_mod(
  input   clock,
  input   reset
);
endmodule",,,,,,,
572,Assigning to constants!,2021-02-08T22:43:48Z,closed,"bug, ExportVerilog","```
  ; CHECK-LABEL: module IsInvalid(
  ; CHECK-NEXT:    input a);
  module IsInvalid :
    output a: Analog<1>
    a is invalid  @[Place.scala 101]
```
Generates this awesome verilog:
```
module IsInvalid(
  input a);


  `ifndef SYNTHESIS
    alias a = '0;       // Place.scala:101
  `endif
  `ifdef SYNTHESIS
    assign '0 = a;      // Place.scala:101
    assign a = '0;      // Place.scala:101
  `endif // SYNTHESIS
endmodule
```
","; CHECK-LABEL: module IsInvalid(
  ; CHECK-NEXT:    input a);
  module IsInvalid :
    output a: Analog<1>
    a is invalid  @[Place.scala 101]","module IsInvalid(
  input a);


  `ifndef SYNTHESIS
    alias a = '0;       // Place.scala:101
  `endif
  `ifdef SYNTHESIS
    assign '0 = a;      // Place.scala:101
    assign a = '0;      // Place.scala:101
  `endif // SYNTHESIS
endmodule",,,,,,,,
571,[Windows build] Fixing 'invalid' path error,2021-02-08T21:03:04Z,closed,bug,"Windows build was broken by #554's introduction of an ""invalid path"" so the [Windows build](https://github.com/llvm/circt/actions/runs/543081032) wasn't able checkout the repo. Apparently, Windows doesn't allow filenames with only 3 characters...?

Working build: https://github.com/llvm/circt/runs/1858162878?check_suite_focus=true",,,,,,,,,,
570,Windows build warnings,2021-02-08T21:00:39Z,closed,bug,"```
cl : command line warning D9002: ignoring unknown option '-fno-exceptions'
cl : command line warning D9002: ignoring unknown option '-fno-rtti'
```

The `cl` flag for this is different.","cl : command line warning D9002: ignoring unknown option '-fno-exceptions'
cl : command line warning D9002: ignoring unknown option '-fno-rtti'",,,,,,,,,
564,[FIRRTL] Add CheckInitialization Support,2021-02-06T01:53:30Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module mod_0 :
    input tmp1: UInt<5>
    output tmp2: UInt<5>
    tmp2 <= tmp1
  module top_mod :
    input tmp1: UInt<5>
    output tmp2: UInt<5>
    inst U0 of mod_0
```

Compiled with `firtool --lower-to-rtl` produces legit Verilog, but:

Compiled with `firrtl-1.5.0` produces this error:

```python
Exception in thread ""main"" firrtl.passes.PassExceptions: 
firrtl.passes.CheckInitialization$RefNotInitializedException:  : [module top_mod]  Reference U0 is not fully initialized.
   : U0.tmp1 <= VOID
firrtl.passes.CheckInitialization$RefNotInitializedException:  : [module top_mod]  Reference tmp2 is not fully initialized.
   : tmp2 <= VOID
firrtl.passes.PassException: 2 errors detected!
```
","circuit top_mod :
  module mod_0 :
    input tmp1: UInt<5>
    output tmp2: UInt<5>
    tmp2 <= tmp1
  module top_mod :
    input tmp1: UInt<5>
    output tmp2: UInt<5>
    inst U0 of mod_0","Exception in thread ""main"" firrtl.passes.PassExceptions: 
firrtl.passes.CheckInitialization$RefNotInitializedException:  : [module top_mod]  Reference U0 is not fully initialized.
   : U0.tmp1 <= VOID
firrtl.passes.CheckInitialization$RefNotInitializedException:  : [module top_mod]  Reference tmp2 is not fully initialized.
   : tmp2 <= VOID
firrtl.passes.PassException: 2 errors detected!",,,,,,,,
563,[FIRRTL] instance invalid bindings,2021-02-06T01:49:31Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module mod_0 :
    input tmp1: UInt<5>
    output tmp2: UInt<5>
    tmp2 <= tmp1
  module top_mod :
    input tmp1: UInt<5>
    output tmp2: UInt<5>
    inst U0 of mod_0
    U0 is invalid
```

Compiled with `firtool --lower-to-rtl` gives an error:

```mlir
a_top_mod.fir:10:8: error: expected '.' in field reference
    U0 is invalid
       ^
```

Compiled with `firrtl-1.5.0` produces this Verilog:

```verilog
module mod_0(
  input  [4:0] tmp1,
  output [4:0] tmp2
);
  assign tmp2 = tmp1;
endmodule
module top_mod(
  input  [4:0] tmp1,
  output [4:0] tmp2
);
  wire [4:0] U0_tmp1;
  wire [4:0] U0_tmp2;
  mod_0 U0 (
    .tmp1(U0_tmp1),
    .tmp2(U0_tmp2)
  );
  assign tmp2 = U0_tmp2;
  assign U0_tmp1 = tmp1;
endmodule
```
","circuit top_mod :
  module mod_0 :
    input tmp1: UInt<5>
    output tmp2: UInt<5>
    tmp2 <= tmp1
  module top_mod :
    input tmp1: UInt<5>
    output tmp2: UInt<5>
    inst U0 of mod_0
    U0 is invalid","a_top_mod.fir:10:8: error: expected '.' in field reference
    U0 is invalid
       ^","module mod_0(
  input  [4:0] tmp1,
  output [4:0] tmp2
);
  assign tmp2 = tmp1;
endmodule
module top_mod(
  input  [4:0] tmp1,
  output [4:0] tmp2
);
  wire [4:0] U0_tmp1;
  wire [4:0] U0_tmp2;
  mod_0 U0 (
    .tmp1(U0_tmp1),
    .tmp2(U0_tmp2)
  );
  assign tmp2 = U0_tmp2;
  assign U0_tmp1 = tmp1;
endmodule",,,,,,,
559,[FIRRTL] Context Dependent Port Parsing,2021-02-04T21:42:55Z,closed,"bug, FIRRTL","The following circuit is currently valid, but fails parsing:

```scala
circuit Tricky:
  module Tricky:
    input input: UInt<1>
    output output: UInt<1>
    output <= input
```

```bash
firtool Tricky.fir
# Tricky.fir:5:12: error: expected port name
#     output <= input
```","circuit Tricky:
  module Tricky:
    input input: UInt<1>
    output output: UInt<1>
    output <= input","firtool Tricky.fir
# Tricky.fir:5:12: error: expected port name
#     output <= input",,,,,,,,
550,"[FIRRTL] Parsing Problem with Instance Named ""write""",2021-02-03T21:16:34Z,closed,"bug, FIRRTL","The following FIRRTL text fails to parse:

```scala
circuit Foo:
  module Bar:
    input a: Clock
  module Foo:
    input a: Clock

    inst write of Bar
    write.a <= a
```

```bash
firtool Foo.fir
# Foo.fir:8:5: error: bundle value 'write' should only be used from subfield
#     write.a <= a
#     ^
```

However, changing the name of the instance to ""bar"" causes it to parse:

```scala
circuit Foo:
  module Bar:
    input a: Clock
  module Foo:
    input a: Clock

    inst bar of Bar
    bar.a <= a
```","circuit Foo:
  module Bar:
    input a: Clock
  module Foo:
    input a: Clock

    inst write of Bar
    write.a <= a","firtool Foo.fir
# Foo.fir:8:5: error: bundle value 'write' should only be used from subfield
#     write.a <= a
#     ^","circuit Foo:
  module Bar:
    input a: Clock
  module Foo:
    input a: Clock

    inst bar of Bar
    bar.a <= a",,,,,,,
534,HandshakeToFIRRTL should respect FIRRTL requiring classic SSA def-before-use,2021-01-29T18:39:15Z,closed,"bug, Handshake","The following psuedo-IR can be produced by HandshakeToFIRRTL, passes the verifier, but will crash the LowerTypes pass:

```
%0 = firrtl.instance ...
firrtl.connect %0, %1
%1 = firrtl.instance ...
```

The actual test case I have is quite complex, and I'm trying to reduce it to something we can realistically put in a unit test.

The ~solution~ quick fix seems pretty clear: instead of processing every operation in order in the LowerTypes `runOnOperation` function, just track the connects to process, and take a second pass to actually process them. I've implemented this already, and will share a PR once I've reduced a reasonable test case.","%0 = firrtl.instance ...
firrtl.connect %0, %1
%1 = firrtl.instance ...",,,,,,,,,
525,Verilog emitter will output invalid or reserved names,2021-01-27T20:55:41Z,closed,"bug, ExportVerilog","for example, a port name struct.",,,,,,,,,,
520,[FIRRTL] lower-types does not support external modules,2021-01-27T09:28:13Z,closed,"bug, FIRRTL","The lower types pass flattens bundles returned from `firrtl.instance` operations.  When there is an instance of an `firrtl.extmodule`, the instance is flattened while the module declaration is not. The pass should be extended to flatten bundles in external module declarations

Test Case:
``` mlir
// circt-opt -pass-pipeline='firrtl.circuit(firrtl.module(firrtl-lower-types))' ./external-module-lower-bundles.mlir
module  {
  firrtl.circuit ""Test"" {
    firrtl.extmodule @ExternalModule(!firrtl.bundle<valid: uint<1>, ready: flip<uint<1>>, data: uint<64>> {firrtl.name = ""source""})
    firrtl.module @Test() {
      %inst_source = firrtl.instance @ExternalModule {name = """", portNames = [""source""]} : !firrtl.bundle<valid: flip<uint<1>>, ready: uint<1>, data: flip<uint<64>>>
    }
  }
}
```
```
./external-module-lower-bundles.mlir:6:16: error: 'firrtl.instance' op has a wrong number of results; expected 1 but got 3
    %sourceV = firrtl.instance @ExternalModule {name = """", portNames = [""source""]} : !firrtl.bundle<valid: flip<uint<1>>, ready: uint<1>, data: flip<uint<64>>>
               ^
./external-module-lower-bundles.mlir:6:16: note: see current operation: %inst_source_valid, %inst_source_ready, %inst_source_data = ""firrtl.instance""() {moduleName = @ExternalModule, name = """", portNames = [""source_valid"", ""source_ready"", ""source_data""]} : () -> (!firrtl.flip<uint<1>>, !firrtl.uint<1>, !firrtl.flip<uint<64>>)
./external-module-lower-bundles.mlir:3:3: note: original module declared here
  firrtl.extmodule @ExternalModule(%source: !firrtl.bundle<valid: uint<1>, ready: flip<uint<1>>, data: uint<64>>)
```
","mlir
// circt-opt -pass-pipeline='firrtl.circuit(firrtl.module(firrtl-lower-types))' ./external-module-lower-bundles.mlir
module  {
  firrtl.circuit ""Test"" {
    firrtl.extmodule @ExternalModule(!firrtl.bundle<valid: uint<1>, ready: flip<uint<1>>, data: uint<64>> {firrtl.name = ""source""})
    firrtl.module @Test() {
      %inst_source = firrtl.instance @ExternalModule {name = """", portNames = [""source""]} : !firrtl.bundle<valid: flip<uint<1>>, ready: uint<1>, data: flip<uint<64>>>
    }
  }
}","./external-module-lower-bundles.mlir:6:16: error: 'firrtl.instance' op has a wrong number of results; expected 1 but got 3
    %sourceV = firrtl.instance @ExternalModule {name = """", portNames = [""source""]} : !firrtl.bundle<valid: flip<uint<1>>, ready: uint<1>, data: flip<uint<64>>>
               ^
./external-module-lower-bundles.mlir:6:16: note: see current operation: %inst_source_valid, %inst_source_ready, %inst_source_data = ""firrtl.instance""() {moduleName = @ExternalModule, name = """", portNames = [""source_valid"", ""source_ready"", ""source_data""]} : () -> (!firrtl.flip<uint<1>>, !firrtl.uint<1>, !firrtl.flip<uint<64>>)
./external-module-lower-bundles.mlir:3:3: note: original module declared here
  firrtl.extmodule @ExternalModule(%source: !firrtl.bundle<valid: uint<1>, ready: flip<uint<1>>, data: uint<64>>)",,,,,,,,
516,[FIRRTL] (div) 0-width (core dump),2021-01-26T23:49:54Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_0: UInt<0>
    output tmp3: UInt<0>
    tmp3 <= div(inp_0, inp_0)
```

Compiled with `firtool --lower-to-rtl --verilog` gives an error:

```mlir
firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:280: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && ""bitwidth too small""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v
 #0 0x00000000004c196b llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004c1a22 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004bfa22 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004c13be SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007fdbbd4691d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007fdbbcf28ae5 raise (/lib64/libc.so.6+0x3dae5)
 #6 0x00007fdbbcf11864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007fdbbcf11749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007fdbbcf21016 (/lib64/libc.so.6+0x36016)
 #9 0x000000000045c0ee llvm::APInt::APInt(unsigned int, unsigned long, bool) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:281:21
#10 0x000000000064d587 mlir::IntegerAttr::get(mlir::Type, long) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/BuiltinAttributes.cpp:307:79
#11 0x00000000007a4a92 circt::firrtl::DivPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/FIRRTLFolds.cpp:68:69
#12 0x00000000007993ca mlir::LogicalResult mlir::Op<circt::firrtl::DivPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::IntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::DivPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1619:53
#13 0x00000000006d8946 mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3
#14 0x00000000006d1fb0 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30
#15 0x00000000008a6ca3 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13
#16 0x00000000008a6602 mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13
#17 0x000000000088b3d1 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#18 0x000000000088b6fc mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#19 0x000000000088b5e8 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#20 0x0000000000746aea (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3
#21 0x0000000000974a85 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36
#22 0x0000000000974cb1 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15
#23 0x0000000000976cc6 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:885:74
#24 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13
#25 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13
#26 0x00007fdbbcf13152 __libc_start_main (/lib64/libc.so.6+0x28152)
#27 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 14: 11144 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=$VFILE2
```

Compiled with `firrtl-1.5.0` produces this Verilog:

```verilog
module top_mod(
);
endmodule
```
","circuit top_mod :
  module top_mod :
    input inp_0: UInt<0>
    output tmp3: UInt<0>
    tmp3 <= div(inp_0, inp_0)","firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:280: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && ""bitwidth too small""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v
 #0 0x00000000004c196b llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004c1a22 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004bfa22 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004c13be SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007fdbbd4691d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007fdbbcf28ae5 raise (/lib64/libc.so.6+0x3dae5)
 #6 0x00007fdbbcf11864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007fdbbcf11749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007fdbbcf21016 (/lib64/libc.so.6+0x36016)
 #9 0x000000000045c0ee llvm::APInt::APInt(unsigned int, unsigned long, bool) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:281:21
#10 0x000000000064d587 mlir::IntegerAttr::get(mlir::Type, long) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/BuiltinAttributes.cpp:307:79
#11 0x00000000007a4a92 circt::firrtl::DivPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/FIRRTLFolds.cpp:68:69
#12 0x00000000007993ca mlir::LogicalResult mlir::Op<circt::firrtl::DivPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::IntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::DivPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1619:53
#13 0x00000000006d8946 mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3
#14 0x00000000006d1fb0 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30
#15 0x00000000008a6ca3 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13
#16 0x00000000008a6602 mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13
#17 0x000000000088b3d1 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#18 0x000000000088b6fc mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#19 0x000000000088b5e8 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#20 0x0000000000746aea (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3
#21 0x0000000000974a85 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36
#22 0x0000000000974cb1 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15
#23 0x0000000000976cc6 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:885:74
#24 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13
#25 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13
#26 0x00007fdbbcf13152 __libc_start_main (/lib64/libc.so.6+0x28152)
#27 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 14: 11144 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=$VFILE2","module top_mod(
);
endmodule",,,,,,,
511,[FIRRTL] circuit with a register (core dump),2021-01-26T04:16:43Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input inp_0: UInt<1>
    output tmp1: UInt<1>
    reg _tmp2: UInt<1>, clock with: (reset => (reset, UInt<1>(0)))
    _tmp2 <= inp_0
    tmp1 <= _tmp2
```

Compiled with `firtool --lower-to-rtl --verilog` gives an error:

```mlir
firtool: ../llvm/llvm/include/llvm/ADT/ilist_iterator.h:138: llvm::ilist_iterator<OptionsT, IsReverse, IsConst>::reference llvm::ilist_iterator<OptionsT, IsReverse, IsConst>::operator*() const [with OptionsT = llvm::ilist_detail::node_options<mlir::Block, true, false, void>; bool IsReverse = false; bool IsConst = false; llvm::ilist_iterator<OptionsT, IsReverse, IsConst>::reference = mlir::Block&]: Assertion `!NodePtr->isKnownSentinel()' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v
 #0 0x00000000004c196b llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004c1a22 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004bfa22 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004c13be SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f28169991d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007f2816458ae5 raise (/lib64/libc.so.6+0x3dae5)
 #6 0x00007f2816441864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f2816441749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f2816451016 (/lib64/libc.so.6+0x36016)
 #9 0x000000000040e32d llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Block, true, false, void>, false, false>::operator*() const /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/ilist_iterator.h:139:33
#10 0x000000000040c8c0 llvm::simple_ilist<mlir::Block>::front() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/simple_ilist.h:138:40
#11 0x000000000040bb0c mlir::Region::front() /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/Region.h:61:43
#12 0x000000000050e3ac circt::sv::AlwaysFFOp::getResetBlock() /home/drom/work/github/llvm/circt/build/include/circt/Dialect/SV/SV.h.inc:243:58
#13 0x0000000000502b4f (anonymous namespace)::ModuleEmitter::visitSV(circt::sv::AlwaysFFOp) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:1500:23
#14 0x00000000005095f9 mlir::LogicalResult circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::sv::AlwaysFFOp>(auto) const /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/SV/SVVisitors.h:43:13
#15 0x0000000000509275 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::sv::AlwaysFFOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(mlir::LogicalResult&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:116:22
#16 0x0000000000508ed1 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42
#17 0x0000000000508b33 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3
#18 0x0000000000508681 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3
#19 0x0000000000507c67 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::IfDefOp, circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3
#20 0x00000000005074af llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::RegOp, circt::sv::IfDefOp, circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3
#21 0x0000000000506bab llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::TextualValueOp, circt::sv::RegOp, circt::sv::IfDefOp, circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3
#22 0x00000000005063d0 circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/SV/SVVisitors.h:42:52
#23 0x0000000000504cd8 (anonymous namespace)::ModuleEmitter::emitOperation(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:1929:16
#24 0x0000000000505757 (anonymous namespace)::ModuleEmitter::emitRTLModule(circt::rtl::RTLModuleOp) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:2058:40
#25 0x0000000000505908 (anonymous namespace)::MLIRModuleEmitter::emit(mlir::ModuleOp) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:2084:7
#26 0x0000000000505abd circt::exportVerilog(mlir::ModuleOp, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:2097:24
#27 0x00000000004096f0 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:153:44
#28 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13
#29 0x00007f2816443152 __libc_start_main (/lib64/libc.so.6+0x28152)
#30 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 14: 29799 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=$VFILE2
```

Compiled with `firrtl-1.5.0` produces this Verilog:

```verilog
module top_mod(
  input   clock,
  input   reset,
  input   inp_0,
  output  tmp1
);
`ifdef RANDOMIZE_REG_INIT
  reg [31:0] _RAND_0;
`endif // RANDOMIZE_REG_INIT
  reg  _tmp2;
  assign tmp1 = _tmp2;
  always @(posedge clock) begin
    if (reset) begin
      _tmp2 <= 1'h0;
    end else begin
      _tmp2 <= inp_0;
    end
  end
// Register and memory initialization
`ifdef RANDOMIZE_GARBAGE_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_INVALID_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_REG_INIT
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_MEM_INIT
`define RANDOMIZE
`endif
`ifndef RANDOM
`define RANDOM $random
`endif
`ifdef RANDOMIZE_MEM_INIT
  integer initvar;
`endif
`ifndef SYNTHESIS
`ifdef FIRRTL_BEFORE_INITIAL
`FIRRTL_BEFORE_INITIAL
`endif
initial begin
  `ifdef RANDOMIZE
    `ifdef INIT_RANDOM
      `INIT_RANDOM
    `endif
    `ifndef VERILATOR
      `ifdef RANDOMIZE_DELAY
        #`RANDOMIZE_DELAY begin end
      `else
        #0.002 begin end
      `endif
    `endif
`ifdef RANDOMIZE_REG_INIT
  _RAND_0 = {1{`RANDOM}};
  _tmp2 = _RAND_0[0:0];
`endif // RANDOMIZE_REG_INIT
  `endif // RANDOMIZE
end // initial
`ifdef FIRRTL_AFTER_INITIAL
`FIRRTL_AFTER_INITIAL
`endif
`endif // SYNTHESIS
endmodule
```
","circuit top_mod :
  module top_mod :
    input clock: Clock
    input reset: UInt<1>
    input inp_0: UInt<1>
    output tmp1: UInt<1>
    reg _tmp2: UInt<1>, clock with: (reset => (reset, UInt<1>(0)))
    _tmp2 <= inp_0
    tmp1 <= _tmp2","firtool: ../llvm/llvm/include/llvm/ADT/ilist_iterator.h:138: llvm::ilist_iterator<OptionsT, IsReverse, IsConst>::reference llvm::ilist_iterator<OptionsT, IsReverse, IsConst>::operator*() const [with OptionsT = llvm::ilist_detail::node_options<mlir::Block, true, false, void>; bool IsReverse = false; bool IsConst = false; llvm::ilist_iterator<OptionsT, IsReverse, IsConst>::reference = mlir::Block&]: Assertion `!NodePtr->isKnownSentinel()' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v
 #0 0x00000000004c196b llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004c1a22 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004bfa22 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004c13be SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f28169991d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007f2816458ae5 raise (/lib64/libc.so.6+0x3dae5)
 #6 0x00007f2816441864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f2816441749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f2816451016 (/lib64/libc.so.6+0x36016)
 #9 0x000000000040e32d llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Block, true, false, void>, false, false>::operator*() const /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/ilist_iterator.h:139:33
#10 0x000000000040c8c0 llvm::simple_ilist<mlir::Block>::front() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/simple_ilist.h:138:40
#11 0x000000000040bb0c mlir::Region::front() /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/Region.h:61:43
#12 0x000000000050e3ac circt::sv::AlwaysFFOp::getResetBlock() /home/drom/work/github/llvm/circt/build/include/circt/Dialect/SV/SV.h.inc:243:58
#13 0x0000000000502b4f (anonymous namespace)::ModuleEmitter::visitSV(circt::sv::AlwaysFFOp) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:1500:23
#14 0x00000000005095f9 mlir::LogicalResult circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::sv::AlwaysFFOp>(auto) const /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/SV/SVVisitors.h:43:13
#15 0x0000000000509275 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::sv::AlwaysFFOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(mlir::LogicalResult&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:116:22
#16 0x0000000000508ed1 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42
#17 0x0000000000508b33 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3
#18 0x0000000000508681 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3
#19 0x0000000000507c67 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::IfDefOp, circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3
#20 0x00000000005074af llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::RegOp, circt::sv::IfDefOp, circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3
#21 0x0000000000506bab llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::TextualValueOp, circt::sv::RegOp, circt::sv::IfDefOp, circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3
#22 0x00000000005063d0 circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/SV/SVVisitors.h:42:52
#23 0x0000000000504cd8 (anonymous namespace)::ModuleEmitter::emitOperation(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:1929:16
#24 0x0000000000505757 (anonymous namespace)::ModuleEmitter::emitRTLModule(circt::rtl::RTLModuleOp) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:2058:40
#25 0x0000000000505908 (anonymous namespace)::MLIRModuleEmitter::emit(mlir::ModuleOp) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:2084:7
#26 0x0000000000505abd circt::exportVerilog(mlir::ModuleOp, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:2097:24
#27 0x00000000004096f0 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:153:44
#28 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13
#29 0x00007f2816443152 __libc_start_main (/lib64/libc.so.6+0x28152)
#30 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
./process1.sh: line 14: 29799 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=$VFILE2","module top_mod(
  input   clock,
  input   reset,
  input   inp_0,
  output  tmp1
);
`ifdef RANDOMIZE_REG_INIT
  reg [31:0] _RAND_0;
`endif // RANDOMIZE_REG_INIT
  reg  _tmp2;
  assign tmp1 = _tmp2;
  always @(posedge clock) begin
    if (reset) begin
      _tmp2 <= 1'h0;
    end else begin
      _tmp2 <= inp_0;
    end
  end
// Register and memory initialization
`ifdef RANDOMIZE_GARBAGE_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_INVALID_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_REG_INIT
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_MEM_INIT
`define RANDOMIZE
`endif
`ifndef RANDOM
`define RANDOM $random
`endif
`ifdef RANDOMIZE_MEM_INIT
  integer initvar;
`endif
`ifndef SYNTHESIS
`ifdef FIRRTL_BEFORE_INITIAL
`FIRRTL_BEFORE_INITIAL
`endif
initial begin
  `ifdef RANDOMIZE
    `ifdef INIT_RANDOM
      `INIT_RANDOM
    `endif
    `ifndef VERILATOR
      `ifdef RANDOMIZE_DELAY
        #`RANDOMIZE_DELAY begin end
      `else
        #0.002 begin end
      `endif
    `endif
`ifdef RANDOMIZE_REG_INIT
  _RAND_0 = {1{`RANDOM}};
  _tmp2 = _RAND_0[0:0];
`endif // RANDOMIZE_REG_INIT
  `endif // RANDOMIZE
end // initial
`ifdef FIRRTL_AFTER_INITIAL
`FIRRTL_AFTER_INITIAL
`endif
`endif // SYNTHESIS
endmodule",,,,,,,
508,Sensitivity list for always* blocks could include expressions,2021-01-25T19:45:12Z,closed,"bug, ExportVerilog","always* blocks should be emitted with names in the sensitivity list, not inline expressions.  Thus anything that might be in a sensitivity list must be output first to an assign statement and referenced by name.
consider:
```
%clk = %clk2+ %clk2
always posedge clk
```
will output something like
```
always @(posedge (clk2 + clk3)
```
which is wrong ","%clk = %clk2+ %clk2
always posedge clk",always @(posedge (clk2 + clk3),,,,,,,,
507,[FIRRTL] Lower Types Fails for Certain Nested Bundles,2021-01-25T18:28:47Z,closed,"bug, FIRRTL","The `LowerTypes` pass has problems with nested aggregates. Consider the following example:

```scala
circuit Foo :
  module Foo :
    input a: { b: {c: UInt<1>}}
    output b: { b: {c: UInt<1>}}

    b <= a
```

```bash
firtool -lower-to-rtl -enable-lower-types -verilog Foo.fir
# Assertion failed: (entry && ""bundle lowering was not set""), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 530.
```

I believe this is trying to find a lowering for the non-leaf types, but such a lowering was never recorded.","circuit Foo :
  module Foo :
    input a: { b: {c: UInt<1>}}
    output b: { b: {c: UInt<1>}}

    b <= a","firtool -lower-to-rtl -enable-lower-types -verilog Foo.fir
# Assertion failed: (entry && ""bundle lowering was not set""), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 530.",,,,,,,,
492,[FIRRTL] Write Only Memory Causes Type Error,2021-01-21T02:12:24Z,closed,"bug, FIRRTL","If you try to create a memory that only has a writer, the type of the memory will be `FlipType` due to type canonicalization. However, this then fails the ODS requirement that a memory is a `BundleType`. I ran into this from a different direction when working on #479/#488 where this problem will always happen when returning a variadic `BundleType` (the write port will always be flipped).

Consider:

```
circuit Bar :
  module Bar :
    input clock: Clock
    input wAddr: UInt<4>
    input wEn: UInt<1>
    input wMask: UInt<1>
    input wData: UInt<8>

    mem memory:
      data-type => UInt<8>
      depth => 16
      writer => w
      read-latency => 0
      write-latency => 1
      read-under-write => undefined

    memory.w.clk <= clock
    memory.w.en <= wEn
    memory.w.addr <= wAddr
    memory.w.mask <= wMask
    memory.w.data <= wData
```

This will fail with:

```bash
firtool Bar.fir
# Bar.fir:9:5: error: 'firrtl.mem' op result #0 must be BundleType, but got '!firrtl.flip<bundle<w: bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>>>'
#     mem memory:
#     ^
# Bar.fir:9:5: note: see current operation: %memory = ""firrtl.mem""() {depth = 16 : i64, name = ""memory"", readLatency = 0 : i32, ruw = 0 : i32, writeLatency = 1 : i32} : () -> !firrtl.flip<bundle<w: bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>>>
```

The SFC will return an empty module:

```
module Bar(
  input        clock,
  input  [3:0] wAddr,
  input        wEn,
  input        wMask,
  input  [7:0] wData
);
endmodule
```

I admit that intentional description of a memory hole is a weird one...","circuit Bar :
  module Bar :
    input clock: Clock
    input wAddr: UInt<4>
    input wEn: UInt<1>
    input wMask: UInt<1>
    input wData: UInt<8>

    mem memory:
      data-type => UInt<8>
      depth => 16
      writer => w
      read-latency => 0
      write-latency => 1
      read-under-write => undefined

    memory.w.clk <= clock
    memory.w.en <= wEn
    memory.w.addr <= wAddr
    memory.w.mask <= wMask
    memory.w.data <= wData","firtool Bar.fir
# Bar.fir:9:5: error: 'firrtl.mem' op result #0 must be BundleType, but got '!firrtl.flip<bundle<w: bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>>>'
#     mem memory:
#     ^
# Bar.fir:9:5: note: see current operation: %memory = ""firrtl.mem""() {depth = 16 : i64, name = ""memory"", readLatency = 0 : i32, ruw = 0 : i32, writeLatency = 1 : i32} : () -> !firrtl.flip<bundle<w: bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>>>","module Bar(
  input        clock,
  input  [3:0] wAddr,
  input        wEn,
  input        wMask,
  input  [7:0] wData
);
endmodule",,,,,,,
480,[FIRRTL] Handle read-write memory ports,2021-01-18T18:43:37Z,closed,"bug, FIRRTL","Currently, any read-write memory ports get dropped during conversion to RTL with an error (but no hard exit from `firtool`). These, as the error message suggests, should be split up into separate read and write ports sometime before conversion to RTL to align with how the SFC handles these. Alternatively, these could be directly lowered to some structure that more directly expressions a true read/write port.

The main question is whether this should be a new pass or if this should be handled during an existing pass/conversion.

### Example

Consider the following FIRRTL circuit:

```
circuit Foo :
  module Foo :
    input clock: Clock
    input rwMode: UInt<1>
    input rwEn: UInt<1>
    input rwAddr: UInt<1>
    input rwMask: UInt<1>
    input rwDataIn: UInt<8>
    output rwDataOut: UInt<8>

    mem memory:
      data-type => UInt<8>
      depth => 16
      readwriter => rw
      read-latency => 0
      write-latency => 1
      read-under-write => undefined

    memory.rw.clk <= clock
    memory.rw.wmode <= rwMode
    memory.rw.en <= rwEn
    memory.rw.addr <= rwAddr
    memory.rw.wdata <= rwDataIn
    memory.rw.wmask <= rwMask
    rwDataOut <= memory.rw.rdata
```

The SFC will, during the `VerilogMemDelays` pass, split this into separate read and write ports. After that, the circuit looks like:

```
circuit Foo :
  module Foo :
    input clock : Clock
    input rwMode : UInt<1>
    input rwEn : UInt<1>
    input rwAddr : UInt<1>
    input rwMask : UInt<1>
    input rwDataIn : UInt<8>
    output rwDataOut : UInt<8>

    mem memory :
      data-type => UInt<8>
      depth => 16
      read-latency => 0
      write-latency => 1
      reader => rw_r
      writer => rw_w
      read-under-write => undefined
    rwDataOut <= memory.rw_r.data
    memory.rw_r.en <= and(rwEn, not(rwMode))
    memory.rw_r.addr <= pad(rwAddr, 4)
    memory.rw_r.clk <= clock
    memory.rw_w.en <= and(rwEn, rwMode)
    memory.rw_w.addr <= pad(rwAddr, 4)
    memory.rw_w.mask <= rwMask
    memory.rw_w.data <= rwDataIn
    memory.rw_w.clk <= clock
```

Currently, if we run the original FIRRTL IR through `firtool`, the memory is just dropped.","circuit Foo :
  module Foo :
    input clock: Clock
    input rwMode: UInt<1>
    input rwEn: UInt<1>
    input rwAddr: UInt<1>
    input rwMask: UInt<1>
    input rwDataIn: UInt<8>
    output rwDataOut: UInt<8>

    mem memory:
      data-type => UInt<8>
      depth => 16
      readwriter => rw
      read-latency => 0
      write-latency => 1
      read-under-write => undefined

    memory.rw.clk <= clock
    memory.rw.wmode <= rwMode
    memory.rw.en <= rwEn
    memory.rw.addr <= rwAddr
    memory.rw.wdata <= rwDataIn
    memory.rw.wmask <= rwMask
    rwDataOut <= memory.rw.rdata","circuit Foo :
  module Foo :
    input clock : Clock
    input rwMode : UInt<1>
    input rwEn : UInt<1>
    input rwAddr : UInt<1>
    input rwMask : UInt<1>
    input rwDataIn : UInt<8>
    output rwDataOut : UInt<8>

    mem memory :
      data-type => UInt<8>
      depth => 16
      read-latency => 0
      write-latency => 1
      reader => rw_r
      writer => rw_w
      read-under-write => undefined
    rwDataOut <= memory.rw_r.data
    memory.rw_r.en <= and(rwEn, not(rwMode))
    memory.rw_r.addr <= pad(rwAddr, 4)
    memory.rw_r.clk <= clock
    memory.rw_w.en <= and(rwEn, rwMode)
    memory.rw_w.addr <= pad(rwAddr, 4)
    memory.rw_w.mask <= rwMask
    memory.rw_w.data <= rwDataIn
    memory.rw_w.clk <= clock",,,,,,,,
478,[FIRRTL] LowerTypes with memories crashes LowerToRTL,2021-01-18T18:00:07Z,closed,"bug, FIRRTL","Running a memory through `LowerTypes` followed by `LowerToRTL` causes a crash. (**edit**: Originally I thought this was related to memories with aggregate types, but it's actually _any_ memory.)

E.g., the following will crash with `firtool -enable-lower-types -lower-to-rtl`:

```
circuit Foo :
  module Foo :
    input clock: Clock
    input readAddr: UInt<4>
    input readEn: UInt<1>
    output readData: UInt<8>

    mem memory:
      data-type => UInt<8>
      depth => 16
      reader => r
      read-latency => 0
      write-latency => 1
      read-under-write => undefined

    memory.r.clk <= clock
    memory.r.en <= readEn
    memory.r.addr <= readAddr
    readData <= memory.r.data
```

```
Assertion failed: (entry && ""bundle lowering was not set""), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 400.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.	Program arguments: firtool -lower-to-rtl -enable-lower-types Foo.fir
1.	2.	Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x000000010957a16d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x000000010957a71b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x00000001095783bb llvm::sys::RunSignalHandlers() + 123
3  firtool                  0x000000010957ca68 SignalHandler(int) + 232
4  libsystem_platform.dylib 0x00007fff203aad7d _sigtramp + 29
5  firtool                  0x0000000109e9dd70 llvm::ColorCategory + 211904
6  libsystem_c.dylib        0x00007fff202b9720 abort + 120
7  libsystem_c.dylib        0x00007fff202b89d6 err + 0
8  firtool                  0x00000001096bfac3 (anonymous namespace)::FIRRTLTypesLowering::getBundleLowering(mlir::Value, llvm::StringRef) + 211
9  firtool                  0x00000001096bf810 (anonymous namespace)::FIRRTLTypesLowering::visitExpr(circt::firrtl::SubfieldOp) + 384
10 firtool                  0x00000001096bf67b void circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::SubfieldOp>(auto) const + 43
11 firtool                  0x00000001096bf5c1 llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::SubfieldOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(void&&) + 113
12 firtool                  0x00000001096bf445 llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::SubfieldOp, circt::firrtl::SubindexOp, circt::firrtl::SubaccessOp, circt::firrtl::AddPrimOp, circt::firrtl::SubPrimOp, circt::firrtl::MulPrimOp, circt::firrtl::DivPrimOp, circt::firrtl::RemPrimOp, circt::firrtl::AndPrimOp, circt::firrtl::OrPrimOp, circt::firrtl::XorPrimOp, circt::firrtl::LEQPrimOp, circt::firrtl::LTPrimOp, circt::firrtl::GEQPrimOp, circt::firrtl::GTPrimOp, circt::firrtl::EQPrimOp, circt::firrtl::NEQPrimOp, circt::firrtl::CatPrimOp, circt::firrtl::DShlPrimOp, circt::firrtl::DShlwPrimOp, circt::firrtl::DShrPrimOp, circt::firrtl::ValidIfPrimOp, circt::firrtl::AsSIntPrimOp, circt::firrtl::AsUIntPrimOp, circt::firrtl::AsAsyncResetPrimOp, circt::firrtl::AsClockPrimOp, circt::firrtl::CvtPrimOp, circt::firrtl::NegPrimOp, circt::firrtl::NotPrimOp, circt::firrtl::AndRPrimOp, circt::firrtl::OrRPrimOp, circt::firrtl::XorRPrimOp, circt::firrtl::BitsPrimOp, circt::firrtl::HeadPrimOp, circt::firrtl::InvalidValuePrimOp, circt::firrtl::MuxPrimOp, circt::firrtl::PadPrimOp, circt::firrtl::ShlPrimOp, circt::firrtl::ShrPrimOp, circt::firrtl::TailPrimOp, circt::firrtl::AsPassivePrimOp, circt::firrtl::AsNonPassivePrimOp, circt::firrtl::StdIntCastOp, circt::firrtl::AnalogInOutCastOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&) + 37
13 firtool                  0x00000001096bf2e1 llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::ConstantOp, circt::firrtl::SubfieldOp, circt::firrtl::SubindexOp, circt::firrtl::SubaccessOp, circt::firrtl::AddPrimOp, circt::firrtl::SubPrimOp, circt::firrtl::MulPrimOp, circt::firrtl::DivPrimOp, circt::firrtl::RemPrimOp, circt::firrtl::AndPrimOp, circt::firrtl::OrPrimOp, circt::firrtl::XorPrimOp, circt::firrtl::LEQPrimOp, circt::firrtl::LTPrimOp, circt::firrtl::GEQPrimOp, circt::firrtl::GTPrimOp, circt::firrtl::EQPrimOp, circt::firrtl::NEQPrimOp, circt::firrtl::CatPrimOp, circt::firrtl::DShlPrimOp, circt::firrtl::DShlwPrimOp, circt::firrtl::DShrPrimOp, circt::firrtl::ValidIfPrimOp, circt::firrtl::AsSIntPrimOp, circt::firrtl::AsUIntPrimOp, circt::firrtl::AsAsyncResetPrimOp, circt::firrtl::AsClockPrimOp, circt::firrtl::CvtPrimOp, circt::firrtl::NegPrimOp, circt::firrtl::NotPrimOp, circt::firrtl::AndRPrimOp, circt::firrtl::OrRPrimOp, circt::firrtl::XorRPrimOp, circt::firrtl::BitsPrimOp, circt::firrtl::HeadPrimOp, circt::firrtl::InvalidValuePrimOp, circt::firrtl::MuxPrimOp, circt::firrtl::PadPrimOp, circt::firrtl::ShlPrimOp, circt::firrtl::ShrPrimOp, circt::firrtl::TailPrimOp, circt::firrtl::AsPassivePrimOp, circt::firrtl::AsNonPassivePrimOp, circt::firrtl::StdIntCastOp, circt::firrtl::AnalogInOutCastOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&&) + 49
14 firtool                  0x00000001096bf25d circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*) + 61
15 firtool                  0x00000001096bbd60 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchVisitor(mlir::Operation*) + 32
16 firtool                  0x00000001096ba19e (anonymous namespace)::FIRRTLTypesLowering::runOnOperation() + 670
17 firtool                  0x0000000109d4f7e5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 661
18 firtool                  0x0000000109d4fef7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359
19 firtool                  0x0000000109d67ccf mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const + 559
20 firtool                  0x0000000109d66002 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8 std::__1::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 82
21 firtool                  0x0000000109d65f73 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 499
22 firtool                  0x0000000109d51734 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 180
23 firtool                  0x0000000109d50d3f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 1279
24 firtool                  0x0000000109d4fb2d mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) + 77
25 firtool                  0x0000000109d4f7d0 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 640
26 firtool                  0x0000000109d4fef7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359
27 firtool                  0x0000000109d67ccf mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const + 559
28 firtool                  0x0000000109d66002 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8 std::__1::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 82
29 firtool                  0x0000000109d65f73 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 499
30 firtool                  0x0000000109d51734 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 180
31 firtool                  0x0000000109d50d3f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 1279
32 firtool                  0x0000000109d4fb2d mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) + 77
33 firtool                  0x0000000109d4f7d0 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 640
34 firtool                  0x0000000109d4fef7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359
35 firtool                  0x0000000109d526c1 mlir::PassManager::run(mlir::Operation*) + 657
36 firtool                  0x00000001093ee356 processBuffer(std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) + 1238
37 firtool                  0x00000001093edb01 main + 897
38 libdyld.dylib            0x00007fff20381621 start + 1
39 libdyld.dylib            0x0000000000000004 start + 18446603339975616996
```","circuit Foo :
  module Foo :
    input clock: Clock
    input readAddr: UInt<4>
    input readEn: UInt<1>
    output readData: UInt<8>

    mem memory:
      data-type => UInt<8>
      depth => 16
      reader => r
      read-latency => 0
      write-latency => 1
      read-under-write => undefined

    memory.r.clk <= clock
    memory.r.en <= readEn
    memory.r.addr <= readAddr
    readData <= memory.r.data","Assertion failed: (entry && ""bundle lowering was not set""), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 400.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.	Program arguments: firtool -lower-to-rtl -enable-lower-types Foo.fir
1.	2.	Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x000000010957a16d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x000000010957a71b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x00000001095783bb llvm::sys::RunSignalHandlers() + 123
3  firtool                  0x000000010957ca68 SignalHandler(int) + 232
4  libsystem_platform.dylib 0x00007fff203aad7d _sigtramp + 29
5  firtool                  0x0000000109e9dd70 llvm::ColorCategory + 211904
6  libsystem_c.dylib        0x00007fff202b9720 abort + 120
7  libsystem_c.dylib        0x00007fff202b89d6 err + 0
8  firtool                  0x00000001096bfac3 (anonymous namespace)::FIRRTLTypesLowering::getBundleLowering(mlir::Value, llvm::StringRef) + 211
9  firtool                  0x00000001096bf810 (anonymous namespace)::FIRRTLTypesLowering::visitExpr(circt::firrtl::SubfieldOp) + 384
10 firtool                  0x00000001096bf67b void circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::SubfieldOp>(auto) const + 43
11 firtool                  0x00000001096bf5c1 llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::SubfieldOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(void&&) + 113
12 firtool                  0x00000001096bf445 llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::SubfieldOp, circt::firrtl::SubindexOp, circt::firrtl::SubaccessOp, circt::firrtl::AddPrimOp, circt::firrtl::SubPrimOp, circt::firrtl::MulPrimOp, circt::firrtl::DivPrimOp, circt::firrtl::RemPrimOp, circt::firrtl::AndPrimOp, circt::firrtl::OrPrimOp, circt::firrtl::XorPrimOp, circt::firrtl::LEQPrimOp, circt::firrtl::LTPrimOp, circt::firrtl::GEQPrimOp, circt::firrtl::GTPrimOp, circt::firrtl::EQPrimOp, circt::firrtl::NEQPrimOp, circt::firrtl::CatPrimOp, circt::firrtl::DShlPrimOp, circt::firrtl::DShlwPrimOp, circt::firrtl::DShrPrimOp, circt::firrtl::ValidIfPrimOp, circt::firrtl::AsSIntPrimOp, circt::firrtl::AsUIntPrimOp, circt::firrtl::AsAsyncResetPrimOp, circt::firrtl::AsClockPrimOp, circt::firrtl::CvtPrimOp, circt::firrtl::NegPrimOp, circt::firrtl::NotPrimOp, circt::firrtl::AndRPrimOp, circt::firrtl::OrRPrimOp, circt::firrtl::XorRPrimOp, circt::firrtl::BitsPrimOp, circt::firrtl::HeadPrimOp, circt::firrtl::InvalidValuePrimOp, circt::firrtl::MuxPrimOp, circt::firrtl::PadPrimOp, circt::firrtl::ShlPrimOp, circt::firrtl::ShrPrimOp, circt::firrtl::TailPrimOp, circt::firrtl::AsPassivePrimOp, circt::firrtl::AsNonPassivePrimOp, circt::firrtl::StdIntCastOp, circt::firrtl::AnalogInOutCastOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&) + 37
13 firtool                  0x00000001096bf2e1 llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::ConstantOp, circt::firrtl::SubfieldOp, circt::firrtl::SubindexOp, circt::firrtl::SubaccessOp, circt::firrtl::AddPrimOp, circt::firrtl::SubPrimOp, circt::firrtl::MulPrimOp, circt::firrtl::DivPrimOp, circt::firrtl::RemPrimOp, circt::firrtl::AndPrimOp, circt::firrtl::OrPrimOp, circt::firrtl::XorPrimOp, circt::firrtl::LEQPrimOp, circt::firrtl::LTPrimOp, circt::firrtl::GEQPrimOp, circt::firrtl::GTPrimOp, circt::firrtl::EQPrimOp, circt::firrtl::NEQPrimOp, circt::firrtl::CatPrimOp, circt::firrtl::DShlPrimOp, circt::firrtl::DShlwPrimOp, circt::firrtl::DShrPrimOp, circt::firrtl::ValidIfPrimOp, circt::firrtl::AsSIntPrimOp, circt::firrtl::AsUIntPrimOp, circt::firrtl::AsAsyncResetPrimOp, circt::firrtl::AsClockPrimOp, circt::firrtl::CvtPrimOp, circt::firrtl::NegPrimOp, circt::firrtl::NotPrimOp, circt::firrtl::AndRPrimOp, circt::firrtl::OrRPrimOp, circt::firrtl::XorRPrimOp, circt::firrtl::BitsPrimOp, circt::firrtl::HeadPrimOp, circt::firrtl::InvalidValuePrimOp, circt::firrtl::MuxPrimOp, circt::firrtl::PadPrimOp, circt::firrtl::ShlPrimOp, circt::firrtl::ShrPrimOp, circt::firrtl::TailPrimOp, circt::firrtl::AsPassivePrimOp, circt::firrtl::AsNonPassivePrimOp, circt::firrtl::StdIntCastOp, circt::firrtl::AnalogInOutCastOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&&) + 49
14 firtool                  0x00000001096bf25d circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*) + 61
15 firtool                  0x00000001096bbd60 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchVisitor(mlir::Operation*) + 32
16 firtool                  0x00000001096ba19e (anonymous namespace)::FIRRTLTypesLowering::runOnOperation() + 670
17 firtool                  0x0000000109d4f7e5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 661
18 firtool                  0x0000000109d4fef7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359
19 firtool                  0x0000000109d67ccf mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const + 559
20 firtool                  0x0000000109d66002 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8 std::__1::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 82
21 firtool                  0x0000000109d65f73 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 499
22 firtool                  0x0000000109d51734 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 180
23 firtool                  0x0000000109d50d3f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 1279
24 firtool                  0x0000000109d4fb2d mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) + 77
25 firtool                  0x0000000109d4f7d0 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 640
26 firtool                  0x0000000109d4fef7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359
27 firtool                  0x0000000109d67ccf mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const + 559
28 firtool                  0x0000000109d66002 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8 std::__1::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 82
29 firtool                  0x0000000109d65f73 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 499
30 firtool                  0x0000000109d51734 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 180
31 firtool                  0x0000000109d50d3f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 1279
32 firtool                  0x0000000109d4fb2d mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) + 77
33 firtool                  0x0000000109d4f7d0 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 640
34 firtool                  0x0000000109d4fef7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359
35 firtool                  0x0000000109d526c1 mlir::PassManager::run(mlir::Operation*) + 657
36 firtool                  0x00000001093ee356 processBuffer(std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) + 1238
37 firtool                  0x00000001093edb01 main + 897
38 libdyld.dylib            0x00007fff20381621 start + 1
39 libdyld.dylib            0x0000000000000004 start + 18446603339975616996",,,,,,,,
477,"[FIRRTL] Lower to RTL for Memories of Read Latency > 0, Write Latency > 1",2021-01-18T17:55:36Z,closed,"bug, enhancement, FIRRTL","Currently, RTL lowering from FIRRTL only handles ""combinational read memories"", i.e., FIRRTL memories with read latency == 0 and write latency == 1. This is mostly reasonable as ""sequential read memories"", i.e., FIRRTL memories with read latency == 1 and write latency == 1, are usually replaced with technology-specific macros generated by a memory compiler. However, this is not always the case---sometimes you want to simulate the sequential memory directly or you can rely on an FPGA toolchain to infer the sequential memory as BRAM.

We should support arbitrary, legal values of read and write latency in the same way that the Scala FIRRTL Compiler (SFC) handles these. Namely, add register delays of en/addr for read latency and en/addr/data for write latency.

At minimum, we should support sequential read memories and error on any read or write latency greater than 1.

### Example

The following sequential memory:

```
circuit Foo :
  module Foo :
    input clock: Clock
    input readAddr: UInt<4>
    input readEn: UInt<1>
    output readData: UInt<8>

    mem memory:
      data-type => UInt<8>
      depth => 16
      reader => r
      read-latency => 1
      write-latency => 1
      read-under-write => undefined

    memory.r.clk <= clock
    memory.r.en <= readEn
    memory.r.addr <= readAddr
    readData <= memory.r.data
```

Emits incorrectly as:

```verilog
module Foo(
  input        clock,
  input  [3:0] readAddr,
  input        readEn,
  output [7:0] readData);

  reg  [7:0] memory[15:0];	// Foo.fir:8:5
  wire [3:0] memory_r_addr;	// Foo.fir:8:5
  wire [7:0] memory_r_data;	// Foo.fir:8:5

  assign memory_r_data = memory[memory_r_addr];	// Foo.fir:8:5
  assign memory_r_addr = readAddr;	// Foo.fir:18:19
  assign readData = memory_r_data;	// Foo.fir:2:3
endmodule
```

### Additional Info

Currently, the Scala FIRRTL Compiler (SFC) has an optional pass to replace sequential read memories with blackboxes to support the technology-specific path. However, the SFC will happily lower memories with any read/write latency the user specifies by just adding the necessary delay registers for the output.

E.g., if the read latency is 8, you get a pipe of 8 registers on the read value.

I'm not aware of any mechanism by which a Chisel user can emit a memory which isn't a combinational read or sequential read memory. Chisel provides two primitives for working with memories:

1. [`Mem`](https://www.chisel-lang.org/api/latest/chisel3/Mem.html): combinational read (read latency 0, write latency 1)
2. [`SyncReadMem`](https://www.chisel-lang.org/api/latest/chisel3/SyncReadMem.html): sequential read (read latency 1, write latency 1)

With this in mind, it may make sense to de-prioritize implementing generic support for arbitrary, legal read/write latencies.","circuit Foo :
  module Foo :
    input clock: Clock
    input readAddr: UInt<4>
    input readEn: UInt<1>
    output readData: UInt<8>

    mem memory:
      data-type => UInt<8>
      depth => 16
      reader => r
      read-latency => 1
      write-latency => 1
      read-under-write => undefined

    memory.r.clk <= clock
    memory.r.en <= readEn
    memory.r.addr <= readAddr
    readData <= memory.r.data","module Foo(
  input        clock,
  input  [3:0] readAddr,
  input        readEn,
  output [7:0] readData);

  reg  [7:0] memory[15:0];	// Foo.fir:8:5
  wire [3:0] memory_r_addr;	// Foo.fir:8:5
  wire [7:0] memory_r_data;	// Foo.fir:8:5

  assign memory_r_data = memory[memory_r_addr];	// Foo.fir:8:5
  assign memory_r_addr = readAddr;	// Foo.fir:18:19
  assign readData = memory_r_data;	// Foo.fir:2:3
endmodule",,,,,,,,
471,[ExportVerilog] Zero width module ports which appear last in a port list cause syntax errors,2021-01-17T20:59:02Z,closed,"bug, ExportVerilog","As [noted in the code](https://github.com/llvm/circt/blob/1606160e433d378d188f214090c4f2c473e78e70/lib/Translation/ExportVerilog/ExportVerilog.cpp#L1525) in a list of port assignments (in a module instantiation): if the last port is zero width, the previous port will end with a comma, which is a syntax error.",,,,,,,,,,
463,[FIRRTL][RTL][ExportVerilog] Instances with no names,2021-01-15T21:49:47Z,closed,bug,"I have a question regarding FIRRTL instances with no names, lowering to RTL, and exporting Verilog.

Here's a really stripped down example. All that really matters is I am starting with a FIRRTL instance that has no name:

```
module  {                                                                                                                                                                                                          
  firrtl.circuit ""top"" {                                                                                                                                                                                           
    firrtl.module @sub() {}                                                                                                                                                                                        
    firrtl.module @top() {                                                                                                                                                                                         
      %0 = firrtl.instance @sub : !firrtl.bundle<>                                                                                                                                                                 
    }                                                                                                                                                                                                              
  }                                                                                                                                                                                                                
}
```

The `name` attribute is marked optional, and the lowering pass from Handshake to FIRRTL makes use of this to generate IR similar to the above.

If I use FIRRTL to directly export verilog (`firtool -format=mlir -verilog`), I get the following output:

```
module sub();                                                                                                                                                                                                      
endmodule                                                                                                                                                                                                          
                                                                                                                                                                                                                   
module top();                                                                                                                                                                                                      
  sub _T (
  );                                                                                                                                                                                                               
endmodule 
```

Because of how instances are handled in `ExportVerilogFIRRTL`, the instance goes through `addName`/`getName` and a unique name is generated.

If I try to lower to RTL first (`firtool -format=mlir -lower-to-rtl -verilog`), I get a helpful error that explains `'rtl.instance' op requires attribute 'instanceName'`.

Should the LowerToRTL pass do something to generate names in this case? It's nice to be able to leave off the name for passes like Handshake that don't really care how the instances are identified.","module  {                                                                                                                                                                                                          
  firrtl.circuit ""top"" {                                                                                                                                                                                           
    firrtl.module @sub() {}                                                                                                                                                                                        
    firrtl.module @top() {                                                                                                                                                                                         
      %0 = firrtl.instance @sub : !firrtl.bundle<>                                                                                                                                                                 
    }                                                                                                                                                                                                              
  }                                                                                                                                                                                                                
}","module sub();                                                                                                                                                                                                      
endmodule                                                                                                                                                                                                          
                                                                                                                                                                                                                   
module top();                                                                                                                                                                                                      
  sub _T (
  );                                                                                                                                                                                                               
endmodule",,,,,,,,
446,[FIRRTL] (xor) 0-width result (core dump),2021-01-13T02:23:56Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_1: SInt<0>
    output tmp10: UInt<1>
    tmp10 <= xor(inp_1, inp_1)
```

Compiled with `firtool --lower-to-rtl` gives an error:

```mlir
firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:280: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && ""bitwidth too small""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v
 #0 0x00000000004c16e3 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004c179a PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004bf7a0 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004c1136 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f76f9a031d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007f76f94c2ae5 raise (/lib64/libc.so.6+0x3dae5)
 #6 0x00007f76f94ab864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f76f94ab749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f76f94bb016 (/lib64/libc.so.6+0x36016)
 #9 0x000000000045bd42 llvm::APInt::APInt(unsigned int, unsigned long, bool) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:281:21
#10 0x000000000063dcc9 mlir::Builder::getZeroAttr(mlir::Type) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Builders.cpp:282:78
#11 0x0000000000793637 circt::firrtl::XorPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/FIRRTLFolds.cpp:140:50
#12 0x00000000007899d8 mlir::LogicalResult mlir::Op<circt::firrtl::XorPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::OpTrait::IsCommutative, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::XorPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1699:53
#13 0x00000000006cae3c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3
#14 0x00000000006c45a2 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30
#15 0x000000000088b90d mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13
#16 0x000000000088b26c mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13
#17 0x000000000086f7e9 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#18 0x000000000086fb14 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#19 0x000000000086fa00 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#20 0x0000000000738372 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3
#21 0x0000000000959dfb mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36
#22 0x000000000095a027 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15
#23 0x000000000095bf3e mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:854:74
#24 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13
#25 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13
#26 0x00007f76f94ad152 __libc_start_main (/lib64/libc.so.6+0x28152)
#27 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  output  tmp10
);
  assign tmp10 = 1'h0;
endmodule
```
","circuit top_mod :
  module top_mod :
    input inp_1: SInt<0>
    output tmp10: UInt<1>
    tmp10 <= xor(inp_1, inp_1)","firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:280: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && ""bitwidth too small""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v
 #0 0x00000000004c16e3 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004c179a PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004bf7a0 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004c1136 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f76f9a031d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007f76f94c2ae5 raise (/lib64/libc.so.6+0x3dae5)
 #6 0x00007f76f94ab864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f76f94ab749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f76f94bb016 (/lib64/libc.so.6+0x36016)
 #9 0x000000000045bd42 llvm::APInt::APInt(unsigned int, unsigned long, bool) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:281:21
#10 0x000000000063dcc9 mlir::Builder::getZeroAttr(mlir::Type) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Builders.cpp:282:78
#11 0x0000000000793637 circt::firrtl::XorPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/FIRRTLFolds.cpp:140:50
#12 0x00000000007899d8 mlir::LogicalResult mlir::Op<circt::firrtl::XorPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::OpTrait::IsCommutative, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::XorPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1699:53
#13 0x00000000006cae3c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3
#14 0x00000000006c45a2 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30
#15 0x000000000088b90d mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13
#16 0x000000000088b26c mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13
#17 0x000000000086f7e9 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#18 0x000000000086fb14 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#19 0x000000000086fa00 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#20 0x0000000000738372 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3
#21 0x0000000000959dfb mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36
#22 0x000000000095a027 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15
#23 0x000000000095bf3e mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:854:74
#24 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13
#25 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13
#26 0x00007f76f94ad152 __libc_start_main (/lib64/libc.so.6+0x28152)
#27 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0","module top_mod(
  output  tmp10
);
  assign tmp10 = 1'h0;
endmodule",,,,,,,
438,[ExportVerilog] Wires are declared after they are referenced,2021-01-12T19:36:56Z,closed,"bug, ExportVerilog","In the situation where an expression cannot be inlined and appears in the IR after its use, ExportVerilog will emit the use before the declaration. Generally speaking, this will likely occur when a cycle occurs.

Setting `emitInlineWireDecls` ([here](https://github.com/llvm/circt/blob/8cbe578d2363a9e97395d1b7af99d9ad3cac60bc/lib/Translation/ExportVerilog/ExportVerilog.cpp#L33)) to false mitigates the issue. Always putting the wire declarations at the beginning of the file is the simplest thing to do, but probably not what we want.

Should we set `emitInlineWireDecls` to false and treat optimal decl placement as a future cleanup/enhancement?",,,,,,,,,,
437,"[FIRRTL] (bits) parameters 0,0 (core dump)",2021-01-12T19:26:15Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    output tmp19: UInt<1>
    tmp19 <= bits(SInt<1>(-1), 0, 0)
```

Compiled with `firtool --lower-to-rtl` gives an error:

```mlir
firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:859: llvm::APInt llvm::APInt::trunc(unsigned int) const: Assertion `width < BitWidth && ""Invalid APInt Truncate request""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v
 #0 0x00000000004c16e3 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004c179a PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004bf7a0 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004c1136 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f927f19f1d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007f927ec5eae5 raise (/lib64/libc.so.6+0x3dae5)
 #6 0x00007f927ec47864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f927ec47749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f927ec57016 (/lib64/libc.so.6+0x36016)
 #9 0x00000000004e2e0a llvm::APInt::trunc(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:860:3
#10 0x000000000079391d circt::firrtl::BitsPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/FIRRTLFolds.cpp:256:76
#11 0x0000000000786255 mlir::LogicalResult mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::BitsPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1699:53
#12 0x00000000006ca63e mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3
#13 0x00000000006c3da4 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30
#14 0x000000000088b0ab mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13
#15 0x000000000088aa0a mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13
#16 0x000000000086ef87 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#17 0x000000000086f2b2 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#18 0x000000000086f19e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#19 0x0000000000737b74 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3
#20 0x0000000000959599 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36
#21 0x00000000009597c5 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15
#22 0x000000000095b6dc mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:854:74
#23 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13
#24 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13
#25 0x00007f927ec49152 __libc_start_main (/lib64/libc.so.6+0x28152)
#26 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  output  tmp19
);
  assign tmp19 = 1'h1;
endmodule
```
","circuit top_mod :
  module top_mod :
    output tmp19: UInt<1>
    tmp19 <= bits(SInt<1>(-1), 0, 0)","firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:859: llvm::APInt llvm::APInt::trunc(unsigned int) const: Assertion `width < BitWidth && ""Invalid APInt Truncate request""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v
 #0 0x00000000004c16e3 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004c179a PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004bf7a0 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004c1136 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f927f19f1d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007f927ec5eae5 raise (/lib64/libc.so.6+0x3dae5)
 #6 0x00007f927ec47864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f927ec47749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f927ec57016 (/lib64/libc.so.6+0x36016)
 #9 0x00000000004e2e0a llvm::APInt::trunc(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:860:3
#10 0x000000000079391d circt::firrtl::BitsPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/FIRRTLFolds.cpp:256:76
#11 0x0000000000786255 mlir::LogicalResult mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::BitsPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1699:53
#12 0x00000000006ca63e mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3
#13 0x00000000006c3da4 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30
#14 0x000000000088b0ab mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13
#15 0x000000000088aa0a mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13
#16 0x000000000086ef87 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#17 0x000000000086f2b2 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#18 0x000000000086f19e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#19 0x0000000000737b74 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3
#20 0x0000000000959599 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36
#21 0x00000000009597c5 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15
#22 0x000000000095b6dc mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:854:74
#23 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13
#24 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13
#25 0x00007f927ec49152 __libc_start_main (/lib64/libc.so.6+0x28152)
#26 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0","module top_mod(
  output  tmp19
);
  assign tmp19 = 1'h1;
endmodule",,,,,,,
436,[FIRRTL] (eq) 0-width error. LowerToRTL couldn't handle this operation,2021-01-12T18:56:01Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_2: UInt<0>
    wire tmp19: UInt<1>
    tmp19 <= eq(inp_2, inp_2)
```

Compiled with `firtool --lower-to-rtl` gives an error:

```mlir
a_top_mod.fir:5:14: error: 'firrtl.eq' op LowerToRTL couldn't handle this operation
    tmp19 <= eq(inp_2, inp_2)
             ^
a_top_mod.fir:5:14: note: see current operation: %2 = ""firrtl.eq""(%1, %1) : (!firrtl.uint<0>, !firrtl.uint<0>) -> !firrtl.uint<1>
a_top_mod.fir:5:11: error: 'firrtl.connect' op LowerToRTL couldn't handle this operation
    tmp19 <= eq(inp_2, inp_2)
          ^
a_top_mod.fir:5:11: note: see current operation: ""firrtl.connect""(%tmp19_0, %2) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
a_top_mod.fir:2:3: error: value has an unsupported verilog type '!firrtl.flip<uint<0>>'
  module top_mod :
  ^
a_top_mod.fir:2:3: error: value has an unsupported verilog type '!firrtl.uint<0>'
  module top_mod :
  ^
a_top_mod.fir:4:5: error: value has an unsupported verilog type '!firrtl.uint<1>'
    wire tmp19: UInt<1>
    ^
a_top_mod.fir:5:14: error: value has an unsupported verilog type '!firrtl.uint<1>'
    tmp19 <= eq(inp_2, inp_2)
             ^
a_top_mod.fir:2:3: error: 'firrtl.wire' op cannot emit this operation to Verilog
  module top_mod :
  ^
a_top_mod.fir:2:3: note: see current operation: %0 = ""firrtl.wire""() : () -> !firrtl.flip<uint<0>>
a_top_mod.fir:2:3: error: 'firrtl.asPassive' op cannot emit this operation to Verilog
  module top_mod :
  ^
a_top_mod.fir:2:3: note: see current operation: %1 = ""firrtl.asPassive""(%0) : (!firrtl.flip<uint<0>>) -> !firrtl.uint<0>
a_top_mod.fir:4:5: error: 'firrtl.wire' op cannot emit this operation to Verilog
    wire tmp19: UInt<1>
    ^
a_top_mod.fir:4:5: note: see current operation: %tmp19_0 = ""firrtl.wire""() {name = ""tmp19""} : () -> !firrtl.uint<1>
a_top_mod.fir:5:14: error: 'firrtl.eq' op cannot emit this operation to Verilog
    tmp19 <= eq(inp_2, inp_2)
             ^
a_top_mod.fir:5:14: note: see current operation: %2 = ""firrtl.eq""(%1, %1) : (!firrtl.uint<0>, !firrtl.uint<0>) -> !firrtl.uint<1>
a_top_mod.fir:5:11: error: 'firrtl.connect' op cannot emit this operation to Verilog
    tmp19 <= eq(inp_2, inp_2)
          ^
a_top_mod.fir:5:11: note: see current operation: ""firrtl.connect""(%tmp19_0, %2) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
);
endmodule
```","circuit top_mod :
  module top_mod :
    input inp_2: UInt<0>
    wire tmp19: UInt<1>
    tmp19 <= eq(inp_2, inp_2)","a_top_mod.fir:5:14: error: 'firrtl.eq' op LowerToRTL couldn't handle this operation
    tmp19 <= eq(inp_2, inp_2)
             ^
a_top_mod.fir:5:14: note: see current operation: %2 = ""firrtl.eq""(%1, %1) : (!firrtl.uint<0>, !firrtl.uint<0>) -> !firrtl.uint<1>
a_top_mod.fir:5:11: error: 'firrtl.connect' op LowerToRTL couldn't handle this operation
    tmp19 <= eq(inp_2, inp_2)
          ^
a_top_mod.fir:5:11: note: see current operation: ""firrtl.connect""(%tmp19_0, %2) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()
a_top_mod.fir:2:3: error: value has an unsupported verilog type '!firrtl.flip<uint<0>>'
  module top_mod :
  ^
a_top_mod.fir:2:3: error: value has an unsupported verilog type '!firrtl.uint<0>'
  module top_mod :
  ^
a_top_mod.fir:4:5: error: value has an unsupported verilog type '!firrtl.uint<1>'
    wire tmp19: UInt<1>
    ^
a_top_mod.fir:5:14: error: value has an unsupported verilog type '!firrtl.uint<1>'
    tmp19 <= eq(inp_2, inp_2)
             ^
a_top_mod.fir:2:3: error: 'firrtl.wire' op cannot emit this operation to Verilog
  module top_mod :
  ^
a_top_mod.fir:2:3: note: see current operation: %0 = ""firrtl.wire""() : () -> !firrtl.flip<uint<0>>
a_top_mod.fir:2:3: error: 'firrtl.asPassive' op cannot emit this operation to Verilog
  module top_mod :
  ^
a_top_mod.fir:2:3: note: see current operation: %1 = ""firrtl.asPassive""(%0) : (!firrtl.flip<uint<0>>) -> !firrtl.uint<0>
a_top_mod.fir:4:5: error: 'firrtl.wire' op cannot emit this operation to Verilog
    wire tmp19: UInt<1>
    ^
a_top_mod.fir:4:5: note: see current operation: %tmp19_0 = ""firrtl.wire""() {name = ""tmp19""} : () -> !firrtl.uint<1>
a_top_mod.fir:5:14: error: 'firrtl.eq' op cannot emit this operation to Verilog
    tmp19 <= eq(inp_2, inp_2)
             ^
a_top_mod.fir:5:14: note: see current operation: %2 = ""firrtl.eq""(%1, %1) : (!firrtl.uint<0>, !firrtl.uint<0>) -> !firrtl.uint<1>
a_top_mod.fir:5:11: error: 'firrtl.connect' op cannot emit this operation to Verilog
    tmp19 <= eq(inp_2, inp_2)
          ^
a_top_mod.fir:5:11: note: see current operation: ""firrtl.connect""(%tmp19_0, %2) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()","module top_mod(
);
endmodule",,,,,,,
432,[FIRRTL] (tail) parameter 0 (core dump),2021-01-12T02:25:49Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    output tmp8: UInt<10>
    tmp8 <= tail(SInt<10>(130), 0)
```

Compiled with `firtool --lower-to-rtl` gives an error:

```mlir
firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:859: llvm::APInt llvm::APInt::trunc(unsigned int) const: Assertion `width < BitWidth && ""Invalid APInt Truncate request""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v
 #0 0x00000000004c16e3 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004c179a PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004bf7a0 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004c1136 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f901dc491d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007f901d708ae5 raise (/lib64/libc.so.6+0x3dae5)
 #6 0x00007f901d6f1864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f901d6f1749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f901d701016 (/lib64/libc.so.6+0x36016)
 #9 0x00000000004e2e0a llvm::APInt::trunc(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:860:3
#10 0x0000000000809e2f circt::firrtl::BitsPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/OpFolds.cpp:232:76
#11 0x0000000000785d6f mlir::LogicalResult mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::BitsPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1699:53
#12 0x00000000006ca37c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3
#13 0x00000000006c3ae2 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30
#14 0x000000000088a72b mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13
#15 0x000000000088a08a mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13
#16 0x000000000086e607 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#17 0x000000000086e932 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#18 0x000000000086e81e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#19 0x00000000007378b2 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3
#20 0x0000000000958c19 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36
#21 0x0000000000958e45 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15
#22 0x000000000095ad5c mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:854:74
#23 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13
#24 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13
#25 0x00007f901d6f3152 __libc_start_main (/lib64/libc.so.6+0x28152)
#26 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  output [9:0] tmp8
);
  assign tmp8 = 10'h82;
endmodule
```
","circuit top_mod :
  module top_mod :
    output tmp8: UInt<10>
    tmp8 <= tail(SInt<10>(130), 0)","firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:859: llvm::APInt llvm::APInt::trunc(unsigned int) const: Assertion `width < BitWidth && ""Invalid APInt Truncate request""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v
 #0 0x00000000004c16e3 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x00000000004c179a PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x00000000004bf7a0 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004c1136 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007f901dc491d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007f901d708ae5 raise (/lib64/libc.so.6+0x3dae5)
 #6 0x00007f901d6f1864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007f901d6f1749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007f901d701016 (/lib64/libc.so.6+0x36016)
 #9 0x00000000004e2e0a llvm::APInt::trunc(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:860:3
#10 0x0000000000809e2f circt::firrtl::BitsPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/OpFolds.cpp:232:76
#11 0x0000000000785d6f mlir::LogicalResult mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::BitsPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1699:53
#12 0x00000000006ca37c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3
#13 0x00000000006c3ae2 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30
#14 0x000000000088a72b mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13
#15 0x000000000088a08a mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13
#16 0x000000000086e607 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#17 0x000000000086e932 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#18 0x000000000086e81e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#19 0x00000000007378b2 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3
#20 0x0000000000958c19 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36
#21 0x0000000000958e45 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15
#22 0x000000000095ad5c mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:854:74
#23 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13
#24 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13
#25 0x00007f901d6f3152 __libc_start_main (/lib64/libc.so.6+0x28152)
#26 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0","module top_mod(
  output [9:0] tmp8
);
  assign tmp8 = 10'h82;
endmodule",,,,,,,
431,[FIRRTL] (tail) 0-width result ,2021-01-12T01:16:23Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    output tmp9: UInt<0>
    tmp9 <= tail(UInt<23>(42), 23)
```

Compiled with `firtool --lower-to-rtl` gives an error:

```mlir
a_top_mod.fir:4:13: error: amount must be less than operand width
    tmp9 <= tail(UInt<23>(42), 23)
            ^
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
);
endmodule
```
","circuit top_mod :
  module top_mod :
    output tmp9: UInt<0>
    tmp9 <= tail(UInt<23>(42), 23)","a_top_mod.fir:4:13: error: amount must be less than operand width
    tmp9 <= tail(UInt<23>(42), 23)
            ^","module top_mod(
);
endmodule",,,,,,,
430,[FIRRTL] (head) parameter 0 error,2021-01-12T00:43:20Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    output tmp27: UInt<28>
    tmp27 <= head(UInt<28>(42), 0)
```

Compiled with `firtool --lower-to-rtl` gives an error:

```mlir
a_top_mod.fir:4:14: error: operand must have integer type and amount must be >= 1
    tmp27 <= head(UInt<28>(42), 0)
             ^
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  output [27:0] tmp27
);
  assign tmp27 = 28'h0;
endmodule
```
","circuit top_mod :
  module top_mod :
    output tmp27: UInt<28>
    tmp27 <= head(UInt<28>(42), 0)","a_top_mod.fir:4:14: error: operand must have integer type and amount must be >= 1
    tmp27 <= head(UInt<28>(42), 0)
             ^","module top_mod(
  output [27:0] tmp27
);
  assign tmp27 = 28'h0;
endmodule",,,,,,,
429,[FIRRTL] (div) 0-width error,2021-01-12T00:35:47Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_5: UInt<0>
    output tmp17: UInt<0>
    tmp17 <= div(inp_5, UInt<5>(5))
```

Compiled with `firtool --lower-to-rtl` gives an error:

```mlir
a_top_mod.fir:5:11: error: LowerToRTL couldn't handle this operation
    tmp17 <= div(inp_5, UInt<5>(5))
          ^
a_top_mod.fir:5:11: note: see current operation: ""firrtl.connect""(%2, %5) : (!firrtl.flip<uint<0>>, !firrtl.uint<0>) -> ()
a_top_mod.fir:5:14: error: 'rtl.extract' op result #0 must be an integer bitvector of one or more bits, but got 'i0'
    tmp17 <= div(inp_5, UInt<5>(5))
             ^
a_top_mod.fir:5:14: note: see current operation: %4 = ""rtl.extract""(%3) {lowBit = 0 : i32} : (i5) -> i0
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
);
endmodule
```","circuit top_mod :
  module top_mod :
    input inp_5: UInt<0>
    output tmp17: UInt<0>
    tmp17 <= div(inp_5, UInt<5>(5))","a_top_mod.fir:5:11: error: LowerToRTL couldn't handle this operation
    tmp17 <= div(inp_5, UInt<5>(5))
          ^
a_top_mod.fir:5:11: note: see current operation: ""firrtl.connect""(%2, %5) : (!firrtl.flip<uint<0>>, !firrtl.uint<0>) -> ()
a_top_mod.fir:5:14: error: 'rtl.extract' op result #0 must be an integer bitvector of one or more bits, but got 'i0'
    tmp17 <= div(inp_5, UInt<5>(5))
             ^
a_top_mod.fir:5:14: note: see current operation: %4 = ""rtl.extract""(%3) {lowBit = 0 : i32} : (i5) -> i0","module top_mod(
);
endmodule",,,,,,,
428,[FIRRTL] (dshl) error,2021-01-12T00:25:06Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_1: UInt<1>
    input inp_2: SInt<5>
    output tmp9: SInt<3>
    tmp9 <= dshl(inp_2, inp_1)
```

Compiled with `firtool --lower-to-rtl` gives an error:

```mlir
a_top_mod.fir:6:10: error: destination width 3 is not greater than or equal to source width 6
    tmp9 <= dshl(inp_2, inp_1)
         ^
a_top_mod.fir:6:10: note: see current operation: ""firrtl.connect""(%tmp9, %0) : (!firrtl.flip<sint<3>>, !firrtl.sint<6>) -> ()
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  input        inp_1,
  input  [4:0] inp_2,
  output [2:0] tmp9
);
  wire [5:0] _GEN_0 = {{1{inp_2[4]}},inp_2};
  wire [5:0] _GEN_1 = $signed(_GEN_0) << inp_1;
  assign tmp9 = _GEN_1[2:0];
endmodule
```","circuit top_mod :
  module top_mod :
    input inp_1: UInt<1>
    input inp_2: SInt<5>
    output tmp9: SInt<3>
    tmp9 <= dshl(inp_2, inp_1)","a_top_mod.fir:6:10: error: destination width 3 is not greater than or equal to source width 6
    tmp9 <= dshl(inp_2, inp_1)
         ^
a_top_mod.fir:6:10: note: see current operation: ""firrtl.connect""(%tmp9, %0) : (!firrtl.flip<sint<3>>, !firrtl.sint<6>) -> ()","module top_mod(
  input        inp_1,
  input  [4:0] inp_2,
  output [2:0] tmp9
);
  wire [5:0] _GEN_0 = {{1{inp_2[4]}},inp_2};
  wire [5:0] _GEN_1 = $signed(_GEN_0) << inp_1;
  assign tmp9 = _GEN_1[2:0];
endmodule",,,,,,,
426,[FIRRTL] MLIR parser crashes on zero bit constants,2021-01-10T19:03:15Z,closed,"bug, FIRRTL","This in an mlir file crashes the mlir parser:
```
     %c0_ui0 = firrtl.constant(0 : ui0) : !firrtl.uint<0>
```

@seldridge are zero bit constants supported by SFC?  If so, I'll fix this to be allowed.  If not, I'll fix them to be rejected.",%c0_ui0 = firrtl.constant(0 : ui0) : !firrtl.uint<0>,,,,,,,,,
423,[FIRRTL] Relax or Promote Connect to Partial Connect Semantics,2021-01-09T21:55:21Z,closed,"bug, FIRRTL","Chisel currently emits connects between a wider source and a narrower sink. The Scala FIRRTL Compiler accepts these and truncates the source (which is incorrect connect semantics, but correct partial connect semantics). This results in circuits that come out of Chisel which CIRCT won't accept.

Either:

1. We relax the connection verification checks 
2. We promote connects to partial connects if we see this during parsing

Example circuit:

```
circuit Foo :
  module Foo :
    input a: UInt<2>
    output b: UInt<1>

    b <= a
```

The SFC produces:

```verilog
module Foo(
  input  [1:0] a,
  output       b
);
  assign b = a[0];
endmodule
```

CIRCT gives us:

```bash
firtool Foo.fir
# Foo.fir:6:7: error: destination width 1 is not greater than or equal to source width 2
#    b <= a
#      ^
# Foo.fir:6:7: note: see current operation: ""firrtl.connect""(%b, %a) : (!firrtl.flip<uint<1>>, !firrtl.uint<2>) -> ()
```","circuit Foo :
  module Foo :
    input a: UInt<2>
    output b: UInt<1>

    b <= a","module Foo(
  input  [1:0] a,
  output       b
);
  assign b = a[0];
endmodule","firtool Foo.fir
# Foo.fir:6:7: error: destination width 1 is not greater than or equal to source width 2
#    b <= a
#      ^
# Foo.fir:6:7: note: see current operation: ""firrtl.connect""(%b, %a) : (!firrtl.flip<uint<1>>, !firrtl.uint<2>) -> ()",,,,,,,
419,[FIRRTL] Extend lower types with partial connect support,2021-01-08T16:31:35Z,closed,"bug, enhancement, FIRRTL","Add support to FIRRTL type lowering to work with partial connects `<-`. 

This is both used by ""Chisel 2 compatibility mode"" and it's been discussed that Chisel should emit these instead of normal connects (`<=`) for the reason that Chisel and the Scala FIRRTL Compiler (SFC) incorrectly truncate `<=` (which is supposed to only be a feature of `<-`).

Currently, `firtool` will throw a stack trace if you have any partial connects.

Example input that currently fails:

```scala
circuit Foo:
  module Foo:
    input a: { a: UInt<1>, b: UInt<1> }
    output b: { a: UInt<1> }

    b <- a
```

With the SFC, you get the following lowered circuit:

```scala
circuit Foo :
  module Foo :
    input a_a : UInt<1>
    input a_b : UInt<1>
    output b_a : UInt<1>

    b_a <= a_a
```

Currently CIRCT will crash with this.","circuit Foo:
  module Foo:
    input a: { a: UInt<1>, b: UInt<1> }
    output b: { a: UInt<1> }

    b <- a","circuit Foo :
  module Foo :
    input a_a : UInt<1>
    input a_b : UInt<1>
    output b_a : UInt<1>

    b_a <= a_a",,,,,,,,
418,[FIRRTL] Stack trace on multi-argument not operand,2021-01-08T16:21:56Z,closed,"bug, FIRRTL","The following circuit causes a stack trace because it has an invalid multi-argument `not`. The checking for `UnaryPrimOp` doesn't seem to be working like with `BinaryPrimOp`. My guess is that the default checks generated by ODS are running before the check we have for `UnaryPrimOp`'s `getResultType` (or this isn't running).

Minimal circuit:
```
circuit Foo:
  module Foo:
    input a: UInt<1>
    output b: UInt<1>

    b <= not(a, a)
```

Running with:
```bash
firtool Foo.fir
```

You get:
```
Assertion failed: (operands.size() == 1u && ""mismatched number of parameters""), function build, file include/circt/Dialect/FIRRTL/FIRRTL.cpp.inc, line 8390.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: firtool Foo.fir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x000000010c57fbad llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x000000010c58015b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x000000010c57ddfb llvm::sys::RunSignalHandlers() + 123
3  firtool                  0x000000010c58248d SignalHandler(int) + 205
4  libsystem_platform.dylib 0x00007fff20394d7d _sigtramp + 29
5  firtool                  0x000000010ce75ba0 llvm::ColorCategory + 212064
6  libsystem_c.dylib        0x00007fff202a3720 abort + 120
7  libsystem_c.dylib        0x00007fff202a29d6 err + 0
8  firtool                  0x000000010cb0b1e2 circt::firrtl::NotPrimOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::TypeRange, mlir::ValueRange, llvm::ArrayRef<std::__1::pair<mlir::Identifier, mlir::Attribute> >) + 130
9  firtool                  0x000000010c625833 circt::firrtl::NotPrimOp mlir::OpBuilder::create<circt::firrtl::NotPrimOp, circt::firrtl::FIRRTLType&, mlir::ValueRange, mlir::NamedAttrList&>(mlir::Location, circt::firrtl::FIRRTLType&, mlir::ValueRange&&, mlir::NamedAttrList&) + 499
10 firtool                  0x000000010c61ce2b (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) + 11051
11 firtool                  0x000000010c60f720 (anonymous namespace)::FIRStmtParser::parseExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&) + 144
12 firtool                  0x000000010c60fd7e (anonymous namespace)::FIRStmtParser::parseLeadingExpStmt(mlir::Value, llvm::SmallVectorImpl<mlir::Operation*>&) + 1214
13 firtool                  0x000000010c60c108 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) + 600
14 firtool                  0x000000010c604be9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) + 377
15 firtool                  0x000000010c5ff918 (anonymous namespace)::FIRModuleParser::parseModule(unsigned int) + 1320
16 firtool                  0x000000010c5fe386 (anonymous namespace)::FIRCircuitParser::parseCircuit() + 1526
17 firtool                  0x000000010c5fdbc5 circt::firrtl::importFIRRTL(llvm::SourceMgr&, mlir::MLIRContext*, circt::firrtl::FIRParserOptions) + 325
18 firtool                  0x000000010c3f49a5 processBuffer(std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) + 389
19 firtool                  0x000000010c3f44a1 main + 897
20 libdyld.dylib            0x00007fff2036b621 start + 1
21 libdyld.dylib            0x0000000000000002 start + 18446603339975707106
zsh: abort      firtool Foo.fir
```

Conversely, if you run this with the following circuit:

```
circuit Foo:
  module Foo:
    input a: UInt<1>
    output b: UInt<1>
    output c: UInt<1>

    c <= and(a, a, a)
```

You get the saner:

```
Foo.fir:7:10: error: operation requires two operands and no constants
    c <= and(a, a, a)
```","circuit Foo:
  module Foo:
    input a: UInt<1>
    output b: UInt<1>

    b <= not(a, a)",firtool Foo.fir,"Assertion failed: (operands.size() == 1u && ""mismatched number of parameters""), function build, file include/circt/Dialect/FIRRTL/FIRRTL.cpp.inc, line 8390.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: firtool Foo.fir
Stack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):
0  firtool                  0x000000010c57fbad llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61
1  firtool                  0x000000010c58015b PrintStackTraceSignalHandler(void*) + 27
2  firtool                  0x000000010c57ddfb llvm::sys::RunSignalHandlers() + 123
3  firtool                  0x000000010c58248d SignalHandler(int) + 205
4  libsystem_platform.dylib 0x00007fff20394d7d _sigtramp + 29
5  firtool                  0x000000010ce75ba0 llvm::ColorCategory + 212064
6  libsystem_c.dylib        0x00007fff202a3720 abort + 120
7  libsystem_c.dylib        0x00007fff202a29d6 err + 0
8  firtool                  0x000000010cb0b1e2 circt::firrtl::NotPrimOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::TypeRange, mlir::ValueRange, llvm::ArrayRef<std::__1::pair<mlir::Identifier, mlir::Attribute> >) + 130
9  firtool                  0x000000010c625833 circt::firrtl::NotPrimOp mlir::OpBuilder::create<circt::firrtl::NotPrimOp, circt::firrtl::FIRRTLType&, mlir::ValueRange, mlir::NamedAttrList&>(mlir::Location, circt::firrtl::FIRRTLType&, mlir::ValueRange&&, mlir::NamedAttrList&) + 499
10 firtool                  0x000000010c61ce2b (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) + 11051
11 firtool                  0x000000010c60f720 (anonymous namespace)::FIRStmtParser::parseExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&) + 144
12 firtool                  0x000000010c60fd7e (anonymous namespace)::FIRStmtParser::parseLeadingExpStmt(mlir::Value, llvm::SmallVectorImpl<mlir::Operation*>&) + 1214
13 firtool                  0x000000010c60c108 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) + 600
14 firtool                  0x000000010c604be9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) + 377
15 firtool                  0x000000010c5ff918 (anonymous namespace)::FIRModuleParser::parseModule(unsigned int) + 1320
16 firtool                  0x000000010c5fe386 (anonymous namespace)::FIRCircuitParser::parseCircuit() + 1526
17 firtool                  0x000000010c5fdbc5 circt::firrtl::importFIRRTL(llvm::SourceMgr&, mlir::MLIRContext*, circt::firrtl::FIRParserOptions) + 325
18 firtool                  0x000000010c3f49a5 processBuffer(std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) + 389
19 firtool                  0x000000010c3f44a1 main + 897
20 libdyld.dylib            0x00007fff2036b621 start + 1
21 libdyld.dylib            0x0000000000000002 start + 18446603339975707106
zsh: abort      firtool Foo.fir","circuit Foo:
  module Foo:
    input a: UInt<1>
    output b: UInt<1>
    output c: UInt<1>

    c <= and(a, a, a)","Foo.fir:7:10: error: operation requires two operands and no constants
    c <= and(a, a, a)",,,,,
407,[ExportVerilog] Instance name collisions,2021-01-06T01:47:55Z,closed,"bug, ExportVerilog","https://github.com/llvm/circt/blob/27155e4d1740dc44bd596a0a04ca961b2136d014/lib/Translation/ExportVerilog/ExportVerilog.cpp#L1494

ExportVerilog just spits out instance names. If you've got two instances with the same name (as I'd imagine is frequent in generated code), they will conflict in the output. Those names may also conflict with other identifiers, such as wires and ports.

We should at least error out in the case where an instanceName conflicts with another idenifier. I think we should go further and automatically rename the instance.",,,,,,,,,,
395,firrtl.node type verification,2021-01-04T23:27:25Z,closed,"bug, FIRRTL","The following now fails

```
module  {
  firrtl.circuit ""foo"" {
    firrtl.extmodule @bar(%baz: !firrtl.uint<1>)
    firrtl.module @foo() {
      %fetch = firrtl.instance @bar {name = ""fetch""} : !firrtl.bundle<baz: flip<uint<1>>>
      %1454 = firrtl.subfield %fetch(""baz"") : (!firrtl.bundle<baz: flip<uint<1>>>) -> !firrtl.flip<uint<1>>
      %hits_1_7 = firrtl.node %1454 {name = ""hits_1_7""} : !firrtl.flip<uint<1>>
    }
  }
}
```
","module  {
  firrtl.circuit ""foo"" {
    firrtl.extmodule @bar(%baz: !firrtl.uint<1>)
    firrtl.module @foo() {
      %fetch = firrtl.instance @bar {name = ""fetch""} : !firrtl.bundle<baz: flip<uint<1>>>
      %1454 = firrtl.subfield %fetch(""baz"") : (!firrtl.bundle<baz: flip<uint<1>>>) -> !firrtl.flip<uint<1>>
      %hits_1_7 = firrtl.node %1454 {name = ""hits_1_7""} : !firrtl.flip<uint<1>>
    }
  }
}",,,,,,,,,
394,[FIRRTL] (add / mux) missmatch,2021-01-04T21:48:42Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_3: SInt<16>
    input inp_6: UInt<13>
    output tmp13: SInt<14>
    wire tmp11: UInt<14>
    tmp11 <= add(inp_6, UInt<12>(1))
    tmp13 <= mux(tail(asUInt(inp_3), 15), asSInt(tmp11), SInt<13>(1))
```

Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  input  [15:0] inp_3,
  input  [12:0] inp_6,
  output [13:0] tmp13);

  wire [13:0] tmp11;	// a_top_mod.fir:6:5

  assign tmp11 = {{1'd0}, inp_6} + 14'h1;	// a_top_mod.fir:7:{11,14}
  assign tmp13 = inp_3[0] ? tmp11 : 14'h1;	// a_top_mod.fir:2:3, :8:{14,18,43}
endmodule
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  input  [15:0] inp_3,
  input  [12:0] inp_6,
  output [13:0] tmp13
);
  wire [15:0] _GEN_0 = inp_3;
  assign tmp13 = _GEN_0[0] ? $signed(inp_6 + 13'h1) : $signed(14'sh1);
endmodule
```

Yosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:

```
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
```
","circuit top_mod :
  module top_mod :
    input inp_3: SInt<16>
    input inp_6: UInt<13>
    output tmp13: SInt<14>
    wire tmp11: UInt<14>
    tmp11 <= add(inp_6, UInt<12>(1))
    tmp13 <= mux(tail(asUInt(inp_3), 15), asSInt(tmp11), SInt<13>(1))","module top_mod(
  input  [15:0] inp_3,
  input  [12:0] inp_6,
  output [13:0] tmp13);

  wire [13:0] tmp11;	// a_top_mod.fir:6:5

  assign tmp11 = {{1'd0}, inp_6} + 14'h1;	// a_top_mod.fir:7:{11,14}
  assign tmp13 = inp_3[0] ? tmp11 : 14'h1;	// a_top_mod.fir:2:3, :8:{14,18,43}
endmodule","module top_mod(
  input  [15:0] inp_3,
  input  [12:0] inp_6,
  output [13:0] tmp13
);
  wire [15:0] _GEN_0 = inp_3;
  assign tmp13 = _GEN_0[0] ? $signed(inp_6 + 13'h1) : $signed(14'sh1);
endmodule",ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
388,[FIRRTL] Verify that FIRRTL nodes are passive,2021-01-02T03:23:37Z,closed,"bug, good first issue, FIRRTL","Nodes need to be passive, but the FIRRTL dialect allows them to not be. Add a verifier that asserts passivity of nodes.

E.g., the following should fail, but doesn't:

```
circuit Foo :
  module Foo :
    input a: { a: UInt<1>, flip b: UInt<1> }
    output b: { a: UInt<1>, flip b: UInt<1> }

    node x = a

    b <= x
```

The Scala FIRRTL Compiler returns:

```bash
firrtl -i Foo.fir 
# Exception in thread ""main"" firrtl.passes.CheckTypes$NodePassiveType: : [module Foo]  Node must be a passive type.
```","circuit Foo :
  module Foo :
    input a: { a: UInt<1>, flip b: UInt<1> }
    output b: { a: UInt<1>, flip b: UInt<1> }

    node x = a

    b <= x","firrtl -i Foo.fir 
# Exception in thread ""main"" firrtl.passes.CheckTypes$NodePassiveType: : [module Foo]  Node must be a passive type.",,,,,,,,
373,[FIRRTL] LowerToRTL issues with instance inputs,2020-12-28T18:15:47Z,closed,"bug, FIRRTL","
[This patch](https://github.com/llvm/circt/commit/6752760bb93835f3e46b019c7dfb2007fd7c17a8) introduced logic into LowerToRTLModule to avoid making wires for inputs all inputs.  Unfortunately, this breaks the ""dag"" property of FIRRTL.  While this is technically ok (the output of the pass is an RTL module which allows cycles) the logic in LowerToRTL expects non-cycles, because assignments to inputs happen after the instance and can have arbitrary logic.

This breaks some larger testcases, here is a reduced testcase:

```
 rtl.module @instance_ooo(%arg0: i2, %arg1: i2) {
   %arg0c = firrtl.stdIntCast %arg0 : (i2) -> !firrtl.uint<2>
   %arg1c = firrtl.stdIntCast %arg1 : (i2) -> !firrtl.uint<2>

   %b = firrtl.stdIntCast %a : (!firrtl.uint<1>) -> i1
   rtl.instance ""barmobile"" @bar(%b)  : (i1) -> ()
   %a = firrtl.eq %arg0c, %arg1c : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>
 }
```

I plan to work on this today, but if anyone is blocked, I can back out the problematic part of the patch, just lemme know.
","rtl.module @instance_ooo(%arg0: i2, %arg1: i2) {
   %arg0c = firrtl.stdIntCast %arg0 : (i2) -> !firrtl.uint<2>
   %arg1c = firrtl.stdIntCast %arg1 : (i2) -> !firrtl.uint<2>

   %b = firrtl.stdIntCast %a : (!firrtl.uint<1>) -> i1
   rtl.instance ""barmobile"" @bar(%b)  : (i1) -> ()
   %a = firrtl.eq %arg0c, %arg1c : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>
 }",,,,,,,,,
368,[FIRRTL] (eq) with constant mismatch,2020-12-26T06:20:54Z,closed,"bug, FIRRTL","## 1) The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_1: UInt<15>
    input inp_2: UInt<15>
    output tmp9: UInt<1>
    wire tmp4: UInt<1>
    tmp4 <= eq(inp_2, inp_1)
    tmp9 <= eq(tmp4, UInt<2>(3))
```

Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  input  [14:0] inp_1, inp_2,
  output        tmp9);

  wire tmp4;	// a_top_mod.fir:6:5

  assign tmp4 = inp_2 == inp_1;	// a_top_mod.fir:7:{10,13}
  assign tmp9 = tmp4;	// a_top_mod.fir:2:3
endmodule
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  input  [14:0] inp_1,
  input  [14:0] inp_2,
  output        tmp9
);
  wire  tmp4 = inp_2 == inp_1;
  wire [1:0] _GEN_0 = {{1'd0}, tmp4};
  assign tmp9 = _GEN_0 == 2'h3;
endmodule
```

Yosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:

```
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
```

## 2) Even simpler FIRRTL program

```python
circuit top_mod :
  module top_mod :
    output tmp15: UInt<1>
    tmp15 <= eq(UInt<1>(1), UInt<3>(7))
```

Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  output tmp15);

  assign tmp15 = 1'h1;	// a_top_mod.fir:2:3, :4:17
endmodule
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  output  tmp15
);
  assign tmp15 = 1'h0;
endmodule
```

Yosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:

```
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
```
","circuit top_mod :
  module top_mod :
    input inp_1: UInt<15>
    input inp_2: UInt<15>
    output tmp9: UInt<1>
    wire tmp4: UInt<1>
    tmp4 <= eq(inp_2, inp_1)
    tmp9 <= eq(tmp4, UInt<2>(3))","module top_mod(
  input  [14:0] inp_1, inp_2,
  output        tmp9);

  wire tmp4;	// a_top_mod.fir:6:5

  assign tmp4 = inp_2 == inp_1;	// a_top_mod.fir:7:{10,13}
  assign tmp9 = tmp4;	// a_top_mod.fir:2:3
endmodule","module top_mod(
  input  [14:0] inp_1,
  input  [14:0] inp_2,
  output        tmp9
);
  wire  tmp4 = inp_2 == inp_1;
  wire [1:0] _GEN_0 = {{1'd0}, tmp4};
  assign tmp9 = _GEN_0 == 2'h3;
endmodule",ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.,"circuit top_mod :
  module top_mod :
    output tmp15: UInt<1>
    tmp15 <= eq(UInt<1>(1), UInt<3>(7))","module top_mod(
  output tmp15);

  assign tmp15 = 1'h1;	// a_top_mod.fir:2:3, :4:17
endmodule","module top_mod(
  output  tmp15
);
  assign tmp15 = 1'h0;
endmodule",ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.,,
367,[FIRRTL] (dshr) unsign mismatch,2020-12-26T01:24:49Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_4: SInt<6>
    input tmp7: UInt<1>
    output tmp13: UInt<1>
    tmp13 <= dshr(tmp7, asUInt(inp_4))
```

Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  input  [5:0] inp_4,
  input        tmp7,
  output       tmp13);

  assign tmp13 = tmp7 >> inp_4[0];	// a_top_mod.fir:2:3, :6:14
endmodule
```

![image](https://user-images.githubusercontent.com/511872/103143899-872fcd00-46d4-11eb-9ecd-c4bff7d0ba26.png)

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  input  [5:0] inp_4,
  input        tmp7,
  output       tmp13
);
  assign tmp13 = tmp7 >> inp_4;
endmodule
```

Yosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:

```
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
```
","circuit top_mod :
  module top_mod :
    input inp_4: SInt<6>
    input tmp7: UInt<1>
    output tmp13: UInt<1>
    tmp13 <= dshr(tmp7, asUInt(inp_4))","module top_mod(
  input  [5:0] inp_4,
  input        tmp7,
  output       tmp13);

  assign tmp13 = tmp7 >> inp_4[0];	// a_top_mod.fir:2:3, :6:14
endmodule","module top_mod(
  input  [5:0] inp_4,
  input        tmp7,
  output       tmp13
);
  assign tmp13 = tmp7 >> inp_4;
endmodule",ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
366,[FIRRTL] (dshr) signed mismatch,2020-12-26T01:13:45Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_7: UInt<10>
    output tmp12: SInt<5>
    tmp12 <= dshr(SInt<5>(6), inp_7)
```

Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  input  [9:0] inp_7,
  output [4:0] tmp12);

  assign tmp12 = $signed(5'h6) >>> $signed(inp_7[4:0]);	// a_top_mod.fir:3:3, :6:{14,19}
endmodule
```

![image](https://user-images.githubusercontent.com/511872/103143899-872fcd00-46d4-11eb-9ecd-c4bff7d0ba26.png)

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  input  [9:0] inp_7,
  output [4:0] tmp12
);
  assign tmp12 = 5'sh6 >>> inp_7;
endmodule
```

Yosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:

```
ERROR: Found 3 unproven $equiv cells in 'equiv_status -assert'.
```
","circuit top_mod :
  module top_mod :
    input inp_7: UInt<10>
    output tmp12: SInt<5>
    tmp12 <= dshr(SInt<5>(6), inp_7)","module top_mod(
  input  [9:0] inp_7,
  output [4:0] tmp12);

  assign tmp12 = $signed(5'h6) >>> $signed(inp_7[4:0]);	// a_top_mod.fir:3:3, :6:{14,19}
endmodule","module top_mod(
  input  [9:0] inp_7,
  output [4:0] tmp12
);
  assign tmp12 = 5'sh6 >>> inp_7;
endmodule",ERROR: Found 3 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
365,[FIRRTL] (rem) mismatch,2020-12-25T23:48:04Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    output tmp9: SInt<1>
    wire tmp4: UInt<1>
    tmp4 <= UInt<1>(0)
    tmp9 <= rem(SInt<22>(1), asSInt(tmp4))
```

Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  output tmp9);

  wire tmp4;	// top_mod.fir:4:5

  assign tmp4 = 1'h0;	// top_mod.fir:5:{10,13}
  wire [21:0] _T = $signed(22'h1) % $signed({22{tmp4}});	// top_mod.fir:6:{13,17,30}
  assign tmp9 = _T[0];	// top_mod.fir:2:3, :6:13
endmodule
```
Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  output  tmp9
);
  wire [21:0] _GEN_0 = 22'sh1 % 22'sh0;
  assign tmp9 = _GEN_0[0];
endmodule
```

Yosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:

```
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
```
Is it a bug in Yosys?","circuit top_mod :
  module top_mod :
    output tmp9: SInt<1>
    wire tmp4: UInt<1>
    tmp4 <= UInt<1>(0)
    tmp9 <= rem(SInt<22>(1), asSInt(tmp4))","module top_mod(
  output tmp9);

  wire tmp4;	// top_mod.fir:4:5

  assign tmp4 = 1'h0;	// top_mod.fir:5:{10,13}
  wire [21:0] _T = $signed(22'h1) % $signed({22{tmp4}});	// top_mod.fir:6:{13,17,30}
  assign tmp9 = _T[0];	// top_mod.fir:2:3, :6:13
endmodule","module top_mod(
  output  tmp9
);
  wire [21:0] _GEN_0 = 22'sh1 % 22'sh0;
  assign tmp9 = _GEN_0[0];
endmodule",ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
364,[FIRRTL] (neg) mismatch,2020-12-25T23:19:22Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    output tmp3: SInt<12>
    tmp3 <= neg(UInt<11>(1175))
```

Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  output [11:0] tmp3);

  assign tmp3 = 12'h0 - {{1'd0}, 11'h497};	// top_mod.fir:2:3, :4:{13,17}
endmodule
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  output [11:0] tmp3
);
  assign tmp3 = -$signed(11'h497);
endmodule
```

Yosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:

```
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
```
","circuit top_mod :
  module top_mod :
    output tmp3: SInt<12>
    tmp3 <= neg(UInt<11>(1175))","module top_mod(
  output [11:0] tmp3);

  assign tmp3 = 12'h0 - {{1'd0}, 11'h497};	// top_mod.fir:2:3, :4:{13,17}
endmodule","module top_mod(
  output [11:0] tmp3
);
  assign tmp3 = -$signed(11'h497);
endmodule",ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
363,[FIRRTL] (div) A/A mismatch,2020-12-25T22:58:59Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_1: UInt<14>
    output tmp4: UInt<14>
    tmp4 <= div(inp_1, inp_1)
```

Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  input  [13:0] inp_1,
  output [13:0] tmp4);

  assign tmp4 = inp_1 / inp_1;	// top_mod.fir:3:3, :6:13
endmodule
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  input  [13:0] inp_1,
  output [13:0] tmp4
);
  assign tmp4 = 14'h1;
endmodule
```

Yosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:

```
ERROR: Found 13 unproven $equiv cells in 'equiv_status -assert'.
```
","circuit top_mod :
  module top_mod :
    input inp_1: UInt<14>
    output tmp4: UInt<14>
    tmp4 <= div(inp_1, inp_1)","module top_mod(
  input  [13:0] inp_1,
  output [13:0] tmp4);

  assign tmp4 = inp_1 / inp_1;	// top_mod.fir:3:3, :6:13
endmodule","module top_mod(
  input  [13:0] inp_1,
  output [13:0] tmp4
);
  assign tmp4 = 14'h1;
endmodule",ERROR: Found 13 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
361,[FIRRTL] (div) sign extension ,2020-12-25T21:32:31Z,closed,"bug, FIRRTL","Maybe related to #355 

The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_6: UInt<7>
    output tmp9: SInt<23>
    tmp9 <= div(asSInt(UInt<22>(5)), SInt<4>(-3))
```

Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  input  [6:0]  inp_6,
  output [22:0] tmp9);

  wire [21:0] _T = 22'h5;	// top_mod.fir:6:24
  assign tmp9 = $signed({{1{_T[21]}}, _T}) / $signed({{19'd0}, 4'hD});	// top_mod.fir:3:3, :6:{13,38}
endmodule
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  input  [6:0]  inp_6,
  output [22:0] tmp9
);
  assign tmp9 = 22'sh5 / -22'sh3;
endmodule
```

Yosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:

```
ERROR: Found 23 unproven $equiv cells in 'equiv_status -assert'.
```
","circuit top_mod :
  module top_mod :
    input inp_6: UInt<7>
    output tmp9: SInt<23>
    tmp9 <= div(asSInt(UInt<22>(5)), SInt<4>(-3))","module top_mod(
  input  [6:0]  inp_6,
  output [22:0] tmp9);

  wire [21:0] _T = 22'h5;	// top_mod.fir:6:24
  assign tmp9 = $signed({{1{_T[21]}}, _T}) / $signed({{19'd0}, 4'hD});	// top_mod.fir:3:3, :6:{13,38}
endmodule","module top_mod(
  input  [6:0]  inp_6,
  output [22:0] tmp9
);
  assign tmp9 = 22'sh5 / -22'sh3;
endmodule",ERROR: Found 23 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
356,[FIRRTL] (dshr) emit verilog error,2020-12-24T06:57:48Z,closed,"bug, ExportVerilog","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_0: UInt<14>
    output tmp1: UInt<5>
    tmp1 <= dshr(UInt<5>(4), inp_0)
```

Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  input  [13:0] inp_0,
  output [4:0]  tmp1
);
  assign tmp1 = 5'h4 >> inp_0;
endmodule
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  input  [13:0] inp_0,
  output [4:0]  tmp1);

  assign tmp1 = 5'h4 >>> inp_0[4:0];	// top_mod.fir:3:3, :6:{13,18}
endmodule
```

Yosys reports formal mismatch:

```
ERROR: Found 3 unproven $equiv cells in 'equiv_status -assert'.
```
","circuit top_mod :
  module top_mod :
    input inp_0: UInt<14>
    output tmp1: UInt<5>
    tmp1 <= dshr(UInt<5>(4), inp_0)","module top_mod(
  input  [13:0] inp_0,
  output [4:0]  tmp1
);
  assign tmp1 = 5'h4 >> inp_0;
endmodule","module top_mod(
  input  [13:0] inp_0,
  output [4:0]  tmp1);

  assign tmp1 = 5'h4 >>> inp_0[4:0];	// top_mod.fir:3:3, :6:{13,18}
endmodule",ERROR: Found 3 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
355,[FIRRTL] (div) operand extension error,2020-12-24T06:32:47Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_0: UInt<15>
    output tmp1: UInt<8>
    tmp1 <= div(UInt<8>(104), UInt<10>(306))
```

Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  input  [14:0] inp_0,
  output [7:0]  tmp1
);
  assign tmp1 = 10'h68 / 10'h132;
endmodule
```
`div` result width expected to be Wnum
![image](https://user-images.githubusercontent.com/511872/103143155-108bd300-46c6-11eb-9ccd-5b2e77761aa5.png)

`verilator --lint-only` generates this message:

```
%Warning-WIDTH: top_mod.v:5:15: Operator ASSIGNW expects 8 bits on the Assign RHS, but Assign RHS's DIV generates 10 bits.
                              : ... In instance top_mod
    5 |   assign tmp1 = 10'h68 / 10'h132;
      |               ^
                ... Use ""/* verilator lint_off WIDTH */"" and lint_on around source to disable this message.
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  input  [14:0] inp_0,
  output [7:0]  tmp1);

  wire [9:0] _T = 10'h132;	// top_mod.fir:5:31
  assign tmp1 = 8'h68 / _T[7:0];	// top_mod.fir:2:3, :5:{13,17}
endmodule
```

Yosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:

```
ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.
```
","circuit top_mod :
  module top_mod :
    input inp_0: UInt<15>
    output tmp1: UInt<8>
    tmp1 <= div(UInt<8>(104), UInt<10>(306))","module top_mod(
  input  [14:0] inp_0,
  output [7:0]  tmp1
);
  assign tmp1 = 10'h68 / 10'h132;
endmodule","%Warning-WIDTH: top_mod.v:5:15: Operator ASSIGNW expects 8 bits on the Assign RHS, but Assign RHS's DIV generates 10 bits.
                              : ... In instance top_mod
    5 |   assign tmp1 = 10'h68 / 10'h132;
      |               ^
                ... Use ""/* verilator lint_off WIDTH */"" and lint_on around source to disable this message.","module top_mod(
  input  [14:0] inp_0,
  output [7:0]  tmp1);

  wire [9:0] _T = 10'h132;	// top_mod.fir:5:31
  assign tmp1 = 8'h68 / _T[7:0];	// top_mod.fir:2:3, :5:{13,17}
endmodule",ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.,,,,,
354,[FIRRTL]  SInt literal sign extension error,2020-12-24T05:45:46Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    output tmp5: SInt<19>
    tmp5 <= SInt<19>(8)
```

Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  output [18:0] tmp5);

  assign tmp5 = 19'h7FFF8;	// top_mod.fir:3:3, :5:13
endmodule
```

Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  output [18:0] tmp5
);
  assign tmp5 = 19'sh8;
endmodule
```

Yosys reports formal mismatch:

```
ERROR: Found 15 unproven $equiv cells in 'equiv_status -assert'.
```

","circuit top_mod :
  module top_mod :
    output tmp5: SInt<19>
    tmp5 <= SInt<19>(8)","module top_mod(
  output [18:0] tmp5);

  assign tmp5 = 19'h7FFF8;	// top_mod.fir:3:3, :5:13
endmodule","module top_mod(
  output [18:0] tmp5
);
  assign tmp5 = 19'sh8;
endmodule",ERROR: Found 15 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
353,[FIRRTL] (and) SInt -> UInt formal mismatch,2020-12-24T04:31:36Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_0: SInt<7>
    input inp_7: SInt<14>
    output tmp8: UInt<14>
    tmp8 <= and(inp_7, inp_0)
```
Compiled with `firtool --lower-to-rtl` produces this Verilog:

```verilog
module top_mod(
  input  [6:0]  inp_0,
  input  [13:0] inp_7,
  output [13:0] tmp8);

  assign tmp8 = inp_7 & {{7'd0}, inp_0};	// top_mod.fir:3:3, :7:13
endmodule
```
Compiled with `firrtl-1.4.0` produces this Verilog:

```verilog
module top_mod(
  input  [6:0]  inp_0,
  input  [13:0] inp_7,
  output [13:0] tmp8
);
  wire [13:0] _GEN_0 = {{7{inp_0[6]}},inp_0};
  assign tmp8 = $signed(inp_7) & $signed(_GEN_0);
endmodule
```

Yosys reports formal missmatch:

```
ERROR: Found 7 unproven $equiv cells in 'equiv_status -assert'.
```

note: Similar behavior is true for (and, or, xor) operations","circuit top_mod :
  module top_mod :
    input inp_0: SInt<7>
    input inp_7: SInt<14>
    output tmp8: UInt<14>
    tmp8 <= and(inp_7, inp_0)","module top_mod(
  input  [6:0]  inp_0,
  input  [13:0] inp_7,
  output [13:0] tmp8);

  assign tmp8 = inp_7 & {{7'd0}, inp_0};	// top_mod.fir:3:3, :7:13
endmodule","module top_mod(
  input  [6:0]  inp_0,
  input  [13:0] inp_7,
  output [13:0] tmp8
);
  wire [13:0] _GEN_0 = {{7{inp_0[6]}},inp_0};
  assign tmp8 = $signed(inp_7) & $signed(_GEN_0);
endmodule",ERROR: Found 7 unproven $equiv cells in 'equiv_status -assert'.,,,,,,
347,[FIRRTL] Negative Signed Literal error,2020-12-22T01:00:18Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    output tmp12: SInt<4>
    tmp12 <= SInt<4>(-4)
```
Compiled with `firtool --lower-to-rtl` produces this error:

```python
top_mod.fir:4:22: error: expected '.' in floating point literal
    tmp12 <= SInt<4>(-4)
                     ^
```
","circuit top_mod :
  module top_mod :
    output tmp12: SInt<4>
    tmp12 <= SInt<4>(-4)","top_mod.fir:4:22: error: expected '.' in floating point literal
    tmp12 <= SInt<4>(-4)
                     ^",,,,,,,,
331,[FIRRTL] (shr) core dump,2020-12-15T21:31:45Z,closed,"bug, FIRRTL","maybe related to #326 

The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    output tmp81: SInt<1>
    tmp81 <= shr(SInt<1>(1), 3)
```

Compiled with `firtool --lower-to-rtl` triggers this error:

```bash
firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:859: llvm::APInt llvm::APInt::trunc(unsigned int) const: Assertion `width < BitWidth && ""Invalid APInt Truncate request""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool --lower-to-rtl top_mod.fir --verilog -o=top_mod.v
 #0 0x00000000004bd25f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:563:22
 #1 0x00000000004bd316 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:630:1
 #2 0x00000000004bb332 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bccb2 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:405:1
 #4 0x00007efd5ce521d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007efd5c911a65 raise (/lib64/libc.so.6+0x3da65)
 #6 0x00007efd5c8fa864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007efd5c8fa749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007efd5c909f96 (/lib64/libc.so.6+0x35f96)
 #9 0x00000000004de802 llvm::APInt::trunc(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:860:3
#10 0x000000000076ab02 circt::firrtl::ShrPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/OpFolds.cpp:376:61
#11 0x0000000000754d13 mlir::LogicalResult mlir::Op<circt::firrtl::ShrPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::ShrPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1641:53
#12 0x000000000068c45c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:138:3
#13 0x00000000006860ba mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:566:30
#14 0x0000000000733897 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:186:13
#15 0x00000000007331de mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:89:13
#16 0x0000000000716c23 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#17 0x0000000000716f4e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#18 0x0000000000716e3a mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#19 0x0000000000707e93 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:71
#20 0x000000000084f635 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:368:36
#21 0x000000000084f7ed mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:15
#22 0x00000000008516fd mlir::PassManager::run(mlir::ModuleOp) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:808:73
#23 0x000000000040952d processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:128:15
#24 0x00000000004099a8 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:181:13
#25 0x00007efd5c8fc152 __libc_start_main (/lib64/libc.so.6+0x28152)
#26 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
Aborted (core dumped)
```
","circuit top_mod :
  module top_mod :
    output tmp81: SInt<1>
    tmp81 <= shr(SInt<1>(1), 3)","firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:859: llvm::APInt llvm::APInt::trunc(unsigned int) const: Assertion `width < BitWidth && ""Invalid APInt Truncate request""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool --lower-to-rtl top_mod.fir --verilog -o=top_mod.v
 #0 0x00000000004bd25f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:563:22
 #1 0x00000000004bd316 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:630:1
 #2 0x00000000004bb332 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bccb2 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:405:1
 #4 0x00007efd5ce521d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007efd5c911a65 raise (/lib64/libc.so.6+0x3da65)
 #6 0x00007efd5c8fa864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007efd5c8fa749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007efd5c909f96 (/lib64/libc.so.6+0x35f96)
 #9 0x00000000004de802 llvm::APInt::trunc(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:860:3
#10 0x000000000076ab02 circt::firrtl::ShrPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/OpFolds.cpp:376:61
#11 0x0000000000754d13 mlir::LogicalResult mlir::Op<circt::firrtl::ShrPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::ShrPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1641:53
#12 0x000000000068c45c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:138:3
#13 0x00000000006860ba mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:566:30
#14 0x0000000000733897 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:186:13
#15 0x00000000007331de mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:89:13
#16 0x0000000000716c23 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#17 0x0000000000716f4e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#18 0x0000000000716e3a mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#19 0x0000000000707e93 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:71
#20 0x000000000084f635 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:368:36
#21 0x000000000084f7ed mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:15
#22 0x00000000008516fd mlir::PassManager::run(mlir::ModuleOp) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:808:73
#23 0x000000000040952d processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:128:15
#24 0x00000000004099a8 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:181:13
#25 0x00007efd5c8fc152 __libc_start_main (/lib64/libc.so.6+0x28152)
#26 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
Aborted (core dumped)",,,,,,,,
328,[FIRRTL] (mul) 0-width,2020-12-15T04:14:08Z,closed,"bug, FIRRTL","Maybe related to #319

The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_g: SInt<0>
    input inp_13: SInt<383>
    output tmp75: SInt<383>
    tmp75 <= mul(inp_13, inp_g)
```
Compiled with `firtool --lower-to-rtl` produces this verilog:

```verilog
module top_mod(
  input          inp_g,
  input  [382:0] inp_13,
  output [382:0] tmp75);

  assign tmp75 = inp_13 * {{383{inp_g[4294967295]}}, inp_g};	// top_mod.fir:2:3, :6:14
endmodule
```

That has the following error:

```bash
%Error: top_mod.v:6:38: Illegal bit or array select; type does not have a bit range, or bad dimension: data type is 'logic'
                      : ... In instance top_mod
    6 |   assign tmp75 = inp_13 * {{383{inp_g[4294967295]}}, inp_g};  
      |                                      ^
```
","circuit top_mod :
  module top_mod :
    input inp_g: SInt<0>
    input inp_13: SInt<383>
    output tmp75: SInt<383>
    tmp75 <= mul(inp_13, inp_g)","module top_mod(
  input          inp_g,
  input  [382:0] inp_13,
  output [382:0] tmp75);

  assign tmp75 = inp_13 * {{383{inp_g[4294967295]}}, inp_g};	// top_mod.fir:2:3, :6:14
endmodule","%Error: top_mod.v:6:38: Illegal bit or array select; type does not have a bit range, or bad dimension: data type is 'logic'
                      : ... In instance top_mod
    6 |   assign tmp75 = inp_13 * {{383{inp_g[4294967295]}}, inp_g};  
      |                                      ^",,,,,,,
326,[FIRRTL] (shr) core dump,2020-12-15T03:57:36Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    output tmp57: SInt<1>
    tmp57 <= shr(SInt<7>(29), 47)
```

Compiled with `firtool --lower-to-rtl` triggers this error:

```bash
firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:971: void llvm::APInt::ashrInPlace(unsigned int): Assertion `ShiftAmt <= BitWidth && ""Invalid shift amount""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool --lower-to-rtl top_mod.fir --verilog -o=top_mod.v
 #0 0x00000000004bd25f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:563:22
 #1 0x00000000004bd316 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:630:1
 #2 0x00000000004bb332 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bccb2 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:405:1
 #4 0x00007fd442b431d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007fd442602a65 raise (/lib64/libc.so.6+0x3da65)
 #6 0x00007fd4425eb864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007fd4425eb749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007fd4425faf96 (/lib64/libc.so.6+0x35f96)
 #9 0x00000000004e868c llvm::APInt::ashrInPlace(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:972:21
#10 0x000000000076f5b9 llvm::APInt::ashr(unsigned int) const /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/APInt.h:966:12
#11 0x000000000076aa33 circt::firrtl::ShrPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/OpFolds.cpp:374:37
#12 0x0000000000754d13 mlir::LogicalResult mlir::Op<circt::firrtl::ShrPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::ShrPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1641:53
#13 0x000000000068c45c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:138:3
#14 0x00000000006860ba mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:566:30
#15 0x0000000000733897 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:186:13
#16 0x00000000007331de mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:89:13
#17 0x0000000000716c23 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#18 0x0000000000716f4e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#19 0x0000000000716e3a mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#20 0x0000000000707e93 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:71
#21 0x000000000084f5b3 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:368:36
#22 0x000000000084f76b mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:15
#23 0x000000000085167b mlir::PassManager::run(mlir::ModuleOp) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:808:73
#24 0x000000000040952d processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:128:15
#25 0x00000000004099a8 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:181:13
#26 0x00007fd4425ed152 __libc_start_main (/lib64/libc.so.6+0x28152)
#27 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
Aborted (core dumped)
```
","circuit top_mod :
  module top_mod :
    output tmp57: SInt<1>
    tmp57 <= shr(SInt<7>(29), 47)","firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:971: void llvm::APInt::ashrInPlace(unsigned int): Assertion `ShiftAmt <= BitWidth && ""Invalid shift amount""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool --lower-to-rtl top_mod.fir --verilog -o=top_mod.v
 #0 0x00000000004bd25f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:563:22
 #1 0x00000000004bd316 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:630:1
 #2 0x00000000004bb332 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bccb2 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:405:1
 #4 0x00007fd442b431d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007fd442602a65 raise (/lib64/libc.so.6+0x3da65)
 #6 0x00007fd4425eb864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007fd4425eb749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007fd4425faf96 (/lib64/libc.so.6+0x35f96)
 #9 0x00000000004e868c llvm::APInt::ashrInPlace(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:972:21
#10 0x000000000076f5b9 llvm::APInt::ashr(unsigned int) const /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/APInt.h:966:12
#11 0x000000000076aa33 circt::firrtl::ShrPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/OpFolds.cpp:374:37
#12 0x0000000000754d13 mlir::LogicalResult mlir::Op<circt::firrtl::ShrPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::ShrPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1641:53
#13 0x000000000068c45c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:138:3
#14 0x00000000006860ba mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:566:30
#15 0x0000000000733897 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:186:13
#16 0x00000000007331de mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:89:13
#17 0x0000000000716c23 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21
#18 0x0000000000716f4e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35
#19 0x0000000000716e3a mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1
#20 0x0000000000707e93 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:71
#21 0x000000000084f5b3 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:368:36
#22 0x000000000084f76b mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:15
#23 0x000000000085167b mlir::PassManager::run(mlir::ModuleOp) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:808:73
#24 0x000000000040952d processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:128:15
#25 0x00000000004099a8 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:181:13
#26 0x00007fd4425ed152 __libc_start_main (/lib64/libc.so.6+0x28152)
#27 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
Aborted (core dumped)",,,,,,,,
323,[FIRRTL] firrtl.connect not catching bit truncation,2020-12-13T19:43:09Z,closed,"bug, FIRRTL","I think that this is malformed firrtl, because the connect is truncating from 4 to 6 bits, but it looks like the verifier doesn't reject it:

```
 module Precedence :
    input a: UInt<4>
    input b: UInt<4>
    input c: UInt<4>
    output out1: UInt<1>
    output out: UInt<4>
    out <= add(a, add(b, c))
```

```
   firrtl.module @Precedence(%a: !firrtl.uint<4>, %b: !firrtl.uint<4>, %c: !firrtl.uint<4>, %out1: !firrtl.flip<uint<1>>, %out: !firrtl.flip<uint<4>>) {
      %0 = firrtl.add %b, %c : (!firrtl.uint<4>, !firrtl.uint<4>) -> !firrtl.uint<5>
      %1 = firrtl.add %a, %0 : (!firrtl.uint<4>, !firrtl.uint<5>) -> !firrtl.uint<6>
      firrtl.connect %out, %1 : !firrtl.flip<uint<4>>, !firrtl.uint<6>
 }
```

The LowerToRTL pass is rejecting it, but it seems like the FIRRTL verifier should also catch this.  This would allow the firrtl parser to correct reject the input.","module Precedence :
    input a: UInt<4>
    input b: UInt<4>
    input c: UInt<4>
    output out1: UInt<1>
    output out: UInt<4>
    out <= add(a, add(b, c))","firrtl.module @Precedence(%a: !firrtl.uint<4>, %b: !firrtl.uint<4>, %c: !firrtl.uint<4>, %out1: !firrtl.flip<uint<1>>, %out: !firrtl.flip<uint<4>>) {
      %0 = firrtl.add %b, %c : (!firrtl.uint<4>, !firrtl.uint<4>) -> !firrtl.uint<5>
      %1 = firrtl.add %a, %0 : (!firrtl.uint<4>, !firrtl.uint<5>) -> !firrtl.uint<6>
      firrtl.connect %out, %1 : !firrtl.flip<uint<4>>, !firrtl.uint<6>
 }",,,,,,,,
320,[FIRRTL] literal slicing,2020-12-11T08:30:45Z,closed,"bug, ExportVerilog","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_1: SInt<349>
    output tmp6: UInt<1>
    tmp6 <= eq(inp_1, asSInt(UInt<17>(72236)))
```

Compiled with `firtool --lower-to-rtl` produces this verilog:

```verilog
module top_mod(
  input  [348:0] inp_1,
  output         tmp6);

  assign tmp6 = inp_1 == {{332{17'h11A2C[16]}}, 17'h11A2C};	// top_mod.fir:3:3, :6:{13,30}
endmodule
```
That has the following error:

```verilog
%Error: top_mod.v:5:41: syntax error, unexpected '[', expecting ',' or '}'
    5 |   assign tmp6 = inp_1 == {{332{17'h11A2C[16]}}, 17'h11A2C};  
      |                                         ^
```
","circuit top_mod :
  module top_mod :
    input inp_1: SInt<349>
    output tmp6: UInt<1>
    tmp6 <= eq(inp_1, asSInt(UInt<17>(72236)))","module top_mod(
  input  [348:0] inp_1,
  output         tmp6);

  assign tmp6 = inp_1 == {{332{17'h11A2C[16]}}, 17'h11A2C};	// top_mod.fir:3:3, :6:{13,30}
endmodule","%Error: top_mod.v:5:41: syntax error, unexpected '[', expecting ',' or '}'
    5 |   assign tmp6 = inp_1 == {{332{17'h11A2C[16]}}, 17'h11A2C};  
      |                                         ^",,,,,,,
319,[FIRRTL] (cat) 0-bit width,2020-12-11T07:37:23Z,closed,"bug, ExportVerilog","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_0: UInt<0>
    input inp_1: UInt<5>
    output out_0: UInt<5>
    out_0 <= cat(inp_1, inp_0)
```

Compiled with `firtool --lower-to-rtl` produces this verilog:

```verilog
module top_mod(
  input        inp_0,
  input  [4:0] inp_1,
  output [4:0] out_0);

  assign out_0 = {inp_1, inp_0};	// top_mod.fir:2:3, :6:14
endmodule
```

That has the following error:

```bash
%Warning-WIDTH: top_mod.v:6:16: Operator ASSIGNW expects 5 bits on the Assign RHS, but Assign RHS's REPLICATE generates 6 bits.
                              : ... In instance top_mod
    6 |   assign out_0 = {inp_1, inp_0};  
      |                ^
                ... Use ""/* verilator lint_off WIDTH */"" and lint_on around source to disable this message.
```

Expected Verilog output is:

```verilog
module top_mod(
  input  [4:0] inp_1,
  output [4:0] out_0);

  assign out_0 = inp_1;	// top_mod.fir:2:3, :6:14
endmodule
```
","circuit top_mod :
  module top_mod :
    input inp_0: UInt<0>
    input inp_1: UInt<5>
    output out_0: UInt<5>
    out_0 <= cat(inp_1, inp_0)","module top_mod(
  input        inp_0,
  input  [4:0] inp_1,
  output [4:0] out_0);

  assign out_0 = {inp_1, inp_0};	// top_mod.fir:2:3, :6:14
endmodule","%Warning-WIDTH: top_mod.v:6:16: Operator ASSIGNW expects 5 bits on the Assign RHS, but Assign RHS's REPLICATE generates 6 bits.
                              : ... In instance top_mod
    6 |   assign out_0 = {inp_1, inp_0};  
      |                ^
                ... Use ""/* verilator lint_off WIDTH */"" and lint_on around source to disable this message.","module top_mod(
  input  [4:0] inp_1,
  output [4:0] out_0);

  assign out_0 = inp_1;	// top_mod.fir:2:3, :6:14
endmodule",,,,,,
318,[FIRRTL] (rem) slicing scalar,2020-12-11T07:18:13Z,closed,"bug, ExportVerilog","Similar to #313 

The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input tmp85: UInt<1>
    input tmp79: UInt<1>
    output tmp106: UInt<1>
    tmp106 <= rem(tmp79, tmp85)
```

Compiled with `firtool --lower-to-rtl` produces this verilog:

```verilog
module top_mod(
  input  tmp85, tmp79,
  output tmp106);

  wire _T = tmp79 % tmp85;	// top_mod.fir:7:15
  assign tmp106 = _T[0];	// top_mod.fir:3:3, :7:15
endmodule
```

That has the following error:

```bash
%Error: top_mod.v:6:21: Illegal bit or array select; type does not have a bit range, or bad dimension: data type is 'logic'
                      : ... In instance top_mod
    6 |   assign tmp106 = _T[0];  
      |                     ^
```
","circuit top_mod :
  module top_mod :
    input tmp85: UInt<1>
    input tmp79: UInt<1>
    output tmp106: UInt<1>
    tmp106 <= rem(tmp79, tmp85)","module top_mod(
  input  tmp85, tmp79,
  output tmp106);

  wire _T = tmp79 % tmp85;	// top_mod.fir:7:15
  assign tmp106 = _T[0];	// top_mod.fir:3:3, :7:15
endmodule","%Error: top_mod.v:6:21: Illegal bit or array select; type does not have a bit range, or bad dimension: data type is 'logic'
                      : ... In instance top_mod
    6 |   assign tmp106 = _T[0];  
      |                     ^",,,,,,,
316,[FIRRTL] 0-wide types,2020-12-11T01:01:54Z,closed,"bug, ExportVerilog","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_0: UInt<0>
```

Compiled with `firtool --lower-to-rtl` produces this crash:

```bash
firtool: ../lib/EmitVerilog/EmitVerilog.cpp:258: void {anonymous}::VerilogEmitterBase::emitTypePaddedToWidth(mlir::Type, size_t, mlir::Operation*): Assertion `bitWidth != 0 && ""Shouldn't emit zero bit declarations""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool --lower-to-rtl top_mod.fir --verilog -o=top_mod.v
 #0 0x00000000004bd25f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:563:22
 #1 0x00000000004bd316 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:630:1
 #2 0x00000000004bb332 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bccb2 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:405:1
 #4 0x00007fedea7d61d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007fedea295a65 raise (/lib64/libc.so.6+0x3da65)
 #6 0x00007fedea27e864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007fedea27e749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007fedea28df96 (/lib64/libc.so.6+0x35f96)
 #9 0x00000000004f8658 (anonymous namespace)::VerilogEmitterBase::emitTypePaddedToWidth(mlir::Type, unsigned long, mlir::Operation*) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:260:3
#10 0x0000000000505809 (anonymous namespace)::ModuleEmitter::emitRTLModule(circt::rtl::RTLModuleOp) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:2679:5
#11 0x0000000000506014 (anonymous namespace)::CircuitEmitter::emitMLIRModule(mlir::ModuleOp) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:2837:7
#12 0x00000000005061b2 circt::emitVerilog(mlir::ModuleOp, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:2850:24
#13 0x000000000040962c processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:140:40
#14 0x00000000004099a8 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:181:13
#15 0x00007fedea280152 __libc_start_main (/lib64/libc.so.6+0x28152)
#16 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
Aborted (core dumped)
```
","circuit top_mod :
  module top_mod :
    input inp_0: UInt<0>","firtool: ../lib/EmitVerilog/EmitVerilog.cpp:258: void {anonymous}::VerilogEmitterBase::emitTypePaddedToWidth(mlir::Type, size_t, mlir::Operation*): Assertion `bitWidth != 0 && ""Shouldn't emit zero bit declarations""' failed.
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.      Program arguments: ../../llvm/circt/build/bin/firtool --lower-to-rtl top_mod.fir --verilog -o=top_mod.v
 #0 0x00000000004bd25f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:563:22
 #1 0x00000000004bd316 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:630:1
 #2 0x00000000004bb332 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20
 #3 0x00000000004bccb2 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:405:1
 #4 0x00007fedea7d61d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)
 #5 0x00007fedea295a65 raise (/lib64/libc.so.6+0x3da65)
 #6 0x00007fedea27e864 abort (/lib64/libc.so.6+0x26864)
 #7 0x00007fedea27e749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)
 #8 0x00007fedea28df96 (/lib64/libc.so.6+0x35f96)
 #9 0x00000000004f8658 (anonymous namespace)::VerilogEmitterBase::emitTypePaddedToWidth(mlir::Type, unsigned long, mlir::Operation*) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:260:3
#10 0x0000000000505809 (anonymous namespace)::ModuleEmitter::emitRTLModule(circt::rtl::RTLModuleOp) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:2679:5
#11 0x0000000000506014 (anonymous namespace)::CircuitEmitter::emitMLIRModule(mlir::ModuleOp) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:2837:7
#12 0x00000000005061b2 circt::emitVerilog(mlir::ModuleOp, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:2850:24
#13 0x000000000040962c processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:140:40
#14 0x00000000004099a8 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:181:13
#15 0x00007fedea280152 __libc_start_main (/lib64/libc.so.6+0x28152)
#16 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0
Aborted (core dumped)",,,,,,,,
315,"[FIRRTL] (add, sub) type mismatch between destination and source",2020-12-10T23:44:57Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_v: UInt<93>
    input inp_1l: SInt<37>
    output tmp118: UInt<94>
    tmp118 <= sub(asSInt(inp_v), inp_1l)
```

Should be fine according to FIRRTL spec

![image](https://user-images.githubusercontent.com/511872/101843179-80af2c00-3afe-11eb-8ded-5c398eae7d72.png)

But compiled with `firtool --lower-to-rtl` produces this error:

```mlir
top_mod.fir:7:12: error: type mismatch between destination '!firrtl.uint<94>' and source '!firrtl.sint<94>'
    tmp118 <= sub(asSInt(inp_v), inp_1l)
```

A similar problem happens with an `add` operation","circuit top_mod :
  module top_mod :
    input inp_v: UInt<93>
    input inp_1l: SInt<37>
    output tmp118: UInt<94>
    tmp118 <= sub(asSInt(inp_v), inp_1l)","top_mod.fir:7:12: error: type mismatch between destination '!firrtl.uint<94>' and source '!firrtl.sint<94>'
    tmp118 <= sub(asSInt(inp_v), inp_1l)",,,,,,,,
314,[FIRRTL] div truncation,2020-12-10T23:21:19Z,closed,"bug, FIRRTL","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_2: UInt<27>
    input inp_i: UInt<65>
    output tmp48: UInt<27>
    tmp48 <= div(inp_2, inp_i)
```

Compiled with `firtool --lower-to-rtl` produces this error:

```mlir
ttop_mod.fir:6:14: error: operand should not be a truncation
    tmp48 <= div(inp_2, inp_i)
             ^
```

it also generates this Verilog:

```verilog
module top_mod(
  input  [26:0] inp_2,
  input  [64:0] inp_i,
  output [26:0] tmp48);

  assign tmp48 = inp_2 / inp_i;	// top_mod.fir:2:3, :6:14
endmodule
```

Verilator Linter is not happy about it:

```bash
%Warning-WIDTH: top_mod.v:6:24: Operator DIV expects 65 bits on the LHS, but LHS's VARREF 'inp_2' generates 27 bits.
                              : ... In instance top_mod
    6 |   assign tmp48 = inp_2 / inp_i;  
      |                        ^
                ... Use ""/* verilator lint_off WIDTH */"" and lint_on around source to disable this message.
%Warning-WIDTH: top_mod.v:6:16: Operator ASSIGNW expects 27 bits on the Assign RHS, but Assign RHS's DIV generates 65 bits.
                              : ... In instance top_mod
    6 |   assign tmp48 = inp_2 / inp_i;  
      |                ^
```

Part from FIRRTL spec

![image](https://user-images.githubusercontent.com/511872/101842129-3b89fa80-3afc-11eb-8446-ce5af07b6dcf.png)
","circuit top_mod :
  module top_mod :
    input inp_2: UInt<27>
    input inp_i: UInt<65>
    output tmp48: UInt<27>
    tmp48 <= div(inp_2, inp_i)","ttop_mod.fir:6:14: error: operand should not be a truncation
    tmp48 <= div(inp_2, inp_i)
             ^","module top_mod(
  input  [26:0] inp_2,
  input  [64:0] inp_i,
  output [26:0] tmp48);

  assign tmp48 = inp_2 / inp_i;	// top_mod.fir:2:3, :6:14
endmodule","%Warning-WIDTH: top_mod.v:6:24: Operator DIV expects 65 bits on the LHS, but LHS's VARREF 'inp_2' generates 27 bits.
                              : ... In instance top_mod
    6 |   assign tmp48 = inp_2 / inp_i;  
      |                        ^
                ... Use ""/* verilator lint_off WIDTH */"" and lint_on around source to disable this message.
%Warning-WIDTH: top_mod.v:6:16: Operator ASSIGNW expects 27 bits on the Assign RHS, but Assign RHS's DIV generates 65 bits.
                              : ... In instance top_mod
    6 |   assign tmp48 = inp_2 / inp_i;  
      |                ^",,,,,,
313,[FIRRTL] slicing scalars,2020-12-10T20:10:55Z,closed,"bug, ExportVerilog","The following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_8: SInt<1>
    output tmp9: SInt<1>
    tmp9 <= shr(inp_8, 42)
```

Compiled with `firtool` produces this verilog:

```verilog
module top_mod(
  input  inp_8,
  output tmp9);

  assign tmp9 = inp_8[0];	// top_mod.fir:6:{10,13}
endmodule
```

That has the following error:

```bash
> verilator --lint-only top_mod.v 

%Error: top_mod.v:57:22: Illegal bit or array select; type does not have a bit range, or bad dimension: data type is 'logic'
                       : ... In instance top_mod
   57 |   assign tmp9 = inp_8[0];  
      |                      ^
```
","circuit top_mod :
  module top_mod :
    input inp_8: SInt<1>
    output tmp9: SInt<1>
    tmp9 <= shr(inp_8, 42)","module top_mod(
  input  inp_8,
  output tmp9);

  assign tmp9 = inp_8[0];	// top_mod.fir:6:{10,13}
endmodule","> verilator --lint-only top_mod.v 

%Error: top_mod.v:57:22: Illegal bit or array select; type does not have a bit range, or bad dimension: data type is 'logic'
                       : ... In instance top_mod
   57 |   assign tmp9 = inp_8[0];  
      |                      ^",,,,,,,
311,[FIRRTL] (or) operation with duplicate input,2020-12-10T05:57:06Z,closed,"bug, FIRRTL","`firtool` with the following FIRRTL program

```python
circuit top_mod :
  module top_mod :
    input inp_r: SInt<38>
    output tmp874: UInt<38>
    tmp874 <= or(inp_r, inp_r)
```

Generates this error:

```mlir
drom@linux-sydi:~/work/github/drom/circt-fuzzer> ../../llvm/circt/build/bin/firtool top_mod.fir
top_mod.fir:6:12: error: type mismatch between destination '!firrtl.uint<38>' and source '!firrtl.sint<38>'
    tmp874 <= or(inp_r, inp_r)
           ^
top_mod.fir:6:12: note: see current operation: ""firrtl.connect""(%tmp874, %inp_r) : (!firrtl.flip<uint<38>>, !firrtl.sint<38>) -> ()
```

Is this expected?","circuit top_mod :
  module top_mod :
    input inp_r: SInt<38>
    output tmp874: UInt<38>
    tmp874 <= or(inp_r, inp_r)","drom@linux-sydi:~/work/github/drom/circt-fuzzer> ../../llvm/circt/build/bin/firtool top_mod.fir
top_mod.fir:6:12: error: type mismatch between destination '!firrtl.uint<38>' and source '!firrtl.sint<38>'
    tmp874 <= or(inp_r, inp_r)
           ^
top_mod.fir:6:12: note: see current operation: ""firrtl.connect""(%tmp874, %inp_r) : (!firrtl.flip<uint<38>>, !firrtl.sint<38>) -> ()",,,,,,,,
261,[FIRRTL] instances with flipped bundles breaks LowerTypes,2020-11-19T15:44:42Z,closed,"bug, FIRRTL","  firrtl.circuit ""foo"" {
    firrtl.module @bar(%clock: !firrtl.clock, %reset: !firrtl.uint<1>) {
    }
    firrtl.module @foo(%clock: !firrtl.clock, %reset: !firrtl.uint<1>) {
      %int_bus = firrtl.instance @bar {name = ""int_bus""} : !firrtl.flip<bundle<clock: clock, reset: uint<1>>>
      %0 = firrtl.subfield %int_bus(""clock"") : (!firrtl.flip<bundle<clock: clock, reset: uint<1>>>) -> !firrtl.flip<clock>
      firrtl.connect %0, %clock : !firrtl.flip<clock>, !firrtl.clock
      %1 = firrtl.subfield %int_bus(""reset"") : (!firrtl.flip<bundle<clock: clock, reset: uint<1>>>) -> !firrtl.flip<uint<1>>
      firrtl.connect %1, %reset : !firrtl.flip<uint<1>>, !firrtl.uint<1>
    }

  }
",,,,,,,,,,
243,[FIRRTL] Inconsistent int type width,2020-11-13T19:57:14Z,closed,"bug, FIRRTL","In [`test/firrtl/test.mlir`,](https://github.com/llvm/circt/blob/688bd0d6f39f20367a305317ca5891dddc301c8f/test/firrtl/test.mlir#L32) there is the following firrtl dialect IR:

```
firrtl.circuit ""Top"" {
  firrtl.module @Top(%out: !firrtl.flip<uint>,
                     %b: !firrtl.uint<32>,
                     %c: !firrtl.analog<13>,
                     %d: !firrtl.uint<16>) {
    %3 = firrtl.add %b, %d : (!firrtl.uint<32>, !firrtl.uint<16>) -> !firrtl.uint<32>
    ....
  }
}
```
The resulting type of `%3` is given as `uint<32>` but when we look at [`getAddSubResult`](https://github.com/llvm/circt/blob/688bd0d6f39f20367a305317ca5891dddc301c8f/lib/Dialect/FIRRTL/Ops.cpp#L838) it should be `uint<33>`.
There are several inconsistent types in tests (basically related to add/sub op). Is it allowed or should we just prohibit this in the verifier? ","firrtl.circuit ""Top"" {
  firrtl.module @Top(%out: !firrtl.flip<uint>,
                     %b: !firrtl.uint<32>,
                     %c: !firrtl.analog<13>,
                     %d: !firrtl.uint<16>) {
    %3 = firrtl.add %b, %d : (!firrtl.uint<32>, !firrtl.uint<16>) -> !firrtl.uint<32>
    ....
  }
}",,,,,,,,,
240,[ESI] Cosim integration test should poll for server,2020-11-12T01:57:47Z,closed,bug,"Currently, it just waits for 50ms. Set up the lit test format to poll instead.",,,,,,,,,,
235,[FIRRTL] Align dhsl lowering with Scala FIRRTL Compiler,2020-11-11T20:31:36Z,closed,"bug, FIRRTL","The Scala FIRRTL Compiler (SFC) does some width padding of the `dshl` operator which is not done by FIRRTL Dialect lowering, i.e., using `firtool`. Specifically, the padding for a shift is:

1. Sign extend the input up to the max width of the shift
2. Convert the `dshl` to a `dshlw`
3. Sign extend the input up to the width of the output

The current lowering from FIRRTL dialect will, from my quick look, cause an issue when lowering `firrtl.sint` shifted into a larger value because the sign extension won't be applied.

Consider the following circuit:

```
circuit Foo:
  module Foo:
    input a_uint: UInt<2>
    output b_uint: UInt<8>
    input a_sint: SInt<2>
    output b_sint: SInt<8>
    input c: UInt<1>
    b_uint <= dshl(a_uint, c)
    b_sint <= dshl(a_sint, c)
```

The SFC will produce, after the `firrtl.passes.PadWidths` transform (`firrtl -i Foo.fir -cll 'firrtl.passes.PadWidths$:trace' && cat Foo.v`):

```
circuit Foo :
  module Foo :
    input a_uint : UInt<2>
    output b_uint : UInt<8>
    input a_sint : SInt<2>
    output b_sint : SInt<8>
    input c : UInt<1>

    b_uint <= pad(dshlw(pad(a_uint, 3), c), 8)
    b_sint <= pad(dshlw(pad(a_sint, 3), c), 8)
```

And the following Verilog:

```verilog
module Foo(
  input  [1:0] a_uint,
  output [7:0] b_uint,
  input  [1:0] a_sint,
  output [7:0] b_sint,
  input        c
);
  wire [2:0] _GEN_0 = {{1'd0}, a_uint};
  wire [2:0] _GEN_1 = _GEN_0 << c;
  wire [2:0] _GEN_2 = {{1{a_sint[1]}},a_sint};
  wire [2:0] _GEN_3 = $signed(_GEN_2) << c;
  assign b_uint = {{5'd0}, _GEN_1};
  assign b_sint = {{5{_GEN_3[2]}},_GEN_3};
endmodule
```

Using `firtool` we get (`firtool -verilog Foo.fir`):

```verilog
module Foo(
  input  [1:0] a_uint,
  output [7:0] b_uint,
  input  [1:0] a_sint,
  output [7:0] b_sint,
  input        c);

  assign b_uint = a_uint << c;	// Foo.fir:8:{12,15}
  assign b_sint = a_sint << c;	// Foo.fir:9:{12,15}
endmodule
```

Note that this style of padding will happen for all other primops, but `dshl` is the only one that results in an operand conversion. 

This issue doesn't matter for any FIRRTL where optimizations have run (since optimizations include `firrtl.passes.PadWidths`). However, this will crop up when trying to lower SFC unoptimized Low FIRRTL.","circuit Foo:
  module Foo:
    input a_uint: UInt<2>
    output b_uint: UInt<8>
    input a_sint: SInt<2>
    output b_sint: SInt<8>
    input c: UInt<1>
    b_uint <= dshl(a_uint, c)
    b_sint <= dshl(a_sint, c)","circuit Foo :
  module Foo :
    input a_uint : UInt<2>
    output b_uint : UInt<8>
    input a_sint : SInt<2>
    output b_sint : SInt<8>
    input c : UInt<1>

    b_uint <= pad(dshlw(pad(a_uint, 3), c), 8)
    b_sint <= pad(dshlw(pad(a_sint, 3), c), 8)","module Foo(
  input  [1:0] a_uint,
  output [7:0] b_uint,
  input  [1:0] a_sint,
  output [7:0] b_sint,
  input        c
);
  wire [2:0] _GEN_0 = {{1'd0}, a_uint};
  wire [2:0] _GEN_1 = _GEN_0 << c;
  wire [2:0] _GEN_2 = {{1{a_sint[1]}},a_sint};
  wire [2:0] _GEN_3 = $signed(_GEN_2) << c;
  assign b_uint = {{5'd0}, _GEN_1};
  assign b_sint = {{5{_GEN_3[2]}},_GEN_3};
endmodule","module Foo(
  input  [1:0] a_uint,
  output [7:0] b_uint,
  input  [1:0] a_sint,
  output [7:0] b_sint,
  input        c);

  assign b_uint = a_uint << c;	// Foo.fir:8:{12,15}
  assign b_sint = a_sint << c;	// Foo.fir:9:{12,15}
endmodule",,,,,,
206,[FIRRTL] LowerToRTL Unhandled op failure,2020-11-05T23:38:41Z,closed,"bug, FIRRTL","Consider:
module {
  firrtl.circuit ""foo"" {
    firrtl.module @bar(%io_cpu_flush: !firrtl.uint<1>) {}
    firrtl.module @foo() {
      %fetch = firrtl.instance @bar {name = ""fetch""} : !firrtl.bundle<io_cpu_flush: flip<uint<1>>>
      %1454 = firrtl.subfield %fetch(""io_cpu_flush"") : (!firrtl.bundle<io_cpu_flush: flip<uint<1>>>) -> !firrtl.flip<uint<1>>
      %hits_1_7 = firrtl.node %1454 {name = ""hits_1_7""} : !firrtl.flip<uint<1>>
      %1455 = firrtl.asPassive %hits_1_7 : (!firrtl.flip<uint<1>>) -> !firrtl.uint<1>
    }
  }
}

FIRRTLLowering::handleUnloweredOp inserts a StdIntCast to a flipped type which fails to verify.",,,,,,,,,,
204,FIRRTL memories of depth 1 are not index correctly,2020-11-05T17:53:42Z,closed,"bug, FIRRTL","Consider:
```

circuit foo :

  module foo :
    input clock : Clock
    input reset : UInt<1>

    mem bar : @[Decoupled.scala 218:16]
      data-type => UInt<3>
      depth => 1
      read-latency => 0
      write-latency => 1
      reader => io_deq_bits_MPORT
      writer => MPORT
      read-under-write => undefined
    
    bar.io_deq_bits_MPORT.addr <= UInt<1>(""h0"")
```

firtool infers a zero-width address for the memory, but chisel is attaching 1-bit integers to it.","circuit foo :

  module foo :
    input clock : Clock
    input reset : UInt<1>

    mem bar : @[Decoupled.scala 218:16]
      data-type => UInt<3>
      depth => 1
      read-latency => 0
      write-latency => 1
      reader => io_deq_bits_MPORT
      writer => MPORT
      read-under-write => undefined
    
    bar.io_deq_bits_MPORT.addr <= UInt<1>(""h0"")",,,,,,,,,
186,[All Dialects] Deprecated OpBuilder format,2020-10-28T03:16:01Z,closed,bug,"With #184 we get a bunch of warnings:
```
/home/jodemme/circt/include/circt/Dialect/SV/Statements.td:74:1: warning: Op uses a deprecated, string-based OpBuilder format; use OpBuilderDAG with '(ins <...>)' instead
def AlwaysAtPosEdgeOp : SVOp<""alwaysat_posedge"", [HasRegionTerminator]>,
```","/home/jodemme/circt/include/circt/Dialect/SV/Statements.td:74:1: warning: Op uses a deprecated, string-based OpBuilder format; use OpBuilderDAG with '(ins <...>)' instead
def AlwaysAtPosEdgeOp : SVOp<""alwaysat_posedge"", [HasRegionTerminator]>,",,,,,,,,,
183,[FIRRTL] Parser fails on negative integer parameters,2020-10-26T23:55:05Z,closed,"bug, FIRRTL","Signed integer parameters will cause the FIRRTL dialect parser to fail. 

Consider the following FIRRTL snippet:

```
circuit Foo:
  extmodule Bar:
    parameter A = -1
  module Foo:
    inst bar of Bar
```

When run through the Scala FIRRTL compiler, you get the following Verilog:

```verilog
module Foo(
);
  Bar #(.A(-1)) bar (
  );
endmodule
```

When run through `firtool` you get:

```bash
firtool Foo.fir
# Foo.fir:3:19: error: expected '.' in floating point literal
#    parameter A = -1
#                  ^
```

This also may motivate a change in the underlying data format of integer parameters. Clearly, something like `-1` needs to be set as a signed integer. However, should unsigned parameters continue to be stored as signless types, should they be unsigned, or should they be signed?","circuit Foo:
  extmodule Bar:
    parameter A = -1
  module Foo:
    inst bar of Bar","module Foo(
);
  Bar #(.A(-1)) bar (
  );
endmodule","firtool Foo.fir
# Foo.fir:3:19: error: expected '.' in floating point literal
#    parameter A = -1
#                  ^",,,,,,,
181,[FIRRTL] AsAsyncResetPrimOp type check is too restrictive,2020-10-26T17:43:30Z,closed,"bug, FIRRTL","The input type required by `AsAsyncResetPrimOp` is too restrictive. The FIRRTL dialect restricts this to `UInt`, `SInt`, or `Clock` types, but the Scala FIRRTL compiler [allows any FIRRTL type](https://github.com/freechipsproject/firrtl/blob/d1c0181e716c37142e233beed2efcea5c5794aa7/src/main/scala/firrtl/passes/CheckTypes.scala#L217).

As one example, the following should not error:

```
circuit Foo :
  module Foo :
    input in : AsyncReset
    output out : AsyncReset

    out <= asAsyncReset(in)
```

Currently, this does:

```bash
firtool AsyncReset.fir 
# AsyncReset.fir:5:12: error: invalid input types for 'asAsyncReset': '!firrtl.asyncreset'
#    out <= asAsyncReset(in)
```","circuit Foo :
  module Foo :
    input in : AsyncReset
    output out : AsyncReset

    out <= asAsyncReset(in)","firtool AsyncReset.fir 
# AsyncReset.fir:5:12: error: invalid input types for 'asAsyncReset': '!firrtl.asyncreset'
#    out <= asAsyncReset(in)",,,,,,,,
180,[FIRRTL] Parse dshlw,2020-10-26T17:06:34Z,closed,"bug, FIRRTL","The Scala FIRRTL compiler adds an undocumented operand, `dshlw`, in the [`PadWidths` transform](https://github.com/freechipsproject/firrtl/blob/d1c0181e716c37142e233beed2efcea5c5794aa7/src/main/scala/firrtl/passes/PadWidths.scala#L64). This will show up in emitted output if you run a low FIRRTL IR emitter with optimizations turned on, e.g.,:

```bash
firrtl -i Foo.fir -X verilog -E low -E verilog
```

This operand should (at least) be parsed by the FIRRTL CIRCT dialect for the same reason that we also parse `cmem` and `smem`---we should strive for interoperability with the lone extant FIRRTL compiler implementation.",firrtl -i Foo.fir -X verilog -E low -E verilog,,,,,,,,,
164,[FIRRTL] firrtl.tail needs to be able to return signed results,2020-10-20T15:47:05Z,closed,"bug, FIRRTL",firrtl produces tail operations on sint.  Currently the firrtl dialect requires unsigned results. ,,,,,,,,,,
163,[FIRRTL] module instances can appear before module declarations,2020-10-20T15:46:09Z,closed,"bug, FIRRTL",Output from firrtl can have module instances before module declarations.  firtool rejects these files.,,,,,,,,,,
139,"[RTL] Fix EmitVerilog.cpp's handling of signed/unsigned rtl dialect ops like divide, rem, compare, etc",2020-10-12T14:33:50Z,closed,"bug, HW","RTL is currently signed-by-operation, but FIRRTL and verilog are sign-by-operand-type.  RTL to verilog emission is broken for signed operations.",,,,,,,,,,
31,linker error building from master,2020-07-08T03:19:45Z,closed,bug,"I am getting linker errors while building from master

```
/usr/bin/ld: lib/libMLIRHandshakeOps.a(HandshakeOps.cpp.o): in function `ValueRange<llvm::SmallVector<mlir::Value, 4> &, void>':
/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'
clang-10.0: error: linker command failed with exit code 1 (use -v to see invocation)
```

```
ldl  -ltinfo  -lpthread  -lm  ../llvm/build/lib/libLLVMDemangle.a && :
/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 2> &, void>':
/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'
/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 5> &, void>':
/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'
/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 7> &, void>':
/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'
/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 1> &, void>':
/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'
/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 3> &, void>':
/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'
clang-10.0: error: linker command failed with exit code 1 (use -v to see invocation)
```

Anybody experiencing similar issues?","/usr/bin/ld: lib/libMLIRHandshakeOps.a(HandshakeOps.cpp.o): in function `ValueRange<llvm::SmallVector<mlir::Value, 4> &, void>':
/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'
clang-10.0: error: linker command failed with exit code 1 (use -v to see invocation)","ldl  -ltinfo  -lpthread  -lm  ../llvm/build/lib/libLLVMDemangle.a && :
/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 2> &, void>':
/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'
/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 5> &, void>':
/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'
/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 7> &, void>':
/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'
/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 1> &, void>':
/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'
/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 3> &, void>':
/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'
clang-10.0: error: linker command failed with exit code 1 (use -v to see invocation)",,,,,,,,
2,"""reg"" is invalid Verilog identifier",2020-04-30T05:30:38Z,closed,"bug, ExportVerilog","Like many other Verilog keywords, `reg` is an invalid identifier.

https://github.com/sifive/clattner-experimental/blob/d231ef24235ce132fd93c313771c56888161e482/test/EmitVerilog/verilog-basic.fir#L343
",,,,,,,,,,
