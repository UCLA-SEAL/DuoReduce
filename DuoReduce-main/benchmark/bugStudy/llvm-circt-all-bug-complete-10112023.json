[{"number": 6275, "title": "[ExportVerilog] Aggregate constant produces invalid assignment pattern", "created_at": "2023-10-10T18:38:20Z", "state": "open", "labels": "bug, ExportVerilog", "body": "The following snippet of MLIR creates an aggregate constant of a struct nested in an array nested in a struct:\r\n```mlir\r\nhw.module @Foo() {\r\n    %bar = sv.reg : !hw.inout<struct<mem: !hw.array<1xstruct<sink: i1>>>>\r\n    %0 = hw.aggregate_constant [[[false]]] : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>\r\n    sv.assign %bar, %0 : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>\r\n}\r\n```\r\nRunning this through `circt-opt --export-verilog` produces the following invalid Verilog:\r\n```verilog\r\nmodule Foo();\r\n  struct packed {struct packed {logic sink; }[0:0] mem; } bar;\r\n  assign bar = '{mem: {'{sink: 1'h0}}};\r\nendmodule\r\n```\r\nThe problematic part is `'{mem: {'{sink: 1'h0}}}`, which contains an assignment pattern `'{sink: 1'h0}` inside a concatenation `{...}` (without the `'`). The assignment pattern `'{...}` (with the `'`) requires an assignment-like context, which the concatenation is not.\r\n\r\nMaybe we can emit the array also as an assignment pattern `'{...}`. Or add explicit types to the assignment patterns somehow, like `struct {...} '{...}`?", "code_snippet_01": "hw.module @Foo() {\r\n    %bar = sv.reg : !hw.inout<struct<mem: !hw.array<1xstruct<sink: i1>>>>\r\n    %0 = hw.aggregate_constant [[[false]]] : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>\r\n    sv.assign %bar, %0 : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>\r\n}", "code_snippet_02": "module Foo();\r\n  struct packed {struct packed {logic sink; }[0:0] mem; } bar;\r\n  assign bar = '{mem: {'{sink: 1'h0}}};\r\nendmodule"}, {"number": 6273, "title": "[HW] Crash in `seq.firreg` canonicalizer", "created_at": "2023-10-09T19:02:20Z", "state": "closed", "labels": "bug, HW", "body": "When playing with some read-only memories in FIRRTL, I came across the following MLIR which causes a crash because the utility `hw::getBitWidth` only knows about HW types, but is being used on a `seq.clock`. This returns the `-1` \"unknown\" value and then blows up:\r\n\r\n```mlir\r\nhw.module @Foo(in %clock : !seq.clock, out r_data : !seq.clock) {\r\n  %0 = seq.const_clock  low\r\n  %1 = seq.firreg %1 clock %0 : !seq.clock\r\n  hw.output %1 : !seq.clock\r\n}\r\n```\r\n\r\n```\r\n# circt-opt -canonicalize Foo.mlir\r\n<unknown>:0: error: integer bitwidth is limited to 16777215 bits\r\nAssertion failed: (succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))), function get, file StorageUniquerSupport.h, line 181.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: firtool firrtl-snippets/circt/xxx.mlir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x0000000104c17be0 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 88\r\n1  firtool                  0x0000000104c181fc PrintStackTraceSignalHandler(void*) + 28\r\n2  firtool                  0x0000000104c15d90 llvm::sys::RunSignalHandlers() + 152\r\n3  firtool                  0x0000000104c194d4 SignalHandler(int) + 276\r\n4  libsystem_platform.dylib 0x00000001a866aa24 _sigtramp + 56\r\n5  libsystem_pthread.dylib  0x00000001a863bc28 pthread_kill + 288\r\n6  libsystem_c.dylib        0x00000001a8549ae8 abort + 180\r\n7  libsystem_c.dylib        0x00000001a8548e44 err + 0\r\n8  firtool                  0x000000010556f174 mlir::IntegerType mlir::detail::StorageUserBase<mlir::IntegerType, mlir::Type, mlir::detail::IntegerTypeStorage, mlir::detail::TypeUniquer>::get<unsigned int, mlir::IntegerType::SignednessSemantics>(mlir::MLIRContext*, unsigned int, mlir::IntegerType::SignednessSemantics) + 152\r\n9  firtool                  0x000000010556ef74 mlir::IntegerType::get(mlir::MLIRContext*, unsigned int, mlir::IntegerType::SignednessSemantics) + 84\r\n10 firtool                  0x000000010604427c circt::hw::ConstantOp::build(mlir::OpBuilder&, mlir::OperationState&, llvm::APInt const&) + 60\r\n11 firtool                  0x0000000105ccaf6c circt::hw::ConstantOp mlir::OpBuilder::create<circt::hw::ConstantOp, llvm::APInt>(mlir::Location, llvm::APInt&&) + 132\r\n12 firtool                  0x000000010515ea7c circt::seq::FirRegOp::canonicalize(circt::seq::FirRegOp, mlir::PatternRewriter&) + 588\r\n```", "code_snippet_01": "hw.module @Foo(in %clock : !seq.clock, out r_data : !seq.clock) {\r\n  %0 = seq.const_clock  low\r\n  %1 = seq.firreg %1 clock %0 : !seq.clock\r\n  hw.output %1 : !seq.clock\r\n}", "code_snippet_02": "# circt-opt -canonicalize Foo.mlir\r\n<unknown>:0: error: integer bitwidth is limited to 16777215 bits\r\nAssertion failed: (succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))), function get, file StorageUniquerSupport.h, line 181.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: firtool firrtl-snippets/circt/xxx.mlir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x0000000104c17be0 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 88\r\n1  firtool                  0x0000000104c181fc PrintStackTraceSignalHandler(void*) + 28\r\n2  firtool                  0x0000000104c15d90 llvm::sys::RunSignalHandlers() + 152\r\n3  firtool                  0x0000000104c194d4 SignalHandler(int) + 276\r\n4  libsystem_platform.dylib 0x00000001a866aa24 _sigtramp + 56\r\n5  libsystem_pthread.dylib  0x00000001a863bc28 pthread_kill + 288\r\n6  libsystem_c.dylib        0x00000001a8549ae8 abort + 180\r\n7  libsystem_c.dylib        0x00000001a8548e44 err + 0\r\n8  firtool                  0x000000010556f174 mlir::IntegerType mlir::detail::StorageUserBase<mlir::IntegerType, mlir::Type, mlir::detail::IntegerTypeStorage, mlir::detail::TypeUniquer>::get<unsigned int, mlir::IntegerType::SignednessSemantics>(mlir::MLIRContext*, unsigned int, mlir::IntegerType::SignednessSemantics) + 152\r\n9  firtool                  0x000000010556ef74 mlir::IntegerType::get(mlir::MLIRContext*, unsigned int, mlir::IntegerType::SignednessSemantics) + 84\r\n10 firtool                  0x000000010604427c circt::hw::ConstantOp::build(mlir::OpBuilder&, mlir::OperationState&, llvm::APInt const&) + 60\r\n11 firtool                  0x0000000105ccaf6c circt::hw::ConstantOp mlir::OpBuilder::create<circt::hw::ConstantOp, llvm::APInt>(mlir::Location, llvm::APInt&&) + 132\r\n12 firtool                  0x000000010515ea7c circt::seq::FirRegOp::canonicalize(circt::seq::FirRegOp, mlir::PatternRewriter&) + 588"}, {"number": 6272, "title": "[LowerToHW] Error in firtool-1.54.0 Memory Lowering w/ Clock Type", "created_at": "2023-10-09T18:21:57Z", "state": "open", "labels": "bug, FIRRTL, HW", "body": "I ran into a bug with `firtool`'s lowering of FIRRTL memories. If you have a memory that includes a `Clock` type, then `LowerToHW` creates a wire of type `(i1) -> !seq.clock` which the verifier is unhappy about.\r\n\r\nExample:\r\n\r\n```\r\ncircuit Foo:\r\n  module Foo:\r\n    input r: {addr: UInt<3>, en: UInt<1> clk: Clock, flip data: {a: Clock}}\r\n    input w: {addr: UInt<3>, en: UInt<1> clk: Clock, data: {a: Clock}, mask: {a: UInt<1>}}\r\n\r\n    mem memory:\r\n      data-type => {a: Clock}\r\n      depth => 16\r\n      reader => r\r\n      writer => w\r\n      read-latency => 1\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.r <= r\r\n    memory.w <= w\r\n```\r\n\r\nCompiling with `firtool-1.54.0 Memory.fir`:\r\n```\r\nMemory.fir:6:5: error: 'hw.wire' op requires the same type for all operands and results\r\n    mem memory:\r\n    ^\r\nMemory.fir:6:5: note: see current operation: %2 = \"hw.wire\"(%5) {name = \"memory_r_data_a\"} : (i1) -> !seq.clock\r\n```\r\n\r\nThe failing MLIR is:\r\n```mlir\r\n#loc = loc(\"Memory.fir\":3:11)\r\n#loc1 = loc(\"Memory.fir\":4:11)\r\n\"builtin.module\"() ({\r\n  \"hw.module\"() ({\r\n  ^bb0(%arg0: i3, %arg1: i1, %arg2: !seq.clock, %arg3: i3, %arg4: i1, %arg5: !seq.clock, %arg6: !seq.clock, %arg7: i1):\r\n    %0 = \"hw.constant\"() {value = false} : () -> i1\r\n    %1 = \"hw.wire\"(%7) {name = \"memory_r_addr\"} : (i4) -> i4\r\n    %2 = \"hw.wire\"(%5) {name = \"memory_r_data_a\"} : (i1) -> !seq.clock\r\n    %3 = \"hw.wire\"(%8) {name = \"memory_w_addr\"} : (i4) -> i4\r\n    %4 = \"seq.firmem\"() <{name = \"memory_a\", prefix = \"\", readLatency = 1 : i32, ruw = 0 : i32, writeLatency = 1 : i32, wuw = 1 : i32}> : () -> !seq.firmem<16 x 1>\r\n    %5 = \"seq.firmem.read_port\"(%4, %1, %arg2, %arg1) : (!seq.firmem<16 x 1>, i4, !seq.clock, i1) -> i1\r\n    %6 = \"comb.and\"(%arg4, %arg7) <{twoState}> : (i1, i1) -> i1\r\n    \"seq.firmem.write_port\"(%4, %3, %arg5, %6, %arg6) <{operandSegmentSizes = array<i32: 1, 1, 1, 1, 1, 0>}> : (!seq.firmem<16 x 1>, i4, !seq.clock, i1, !seq.clock) -> ()\r\n    %7 = \"comb.concat\"(%0, %arg0) : (i1, i3) -> i4\r\n    %8 = \"comb.concat\"(%0, %arg3) : (i1, i3) -> i4\r\n    \"hw.output\"(%2) : (!seq.clock) -> ()\r\n  }) {argLocs = [#loc, #loc, #loc, #loc1, #loc1, #loc1, #loc1, #loc1], argNames = [\"r_addr\", \"r_en\", \"r_clk\", \"w_addr\", \"w_en\", \"w_clk\", \"w_data_a\", \"w_mask_a\"], arg_attrs = [{}, {}, {}, {}, {}, {}, {}, {}], comment = \"\", function_type = (i3, i1, !seq.clock, i3, i1, !seq.clock, !seq.clock, i1) -> !seq.clock, parameters = [], res_attrs = [{}], resultLocs = [#loc], resultNames = [\"r_data_a\"], sym_name = \"Foo\"} : () -> ()\r\n}) : () -> ()\r\n```\r\n\r\nIf I compile with `firtool-1.53.0 Memory.fir -disable-all-randomization`, I get the following Verilog:\r\n```verilog\r\n// Generated by CIRCT firtool-1.53.0\r\n// VCS coverage exclude_file\r\nmodule memory_a_16x1(\r\n  input  [3:0] R0_addr,\r\n  input        R0_en,\r\n               R0_clk,\r\n  input  [3:0] W0_addr,\r\n  input        W0_en,\r\n               W0_clk,\r\n               W0_data,\r\n  output       R0_data\r\n);\r\n\r\n  reg       Memory[0:15];\r\n  reg       _R0_en_d0;\r\n  reg [3:0] _R0_addr_d0;\r\n  always @(posedge R0_clk) begin\r\n    _R0_en_d0 <= R0_en;\r\n    _R0_addr_d0 <= R0_addr;\r\n  end // always @(posedge)\r\n  always @(posedge W0_clk) begin\r\n    if (W0_en)\r\n      Memory[W0_addr] <= W0_data;\r\n  end // always @(posedge)\r\n  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 1'bx;\r\nendmodule\r\n\r\nmodule Foo(\r\n  input  [2:0] r_addr,\r\n  input        r_en,\r\n               r_clk,\r\n  input  [2:0] w_addr,\r\n  input        w_en,\r\n               w_clk,\r\n               w_data_a,\r\n               w_mask_a,\r\n  output       r_data_a\r\n);\r\n\r\n  memory_a_16x1 memory_a_ext (\r\n    .R0_addr ({1'h0, r_addr}),\r\n    .R0_en   (r_en),\r\n    .R0_clk  (r_clk),\r\n    .W0_addr ({1'h0, w_addr}),\r\n    .W0_en   (w_en & w_mask_a),\r\n    .W0_clk  (w_clk),\r\n    .W0_data (w_data_a),\r\n    .R0_data (r_data_a)\r\n  );\r\nendmodule\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input r: {addr: UInt<3>, en: UInt<1> clk: Clock, flip data: {a: Clock}}\r\n    input w: {addr: UInt<3>, en: UInt<1> clk: Clock, data: {a: Clock}, mask: {a: UInt<1>}}\r\n\r\n    mem memory:\r\n      data-type => {a: Clock}\r\n      depth => 16\r\n      reader => r\r\n      writer => w\r\n      read-latency => 1\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.r <= r\r\n    memory.w <= w", "code_snippet_02": "Memory.fir:6:5: error: 'hw.wire' op requires the same type for all operands and results\r\n    mem memory:\r\n    ^\r\nMemory.fir:6:5: note: see current operation: %2 = \"hw.wire\"(%5) {name = \"memory_r_data_a\"} : (i1) -> !seq.clock", "code_snippet_03": "#loc = loc(\"Memory.fir\":3:11)\r\n#loc1 = loc(\"Memory.fir\":4:11)\r\n\"builtin.module\"() ({\r\n  \"hw.module\"() ({\r\n  ^bb0(%arg0: i3, %arg1: i1, %arg2: !seq.clock, %arg3: i3, %arg4: i1, %arg5: !seq.clock, %arg6: !seq.clock, %arg7: i1):\r\n    %0 = \"hw.constant\"() {value = false} : () -> i1\r\n    %1 = \"hw.wire\"(%7) {name = \"memory_r_addr\"} : (i4) -> i4\r\n    %2 = \"hw.wire\"(%5) {name = \"memory_r_data_a\"} : (i1) -> !seq.clock\r\n    %3 = \"hw.wire\"(%8) {name = \"memory_w_addr\"} : (i4) -> i4\r\n    %4 = \"seq.firmem\"() <{name = \"memory_a\", prefix = \"\", readLatency = 1 : i32, ruw = 0 : i32, writeLatency = 1 : i32, wuw = 1 : i32}> : () -> !seq.firmem<16 x 1>\r\n    %5 = \"seq.firmem.read_port\"(%4, %1, %arg2, %arg1) : (!seq.firmem<16 x 1>, i4, !seq.clock, i1) -> i1\r\n    %6 = \"comb.and\"(%arg4, %arg7) <{twoState}> : (i1, i1) -> i1\r\n    \"seq.firmem.write_port\"(%4, %3, %arg5, %6, %arg6) <{operandSegmentSizes = array<i32: 1, 1, 1, 1, 1, 0>}> : (!seq.firmem<16 x 1>, i4, !seq.clock, i1, !seq.clock) -> ()\r\n    %7 = \"comb.concat\"(%0, %arg0) : (i1, i3) -> i4\r\n    %8 = \"comb.concat\"(%0, %arg3) : (i1, i3) -> i4\r\n    \"hw.output\"(%2) : (!seq.clock) -> ()\r\n  }) {argLocs = [#loc, #loc, #loc, #loc1, #loc1, #loc1, #loc1, #loc1], argNames = [\"r_addr\", \"r_en\", \"r_clk\", \"w_addr\", \"w_en\", \"w_clk\", \"w_data_a\", \"w_mask_a\"], arg_attrs = [{}, {}, {}, {}, {}, {}, {}, {}], comment = \"\", function_type = (i3, i1, !seq.clock, i3, i1, !seq.clock, !seq.clock, i1) -> !seq.clock, parameters = [], res_attrs = [{}], resultLocs = [#loc], resultNames = [\"r_data_a\"], sym_name = \"Foo\"} : () -> ()\r\n}) : () -> ()", "code_snippet_04": "// Generated by CIRCT firtool-1.53.0\r\n// VCS coverage exclude_file\r\nmodule memory_a_16x1(\r\n  input  [3:0] R0_addr,\r\n  input        R0_en,\r\n               R0_clk,\r\n  input  [3:0] W0_addr,\r\n  input        W0_en,\r\n               W0_clk,\r\n               W0_data,\r\n  output       R0_data\r\n);\r\n\r\n  reg       Memory[0:15];\r\n  reg       _R0_en_d0;\r\n  reg [3:0] _R0_addr_d0;\r\n  always @(posedge R0_clk) begin\r\n    _R0_en_d0 <= R0_en;\r\n    _R0_addr_d0 <= R0_addr;\r\n  end // always @(posedge)\r\n  always @(posedge W0_clk) begin\r\n    if (W0_en)\r\n      Memory[W0_addr] <= W0_data;\r\n  end // always @(posedge)\r\n  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 1'bx;\r\nendmodule\r\n\r\nmodule Foo(\r\n  input  [2:0] r_addr,\r\n  input        r_en,\r\n               r_clk,\r\n  input  [2:0] w_addr,\r\n  input        w_en,\r\n               w_clk,\r\n               w_data_a,\r\n               w_mask_a,\r\n  output       r_data_a\r\n);\r\n\r\n  memory_a_16x1 memory_a_ext (\r\n    .R0_addr ({1'h0, r_addr}),\r\n    .R0_en   (r_en),\r\n    .R0_clk  (r_clk),\r\n    .W0_addr ({1'h0, w_addr}),\r\n    .W0_en   (w_en & w_mask_a),\r\n    .W0_clk  (w_clk),\r\n    .W0_data (w_data_a),\r\n    .R0_data (r_data_a)\r\n  );\r\nendmodule"}, {"number": 6259, "title": "[FIRRTL] MergeConnections Invalid IR for RWProbes", "created_at": "2023-10-05T21:09:00Z", "state": "closed", "labels": "bug, FIRRTL", "body": "I hit the following issue involving a RWProbe for the following FIRRTL:\r\n\r\n```\r\nFIRRTL version 3.1.0\r\ncircuit Foo : %[[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Foo|Foo>w\"\r\n  }\r\n]]\r\n  module Foo :\r\n    output a : RWProbe<UInt<1>>\r\n\r\n    wire w : { a : UInt<1>, flip b : UInt<2> }\r\n    invalidate w.a\r\n    invalidate w.b\r\n    define a = rwprobe(w.a)\r\n```\r\n\r\nThis errors out with invalid IR after `MergeConnections`:\r\n\r\n```\r\n6259.fir:12:5: error: 'firrtl.aggregateconstant' op Cannot have constant bundle type with flip\r\n    invalidate w.a\r\n    ^\r\n6259.fir:12:5: note: see current operation: %1 = \"firrtl.aggregateconstant\"() {fields = [0 : ui1, 0 : ui2]} : () -> !firrtl.bundle<a: uint<1>, b flip: uint<2>>\r\n6259.fir:13:5: note: additional location here\r\n    invalidate w.b\r\n    ^\r\n```\r\n\r\n```mlir\r\n\"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.rwprobe<uint<1>>):\r\n  %0:2 = \"firrtl.wire\"() {annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}], forceable, name = \"w\", nameKind = #firrtl<name_kind droppable_name>} : () -> (!firrtl.bundle<a: uint<1>, b flip: uint<2>>, !firrtl.rwprobe<bundle<a: uint<1>, b: uint<2>>>)\r\n  %1 = \"firrtl.aggregateconstant\"() {fields = [0 : ui1, 0 : ui2]} : () -> !firrtl.bundle<a: uint<1>, b flip: uint<2>>\r\n  \"firrtl.connect\"(%0#0, %1) : (!firrtl.bundle<a: uint<1>, b flip: uint<2>>, !firrtl.bundle<a: uint<1>, b flip: uint<2>>) -> ()\r\n  %2 = \"firrtl.ref.sub\"(%0#1) {index = 0 : i32} : (!firrtl.rwprobe<bundle<a: uint<1>, b: uint<2>>>) -> !firrtl.rwprobe<uint<1>>\r\n  \"firrtl.ref.define\"(%arg0, %2) : (!firrtl.rwprobe<uint<1>>, !firrtl.rwprobe<uint<1>>) -> ()\r\n}) {annotations = [], convention = #firrtl<convention scalarized>, portAnnotations = [[]], portDirections = true, portLocations = [loc(\"6259.fir\":9:12)], portNames = [\"a\"], portSyms = [], portTypes = [!firrtl.rwprobe<uint<1>>], sym_name = \"Foo\"} : () -> ()\r\n```\r\n\r\nThis is trying to build an aggregate constant with flips. \ud83d\ude15 ", "code_snippet_01": "FIRRTL version 3.1.0\r\ncircuit Foo : %[[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Foo|Foo>w\"\r\n  }\r\n]]\r\n  module Foo :\r\n    output a : RWProbe<UInt<1>>\r\n\r\n    wire w : { a : UInt<1>, flip b : UInt<2> }\r\n    invalidate w.a\r\n    invalidate w.b\r\n    define a = rwprobe(w.a)", "code_snippet_02": "6259.fir:12:5: error: 'firrtl.aggregateconstant' op Cannot have constant bundle type with flip\r\n    invalidate w.a\r\n    ^\r\n6259.fir:12:5: note: see current operation: %1 = \"firrtl.aggregateconstant\"() {fields = [0 : ui1, 0 : ui2]} : () -> !firrtl.bundle<a: uint<1>, b flip: uint<2>>\r\n6259.fir:13:5: note: additional location here\r\n    invalidate w.b\r\n    ^", "code_snippet_03": "\"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.rwprobe<uint<1>>):\r\n  %0:2 = \"firrtl.wire\"() {annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}], forceable, name = \"w\", nameKind = #firrtl<name_kind droppable_name>} : () -> (!firrtl.bundle<a: uint<1>, b flip: uint<2>>, !firrtl.rwprobe<bundle<a: uint<1>, b: uint<2>>>)\r\n  %1 = \"firrtl.aggregateconstant\"() {fields = [0 : ui1, 0 : ui2]} : () -> !firrtl.bundle<a: uint<1>, b flip: uint<2>>\r\n  \"firrtl.connect\"(%0#0, %1) : (!firrtl.bundle<a: uint<1>, b flip: uint<2>>, !firrtl.bundle<a: uint<1>, b flip: uint<2>>) -> ()\r\n  %2 = \"firrtl.ref.sub\"(%0#1) {index = 0 : i32} : (!firrtl.rwprobe<bundle<a: uint<1>, b: uint<2>>>) -> !firrtl.rwprobe<uint<1>>\r\n  \"firrtl.ref.define\"(%arg0, %2) : (!firrtl.rwprobe<uint<1>>, !firrtl.rwprobe<uint<1>>) -> ()\r\n}) {annotations = [], convention = #firrtl<convention scalarized>, portAnnotations = [[]], portDirections = true, portLocations = [loc(\"6259.fir\":9:12)], portNames = [\"a\"], portSyms = [], portTypes = [!firrtl.rwprobe<uint<1>>], sym_name = \"Foo\"} : () -> ()"}, {"number": 6226, "title": "Mixed ssaName and true name fails to parse correctly", "created_at": "2023-09-29T21:51:37Z", "state": "open", "labels": "bug", "body": "See Bar3 below.\r\ncirct-opt foo.mlir --mlir-print-op-generic\r\n\r\n```\r\nhw.module @Bar0(in %0: i1) {\r\n}\r\n\r\nhw.module @Bar1(in %a: i1) {\r\n}\r\n\r\nhw.module @Bar2(in %0 \"space here\" : i1) {\r\n}\r\n\r\nhw.module @Bar3(in %b \"space here\" : i1) {\r\n}\r\n```", "code_snippet_01": "hw.module @Bar0(in %0: i1) {\r\n}\r\n\r\nhw.module @Bar1(in %a: i1) {\r\n}\r\n\r\nhw.module @Bar2(in %0 \"space here\" : i1) {\r\n}\r\n\r\nhw.module @Bar3(in %b \"space here\" : i1) {\r\n}"}, {"number": 6193, "title": "[FIRRTL][firtool] Unknown Windows Release Build Test Failures", "created_at": "2023-09-23T04:21:45Z", "state": "open", "labels": "bug, FIRRTL", "body": "There have been a number of odd test failures that have been observed on Windows release builds.\r\n\r\n## Failures\r\n\r\n### First Failure\r\n\r\nA commit, https://github.com/llvm/circt/commit/3668f6760f9c7ca814035292435f930e30320fea, enabling properties as attributes in the Seq dialect resulted in similar failures in one test. See: https://github.com/llvm/circt/actions/runs/6043611927/job/16400911216 This corrected itself on the subsequent commit, https://github.com/llvm/circt/commit/c88186e18a74fe74e2d2bdb7de2610a0334eaa7d, passed.\r\n\r\nThe failing test was:\r\n  - `Dialect/FIRRTL/SFCTests/width-spec-errors.fir`\r\n\r\nThe exit code was: 3221225477\r\n\r\n### Second Failure\r\n\r\nA commit adding two folders, https://github.com/llvm/circt/commit/68b79fc35fcc2d68abc8a0b830c0f5a303af3f04, failed intermittently. See: https://github.com/llvm/circt/actions/runs/6083208189/job/16502633046. This then passed on retry: https://github.com/llvm/circt/actions/runs/6083208189.\r\n\r\nThe failing test was:\r\n  - `Dialect/FIRRTL/SFCTests/data-taps-flip.fir`\r\n\r\nThe exit code was: 3221225477\r\n\r\nThere was no stack trace.\r\n\r\n### Third Failure\r\n\r\nCommit https://github.com/llvm/circt/commit/3b6f737c360fa19e3f16f9ea4856128f36ce9296 made a change that disabled deduplication. This caused four tests to fail repeatedly. One such run is: https://github.com/llvm/circt/actions/runs/6278904029/job/17056030822\r\n\r\nThe failing tests were:\r\n  - `Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/Wire.fir`\r\n  - `Dialect/FIRRTL/SFCTests/data-taps.fir`\r\n  - `firtool/prefixMemory.fir`\r\n  - `firtool/refs-in-aggs.fir`\r\n\r\nOnly `firtool/prefixMemory.fir` was a test that was sensitive to deduplication and required modifications, in the commit, to fix.\r\n\r\nThis was \"fixed\" by adding a `-no-dedup` option to `firtool` and using it for those four tests. It is unclear if this actually \"fixed\" anything, i.e., if the issue was that not running deduplication fixed it or if this just permuted the sources enough to get `cl` to produce something that didn't crash.\r\n\r\nThe exit code was: 0xc0000005\r\n\r\nThere was a stack trace. (This isn't particularly useful as it is a release build...) Example:\r\n\r\n```\r\n #0 0x00007ff7b9dca204 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x1fa204)\r\n #1 0x00007ff7b9dd00a1 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x2000a1)\r\n #2 0x00007ff7ba5f0107 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa20107)\r\n #3 0x00007ff7ba5f5a27 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa25a27)\r\n #4 0x00007ff7ba5f7529 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa27529)\r\n #5 0x00007ff7ba5f0616 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa20616)\r\n #6 0x00007ff7ba5f6ee2 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa26ee2)\r\n #7 0x00007ff7ba5f00f2 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa200f2)\r\n #8 0x00007ff7ba5f5a27 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa25a27)\r\n #9 0x00007ff7ba5f61fd (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa261fd)\r\n#10 0x00007ff7b9be0544 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x10544)\r\n#11 0x00007ff7b9be09ff (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x109ff)\r\n#12 0x00007ff7b9bdee3b (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xee3b)\r\n#13 0x00007ff7b9be26df (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x126df)\r\n#14 0x00007ff7ba60d560 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa3d560)\r\n#15 0x00007ffe8a4c7ac4 (C:\\Windows\\System32\\KERNEL32.DLL+0x17ac4)\r\n#16 0x00007ffe8bfda351 (C:\\Windows\\SYSTEM32\\ntdll.dll+0x5a351)\r\n```\r\n\r\nJust before the third test, the windows build failed on the previous commit twice. This appeared to be due to issues running PowerShell's `Install-Package`. The two failures were:\r\n\r\n```\r\nWARNING: Unable to resolve package source 'https://www.powershellgallery.com/api/v2'.\r\nInstall-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all\r\navailable registered module repositories.\r\n\r\nError: Process completed with exit code 1.\r\n```\r\n\r\n```\r\nInstall-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all\r\navailable registered module repositories.\r\n\r\nError: Process completed with exit code 1.\r\n```\r\n\r\nThis appears unrelated, though it has high temporal locality to the third failure.\r\n\r\nFor the third failure, I tried a clean rebuild by deleting all `sccache` caches. This again failed in the same way after a 3 hour complete rebuild.\r\n\r\n## Analysis\r\n\r\n1. All tests involved `firtool` end-to-end tests. \r\n2. All tests were some kind of hard crash with exit codes 3221225477 or 0xc0000005. (This is the same number, but the latter seems to produce a stack trace and the former does not.)\r\n3. The third test would repeatedly fail. The second test was intermittent. It is unknown if the first test was intermittent or repeatable.\r\n\r\n## Ideas to try\r\n\r\n1. The Unified Build/Test/Install GitHub Action does support running a Windows build in debug mode or relwithdebinfo. This won't have caching and will be about 3 hours to run.\r\n2. More UBSan or other sanitizers. Is there a way to run these on Windows?", "code_snippet_01": "#0 0x00007ff7b9dca204 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x1fa204)\r\n #1 0x00007ff7b9dd00a1 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x2000a1)\r\n #2 0x00007ff7ba5f0107 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa20107)\r\n #3 0x00007ff7ba5f5a27 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa25a27)\r\n #4 0x00007ff7ba5f7529 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa27529)\r\n #5 0x00007ff7ba5f0616 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa20616)\r\n #6 0x00007ff7ba5f6ee2 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa26ee2)\r\n #7 0x00007ff7ba5f00f2 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa200f2)\r\n #8 0x00007ff7ba5f5a27 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa25a27)\r\n #9 0x00007ff7ba5f61fd (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa261fd)\r\n#10 0x00007ff7b9be0544 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x10544)\r\n#11 0x00007ff7b9be09ff (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x109ff)\r\n#12 0x00007ff7b9bdee3b (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xee3b)\r\n#13 0x00007ff7b9be26df (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x126df)\r\n#14 0x00007ff7ba60d560 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa3d560)\r\n#15 0x00007ffe8a4c7ac4 (C:\\Windows\\System32\\KERNEL32.DLL+0x17ac4)\r\n#16 0x00007ffe8bfda351 (C:\\Windows\\SYSTEM32\\ntdll.dll+0x5a351)", "code_snippet_02": "WARNING: Unable to resolve package source 'https://www.powershellgallery.com/api/v2'.\r\nInstall-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all\r\navailable registered module repositories.\r\n\r\nError: Process completed with exit code 1.", "code_snippet_03": "Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all\r\navailable registered module repositories.\r\n\r\nError: Process completed with exit code 1."}, {"number": 6103, "title": "[FIRRTL] Uninitialized input port error for Integer input, IMDCE bug", "created_at": "2023-09-11T17:02:48Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Simple class with input driven by an integer:\r\n\r\n```firrtl\r\nFIRRTL version 3.2.0\r\ncircuit InputProp:\r\n  class Test :\r\n    input in : Integer\r\n\r\n  module InputProp:\r\n    object o of Test\r\n    propassign o.in, Integer(5)\r\n```\r\n\r\nMLIR before lower-classes:\r\n```mlir\r\nmodule {\r\n  firrtl.circuit \"InputProp\" {\r\n    firrtl.class private @Test(in %in: !firrtl.integer) {\r\n    }\r\n    firrtl.module @InputProp() attributes {convention = #firrtl<convention scalarized>} {\r\n      %o = firrtl.object @Test(in in: !firrtl.integer)\r\n      %0 = firrtl.object.subfield %o[in] : !firrtl.class<@Test(in in: !firrtl.integer)>\r\n      %1 = firrtl.integer 5\r\n      firrtl.propassign %0, %1 : !firrtl.integer\r\n    }\r\n  }\r\n}\r\n```", "code_snippet_01": "FIRRTL version 3.2.0\r\ncircuit InputProp:\r\n  class Test :\r\n    input in : Integer\r\n\r\n  module InputProp:\r\n    object o of Test\r\n    propassign o.in, Integer(5)", "code_snippet_02": "module {\r\n  firrtl.circuit \"InputProp\" {\r\n    firrtl.class private @Test(in %in: !firrtl.integer) {\r\n    }\r\n    firrtl.module @InputProp() attributes {convention = #firrtl<convention scalarized>} {\r\n      %o = firrtl.object @Test(in in: !firrtl.integer)\r\n      %0 = firrtl.object.subfield %o[in] : !firrtl.class<@Test(in in: !firrtl.integer)>\r\n      %1 = firrtl.integer 5\r\n      firrtl.propassign %0, %1 : !firrtl.integer\r\n    }\r\n  }\r\n}"}, {"number": 6076, "title": "[FIRRTL][IMCP] Fix deleting part of probe data-flow through wires", "created_at": "2023-09-07T22:44:22Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Input:\r\n```mlir\r\nfirrtl.circuit \"WireProbe\" {\r\n  firrtl.module @WireProbe(out %p : !firrtl.probe<uint<5>>) {\r\n    %x = firrtl.constant 0: !firrtl.uint<5>\r\n    %0 = firrtl.ref.send %x : !firrtl.uint<5>\r\n    %w = firrtl.wire : !firrtl.probe<uint<5>>\r\n    firrtl.ref.define %w, %0: !firrtl.probe<uint<5>>\r\n    firrtl.ref.define %p, %w : !firrtl.probe<uint<5>>\r\n  }\r\n}\r\n```\r\n\r\nSending through `circt-opt --firrtl-imconstprop` produces the following, deleting what feeds the wire but leaving it there.\r\n\r\n```mlir\r\nmodule {\r\n  firrtl.circuit \"WireProbe\" {\r\n    firrtl.module @WireProbe(out %p: !firrtl.probe<uint<5>>) {\r\n      %w = firrtl.wire : !firrtl.probe<uint<5>>\r\n      firrtl.ref.define %p, %w : !firrtl.probe<uint<5>>\r\n    }\r\n  }\r\n}\r\n```", "code_snippet_01": "firrtl.circuit \"WireProbe\" {\r\n  firrtl.module @WireProbe(out %p : !firrtl.probe<uint<5>>) {\r\n    %x = firrtl.constant 0: !firrtl.uint<5>\r\n    %0 = firrtl.ref.send %x : !firrtl.uint<5>\r\n    %w = firrtl.wire : !firrtl.probe<uint<5>>\r\n    firrtl.ref.define %w, %0: !firrtl.probe<uint<5>>\r\n    firrtl.ref.define %p, %w : !firrtl.probe<uint<5>>\r\n  }\r\n}", "code_snippet_02": "module {\r\n  firrtl.circuit \"WireProbe\" {\r\n    firrtl.module @WireProbe(out %p: !firrtl.probe<uint<5>>) {\r\n      %w = firrtl.wire : !firrtl.probe<uint<5>>\r\n      firrtl.ref.define %p, %w : !firrtl.probe<uint<5>>\r\n    }\r\n  }\r\n}"}, {"number": 6074, "title": "[FIRRTL] Add missing dialect dependencies", "created_at": "2023-09-07T21:54:58Z", "state": "open", "labels": "bug, FIRRTL", "body": "LowerXMR and LowerToHW, at least, may lower/introduce operations from HW, SV, and Seq dialects.\r\n\r\nFix the dependentDialects to ensure this works properly (such as when invoking via `circt-opt`).\r\n\r\nCurrent failing example to demonstrate:\r\n\r\n```mlir\r\nfirrtl.circuit \"ClockProbe\" {\r\n  firrtl.module @ClockProbe(in %in: !firrtl.clock, out %out: !firrtl.clock) attributes {convention = #firrtl<convention scalarized>} {\r\n    %0 = firrtl.ref.send %in : !firrtl.clock\r\n    %1 = firrtl.ref.resolve %0 : !firrtl.probe<clock>\r\n    firrtl.strictconnect %out, %1 : !firrtl.clock\r\n  }\r\n}\r\n```\r\n\r\nWhich presently errors out when running `circt-opt --firrtl-lower-xmr`:\r\n```\r\nLLVM ERROR: can't create type 'circt::seq::ClockType' because storage uniquer isn't initialized: the dialect was likely not loaded, or the type wasn't added with addTypes<...>() in the Dialect::initialize() method.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/circt-opt --firrtl-lower-xmr ./clock-probe.mlir\r\n```", "code_snippet_01": "firrtl.circuit \"ClockProbe\" {\r\n  firrtl.module @ClockProbe(in %in: !firrtl.clock, out %out: !firrtl.clock) attributes {convention = #firrtl<convention scalarized>} {\r\n    %0 = firrtl.ref.send %in : !firrtl.clock\r\n    %1 = firrtl.ref.resolve %0 : !firrtl.probe<clock>\r\n    firrtl.strictconnect %out, %1 : !firrtl.clock\r\n  }\r\n}", "code_snippet_02": "LLVM ERROR: can't create type 'circt::seq::ClockType' because storage uniquer isn't initialized: the dialect was likely not loaded, or the type wasn't added with addTypes<...>() in the Dialect::initialize() method.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/circt-opt --firrtl-lower-xmr ./clock-probe.mlir"}, {"number": 6072, "title": "[ExtractTestCode?] Port Order Flipped for Extracted Covers", "created_at": "2023-09-07T20:07:41Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "I noticed the following change between firrtl 1.53.0 and top-of-tree:\r\n\r\n```\r\nFIRRTL version 3.1.0\r\nFIRRTL version 3.1.0\r\ncircuit TestHarness :\r\n  module DUTTop :\r\n    input clock : Clock\r\n    input in: UInt<1>\r\n\r\n    when in :\r\n      printf(clock, UInt<1>(0h1), \"cover:hello:world\\n\")\r\n\r\n  module TestHarness :\r\n    input clock : Clock\r\n    input in: UInt<1>\r\n\r\n    inst dut of DUTTop\r\n    connect dut.clock, clock\r\n    connect dut.in, in\r\n```\r\n\r\nIf I compile this with firtool-1.53.0 (`firtool-1.53.0 -extract-test-code CoverOrder.fir -disable-all-randomization -split-verilog -o CoverOrder && cat CoverOrder/DUTTop_cover.sv`), I get:\r\n\r\n```verilog\r\n// Generated by CIRCT firtool-1.53.0\r\n// VCS coverage exclude_file\r\nmodule DUTTop_cover(\r\n  input clock,\r\n        in\r\n);\r\n\r\n  cover__hello: cover property (@(posedge clock) in);\r\nendmodule\r\n```\r\n\r\nIf I compile with top-of-tree (`firtool -extract-test-code CoverOrder.fir -disable-all-randomization -split-verilog -o CoverOrder && cat CoverOrder/DUTTop_cover.sv`), I get:\r\n\r\n```verilog\r\n// Generated by CIRCT firtool-1.53.0-56-g5bccfd8b3\r\n// VCS coverage exclude_file\r\nmodule DUTTop_cover(\r\n  input in,\r\n        clock\r\n);\r\n\r\n  cover__hello: cover property (@(posedge clock) in);\r\nendmodule\r\n```\r\n\r\nThe port order flipped. \ud83d\ude15", "code_snippet_01": "FIRRTL version 3.1.0\r\nFIRRTL version 3.1.0\r\ncircuit TestHarness :\r\n  module DUTTop :\r\n    input clock : Clock\r\n    input in: UInt<1>\r\n\r\n    when in :\r\n      printf(clock, UInt<1>(0h1), \"cover:hello:world\\n\")\r\n\r\n  module TestHarness :\r\n    input clock : Clock\r\n    input in: UInt<1>\r\n\r\n    inst dut of DUTTop\r\n    connect dut.clock, clock\r\n    connect dut.in, in", "code_snippet_02": "// Generated by CIRCT firtool-1.53.0\r\n// VCS coverage exclude_file\r\nmodule DUTTop_cover(\r\n  input clock,\r\n        in\r\n);\r\n\r\n  cover__hello: cover property (@(posedge clock) in);\r\nendmodule", "code_snippet_03": "// Generated by CIRCT firtool-1.53.0-56-g5bccfd8b3\r\n// VCS coverage exclude_file\r\nmodule DUTTop_cover(\r\n  input in,\r\n        clock\r\n);\r\n\r\n  cover__hello: cover property (@(posedge clock) in);\r\nendmodule"}, {"number": 6061, "title": "[FIRRTL][Dedup] Don't crash on classes", "created_at": "2023-09-06T16:52:26Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Input:\r\n```firrtl\r\nFIRRTL version 3.2.0\r\ncircuit ClassSpec_Anon :\r\n  class Test :\r\n    input in : Integer @[src/test/scala/chiselTests/properties/ClassSpec.scala 114:20]\r\n    output out : Integer @[src/test/scala/chiselTests/properties/ClassSpec.scala 115:21]\r\n\r\n    propassign out, in @[src/test/scala/chiselTests/properties/ClassSpec.scala 116:13]\r\n\r\n  module ClassSpec_Anon :\r\n\r\n    object obj1 of Test @[src/test/scala/chiselTests/properties/ClassSpec.scala 119:46]\r\n    object obj2 of Test @[src/test/scala/chiselTests/properties/ClassSpec.scala 120:46]\r\n```\r\n\r\nRunning `firtool -dedup` on this crashes with:\r\n```\r\nfirtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = circt::firrtl::InstanceOp, From = circt::igraph::InstanceOpInterface]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool class-crash.fir -dedup\r\n #0 0x000055d94ec24c96 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13\r\n #1 0x000055d94ec22d20 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18\r\n #2 0x000055d94ec2532b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007f86e642bd30 __restore_rt (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38d30)\r\n #4 0x00007f86e647aa8c __pthread_kill_implementation (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x87a8c)\r\n #5 0x00007f86e642bc86 gsignal (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38c86)\r\n #6 0x00007f86e64158ba abort (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x228ba)\r\n #7 0x00007f86e64157d9 _nl_load_domain.cold (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x227d9)\r\n #8 0x00007f86e64249c6 (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x319c6)\r\n #9 0x000055d94eceb505 llvm::ilist_iterator<llvm::ilist_detail::node_options<circt::igraph::InstanceGraphNode, true, false, void>, false, false>::operator*() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist_iterator.h:138:5\r\n#10 0x000055d94eceb505 llvm::mapped_iterator<llvm::ilist_iterator<llvm::ilist_detail::node_options<circt::igraph::InstanceGraphNode, true, false, void>, false, false>, circt::igraph::InstanceGraphNode* (*)(circt::igraph::InstanceGraphNode&), circt::igraph::InstanceGraphNode*>::operator*() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:364:44\r\n#11 0x000055d94eceb505 fixupAllModules(circt::firrtl::InstanceGraph&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/Dedup.cpp:1386:19\r\n#12 0x000055d94eced206 (anonymous namespace)::DedupPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/Dedup.cpp:0:5\r\n#13 0x000055d94f6a0c5f mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:17\r\n#14 0x000055d94f6a0c5f void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n#15 0x000055d94f6a0c5f llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n#16 0x000055d94f6a0c5f void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7\r\n#17 0x000055d94f6a0c5f mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:497:21\r\n#18 0x000055d94f6a14a2 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#19 0x000055d94f6a14a2 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#20 0x000055d94f6a14a2 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:569:9\r\n#21 0x000055d94f6a4716 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:794:5\r\n#22 0x000055d94f6a27bb mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#23 0x000055d94f6a27bb mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#24 0x000055d94f6a27bb mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:11\r\n#25 0x000055d94f6a27bb mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#26 0x000055d94f6a27bb mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:799:14\r\n#27 0x000055d94f6a0e18 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5\r\n#28 0x000055d94f6a0e18 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:501:20\r\n#29 0x000055d94f6a0e18 void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n#30 0x000055d94f6a0e18 llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n#31 0x000055d94f6a0e18 void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7\r\n#32 0x000055d94f6a0e18 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:497:21\r\n#33 0x000055d94f6a35a5 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#34 0x000055d94f6a35a5 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#35 0x000055d94f6a35a5 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:569:9\r\n#36 0x000055d94f6a35a5 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:880:10\r\n#37 0x000055d94f6a35a5 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:860:60\r\n#38 0x000055d94eb763ab mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#39 0x000055d94eb763ab mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#40 0x000055d94eb763ab processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:412:7\r\n#41 0x000055d94eb752b8 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:484:12\r\n#42 0x000055d94eb74e25 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:500:12\r\n#43 0x000055d94eb74e25 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:585:14\r\n#44 0x000055d94eb74a0f mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#45 0x000055d94eb74a0f mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#46 0x000055d94eb74a0f main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:656:8\r\n#47 0x00007f86e6416ace __libc_start_call_main (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x23ace)\r\n#48 0x00007f86e6416b89 __libc_start_main@GLIBC_2.2.5 (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x23b89)\r\n#49 0x000055d94eb74825 _start (./build/bin/firtool+0x584825)\r\n```\r\n\r\nMay be an InstanceGraph thing, not dedup, not sure.\r\n\r\n```\r\n$ firtool --version\r\nLLVM (http://llvm.org/):\r\n  LLVM version 18.0.0git\r\n  Optimized build with assertions.\r\nCIRCT firtool-1.53.0-40-gbcaeecf2d\r\n```", "code_snippet_01": "FIRRTL version 3.2.0\r\ncircuit ClassSpec_Anon :\r\n  class Test :\r\n    input in : Integer @[src/test/scala/chiselTests/properties/ClassSpec.scala 114:20]\r\n    output out : Integer @[src/test/scala/chiselTests/properties/ClassSpec.scala 115:21]\r\n\r\n    propassign out, in @[src/test/scala/chiselTests/properties/ClassSpec.scala 116:13]\r\n\r\n  module ClassSpec_Anon :\r\n\r\n    object obj1 of Test @[src/test/scala/chiselTests/properties/ClassSpec.scala 119:46]\r\n    object obj2 of Test @[src/test/scala/chiselTests/properties/ClassSpec.scala 120:46]", "code_snippet_02": "firtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = circt::firrtl::InstanceOp, From = circt::igraph::InstanceOpInterface]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool class-crash.fir -dedup\r\n #0 0x000055d94ec24c96 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13\r\n #1 0x000055d94ec22d20 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18\r\n #2 0x000055d94ec2532b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007f86e642bd30 __restore_rt (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38d30)\r\n #4 0x00007f86e647aa8c __pthread_kill_implementation (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x87a8c)\r\n #5 0x00007f86e642bc86 gsignal (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38c86)\r\n #6 0x00007f86e64158ba abort (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x228ba)\r\n #7 0x00007f86e64157d9 _nl_load_domain.cold (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x227d9)\r\n #8 0x00007f86e64249c6 (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x319c6)\r\n #9 0x000055d94eceb505 llvm::ilist_iterator<llvm::ilist_detail::node_options<circt::igraph::InstanceGraphNode, true, false, void>, false, false>::operator*() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist_iterator.h:138:5\r\n#10 0x000055d94eceb505 llvm::mapped_iterator<llvm::ilist_iterator<llvm::ilist_detail::node_options<circt::igraph::InstanceGraphNode, true, false, void>, false, false>, circt::igraph::InstanceGraphNode* (*)(circt::igraph::InstanceGraphNode&), circt::igraph::InstanceGraphNode*>::operator*() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:364:44\r\n#11 0x000055d94eceb505 fixupAllModules(circt::firrtl::InstanceGraph&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/Dedup.cpp:1386:19\r\n#12 0x000055d94eced206 (anonymous namespace)::DedupPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/Dedup.cpp:0:5\r\n#13 0x000055d94f6a0c5f mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:17\r\n#14 0x000055d94f6a0c5f void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n#15 0x000055d94f6a0c5f llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n#16 0x000055d94f6a0c5f void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7\r\n#17 0x000055d94f6a0c5f mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:497:21\r\n#18 0x000055d94f6a14a2 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#19 0x000055d94f6a14a2 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#20 0x000055d94f6a14a2 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:569:9\r\n#21 0x000055d94f6a4716 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:794:5\r\n#22 0x000055d94f6a27bb mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#23 0x000055d94f6a27bb mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#24 0x000055d94f6a27bb mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:11\r\n#25 0x000055d94f6a27bb mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_0&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#26 0x000055d94f6a27bb mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:799:14\r\n#27 0x000055d94f6a0e18 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5\r\n#28 0x000055d94f6a0e18 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:501:20\r\n#29 0x000055d94f6a0e18 void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n#30 0x000055d94f6a0e18 llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n#31 0x000055d94f6a0e18 void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7\r\n#32 0x000055d94f6a0e18 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:497:21\r\n#33 0x000055d94f6a35a5 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#34 0x000055d94f6a35a5 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#35 0x000055d94f6a35a5 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:569:9\r\n#36 0x000055d94f6a35a5 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:880:10\r\n#37 0x000055d94f6a35a5 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:860:60\r\n#38 0x000055d94eb763ab mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#39 0x000055d94eb763ab mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#40 0x000055d94eb763ab processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:412:7\r\n#41 0x000055d94eb752b8 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:484:12\r\n#42 0x000055d94eb74e25 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:500:12\r\n#43 0x000055d94eb74e25 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:585:14\r\n#44 0x000055d94eb74a0f mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#45 0x000055d94eb74a0f mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#46 0x000055d94eb74a0f main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:656:8\r\n#47 0x00007f86e6416ace __libc_start_call_main (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x23ace)\r\n#48 0x00007f86e6416b89 __libc_start_main@GLIBC_2.2.5 (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x23b89)\r\n#49 0x000055d94eb74825 _start (./build/bin/firtool+0x584825)", "code_snippet_03": "$ firtool --version\r\nLLVM (http://llvm.org/):\r\n  LLVM version 18.0.0git\r\n  Optimized build with assertions.\r\nCIRCT firtool-1.53.0-40-gbcaeecf2d"}, {"number": 6059, "title": "[FIRRTL][IMDCE] Annotations on ports are not preserved when moving to wires", "created_at": "2023-09-06T16:02:17Z", "state": "open", "labels": "bug, FIRRTL", "body": "Input:\r\n```mlir\r\n// -----\r\n// Test that annotations keep ports alive.\r\n// CHECK-LABEL: \"AnnoAlivePort\"\r\nfirrtl.circuit \"AnnoAlivePort\" {\r\n  // CHECK: module private @AnnoPort\r\n  firrtl.module private @AnnoPort(out %dead : !firrtl.uint<5> [{class = \"circt.test\"}]) {}\r\n  firrtl.module @AnnoAlivePort() {\r\n    // CHECK: firrtl.instance\r\n    %inst_dead = firrtl.instance inst @AnnoPort(out dead : !firrtl.uint<5>)\r\n  }\r\n}\r\n```\r\n\r\nThe port is dead at instantiation sites but alive within the module, so port is dropped and wire is created for it (maybe it's written/read locally, so on).\r\n\r\nLooks like annotations are not moved to the wire, however, here's the current output pointing IMDCE at the above:\r\n```mlir\r\nfirrtl.circuit \"AnnoAlivePort\" {\r\n  firrtl.module private @AnnoPort() {\r\n    %0 = firrtl.wire : !firrtl.uint<5>\r\n  }\r\n  firrtl.module @AnnoAlivePort() {\r\n    firrtl.instance inst @AnnoPort()\r\n  }\r\n}\r\n```\r\n\r\ncc #6046 for more discussion on annotations and IMDCE, but not directly related.", "code_snippet_01": "// -----\r\n// Test that annotations keep ports alive.\r\n// CHECK-LABEL: \"AnnoAlivePort\"\r\nfirrtl.circuit \"AnnoAlivePort\" {\r\n  // CHECK: module private @AnnoPort\r\n  firrtl.module private @AnnoPort(out %dead : !firrtl.uint<5> [{class = \"circt.test\"}]) {}\r\n  firrtl.module @AnnoAlivePort() {\r\n    // CHECK: firrtl.instance\r\n    %inst_dead = firrtl.instance inst @AnnoPort(out dead : !firrtl.uint<5>)\r\n  }\r\n}", "code_snippet_02": "firrtl.circuit \"AnnoAlivePort\" {\r\n  firrtl.module private @AnnoPort() {\r\n    %0 = firrtl.wire : !firrtl.uint<5>\r\n  }\r\n  firrtl.module @AnnoAlivePort() {\r\n    firrtl.instance inst @AnnoPort()\r\n  }\r\n}"}, {"number": 6035, "title": "[FIRRTL] ExtModule Ordering Affects File Emission", "created_at": "2023-09-02T04:27:58Z", "state": "closed", "labels": "bug, FIRRTL", "body": "An internal user reported that BlackBoxes have started showing up in unexpected situations. The problem is that when an external module with a `BlackBoxInlineAnno` does not dedup for valid reasons, e.g., it has different parameters or the user doesn't run dedup, then the order in which the external modules are declared determines the file order.\r\n\r\nConsider the following example. Here, whichever of `BlackBox_1`, `BlackBox_2`, or `BlackBox_3` is declared _first_ will determine if the blackbox is, respectively, created in the `testbench/`, `./` (main design/DUT), or `gct/` directories.\r\n\r\n```\r\nFIRRTL version 4.0.0\r\ncircuit TestHarness: %[[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~TestHarness|GrandCentral\",\r\n    \"parent\": \"~TestHarness|TestHarness\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"Interface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"uint\",\r\n          \"description\": \"a wire called 'uint'\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"TestHarness\",\r\n              \"module\": \"DUT\",\r\n              \"path\": [],\r\n              \"ref\": \"a\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\": \"~TestHarness|DUT\"\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\": \"gct\",\r\n    \"filename\": \"bindings.sv\"\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.firrtl.TestBenchDirAnnotation\",\r\n    \"dirname\": \"testbench\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.BlackBoxInlineAnno\",\r\n    \"target\": \"~TestHarness|BlackBox_1\",\r\n    \"name\": \"BlackBox.sv\",\r\n    \"text\": \"// BlackBox_1\\nmodule BlackBox #(parameter X=0)(output a);\\nendmodule\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.BlackBoxInlineAnno\",\r\n    \"target\": \"~TestHarness|BlackBox_2\",\r\n    \"name\": \"BlackBox.sv\",\r\n    \"text\": \"// BlackBox_2\\nmodule BlackBox #(parameter X=0)(output a);\\nendmodule\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.BlackBoxInlineAnno\",\r\n    \"target\": \"~TestHarness|BlackBox_3\",\r\n    \"name\": \"BlackBox.sv\",\r\n    \"text\": \"// BlackBox_3\\nmodule BlackBox #(parameter X=0)(output a);\\nendmodule\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"target\":\"~TestHarness|DUT\",\r\n    \"prefix\":\"SiFive_\",\r\n    \"inclusive\":true\r\n  }\r\n]]\r\n\r\n  extmodule BlackBox_1:\r\n    output a: UInt<1>\r\n    defname = BlackBox\r\n    parameter X = 1\r\n\r\n  extmodule BlackBox_2:\r\n    output a: UInt<1>\r\n    defname = BlackBox\r\n    parameter X = 2\r\n\r\n  extmodule BlackBox_3:\r\n    output a: UInt<1>\r\n    defname = BlackBox\r\n    parameter X = 3\r\n\r\n  module TestHarness:\r\n\r\n    inst dut of DUT\r\n    inst bbox of BlackBox_1\r\n\r\n  module DUT:\r\n\r\n    wire a: UInt<1>\r\n    invalidate a\r\n\r\n    inst bbox of BlackBox_2\r\n    inst grandCentral of GrandCentral\r\n\r\n  module GrandCentral:\r\n\r\n    inst bbox of BlackBox_3\r\n```\r\n\r\nThe three possible results are:\r\n\r\n```verilog\r\n// ----- 8< ----- FILE \"testbench/BlackBox.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT firtool-1.52.0-152-gb07e210c1\r\n// BlackBox_1\r\nmodule BlackBox #(parameter X=0)(output a);\r\nendmodule\r\n```\r\n\r\n```verilog\r\n// ----- 8< ----- FILE \"./BlackBox.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT firtool-1.52.0-152-gb07e210c1\r\n// BlackBox_2\r\nmodule BlackBox #(parameter X=0)(output a);\r\nendmodule\r\n```\r\n\r\n```verilog\r\n// ----- 8< ----- FILE \"gct/BlackBox.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT firtool-1.52.0-152-gb07e210c1\r\n// BlackBox_3\r\nmodule BlackBox #(parameter X=0)(output a);\r\nendmodule\r\n```\r\n\r\nNote: that this is ignoring a whole separate class of errors where the actual content of the `BlackBoxInlineAnno` annotation is not verified in any way. I placed a different comment in each of them. Put differently, it's dangerous to rely on `defname` with `BlackBoxInlineAnno` blindly. This should at least be checked that these are the same.", "code_snippet_01": "FIRRTL version 4.0.0\r\ncircuit TestHarness: %[[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~TestHarness|GrandCentral\",\r\n    \"parent\": \"~TestHarness|TestHarness\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"Interface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"uint\",\r\n          \"description\": \"a wire called 'uint'\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"TestHarness\",\r\n              \"module\": \"DUT\",\r\n              \"path\": [],\r\n              \"ref\": \"a\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\": \"~TestHarness|DUT\"\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\": \"gct\",\r\n    \"filename\": \"bindings.sv\"\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.firrtl.TestBenchDirAnnotation\",\r\n    \"dirname\": \"testbench\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.BlackBoxInlineAnno\",\r\n    \"target\": \"~TestHarness|BlackBox_1\",\r\n    \"name\": \"BlackBox.sv\",\r\n    \"text\": \"// BlackBox_1\\nmodule BlackBox #(parameter X=0)(output a);\\nendmodule\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.BlackBoxInlineAnno\",\r\n    \"target\": \"~TestHarness|BlackBox_2\",\r\n    \"name\": \"BlackBox.sv\",\r\n    \"text\": \"// BlackBox_2\\nmodule BlackBox #(parameter X=0)(output a);\\nendmodule\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.BlackBoxInlineAnno\",\r\n    \"target\": \"~TestHarness|BlackBox_3\",\r\n    \"name\": \"BlackBox.sv\",\r\n    \"text\": \"// BlackBox_3\\nmodule BlackBox #(parameter X=0)(output a);\\nendmodule\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"target\":\"~TestHarness|DUT\",\r\n    \"prefix\":\"SiFive_\",\r\n    \"inclusive\":true\r\n  }\r\n]]\r\n\r\n  extmodule BlackBox_1:\r\n    output a: UInt<1>\r\n    defname = BlackBox\r\n    parameter X = 1\r\n\r\n  extmodule BlackBox_2:\r\n    output a: UInt<1>\r\n    defname = BlackBox\r\n    parameter X = 2\r\n\r\n  extmodule BlackBox_3:\r\n    output a: UInt<1>\r\n    defname = BlackBox\r\n    parameter X = 3\r\n\r\n  module TestHarness:\r\n\r\n    inst dut of DUT\r\n    inst bbox of BlackBox_1\r\n\r\n  module DUT:\r\n\r\n    wire a: UInt<1>\r\n    invalidate a\r\n\r\n    inst bbox of BlackBox_2\r\n    inst grandCentral of GrandCentral\r\n\r\n  module GrandCentral:\r\n\r\n    inst bbox of BlackBox_3", "code_snippet_02": "// ----- 8< ----- FILE \"testbench/BlackBox.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT firtool-1.52.0-152-gb07e210c1\r\n// BlackBox_1\r\nmodule BlackBox #(parameter X=0)(output a);\r\nendmodule", "code_snippet_03": "// ----- 8< ----- FILE \"./BlackBox.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT firtool-1.52.0-152-gb07e210c1\r\n// BlackBox_2\r\nmodule BlackBox #(parameter X=0)(output a);\r\nendmodule", "code_snippet_04": "// ----- 8< ----- FILE \"gct/BlackBox.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT firtool-1.52.0-152-gb07e210c1\r\n// BlackBox_3\r\nmodule BlackBox #(parameter X=0)(output a);\r\nendmodule"}, {"number": 6029, "title": "[FIRRTL] LowerClasses Support ExtModules", "created_at": "2023-09-01T19:28:05Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Currently, FIRRTL external modules with either input or output property ports error during `LowerClasses`.\r\n\r\nI haven't thought through exactly how this should work in terms of lowering. At a high level, this needs to work such that two OMIR dialect blobs are produced and then these are combined by the OMIR linker.\r\n\r\n### Input Ports\r\n\r\n```\r\nFIRRTL version 4.0.0\r\ncircuit Foo:\r\n  extmodule Bar:\r\n    input a: Integer\r\n\r\n  module Foo:\r\n    inst bar of Bar\r\n    propassign bar.a, Integer(42)\r\n```\r\n\r\n```\r\n# firtool firrtl-snippets/ExtModuleInputProperty.fir\r\nAssertion failed: (Index < this->size() && \"Invalid index!\"), function operator[], file ArrayRef.h, line 443.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: firtool firrtl-snippets/ExtModuleInputProperty.fir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x00000001031ee300 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 88\r\n1  firtool                  0x00000001031ee91c PrintStackTraceSignalHandler(void*) + 28\r\n2  firtool                  0x00000001031ec4b0 llvm::sys::RunSignalHandlers() + 152\r\n3  firtool                  0x00000001031efbf4 SignalHandler(int) + 276\r\n4  libsystem_platform.dylib 0x0000000190b42a24 _sigtramp + 56\r\n5  libsystem_pthread.dylib  0x0000000190b13c28 pthread_kill + 288\r\n6  libsystem_c.dylib        0x0000000190a21ae8 abort + 180\r\n7  libsystem_c.dylib        0x0000000190a20e44 err + 0\r\n8  firtool                  0x00000001038a6338 llvm::MutableArrayRef<mlir::BlockArgument>::operator[](unsigned long) const + 124\r\n9  firtool                  0x00000001038a619c mlir::Region::getArgument(unsigned int) + 56\r\n10 firtool                  0x0000000103530344 (anonymous namespace)::LowerClassesPass::lowerClass((anonymous namespace)::ClassLoweringState&) + 604\r\n```\r\n\r\n### Output Ports\r\n\r\n```\r\nFIRRTL version 4.0.0\r\ncircuit Foo:\r\n  extmodule Bar:\r\n    output a: Integer\r\n\r\n  module Foo:\r\n    output a: Integer\r\n    inst bar of Bar\r\n    propassign a, bar.a\r\n```\r\n\r\n```\r\n# firtool firrtl-snippets/ExtModuleOutputProperty.fir                         \r\nfirrtl-snippets/ExtModuleOutputProperty.fir:8:5: error: failed to legalize operation 'firrtl.instance' that was explicitly marked illegal\r\n    inst bar of Bar\r\n    ^\r\nfirrtl-snippets/ExtModuleOutputProperty.fir:8:5: note: see current operation: %0 = \"firrtl.instance\"() {annotations = [], moduleName = @Bar, name = \"bar\", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [[]], portDirections = true, portNames = [\"a\"]} : () -> !firrtl.integer\r\n```", "code_snippet_01": "FIRRTL version 4.0.0\r\ncircuit Foo:\r\n  extmodule Bar:\r\n    input a: Integer\r\n\r\n  module Foo:\r\n    inst bar of Bar\r\n    propassign bar.a, Integer(42)", "code_snippet_02": "# firtool firrtl-snippets/ExtModuleInputProperty.fir\r\nAssertion failed: (Index < this->size() && \"Invalid index!\"), function operator[], file ArrayRef.h, line 443.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: firtool firrtl-snippets/ExtModuleInputProperty.fir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x00000001031ee300 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 88\r\n1  firtool                  0x00000001031ee91c PrintStackTraceSignalHandler(void*) + 28\r\n2  firtool                  0x00000001031ec4b0 llvm::sys::RunSignalHandlers() + 152\r\n3  firtool                  0x00000001031efbf4 SignalHandler(int) + 276\r\n4  libsystem_platform.dylib 0x0000000190b42a24 _sigtramp + 56\r\n5  libsystem_pthread.dylib  0x0000000190b13c28 pthread_kill + 288\r\n6  libsystem_c.dylib        0x0000000190a21ae8 abort + 180\r\n7  libsystem_c.dylib        0x0000000190a20e44 err + 0\r\n8  firtool                  0x00000001038a6338 llvm::MutableArrayRef<mlir::BlockArgument>::operator[](unsigned long) const + 124\r\n9  firtool                  0x00000001038a619c mlir::Region::getArgument(unsigned int) + 56\r\n10 firtool                  0x0000000103530344 (anonymous namespace)::LowerClassesPass::lowerClass((anonymous namespace)::ClassLoweringState&) + 604", "code_snippet_03": "FIRRTL version 4.0.0\r\ncircuit Foo:\r\n  extmodule Bar:\r\n    output a: Integer\r\n\r\n  module Foo:\r\n    output a: Integer\r\n    inst bar of Bar\r\n    propassign a, bar.a", "code_snippet_04": "# firtool firrtl-snippets/ExtModuleOutputProperty.fir                         \r\nfirrtl-snippets/ExtModuleOutputProperty.fir:8:5: error: failed to legalize operation 'firrtl.instance' that was explicitly marked illegal\r\n    inst bar of Bar\r\n    ^\r\nfirrtl-snippets/ExtModuleOutputProperty.fir:8:5: note: see current operation: %0 = \"firrtl.instance\"() {annotations = [], moduleName = @Bar, name = \"bar\", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [[]], portDirections = true, portNames = [\"a\"]} : () -> !firrtl.integer"}, {"number": 6013, "title": "[FIRRTL] Need to handle Macro Collision", "created_at": "2023-08-31T17:46:47Z", "state": "open", "labels": "bug, FIRRTL", "body": "If a FIRRTL name collides with a macro, the compiler currently crashes. `LowerToHW` and others need to disconnect the symbol creation from the name of the symbol. `sv.macro.decl` already has support for this. It is not used yet.\r\n\r\nConsider:\r\n\r\n```\r\nFIRRTL version 4.0.0\r\ncircuit RANDOM:\r\n  module RANDOM:\r\n    input clock: Clock\r\n    input d: UInt<1>\r\n    output q: UInt<1>\r\n\r\n    reg r: UInt<1>, clock\r\n\r\n    connect r, d\r\n    connect q, r\r\n```\r\n\r\nThis errors during `LowerToHW` with:\r\n\r\n```\r\n<unknown>:0: error: Referenced macro doesn't exist \"ENABLE_INITIAL_MEM_\"\r\n<unknown>:0: note: see current operation: \"sv.macro.def\"() {format_string = \"\", macroName = @ENABLE_INITIAL_MEM_, symbols = []} : () -> ()\r\n```", "code_snippet_01": "FIRRTL version 4.0.0\r\ncircuit RANDOM:\r\n  module RANDOM:\r\n    input clock: Clock\r\n    input d: UInt<1>\r\n    output q: UInt<1>\r\n\r\n    reg r: UInt<1>, clock\r\n\r\n    connect r, d\r\n    connect q, r", "code_snippet_02": "<unknown>:0: error: Referenced macro doesn't exist \"ENABLE_INITIAL_MEM_\"\r\n<unknown>:0: note: see current operation: \"sv.macro.def\"() {format_string = \"\", macroName = @ENABLE_INITIAL_MEM_, symbols = []} : () -> ()"}, {"number": 5991, "title": "[FIRRTL] Make `-lower-annotations-no-ref-type-ports` work for `MemTapAnnotation`", "created_at": "2023-08-29T21:52:29Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following fails and it shouldn't:\r\n\r\n```\r\nfirtool ../test/Dialect/FIRRTL/SFCTests/mem-taps.fir -lower-annotations-no-ref-type-ports\r\n```\r\n\r\nThis produces:\r\n\r\n```\r\n../test/Dialect/FIRRTL/SFCTests/mem-taps.fir:33:5: error: Wiring Problem source type '!firrtl.probe<vector<uint<8>, 8>>' does not match sink type '!firrtl.vector<uint<8>, 8>'\r\n    cmem rf : UInt<8> [8]\r\n    ^\r\n../test/Dialect/FIRRTL/SFCTests/mem-taps.fir:48:5: note: The sink is here.\r\n    wire memTap : UInt<8>[8]\r\n    ^\r\n```\r\n\r\nThis hidden option is a hack. It should still work.", "code_snippet_01": "firtool ../test/Dialect/FIRRTL/SFCTests/mem-taps.fir -lower-annotations-no-ref-type-ports", "code_snippet_02": "../test/Dialect/FIRRTL/SFCTests/mem-taps.fir:33:5: error: Wiring Problem source type '!firrtl.probe<vector<uint<8>, 8>>' does not match sink type '!firrtl.vector<uint<8>, 8>'\r\n    cmem rf : UInt<8> [8]\r\n    ^\r\n../test/Dialect/FIRRTL/SFCTests/mem-taps.fir:48:5: note: The sink is here.\r\n    wire memTap : UInt<8>[8]\r\n    ^"}, {"number": 5983, "title": "[FIRRTL][InferWidths] Ignore propassign (+properties generally)", "created_at": "2023-08-29T14:02:41Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Presently width inference pass exits if encounters, e.g., propassign:\r\n\r\n```\r\nFIRRTL version 3.1.0\r\ncircuit StringAndUInt:\r\n  module StringAndUInt:\r\n    input x : UInt<5>\r\n    output y : UInt\r\n    output s : String\r\n\r\n    connect y, x\r\n    propassign s, String(\"test\")\r\n```\r\n\r\nError:\r\n```\r\ninfer-widths-prop.fir:9:5: error: 'firrtl.propassign' op not supported in width inference\r\n    propassign s, String(\"test\")\r\n    ^\r\ninfer-widths-prop.fir:9:5: note: see current operation: \"firrtl.propassign\"(%arg2, %0) : (!firrtl.string, !firrtl.string) -> ()\r\n```\r\n\r\nProperties should be pass-through for this pass.", "code_snippet_01": "FIRRTL version 3.1.0\r\ncircuit StringAndUInt:\r\n  module StringAndUInt:\r\n    input x : UInt<5>\r\n    output y : UInt\r\n    output s : String\r\n\r\n    connect y, x\r\n    propassign s, String(\"test\")", "code_snippet_02": "infer-widths-prop.fir:9:5: error: 'firrtl.propassign' op not supported in width inference\r\n    propassign s, String(\"test\")\r\n    ^\r\ninfer-widths-prop.fir:9:5: note: see current operation: \"firrtl.propassign\"(%arg2, %0) : (!firrtl.string, !firrtl.string) -> ()"}, {"number": 5975, "title": "[ExtractInstances] Fix module prefix not being applied to NLA", "created_at": "2023-08-28T21:22:09Z", "state": "closed", "labels": "bug, FIRRTL", "body": "When instances are grouped after extraction, the group module would inherit the appropriate prefix from the DUT, but any hierarchical paths pointing to it would not include the prefix. Fix this by using the same name for the module and the hierarchical path.\r\n\r\nFixes #5961.\r\nBackported to firtool 1.5 in #5971."}, {"number": 5971, "title": "[ExtractInstances] Fix module prefix not being applied to NLA", "created_at": "2023-08-28T18:11:59Z", "state": "closed", "labels": "bug, FIRRTL", "body": "When instances are grouped after extraction, the group module would inherit the appropriate prefix from the DUT, but any hierarchical paths pointing to it would not include the prefix. Fix this by using the same name for the module and the hierarchical path.\r\n\r\nFixes #5961."}, {"number": 5961, "title": "[FIRRTL] Clock gate extraction doesn't update hierpath", "created_at": "2023-08-25T23:29:17Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Running the following input through `firtool input.mlir` (version `sifive-1.5.5`):\r\n```mlir\r\n// input.mlir\r\nfirrtl.circuit \"Foo\" attributes {annotations = [{\r\n  class = \"sifive.enterprise.firrtl.ExtractClockGatesFileAnnotation\",\r\n  filename = \"ckgates.txt\",\r\n  group = \"ClockGates\"\r\n}]} {\r\n  firrtl.hierpath @nla_1 [@Foo::@core, @Bar::@ckg, @EICG_wrapper]\r\n  firrtl.extmodule private @EICG_wrapper() attributes {defname = \"EICG_wrapper\"}\r\n  firrtl.module private @Bar() {\r\n    firrtl.instance ckg sym @ckg @EICG_wrapper()\r\n  }\r\n  firrtl.module @Foo() attributes {annotations = [\r\n    {class = \"sifive.enterprise.firrtl.MarkDUTAnnotation\"},\r\n    {\r\n      class = \"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n      inclusive = true,\r\n      prefix = \"Plop_\"\r\n    }\r\n  ]} {\r\n    firrtl.instance core sym @core @Bar()\r\n  }\r\n}\r\n```\r\nProduces the following error:\r\n```\r\nerror: 'firrtl.hierpath' op instance path is incorrect. \\\r\n  Expected module: \"Plop_ClockGates\" instead found: \"ClockGates\"\r\n    firrtl.hierpath @nla_1 [@Foo::@core, @Bar::@ckg, @EICG_wrapper]\r\n    ^\r\n```\r\nIt looks like `ExtractInstances` does not properly update `firrtl.hierpath`s if they aren't referenced anywhere.\r\n\r\nReduced testcase of something @jackkoenig came across in the wild.", "code_snippet_01": "// input.mlir\r\nfirrtl.circuit \"Foo\" attributes {annotations = [{\r\n  class = \"sifive.enterprise.firrtl.ExtractClockGatesFileAnnotation\",\r\n  filename = \"ckgates.txt\",\r\n  group = \"ClockGates\"\r\n}]} {\r\n  firrtl.hierpath @nla_1 [@Foo::@core, @Bar::@ckg, @EICG_wrapper]\r\n  firrtl.extmodule private @EICG_wrapper() attributes {defname = \"EICG_wrapper\"}\r\n  firrtl.module private @Bar() {\r\n    firrtl.instance ckg sym @ckg @EICG_wrapper()\r\n  }\r\n  firrtl.module @Foo() attributes {annotations = [\r\n    {class = \"sifive.enterprise.firrtl.MarkDUTAnnotation\"},\r\n    {\r\n      class = \"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n      inclusive = true,\r\n      prefix = \"Plop_\"\r\n    }\r\n  ]} {\r\n    firrtl.instance core sym @core @Bar()\r\n  }\r\n}", "code_snippet_02": "error: 'firrtl.hierpath' op instance path is incorrect. \\\r\n  Expected module: \"Plop_ClockGates\" instead found: \"ClockGates\"\r\n    firrtl.hierpath @nla_1 [@Foo::@core, @Bar::@ckg, @EICG_wrapper]\r\n    ^"}, {"number": 5947, "title": "[FIRRTL] Annotations indexing cmem crash", "created_at": "2023-08-24T22:37:26Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Input:\r\n```firrtl\r\ncircuit CMemOops: %[[\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~CMemOops|CMemOops>mem.a\"\r\n  }\r\n]]\r\n  module CMemOops:\r\n    cmem mem : UInt<4>[16]\r\n```\r\n\r\nCrashes during resolveEntities:\r\n\r\n```\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool anno_cmem_indexing.fir\r\n #0 0x000055f1b83d8f96 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13\r\n #1 0x000055f1b83d7020 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18\r\n #2 0x000055f1b83d962b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007faa75dd7d30 __restore_rt (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38d30)\r\n #4 0x000055f1b84558a2 mlir::TypeStorage::getAbstractType() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/TypeSupport.h:160:5\r\n #5 0x000055f1b84558a2 mlir::Type::getTypeID() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Types.h:112:37\r\n #6 0x000055f1b84558a2 bool mlir::detail::StorageUserBase<circt::firrtl::BundleType, circt::firrtl::FIRRTLBaseType, circt::firrtl::detail::BundleTypeStorage, mlir::detail::TypeUniquer, circt::hw::FieldIDTypeInterface::Trait>::classof<mlir::Type>(mlir::Type) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:114:16\r\n #7 0x000055f1b84558a2 llvm::CastInfo<circt::firrtl::BundleType, mlir::Type const, void>::isPossible(mlir::Type) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Types.h:403:14\r\n #8 0x000055f1b84558a2 bool llvm::isa<circt::firrtl::BundleType, mlir::Type>(mlir::Type const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:549:10\r\n #9 0x000055f1b84558a2 bool circt::firrtl::type_isa<circt::firrtl::BundleType>(mlir::Type) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLTypes.h:474:7\r\n#10 0x000055f1b881fcbb circt::firrtl::BundleType circt::firrtl::type_dyn_cast<circt::firrtl::BundleType>(mlir::Type) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLTypes.h:516:7\r\n#11 0x000055f1b881fcbb findBundleElement(mlir::Operation*, mlir::Type, llvm::StringRef) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp:45:17\r\n#12 0x000055f1b881fcbb findFieldID(circt::firrtl::AnnoTarget&, llvm::ArrayRef<circt::firrtl::TargetToken>) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp:102:21\r\n#13 0x000055f1b881fcbb circt::firrtl::resolveEntities(circt::firrtl::TokenAnnoTarget, circt::firrtl::CircuitOp, mlir::SymbolTable&, circt::firrtl::CircuitTargetCache&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp:277:17\r\n```\r\n\r\nUBSAN reports:\r\n```\r\n/home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Types.h:112:37: runtime error: member call on null pointer of type 'mlir::TypeStorage'\r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Types.h:112:37 in \r\n```\r\n", "code_snippet_01": "circuit CMemOops: %[[\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~CMemOops|CMemOops>mem.a\"\r\n  }\r\n]]\r\n  module CMemOops:\r\n    cmem mem : UInt<4>[16]", "code_snippet_02": "PLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool anno_cmem_indexing.fir\r\n #0 0x000055f1b83d8f96 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13\r\n #1 0x000055f1b83d7020 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18\r\n #2 0x000055f1b83d962b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007faa75dd7d30 __restore_rt (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38d30)\r\n #4 0x000055f1b84558a2 mlir::TypeStorage::getAbstractType() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/TypeSupport.h:160:5\r\n #5 0x000055f1b84558a2 mlir::Type::getTypeID() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Types.h:112:37\r\n #6 0x000055f1b84558a2 bool mlir::detail::StorageUserBase<circt::firrtl::BundleType, circt::firrtl::FIRRTLBaseType, circt::firrtl::detail::BundleTypeStorage, mlir::detail::TypeUniquer, circt::hw::FieldIDTypeInterface::Trait>::classof<mlir::Type>(mlir::Type) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:114:16\r\n #7 0x000055f1b84558a2 llvm::CastInfo<circt::firrtl::BundleType, mlir::Type const, void>::isPossible(mlir::Type) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Types.h:403:14\r\n #8 0x000055f1b84558a2 bool llvm::isa<circt::firrtl::BundleType, mlir::Type>(mlir::Type const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:549:10\r\n #9 0x000055f1b84558a2 bool circt::firrtl::type_isa<circt::firrtl::BundleType>(mlir::Type) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLTypes.h:474:7\r\n#10 0x000055f1b881fcbb circt::firrtl::BundleType circt::firrtl::type_dyn_cast<circt::firrtl::BundleType>(mlir::Type) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLTypes.h:516:7\r\n#11 0x000055f1b881fcbb findBundleElement(mlir::Operation*, mlir::Type, llvm::StringRef) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp:45:17\r\n#12 0x000055f1b881fcbb findFieldID(circt::firrtl::AnnoTarget&, llvm::ArrayRef<circt::firrtl::TargetToken>) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp:102:21\r\n#13 0x000055f1b881fcbb circt::firrtl::resolveEntities(circt::firrtl::TokenAnnoTarget, circt::firrtl::CircuitOp, mlir::SymbolTable&, circt::firrtl::CircuitTargetCache&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLAnnotationHelper.cpp:277:17", "code_snippet_03": "/home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Types.h:112:37: runtime error: member call on null pointer of type 'mlir::TypeStorage'\r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Types.h:112:37 in"}, {"number": 5941, "title": "[FIRRTL][Inliner] Don't crash on property ports", "created_at": "2023-08-24T19:01:58Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Input:\r\n```firrtl\r\nFIRRTL version 3.1.0\r\ncircuit PropertySpec_Anon :%[[\r\n  {\r\n    \"class\":\"firrtl.passes.InlineAnnotation\",\r\n    \"target\":\"PropertySpec_Anon._18_Anon\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\":\"~PropertySpec_Anon|_18_Anon\"\r\n  }\r\n]]\r\n  module _18_Anon :\r\n    input propIn : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 237:24]\r\n    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 238:25]\r\n\r\n    propassign propOut, propIn @[src/test/scala/chiselTests/properties/PropertySpec.scala 239:17]\r\n\r\n  module PropertySpec_Anon :\r\n    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 242:23]\r\n\r\n    inst passthru of _18_Anon @[src/test/scala/chiselTests/properties/PropertySpec.scala 236:28]\r\n    propassign passthru.propIn, Integer(123) @[src/test/scala/chiselTests/properties/PropertySpec.scala 241:23]\r\n    propassign propOut, passthru.propOut @[src/test/scala/chiselTests/properties/PropertySpec.scala 243:15]\r\n```\r\n\r\nThis presently crashes in the Inliner, walking off the end of a TypeSwitch:\r\n\r\n```\r\nfirtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:141: ResultT llvm::TypeSwitch<circt::firrtl::FIRRTLType, mlir::Value>::operator Value() [T = circt::firrtl::FIRRTLType, ResultT = mlir::Value]: Assertion `result && \"Fell off the end of a type-switch\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool inline-props.fir\r\n #0 0x0000562532b77ca6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13\r\n #1 0x0000562532b75d30 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18\r\n #2 0x0000562532b7833b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007f6a5b89cd30 __restore_rt (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38d30)\r\n #4 0x00007f6a5b8eba8c __pthread_kill_implementation (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x87a8c)\r\n #5 0x00007f6a5b89cc86 gsignal (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38c86)\r\n #6 0x00007f6a5b8868ba abort (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x228ba)\r\n #7 0x00007f6a5b8867d9 _nl_load_domain.cold (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x227d9)\r\n #8 0x00007f6a5b8959c6 (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x319c6)\r\n #9 0x0000562532d6cd28 auto (anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&)::$_3::operator()<circt::firrtl::RefType>(circt::firrtl::RefType) const /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:0:0\r\n#10 0x0000562532d6cd28 llvm::TypeSwitch<circt::firrtl::FIRRTLType, mlir::Value>& llvm::TypeSwitch<circt::firrtl::FIRRTLType, mlir::Value>::Case<circt::firrtl::RefType, (anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&)::$_3>((anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&)::$_3&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:22\r\n#11 0x0000562532d6cd28 (anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:920:14\r\n#12 0x0000562532d68bd5 llvm::DenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseSetPair<mlir::Attribute>>::~DenseMap() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:782:5\r\n#13 0x0000562532d68bd5 llvm::detail::DenseSetImpl<mlir::Attribute, llvm::DenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseSetPair<mlir::Attribute>>, llvm::DenseMapInfo<mlir::Attribute, void>>::~DenseSetImpl() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/DenseSet.h:54:7\r\n#14 0x0000562532d68bd5 (anonymous namespace)::Inliner::inlineInstances(circt::firrtl::FModuleOp) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:1291:5\r\n#15 0x0000562532d68bd5 (anonymous namespace)::Inliner::run() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:1416:7\r\n#16 0x0000562532d658a6 (anonymous namespace)::InlinerPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:1539:5\r\n(snip)\r\n```", "code_snippet_01": "FIRRTL version 3.1.0\r\ncircuit PropertySpec_Anon :%[[\r\n  {\r\n    \"class\":\"firrtl.passes.InlineAnnotation\",\r\n    \"target\":\"PropertySpec_Anon._18_Anon\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\":\"~PropertySpec_Anon|_18_Anon\"\r\n  }\r\n]]\r\n  module _18_Anon :\r\n    input propIn : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 237:24]\r\n    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 238:25]\r\n\r\n    propassign propOut, propIn @[src/test/scala/chiselTests/properties/PropertySpec.scala 239:17]\r\n\r\n  module PropertySpec_Anon :\r\n    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 242:23]\r\n\r\n    inst passthru of _18_Anon @[src/test/scala/chiselTests/properties/PropertySpec.scala 236:28]\r\n    propassign passthru.propIn, Integer(123) @[src/test/scala/chiselTests/properties/PropertySpec.scala 241:23]\r\n    propassign propOut, passthru.propOut @[src/test/scala/chiselTests/properties/PropertySpec.scala 243:15]", "code_snippet_02": "firtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:141: ResultT llvm::TypeSwitch<circt::firrtl::FIRRTLType, mlir::Value>::operator Value() [T = circt::firrtl::FIRRTLType, ResultT = mlir::Value]: Assertion `result && \"Fell off the end of a type-switch\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool inline-props.fir\r\n #0 0x0000562532b77ca6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:723:13\r\n #1 0x0000562532b75d30 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:106:18\r\n #2 0x0000562532b7833b SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007f6a5b89cd30 __restore_rt (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38d30)\r\n #4 0x00007f6a5b8eba8c __pthread_kill_implementation (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x87a8c)\r\n #5 0x00007f6a5b89cc86 gsignal (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x38c86)\r\n #6 0x00007f6a5b8868ba abort (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x228ba)\r\n #7 0x00007f6a5b8867d9 _nl_load_domain.cold (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x227d9)\r\n #8 0x00007f6a5b8959c6 (/nix/store/3n58xw4373jp0ljirf06d8077j15pc4j-glibc-2.37-8/lib/libc.so.6+0x319c6)\r\n #9 0x0000562532d6cd28 auto (anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&)::$_3::operator()<circt::firrtl::RefType>(circt::firrtl::RefType) const /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:0:0\r\n#10 0x0000562532d6cd28 llvm::TypeSwitch<circt::firrtl::FIRRTLType, mlir::Value>& llvm::TypeSwitch<circt::firrtl::FIRRTLType, mlir::Value>::Case<circt::firrtl::RefType, (anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&)::$_3>((anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&)::$_3&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:22\r\n#11 0x0000562532d6cd28 (anonymous namespace)::Inliner::mapPortsToWires(llvm::StringRef, (anonymous namespace)::Inliner::InliningLevel&, mlir::IRMapping&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>> const&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:920:14\r\n#12 0x0000562532d68bd5 llvm::DenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseSetPair<mlir::Attribute>>::~DenseMap() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:782:5\r\n#13 0x0000562532d68bd5 llvm::detail::DenseSetImpl<mlir::Attribute, llvm::DenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseSetPair<mlir::Attribute>>, llvm::DenseMapInfo<mlir::Attribute, void>>::~DenseSetImpl() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/DenseSet.h:54:7\r\n#14 0x0000562532d68bd5 (anonymous namespace)::Inliner::inlineInstances(circt::firrtl::FModuleOp) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:1291:5\r\n#15 0x0000562532d68bd5 (anonymous namespace)::Inliner::run() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:1416:7\r\n#16 0x0000562532d658a6 (anonymous namespace)::InlinerPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:1539:5\r\n(snip)"}, {"number": 5940, "title": "[FIRRTL][IMCP] Don't crash on processing properties, getBaseType can be null", "created_at": "2023-08-24T19:00:30Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Input:\r\n```\r\nFIRRTL version 3.1.0\r\ncircuit PropertySpec_Anon :\r\n  module _16_Anon :\r\n    input propIn : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 219:24]\r\n    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 220:25]\r\n\r\n    propassign propOut, propIn @[src/test/scala/chiselTests/properties/PropertySpec.scala 221:17]\r\n\r\n  module PropertySpec_Anon :\r\n    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 224:23]\r\n\r\n    inst passthru of _16_Anon @[src/test/scala/chiselTests/properties/PropertySpec.scala 218:28]\r\n    propassign passthru.propIn, Integer(123) @[src/test/scala/chiselTests/properties/PropertySpec.scala 223:23]\r\n    propassign propOut, passthru.propOut @[src/test/scala/chiselTests/properties/PropertySpec.scala 225:15]\r\n```\r\n\r\nCrashes in IMCP, which expects getBaseType to never return null (it didn't previously, FWIW, but regardless).\r\n\r\nThis issue does not include the ask for IMCP to propagate property constants themselves, but to start with don't crash when encountering them.", "code_snippet_01": "FIRRTL version 3.1.0\r\ncircuit PropertySpec_Anon :\r\n  module _16_Anon :\r\n    input propIn : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 219:24]\r\n    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 220:25]\r\n\r\n    propassign propOut, propIn @[src/test/scala/chiselTests/properties/PropertySpec.scala 221:17]\r\n\r\n  module PropertySpec_Anon :\r\n    output propOut : Integer @[src/test/scala/chiselTests/properties/PropertySpec.scala 224:23]\r\n\r\n    inst passthru of _16_Anon @[src/test/scala/chiselTests/properties/PropertySpec.scala 218:28]\r\n    propassign passthru.propIn, Integer(123) @[src/test/scala/chiselTests/properties/PropertySpec.scala 223:23]\r\n    propassign propOut, passthru.propOut @[src/test/scala/chiselTests/properties/PropertySpec.scala 225:15]"}, {"number": 5898, "title": "[FIRRTL][IMDCE] Forceable support", "created_at": "2023-08-21T23:27:23Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Consider this input:\r\n```firrtl\r\ncircuit RWProbeDCE:\r\n  module RWProbeDCE:\r\n    input x : UInt<5>\r\n    output p : RWProbe<UInt<5>>\r\n    wire w : UInt<5>\r\n    w <= x\r\n    define p = rwprobe(w)\r\n```\r\n\r\nWhich currently generates:\r\n```\r\n// Generated by CIRCT 1.51.0g20230821_61e2b9a\r\nmodule RWProbeDCE(\r\n  input [4:0] x\r\n);\r\n\r\n  wire [4:0] w = 5'bz;\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"ref_RWProbeDCE_RWProbeDCE.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT 1.51.0g20230821_61e2b9a\r\n`define ref_RWProbeDCE_RWProbeDCE_p w\r\n```\r\n\r\n----\r\n\r\nIR before IMDCE:\r\n\r\n```mlir\r\nfirrtl.circuit \"RWProbeDCE\" {\r\n  firrtl.module @RWProbeDCE(in %x: !firrtl.uint<5>, out %p: !firrtl.rwprobe<uint<5>>) attributes {convention = #firrtl<convention scalarized>} {\r\n    %w, %w_ref = firrtl.wire forceable : !firrtl.uint<5>, !firrtl.rwprobe<uint<5>>\r\n    firrtl.strictconnect %w, %x : !firrtl.uint<5>\r\n    firrtl.ref.define %p, %w_ref : !firrtl.rwprobe<uint<5>>\r\n  }\r\n}\r\n```\r\n\r\nAfter (` circt-opt --pass-pipeline='builtin.module(firrtl-imdeadcodeelim)' rwprobe_imdce.mlir`):\r\n```mlir\r\nfirrtl.circuit \"RWProbeDCE\" {\r\n  firrtl.module @RWProbeDCE(in %x: !firrtl.uint<5>, out %p: !firrtl.rwprobe<uint<5>>) attributes {convention = #firrtl<convention scalarized>} {\r\n    %w, %w_ref = firrtl.wire forceable : !firrtl.uint<5>, !firrtl.rwprobe<uint<5>>\r\n    firrtl.ref.define %p, %w_ref : !firrtl.rwprobe<uint<5>>\r\n  }\r\n}\r\n```\r\n\r\nIMDCE drops the connect /to/ the declaration, not noticing that a live use of the forceable result keeps the declaration alive.", "code_snippet_01": "circuit RWProbeDCE:\r\n  module RWProbeDCE:\r\n    input x : UInt<5>\r\n    output p : RWProbe<UInt<5>>\r\n    wire w : UInt<5>\r\n    w <= x\r\n    define p = rwprobe(w)", "code_snippet_02": "// Generated by CIRCT 1.51.0g20230821_61e2b9a\r\nmodule RWProbeDCE(\r\n  input [4:0] x\r\n);\r\n\r\n  wire [4:0] w = 5'bz;\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"ref_RWProbeDCE_RWProbeDCE.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT 1.51.0g20230821_61e2b9a\r\n`define ref_RWProbeDCE_RWProbeDCE_p w", "code_snippet_03": "firrtl.circuit \"RWProbeDCE\" {\r\n  firrtl.module @RWProbeDCE(in %x: !firrtl.uint<5>, out %p: !firrtl.rwprobe<uint<5>>) attributes {convention = #firrtl<convention scalarized>} {\r\n    %w, %w_ref = firrtl.wire forceable : !firrtl.uint<5>, !firrtl.rwprobe<uint<5>>\r\n    firrtl.strictconnect %w, %x : !firrtl.uint<5>\r\n    firrtl.ref.define %p, %w_ref : !firrtl.rwprobe<uint<5>>\r\n  }\r\n}", "code_snippet_04": "firrtl.circuit \"RWProbeDCE\" {\r\n  firrtl.module @RWProbeDCE(in %x: !firrtl.uint<5>, out %p: !firrtl.rwprobe<uint<5>>) attributes {convention = #firrtl<convention scalarized>} {\r\n    %w, %w_ref = firrtl.wire forceable : !firrtl.uint<5>, !firrtl.rwprobe<uint<5>>\r\n    firrtl.ref.define %p, %w_ref : !firrtl.rwprobe<uint<5>>\r\n  }\r\n}"}, {"number": 5886, "title": "[FIRRTL] Enum with uninferred reset", "created_at": "2023-08-18T16:04:53Z", "state": "open", "labels": "bug, FIRRTL, Arc", "body": "Input:\r\n```\r\ncircuit ResetEnum:\r\n  module ResetEnum:\r\n    input in : {| Some: UInt<1> |}\r\n    output out: {| Some: Reset |}\r\n    out <= in\r\n```\r\n\r\nCrashes during parsing, related: #5322 .", "code_snippet_01": "circuit ResetEnum:\r\n  module ResetEnum:\r\n    input in : {| Some: UInt<1> |}\r\n    output out: {| Some: Reset |}\r\n    out <= in"}, {"number": 5884, "title": "[FIRRTL] Can't parse const enum (and therefore can't parse enum w/const elements)", "created_at": "2023-08-18T16:00:26Z", "state": "open", "labels": "bug, FIRRTL", "body": "Enum's must be const if their elements are const, but the way we parse constructs a non-const enum (with the parsed element types) before converting it to const.\r\n\r\nConsider:\r\n\r\n```\r\ncircuit EnumConst:\r\n  module EnumConst:\r\n    input e : {| Some : const UInt<8>, None |}\r\n```\r\nWhich is invalid and should diagnose the invalid enum type.\r\n\r\nor this legal enum:\r\n\r\n```\r\ncircuit ConstEnumConst:\r\n  module ConstEnumConst:\r\n    input e : const {| Some : const UInt<8>, None |}\r\n```", "code_snippet_01": "circuit EnumConst:\r\n  module EnumConst:\r\n    input e : {| Some : const UInt<8>, None |}", "code_snippet_02": "circuit ConstEnumConst:\r\n  module ConstEnumConst:\r\n    input e : const {| Some : const UInt<8>, None |}"}, {"number": 5859, "title": "[FIRRTL] internalPaths crash", "created_at": "2023-08-16T15:43:02Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Input:\r\n```\r\nfirrtl.circuit \"Test\" {\r\n  firrtl.extmodule @GCTDataTap(out probe: !firrtl.rwprobe<uint<5>>, out baz_qux: !firrtl.probe<uint<1>>, out baz_quz: !firrtl.probe<uint<1>>) attributes {defname = \"BlackBox\", internalPaths = [\"baz.qux\", \"baz.quz\"]}\r\n  firrtl.module @Test() {\r\n    %0:3 = firrtl.instance inst @GCTDataTap(out probe: !firrtl.rwprobe<uint<5>>, out baz_qux: !firrtl.probe<uint<1>>, out baz_quz: !firrtl.probe<uint<1>>)\r\n  }\r\n}\r\n```\r\n\r\nThis is reachable from an input that already has a probe port and more are inserted using grand central taps.\r\n\"internalPaths\" should be reworked to support having paths for some (use ABI) and not others.\r\n\r\nThis crashes in LowerXMR but really the IR model is wrong.", "code_snippet_01": "firrtl.circuit \"Test\" {\r\n  firrtl.extmodule @GCTDataTap(out probe: !firrtl.rwprobe<uint<5>>, out baz_qux: !firrtl.probe<uint<1>>, out baz_quz: !firrtl.probe<uint<1>>) attributes {defname = \"BlackBox\", internalPaths = [\"baz.qux\", \"baz.quz\"]}\r\n  firrtl.module @Test() {\r\n    %0:3 = firrtl.instance inst @GCTDataTap(out probe: !firrtl.rwprobe<uint<5>>, out baz_qux: !firrtl.probe<uint<1>>, out baz_quz: !firrtl.probe<uint<1>>)\r\n  }\r\n}"}, {"number": 5816, "title": "[FIRRTL][LowerToHW] race on attribute dictionary", "created_at": "2023-08-09T13:38:13Z", "state": "closed", "labels": "bug", "body": "Looks to be introduced with https://github.com/llvm/circt/pull/5726 .\r\n\r\nModifying the new module's attribute dictionary to clear out the moved symbol while other threads are creating instances to the module and accessing its arg/result attributes.\r\n\r\n<details>\r\n<summary> Example TSAN report</summary>\r\n\r\n```\r\nFAIL: CIRCT :: Dialect/FIRRTL/SFCTests/data-taps.fir (21 of 641)\r\n******************** TEST 'CIRCT :: Dialect/FIRRTL/SFCTests/data-taps.fir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 1';   /build/sifive/tsan/bin/firtool --split-input-file /home/will/src/sifive/circt/test/Dialect/FIRRTL/SFCTests/data-taps.fir | /build/sifive/tsan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/FIRRTL/SFCTests/data-taps.fir\r\n--\r\nExit Code: 66\r\n\r\nCommand Output (stderr):\r\n--\r\n==================\r\nWARNING: ThreadSanitizer: data race (pid=3539269)\r\n  Read of size 8 at 0x7b1800028e38 by thread T2:\r\n    #0 mlir::detail::StorageUserBase<mlir::DictionaryAttr, mlir::Attribute, mlir::detail::DictionaryAttrStorage, mlir::detail::AttributeUniquer>::getImpl() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:211:68 (firtool+0xbd4eac)\r\n    #1 mlir::DictionaryAttr::getValue() const /build/sifive/tsan/tools/mlir/include/mlir/IR/BuiltinAttributes.cpp.inc:253:10 (firtool+0xbd4eac)\r\n    #2 mlir::DictionaryAttr::begin() const /home/will/src/sifive/circt/llvm/mlir/lib/IR/BuiltinAttributes.cpp:194:10 (firtool+0xbd4eac)\r\n    #3 mlir::DictionaryAttr::get(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/IR/BuiltinAttributes.cpp:167:34 (firtool+0xbd4eac)\r\n    #4 mlir::Operation::getAttr(llvm::StringRef) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:507:18 (firtool+0x143f9b8)\r\n    #5 mlir::ArrayAttr mlir::Operation::getAttrOfType<mlir::ArrayAttr>(llvm::StringRef) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:516:46 (firtool+0x143f9b8)\r\n    #6 circt::hw::instance_like_impl::getHWModuleArgAndResultNames(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/HW/InstanceImplementation.cpp:20:19 (firtool+0x143f9b8)\r\n    #7 circt::hw::InstanceOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Operation*, mlir::StringAttr, llvm::ArrayRef<mlir::Value>, mlir::ArrayAttr, circt::hw::InnerSymAttr) /home/will/src/sifive/circt/lib/Dialect/HW/HWOps.cpp:1485:7 (firtool+0x13a878f)\r\n    #8 circt::hw::InstanceOp mlir::OpBuilder::create<circt::hw::InstanceOp, mlir::Operation*&, mlir::StringAttr, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&>(mlir::Location, mlir::Operation*&, mlir::StringAttr&&, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Builders.h:494:5 (firtool+0xd898e3)\r\n    #9 circt::hw::InstanceOp mlir::ImplicitLocOpBuilder::create<circt::hw::InstanceOp, mlir::Operation*&, mlir::StringAttr, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&>(mlir::Operation*&, mlir::StringAttr&&, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/ImplicitLocOpBuilder.h:67:23 (firtool+0xd6df5a)\r\n    #10 (anonymous namespace)::FIRRTLLowering::visitDecl(circt::firrtl::InstanceOp) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:3232:30 (firtool+0xd6df5a)\r\n    #11 mlir::LogicalResult circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::InstanceOp>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:281:28 (firtool+0xd6df5a)\r\n    #12 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::firrtl::InstanceOp, circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*)::'lambda'(auto)&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:22 (firtool+0xd6df5a)\r\n    #13 circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:279:19 (firtool+0xd6df5a)\r\n    #14 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::visitInvalidStmt(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:340:18 (firtool+0xd6429b)\r\n    #15 mlir::LogicalResult circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchStmtVisitor(mlir::Operation*)::'lambda0'(auto)::operator()<mlir::Operation*>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:225:28 (firtool+0xd6429b)\r\n    #16 mlir::LogicalResult llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Default<circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchStmtVisitor(mlir::Operation*)::'lambda0'(auto)>(auto&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:131:12 (firtool+0xd6429b)\r\n    #17 circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchStmtVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:224:10 (firtool+0xd6429b)\r\n    #18 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::visitInvalidExpr(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:337:18 (firtool+0xd58b14)\r\n    #19 mlir::LogicalResult circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)::operator()<mlir::Operation*>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:69:28 (firtool+0xd58b14)\r\n    #20 mlir::LogicalResult llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Default<circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)>(auto&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:131:12 (firtool+0xd58b14)\r\n    #21 circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:68:10 (firtool+0xd58b14)\r\n    #22 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:332:18 (firtool+0xd49af0)\r\n    #23 (anonymous namespace)::FIRRTLLowering::run() /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1784:27 (firtool+0xd49af0)\r\n    #24 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleOperations(circt::hw::HWModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1767:48 (firtool+0xd49af0)\r\n    #25 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1410:10 (firtool+0xd49af0)\r\n    #26 auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5::operator()<unsigned long>(unsigned long) const /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:663:16 (firtool+0xd72dc1)\r\n    #27 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:62:18 (firtool+0xd72dc1)\r\n    #28 llvm::detail::SafeIntIterator<unsigned long, false> std::__invoke_impl<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>(std::__invoke_other, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0xd72dc1)\r\n    #29 std::enable_if<is_invocable_r_v<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>, llvm::detail::SafeIntIterator<unsigned long, false>>::type std::__invoke_r<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>((anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0xd72dc1)\r\n    #30 std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0xd72dc1)\r\n    #31 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7a5d07)\r\n    #32 llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/ThreadPool.h:135:15 (firtool+0x7a5d07)\r\n    #33 void std::__invoke_impl<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(std::__invoke_other, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7a5d07)\r\n    #34 std::enable_if<is_invocable_r_v<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>, void>::type std::__invoke_r<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0x7a5d07)\r\n    #35 std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0x7a5d07)\r\n    #36 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7aa839)\r\n    #37 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:101:5 (firtool+0x7aa839)\r\n    #38 llvm::ThreadPool::grow(int)::$_0::operator()() const /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:49:7 (firtool+0x7ab85e)\r\n    #39 auto void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)::operator()<llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:43:11 (firtool+0x7ab85e)\r\n    #40 auto std::__invoke_impl<void, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(std::__invoke_other, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)&&, llvm::ThreadPool::grow(int)::$_0&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7ab85e)\r\n    #41 std::__invoke_result<auto, auto...>::type std::__invoke<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:96:14 (firtool+0x7ab85e)\r\n    #42 decltype(auto) std::__apply_impl<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&, 0ul>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::integer_sequence<unsigned long, 0ul>) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1852:14 (firtool+0x7ab85e)\r\n    #43 decltype(auto) std::apply<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1863:14 (firtool+0x7ab85e)\r\n    #44 void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:41:5 (firtool+0x7ab85e)\r\n    #45 void* llvm::thread::ThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:55:5 (firtool+0x7ab85e)\r\n\r\n  Previous write of size 8 at 0x7b1800028e38 by thread T14:\r\n    #0 mlir::Operation::removeAttr(mlir::StringAttr) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:571:13 (firtool+0x7c2a7b)\r\n    #1 circt::hw::HWModuleOp::removeResAttrsAttr() /build/sifive/tsan/tools/circt/include/circt/Dialect/HW/HW.cpp.inc:4059:17 (firtool+0x13ead34)\r\n    #2 mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<circt::hw::HWModuleOp>::removeResAttrsAttr(mlir::detail::FunctionOpInterfaceInterfaceTraits::Concept const*, mlir::Operation*) /build/sifive/tsan/tools/mlir/include/mlir/IR/FunctionOpInterfaces.h.inc:1136:56 (firtool+0x1375d97)\r\n    #3 mlir::FunctionOpInterface::removeResAttrsAttr() /build/sifive/tsan/tools/mlir/include/mlir/IR/FunctionOpInterfaces.cpp.inc:51:14 (firtool+0xcc92e7)\r\n    #4 void removeArgResAttrs<false>(mlir::FunctionOpInterface) /home/will/src/sifive/circt/llvm/mlir/lib/IR/FunctionInterfaces.cpp:81:8 (firtool+0xcc92e7)\r\n    #5 void setArgResAttrDict<false>(mlir::FunctionOpInterface, unsigned int, unsigned int, mlir::DictionaryAttr) /home/will/src/sifive/circt/llvm/mlir/lib/IR/FunctionInterfaces.cpp:146:12 (firtool+0xcc92e7)\r\n    #6 mlir::function_interface_impl::setResultAttrs(mlir::FunctionOpInterface, unsigned int, mlir::DictionaryAttr) /home/will/src/sifive/circt/llvm/mlir/lib/IR/FunctionInterfaces.cpp:184:10 (firtool+0xcc9430)\r\n    #7 mlir::detail::FunctionOpInterfaceTrait<circt::hw::HWModuleOp>::setResultAttrs(unsigned int, mlir::DictionaryAttr) /build/sifive/tsan/tools/mlir/include/mlir/IR/FunctionOpInterfaces.h.inc:1051:7 (firtool+0x1417c7f)\r\n    #8 mlir::Attribute mlir::function_interface_impl::removeResultAttr<circt::hw::HWModuleOp>(circt::hw::HWModuleOp, unsigned int, mlir::StringAttr) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/FunctionInterfaces.h:159:8 (firtool+0x1417c7f)\r\n    #9 circt::hw::HWModuleOp::setPortSymbolAttr(unsigned long, circt::hw::InnerSymAttr) /build/sifive/tsan/tools/circt/include/circt/Dialect/HW/HW.cpp.inc:4229:5 (firtool+0x13ec9ac)\r\n    #10 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1392:19 (firtool+0xd48b16)\r\n    #11 auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5::operator()<unsigned long>(unsigned long) const /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:663:16 (firtool+0xd72dc1)\r\n    #12 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:62:18 (firtool+0xd72dc1)\r\n    #13 llvm::detail::SafeIntIterator<unsigned long, false> std::__invoke_impl<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>(std::__invoke_other, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0xd72dc1)\r\n    #14 std::enable_if<is_invocable_r_v<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>, llvm::detail::SafeIntIterator<unsigned long, false>>::type std::__invoke_r<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>((anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0xd72dc1)\r\n    #15 std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0xd72dc1)\r\n    #16 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7a5d07)\r\n    #17 llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/ThreadPool.h:135:15 (firtool+0x7a5d07)\r\n    #18 void std::__invoke_impl<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(std::__invoke_other, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7a5d07)\r\n    #19 std::enable_if<is_invocable_r_v<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>, void>::type std::__invoke_r<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0x7a5d07)\r\n    #20 std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0x7a5d07)\r\n    #21 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7aa839)\r\n    #22 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:101:5 (firtool+0x7aa839)\r\n    #23 llvm::ThreadPool::grow(int)::$_0::operator()() const /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:49:7 (firtool+0x7ab85e)\r\n    #24 auto void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)::operator()<llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:43:11 (firtool+0x7ab85e)\r\n    #25 auto std::__invoke_impl<void, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(std::__invoke_other, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)&&, llvm::ThreadPool::grow(int)::$_0&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7ab85e)\r\n    #26 std::__invoke_result<auto, auto...>::type std::__invoke<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:96:14 (firtool+0x7ab85e)\r\n    #27 decltype(auto) std::__apply_impl<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&, 0ul>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::integer_sequence<unsigned long, 0ul>) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1852:14 (firtool+0x7ab85e)\r\n    #28 decltype(auto) std::apply<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1863:14 (firtool+0x7ab85e)\r\n    #29 void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:41:5 (firtool+0x7ab85e)\r\n    #30 void* llvm::thread::ThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:55:5 (firtool+0x7ab85e)\r\n\r\n  Location is heap block of size 88 at 0x7b1800028e00 allocated by main thread:\r\n    #0 malloc <null> (firtool+0x5cacef)\r\n    #1 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:113:46 (firtool+0xcf1039)\r\n    #2 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:74:10 (firtool+0xcf0af8)\r\n    #3 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:57:7 (firtool+0xcf0af8)\r\n    #4 mlir::Operation::create(mlir::OperationState const&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:35:7 (firtool+0xcf0935)\r\n    #5 mlir::OpBuilder::create(mlir::OperationState const&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Builders.cpp:447:17 (firtool+0xbcf18d)\r\n    #6 circt::hw::HWModuleOp mlir::OpBuilder::create<circt::hw::HWModuleOp, mlir::StringAttr&, llvm::SmallVector<circt::hw::PortInfo, 8u>&>(mlir::Location, mlir::StringAttr&, llvm::SmallVector<circt::hw::PortInfo, 8u>&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Builders.h:495:16 (firtool+0xd75f24)\r\n    #7 (anonymous namespace)::FIRRTLModuleLowering::lowerModule(circt::firrtl::FModuleOp, mlir::Block*, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1117:15 (firtool+0xd40388)\r\n    #8 auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_0::operator()<circt::firrtl::FModuleOp>(circt::firrtl::FModuleOp) const /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:580:29 (firtool+0xd40388)\r\n    #9 llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::FModuleOp, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_0>((anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_0&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:169:7 (firtool+0xd40388)\r\n    #10 (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:579:10 (firtool+0xd40388)\r\n    #11 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:485:17 (firtool+0x1651571)\r\n    #12 void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12 (firtool+0x1651571)\r\n    #13 llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12 (firtool+0x1651571)\r\n    #14 void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7 (firtool+0x1651571)\r\n    #15 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:479:21 (firtool+0x1651571)\r\n    #16 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:551:16 (firtool+0x165567f)\r\n    #17 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:860:10 (firtool+0x165567f)\r\n    #18 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:840:60 (firtool+0x165567f)\r\n    #19 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:358:17 (firtool+0x6397c9)\r\n    #20 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:490:12 (firtool+0x6386fc)\r\n    #21 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/tools/firtool/firtool.cpp:524:16 (firtool+0x63a684)\r\n    #22 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12 (firtool+0x63a684)\r\n    #23 llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12 (firtool+0xb79fda)\r\n    #24 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16 (firtool+0xb79fda)\r\n    #25 void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2101:5 (firtool+0xb79a49)\r\n    #26 void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2119:3 (firtool+0xb79a49)\r\n    #27 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3 (firtool+0xb79a49)\r\n    #28 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:521:10 (firtool+0x63811c)\r\n    #29 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:591:14 (firtool+0x63811c)\r\n    #30 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:650:17 (firtool+0x6379a4)\r\n\r\n<<snip due to limits>>\r\n\r\nSUMMARY: ThreadSanitizer: data race /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:211:68 in mlir::detail::StorageUserBase<mlir::DictionaryAttr, mlir::Attribute, mlir::detail::DictionaryAttrStorage, mlir::detail::AttributeUniquer>::getImpl() const\r\n```\r\n</details>", "code_snippet_01": "FAIL: CIRCT :: Dialect/FIRRTL/SFCTests/data-taps.fir (21 of 641)\r\n******************** TEST 'CIRCT :: Dialect/FIRRTL/SFCTests/data-taps.fir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 1';   /build/sifive/tsan/bin/firtool --split-input-file /home/will/src/sifive/circt/test/Dialect/FIRRTL/SFCTests/data-taps.fir | /build/sifive/tsan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/FIRRTL/SFCTests/data-taps.fir\r\n--\r\nExit Code: 66\r\n\r\nCommand Output (stderr):\r\n--\r\n==================\r\nWARNING: ThreadSanitizer: data race (pid=3539269)\r\n  Read of size 8 at 0x7b1800028e38 by thread T2:\r\n    #0 mlir::detail::StorageUserBase<mlir::DictionaryAttr, mlir::Attribute, mlir::detail::DictionaryAttrStorage, mlir::detail::AttributeUniquer>::getImpl() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:211:68 (firtool+0xbd4eac)\r\n    #1 mlir::DictionaryAttr::getValue() const /build/sifive/tsan/tools/mlir/include/mlir/IR/BuiltinAttributes.cpp.inc:253:10 (firtool+0xbd4eac)\r\n    #2 mlir::DictionaryAttr::begin() const /home/will/src/sifive/circt/llvm/mlir/lib/IR/BuiltinAttributes.cpp:194:10 (firtool+0xbd4eac)\r\n    #3 mlir::DictionaryAttr::get(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/IR/BuiltinAttributes.cpp:167:34 (firtool+0xbd4eac)\r\n    #4 mlir::Operation::getAttr(llvm::StringRef) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:507:18 (firtool+0x143f9b8)\r\n    #5 mlir::ArrayAttr mlir::Operation::getAttrOfType<mlir::ArrayAttr>(llvm::StringRef) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:516:46 (firtool+0x143f9b8)\r\n    #6 circt::hw::instance_like_impl::getHWModuleArgAndResultNames(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/HW/InstanceImplementation.cpp:20:19 (firtool+0x143f9b8)\r\n    #7 circt::hw::InstanceOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Operation*, mlir::StringAttr, llvm::ArrayRef<mlir::Value>, mlir::ArrayAttr, circt::hw::InnerSymAttr) /home/will/src/sifive/circt/lib/Dialect/HW/HWOps.cpp:1485:7 (firtool+0x13a878f)\r\n    #8 circt::hw::InstanceOp mlir::OpBuilder::create<circt::hw::InstanceOp, mlir::Operation*&, mlir::StringAttr, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&>(mlir::Location, mlir::Operation*&, mlir::StringAttr&&, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Builders.h:494:5 (firtool+0xd898e3)\r\n    #9 circt::hw::InstanceOp mlir::ImplicitLocOpBuilder::create<circt::hw::InstanceOp, mlir::Operation*&, mlir::StringAttr, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&>(mlir::Operation*&, mlir::StringAttr&&, llvm::SmallVector<mlir::Value, 8u>&, mlir::ArrayAttr&, circt::hw::InnerSymAttr&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/ImplicitLocOpBuilder.h:67:23 (firtool+0xd6df5a)\r\n    #10 (anonymous namespace)::FIRRTLLowering::visitDecl(circt::firrtl::InstanceOp) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:3232:30 (firtool+0xd6df5a)\r\n    #11 mlir::LogicalResult circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::InstanceOp>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:281:28 (firtool+0xd6df5a)\r\n    #12 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::firrtl::InstanceOp, circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*)::'lambda'(auto)&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:22 (firtool+0xd6df5a)\r\n    #13 circt::firrtl::DeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchDeclVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:279:19 (firtool+0xd6df5a)\r\n    #14 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::visitInvalidStmt(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:340:18 (firtool+0xd6429b)\r\n    #15 mlir::LogicalResult circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchStmtVisitor(mlir::Operation*)::'lambda0'(auto)::operator()<mlir::Operation*>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:225:28 (firtool+0xd6429b)\r\n    #16 mlir::LogicalResult llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Default<circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchStmtVisitor(mlir::Operation*)::'lambda0'(auto)>(auto&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:131:12 (firtool+0xd6429b)\r\n    #17 circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchStmtVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:224:10 (firtool+0xd6429b)\r\n    #18 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::visitInvalidExpr(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:337:18 (firtool+0xd58b14)\r\n    #19 mlir::LogicalResult circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)::operator()<mlir::Operation*>(auto) const /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:69:28 (firtool+0xd58b14)\r\n    #20 mlir::LogicalResult llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Default<circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)>(auto&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:131:12 (firtool+0xd58b14)\r\n    #21 circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:68:10 (firtool+0xd58b14)\r\n    #22 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchVisitor(mlir::Operation*) /home/will/src/sifive/circt/include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:332:18 (firtool+0xd49af0)\r\n    #23 (anonymous namespace)::FIRRTLLowering::run() /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1784:27 (firtool+0xd49af0)\r\n    #24 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleOperations(circt::hw::HWModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1767:48 (firtool+0xd49af0)\r\n    #25 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1410:10 (firtool+0xd49af0)\r\n    #26 auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5::operator()<unsigned long>(unsigned long) const /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:663:16 (firtool+0xd72dc1)\r\n    #27 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:62:18 (firtool+0xd72dc1)\r\n    #28 llvm::detail::SafeIntIterator<unsigned long, false> std::__invoke_impl<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>(std::__invoke_other, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0xd72dc1)\r\n    #29 std::enable_if<is_invocable_r_v<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>, llvm::detail::SafeIntIterator<unsigned long, false>>::type std::__invoke_r<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>((anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0xd72dc1)\r\n    #30 std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0xd72dc1)\r\n    #31 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7a5d07)\r\n    #32 llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/ThreadPool.h:135:15 (firtool+0x7a5d07)\r\n    #33 void std::__invoke_impl<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(std::__invoke_other, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7a5d07)\r\n    #34 std::enable_if<is_invocable_r_v<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>, void>::type std::__invoke_r<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0x7a5d07)\r\n    #35 std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0x7a5d07)\r\n    #36 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7aa839)\r\n    #37 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:101:5 (firtool+0x7aa839)\r\n    #38 llvm::ThreadPool::grow(int)::$_0::operator()() const /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:49:7 (firtool+0x7ab85e)\r\n    #39 auto void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)::operator()<llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:43:11 (firtool+0x7ab85e)\r\n    #40 auto std::__invoke_impl<void, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(std::__invoke_other, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)&&, llvm::ThreadPool::grow(int)::$_0&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7ab85e)\r\n    #41 std::__invoke_result<auto, auto...>::type std::__invoke<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:96:14 (firtool+0x7ab85e)\r\n    #42 decltype(auto) std::__apply_impl<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&, 0ul>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::integer_sequence<unsigned long, 0ul>) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1852:14 (firtool+0x7ab85e)\r\n    #43 decltype(auto) std::apply<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1863:14 (firtool+0x7ab85e)\r\n    #44 void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:41:5 (firtool+0x7ab85e)\r\n    #45 void* llvm::thread::ThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:55:5 (firtool+0x7ab85e)\r\n\r\n  Previous write of size 8 at 0x7b1800028e38 by thread T14:\r\n    #0 mlir::Operation::removeAttr(mlir::StringAttr) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:571:13 (firtool+0x7c2a7b)\r\n    #1 circt::hw::HWModuleOp::removeResAttrsAttr() /build/sifive/tsan/tools/circt/include/circt/Dialect/HW/HW.cpp.inc:4059:17 (firtool+0x13ead34)\r\n    #2 mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<circt::hw::HWModuleOp>::removeResAttrsAttr(mlir::detail::FunctionOpInterfaceInterfaceTraits::Concept const*, mlir::Operation*) /build/sifive/tsan/tools/mlir/include/mlir/IR/FunctionOpInterfaces.h.inc:1136:56 (firtool+0x1375d97)\r\n    #3 mlir::FunctionOpInterface::removeResAttrsAttr() /build/sifive/tsan/tools/mlir/include/mlir/IR/FunctionOpInterfaces.cpp.inc:51:14 (firtool+0xcc92e7)\r\n    #4 void removeArgResAttrs<false>(mlir::FunctionOpInterface) /home/will/src/sifive/circt/llvm/mlir/lib/IR/FunctionInterfaces.cpp:81:8 (firtool+0xcc92e7)\r\n    #5 void setArgResAttrDict<false>(mlir::FunctionOpInterface, unsigned int, unsigned int, mlir::DictionaryAttr) /home/will/src/sifive/circt/llvm/mlir/lib/IR/FunctionInterfaces.cpp:146:12 (firtool+0xcc92e7)\r\n    #6 mlir::function_interface_impl::setResultAttrs(mlir::FunctionOpInterface, unsigned int, mlir::DictionaryAttr) /home/will/src/sifive/circt/llvm/mlir/lib/IR/FunctionInterfaces.cpp:184:10 (firtool+0xcc9430)\r\n    #7 mlir::detail::FunctionOpInterfaceTrait<circt::hw::HWModuleOp>::setResultAttrs(unsigned int, mlir::DictionaryAttr) /build/sifive/tsan/tools/mlir/include/mlir/IR/FunctionOpInterfaces.h.inc:1051:7 (firtool+0x1417c7f)\r\n    #8 mlir::Attribute mlir::function_interface_impl::removeResultAttr<circt::hw::HWModuleOp>(circt::hw::HWModuleOp, unsigned int, mlir::StringAttr) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/FunctionInterfaces.h:159:8 (firtool+0x1417c7f)\r\n    #9 circt::hw::HWModuleOp::setPortSymbolAttr(unsigned long, circt::hw::InnerSymAttr) /build/sifive/tsan/tools/circt/include/circt/Dialect/HW/HW.cpp.inc:4229:5 (firtool+0x13ec9ac)\r\n    #10 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1392:19 (firtool+0xd48b16)\r\n    #11 auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5::operator()<unsigned long>(unsigned long) const /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:663:16 (firtool+0xd72dc1)\r\n    #12 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Threading.h:62:18 (firtool+0xd72dc1)\r\n    #13 llvm::detail::SafeIntIterator<unsigned long, false> std::__invoke_impl<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>(std::__invoke_other, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0xd72dc1)\r\n    #14 std::enable_if<is_invocable_r_v<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>, llvm::detail::SafeIntIterator<unsigned long, false>>::type std::__invoke_r<void, mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()&>((anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0xd72dc1)\r\n    #15 std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_5&&)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0xd72dc1)\r\n    #16 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7a5d07)\r\n    #17 llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/ThreadPool.h:135:15 (firtool+0x7a5d07)\r\n    #18 void std::__invoke_impl<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(std::__invoke_other, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7a5d07)\r\n    #19 std::enable_if<is_invocable_r_v<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>, void>::type std::__invoke_r<void, llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:111:2 (firtool+0x7a5d07)\r\n    #20 std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::'lambda'()>::_M_invoke(std::_Any_data const&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:290:9 (firtool+0x7a5d07)\r\n    #21 std::function<void ()>::operator()() const /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/std_function.h:591:9 (firtool+0x7aa839)\r\n    #22 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:101:5 (firtool+0x7aa839)\r\n    #23 llvm::ThreadPool::grow(int)::$_0::operator()() const /home/will/src/sifive/circt/llvm/llvm/lib/Support/ThreadPool.cpp:49:7 (firtool+0x7ab85e)\r\n    #24 auto void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)::operator()<llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:43:11 (firtool+0x7ab85e)\r\n    #25 auto std::__invoke_impl<void, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(std::__invoke_other, void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...)&&, llvm::ThreadPool::grow(int)::$_0&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:61:14 (firtool+0x7ab85e)\r\n    #26 std::__invoke_result<auto, auto...>::type std::__invoke<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), llvm::ThreadPool::grow(int)::$_0&>(auto&&, auto&&...) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/bits/invoke.h:96:14 (firtool+0x7ab85e)\r\n    #27 decltype(auto) std::__apply_impl<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&, 0ul>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::integer_sequence<unsigned long, 0ul>) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1852:14 (firtool+0x7ab85e)\r\n    #28 decltype(auto) std::apply<void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*)::'lambda'(auto&&, auto&&...), std::tuple<llvm::ThreadPool::grow(int)::$_0>&>(auto&&, std::tuple<llvm::ThreadPool::grow(int)::$_0>&) /nix/store/1x1q5sqa0ilbi8fz7aayk02pjy5g7jhh-gcc-12.3.0/include/c++/12.3.0/tuple:1863:14 (firtool+0x7ab85e)\r\n    #29 void llvm::thread::GenericThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:41:5 (firtool+0x7ab85e)\r\n    #30 void* llvm::thread::ThreadProxy<std::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/thread.h:55:5 (firtool+0x7ab85e)\r\n\r\n  Location is heap block of size 88 at 0x7b1800028e00 allocated by main thread:\r\n    #0 malloc <null> (firtool+0x5cacef)\r\n    #1 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:113:46 (firtool+0xcf1039)\r\n    #2 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:74:10 (firtool+0xcf0af8)\r\n    #3 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:57:7 (firtool+0xcf0af8)\r\n    #4 mlir::Operation::create(mlir::OperationState const&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:35:7 (firtool+0xcf0935)\r\n    #5 mlir::OpBuilder::create(mlir::OperationState const&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Builders.cpp:447:17 (firtool+0xbcf18d)\r\n    #6 circt::hw::HWModuleOp mlir::OpBuilder::create<circt::hw::HWModuleOp, mlir::StringAttr&, llvm::SmallVector<circt::hw::PortInfo, 8u>&>(mlir::Location, mlir::StringAttr&, llvm::SmallVector<circt::hw::PortInfo, 8u>&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Builders.h:495:16 (firtool+0xd75f24)\r\n    #7 (anonymous namespace)::FIRRTLModuleLowering::lowerModule(circt::firrtl::FModuleOp, mlir::Block*, (anonymous namespace)::CircuitLoweringState&) /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:1117:15 (firtool+0xd40388)\r\n    #8 auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_0::operator()<circt::firrtl::FModuleOp>(circt::firrtl::FModuleOp) const /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:580:29 (firtool+0xd40388)\r\n    #9 llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::FModuleOp, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_0>((anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_0&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:169:7 (firtool+0xd40388)\r\n    #10 (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/FIRRTLToHW/LowerToHW.cpp:579:10 (firtool+0xd40388)\r\n    #11 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1::operator()() const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:485:17 (firtool+0x1651571)\r\n    #12 void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_1>(long) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12 (firtool+0x1651571)\r\n    #13 llvm::function_ref<void ()>::operator()() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12 (firtool+0x1651571)\r\n    #14 void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(llvm::function_ref<void ()>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/MLIRContext.h:275:7 (firtool+0x1651571)\r\n    #15 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:479:21 (firtool+0x1651571)\r\n    #16 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:551:16 (firtool+0x165567f)\r\n    #17 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:860:10 (firtool+0x165567f)\r\n    #18 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:840:60 (firtool+0x165567f)\r\n    #19 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:358:17 (firtool+0x6397c9)\r\n    #20 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:490:12 (firtool+0x6386fc)\r\n    #21 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/tools/firtool/firtool.cpp:524:16 (firtool+0x63a684)\r\n    #22 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12 (firtool+0x63a684)\r\n    #23 llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12 (firtool+0xb79fda)\r\n    #24 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16 (firtool+0xb79fda)\r\n    #25 void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2101:5 (firtool+0xb79a49)\r\n    #26 void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2119:3 (firtool+0xb79a49)\r\n    #27 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3 (firtool+0xb79a49)\r\n    #28 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:521:10 (firtool+0x63811c)\r\n    #29 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:591:14 (firtool+0x63811c)\r\n    #30 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:650:17 (firtool+0x6379a4)\r\n\r\n<<snip due to limits>>\r\n\r\nSUMMARY: ThreadSanitizer: data race /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:211:68 in mlir::detail::StorageUserBase<mlir::DictionaryAttr, mlir::Attribute, mlir::detail::DictionaryAttrStorage, mlir::detail::AttributeUniquer>::getImpl() const"}, {"number": 5772, "title": "[Comb] comb.concat doesn't work with type alias", "created_at": "2023-08-03T13:32:25Z", "state": "open", "labels": "bug, Comb", "body": "```\r\nhw.type_scope @__hw_typedecls {\r\n  hw.typedecl @foo : i1\r\n}\r\n\r\nhw.module @Top(%arg0: !hw.typealias<@__hw_typedecls::@foo,i1>) {\r\n  %0 = comb.concat %arg0 : !hw.typealias<@__hw_typedecls::@foo,i1>\r\n}\r\n```\r\n\r\n```\r\ncirct-opt: /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ./build/bin/circt-opt foo.mlir\r\n1.      MLIR Parser: custom op parser 'hw.module'\r\n2.      MLIR Parser: custom op parser 'comb.concat'\r\n #0 0x0000000000447057 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x00000000004451e0 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x000000000044796f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007fe418fd6cf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)\r\n #4 0x00007fe417e61aff raise (/lib64/libc.so.6+0x4eaff)\r\n #5 0x00007fe417e34ea5 abort (/lib64/libc.so.6+0x21ea5)\r\n #6 0x00007fe417e34d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)\r\n #7 0x00007fe417e5a456 (/lib64/libc.so.6+0x47456)\r\n #8 0x0000000000609c3b (./build/bin/circt-opt+0x609c3b)\r\n #9 0x000000000060c749 circt::comb::ConcatOp::inferReturnTypes(mlir::MLIRContext*, std::optional<mlir::Location>, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::RegionRange, llvm::SmallVectorImpl<mlir::Type>&) /scratch/hidetou/circt/lib/Dialect/Comb/CombOps.cpp:270:21\r\n#10 0x000000000060c749 circt::comb::ConcatOp::parse(mlir::OpAsmParser&, mlir::OperationState&) /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/Comb/Comb.cpp.inc:948:22\r\n#11 0x00000000014d521f mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#12 0x00000000014d521f mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43\r\n#13 0x00000000014d521f (anonymous namespace)::CustomOpAsmParser::parseOperation(mlir::OperationState&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1491:9\r\n#14 0x00000000014d521f (anonymous namespace)::OperationParser::parseCustomOperation(llvm::ArrayRef<std::tuple<llvm::StringRef, unsigned int, llvm::SMLoc>>) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1987:19\r\n#15 0x00000000014d521f (anonymous namespace)::OperationParser::parseOperation() /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1146:10\r\n#16 0x00000000014e0ac0 mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#17 0x00000000014e0ac0 mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43\r\n#18 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlockBody(mlir::Block*) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2263:9\r\n#19 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2193:12\r\n```", "code_snippet_01": "hw.type_scope @__hw_typedecls {\r\n  hw.typedecl @foo : i1\r\n}\r\n\r\nhw.module @Top(%arg0: !hw.typealias<@__hw_typedecls::@foo,i1>) {\r\n  %0 = comb.concat %arg0 : !hw.typealias<@__hw_typedecls::@foo,i1>\r\n}", "code_snippet_02": "circt-opt: /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ./build/bin/circt-opt foo.mlir\r\n1.      MLIR Parser: custom op parser 'hw.module'\r\n2.      MLIR Parser: custom op parser 'comb.concat'\r\n #0 0x0000000000447057 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x00000000004451e0 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x000000000044796f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007fe418fd6cf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)\r\n #4 0x00007fe417e61aff raise (/lib64/libc.so.6+0x4eaff)\r\n #5 0x00007fe417e34ea5 abort (/lib64/libc.so.6+0x21ea5)\r\n #6 0x00007fe417e34d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)\r\n #7 0x00007fe417e5a456 (/lib64/libc.so.6+0x47456)\r\n #8 0x0000000000609c3b (./build/bin/circt-opt+0x609c3b)\r\n #9 0x000000000060c749 circt::comb::ConcatOp::inferReturnTypes(mlir::MLIRContext*, std::optional<mlir::Location>, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::RegionRange, llvm::SmallVectorImpl<mlir::Type>&) /scratch/hidetou/circt/lib/Dialect/Comb/CombOps.cpp:270:21\r\n#10 0x000000000060c749 circt::comb::ConcatOp::parse(mlir::OpAsmParser&, mlir::OperationState&) /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/Comb/Comb.cpp.inc:948:22\r\n#11 0x00000000014d521f mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#12 0x00000000014d521f mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43\r\n#13 0x00000000014d521f (anonymous namespace)::CustomOpAsmParser::parseOperation(mlir::OperationState&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1491:9\r\n#14 0x00000000014d521f (anonymous namespace)::OperationParser::parseCustomOperation(llvm::ArrayRef<std::tuple<llvm::StringRef, unsigned int, llvm::SMLoc>>) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1987:19\r\n#15 0x00000000014d521f (anonymous namespace)::OperationParser::parseOperation() /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1146:10\r\n#16 0x00000000014e0ac0 mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#17 0x00000000014e0ac0 mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43\r\n#18 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlockBody(mlir::Block*) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2263:9\r\n#19 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2193:12"}, {"number": 5765, "title": "[ExportVerilog] Fix Expr/PropertyEmitter token buffer crash", "created_at": "2023-08-02T23:13:13Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Fix an issue in `ExportVerilog` where `ExprEmitter`s and `PropertyEmitter`s would not properly use a token buffer passed in as a constructor argument. The emitters have a local buffer of tokens that is used by default if no external one is provided. However, parts of the emitters failed to use `buffer.tokens` to access either the externally provided or the local buffer, and instead would always use the local `tokens` buffer. This caused parentheses and end tokens to be lost if an external buffer was provided, since the emitter would modify the unused local `tokens` buffer.\r\n\r\nThis fixes the issue by properly using `buffer.tokens` everywhere and renaming `tokens` to `localTokens` to make misuse more obvious.\r\n\r\nFixes #5763."}, {"number": 5763, "title": "[ExportVerilog] verif.assert triggers pretty printer assertion", "created_at": "2023-08-02T22:44:05Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```\r\nhw.module @Foo(%a: i3) {\r\n  %c-1_i3 = hw.constant -1 : i3\r\n  %0 = comb.extract %a from 0 : (i3) -> i1\r\n  %1 = comb.icmp bin eq %a, %c-1_i3 : i3\r\n  %2 = comb.and bin %1, %0 : i1\r\n  verif.assert %2 : i1\r\n}\r\n```\r\nRunning this through `firtool` (no options needed) triggers an assertion in the pretty printer:\r\n```\r\nfirtool: /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:285: auto circt::pretty::PrettyPrinter::print(const circt::pretty::PrettyPrinter::FormattedToken &)::(anonymous class)::operator()(const circt::pretty::EndToken *) const: Assertion `!printStack.empty() && \"more ends than begins?\"' failed.\r\n[...]\r\n#10 0x000055f64008abe2 circt::pretty::Token::getKind() const /home/fabian/code/circt/include/circt/Support/PrettyPrinter.h:102:43\r\n#11 0x000055f64008abe2 circt::pretty::TokenBase<circt::pretty::BreakToken, (circt::pretty::Token::Kind)1>::classof(circt::pretty::Token const*) /home/fabian/code/circt/include/circt/Support/PrettyPrinter.h:108:51\r\n[...]\r\n#22 0x000055f64008abe2 circt::pretty::PrettyPrinter::advanceLeft() /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:224:14\r\n#23 0x000055f64008ae03 circt::pretty::PrettyPrinter::checkStream() /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:203:10\r\n#24 0x000055f64008a509 circt::pretty::PrettyPrinter::add(circt::pretty::Token) /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:118:3\r\n#25 0x000055f63f993fcb emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*) /home/fabian/code/circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:0:0\r\n[...]\r\n#31 0x000055f63f9c7490 circt::ExportVerilog::StringOrOpToEmit::setString(llvm::StringRef) /home/fabian/code/circt/lib/Conversion/ExportVerilog/ExportVerilogInternals.h:201:5\r\n#32 0x000055f63f9c7490 circt::ExportVerilog::SharedEmitterState::emitOps(std::vector<circt::ExportVerilog::StringOrOpToEmit, std::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_65::operator()(circt::ExportVerilog::StringOrOpToEmit&) const /home/fabian/code/circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:5899:16\r\n[...]\r\n```\r\nProbably related to the emission of `verif.assert` doing something fishy. I was tracking down a different failure related to `verif.assert` where the number of opening and closing parentheses don't match. Accidentally stumbled across this there.", "code_snippet_01": "hw.module @Foo(%a: i3) {\r\n  %c-1_i3 = hw.constant -1 : i3\r\n  %0 = comb.extract %a from 0 : (i3) -> i1\r\n  %1 = comb.icmp bin eq %a, %c-1_i3 : i3\r\n  %2 = comb.and bin %1, %0 : i1\r\n  verif.assert %2 : i1\r\n}", "code_snippet_02": "firtool: /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:285: auto circt::pretty::PrettyPrinter::print(const circt::pretty::PrettyPrinter::FormattedToken &)::(anonymous class)::operator()(const circt::pretty::EndToken *) const: Assertion `!printStack.empty() && \"more ends than begins?\"' failed.\r\n[...]\r\n#10 0x000055f64008abe2 circt::pretty::Token::getKind() const /home/fabian/code/circt/include/circt/Support/PrettyPrinter.h:102:43\r\n#11 0x000055f64008abe2 circt::pretty::TokenBase<circt::pretty::BreakToken, (circt::pretty::Token::Kind)1>::classof(circt::pretty::Token const*) /home/fabian/code/circt/include/circt/Support/PrettyPrinter.h:108:51\r\n[...]\r\n#22 0x000055f64008abe2 circt::pretty::PrettyPrinter::advanceLeft() /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:224:14\r\n#23 0x000055f64008ae03 circt::pretty::PrettyPrinter::checkStream() /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:203:10\r\n#24 0x000055f64008a509 circt::pretty::PrettyPrinter::add(circt::pretty::Token) /home/fabian/code/circt/lib/Support/PrettyPrinter.cpp:118:3\r\n#25 0x000055f63f993fcb emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*) /home/fabian/code/circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:0:0\r\n[...]\r\n#31 0x000055f63f9c7490 circt::ExportVerilog::StringOrOpToEmit::setString(llvm::StringRef) /home/fabian/code/circt/lib/Conversion/ExportVerilog/ExportVerilogInternals.h:201:5\r\n#32 0x000055f63f9c7490 circt::ExportVerilog::SharedEmitterState::emitOps(std::vector<circt::ExportVerilog::StringOrOpToEmit, std::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_65::operator()(circt::ExportVerilog::StringOrOpToEmit&) const /home/fabian/code/circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:5899:16\r\n[...]"}, {"number": 5727, "title": "[FIRRTL] Lower XMR assumes unique port names", "created_at": "2023-07-28T21:07:23Z", "state": "open", "labels": "bug, FIRRTL", "body": "FIRRTL's `LoweXMR` pass will currently produce invalid IR if it is given a module which has duplicate port names.\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [\"a\", \"a\"]} {\r\n    %b = firrtl.wire interesting_name : !firrtl.uint<1>\r\n    %0 = firrtl.ref.send %b : !firrtl.uint<1>\r\n    firrtl.ref.define %a, %0 : !firrtl.probe<uint<1>>\r\n    %1 = firrtl.ref.send %b : !firrtl.uint<1>\r\n    firrtl.ref.define %a0, %1 : !firrtl.probe<uint<1>>\r\n  }\r\n}\r\n```\r\n\r\nThis produces:\r\n\r\n```\r\n# circt-opt Foo.mlir -firrtl-lower-xmr                                   \r\nfirrtl-snippets/issues/x.mlir:3:5: error: redefinition of symbol named 'ref_Foo_Foo_a'\r\n    firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [\"a\", \"a\"]} {\r\n    ^\r\nfirrtl-snippets/issues/x.mlir:3:5: note: see current operation: \"sv.macro.decl\"() {sym_name = \"ref_Foo_Foo_a\"} : () -> ()\r\nfirrtl-snippets/issues/x.mlir:3:5: note: see existing symbol definition here\r\n```", "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [\"a\", \"a\"]} {\r\n    %b = firrtl.wire interesting_name : !firrtl.uint<1>\r\n    %0 = firrtl.ref.send %b : !firrtl.uint<1>\r\n    firrtl.ref.define %a, %0 : !firrtl.probe<uint<1>>\r\n    %1 = firrtl.ref.send %b : !firrtl.uint<1>\r\n    firrtl.ref.define %a0, %1 : !firrtl.probe<uint<1>>\r\n  }\r\n}", "code_snippet_02": "# circt-opt Foo.mlir -firrtl-lower-xmr                                   \r\nfirrtl-snippets/issues/x.mlir:3:5: error: redefinition of symbol named 'ref_Foo_Foo_a'\r\n    firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [\"a\", \"a\"]} {\r\n    ^\r\nfirrtl-snippets/issues/x.mlir:3:5: note: see current operation: \"sv.macro.decl\"() {sym_name = \"ref_Foo_Foo_a\"} : () -> ()\r\nfirrtl-snippets/issues/x.mlir:3:5: note: see existing symbol definition here"}, {"number": 5721, "title": "[FIRRTL] FIRRTL Exporter needs to unique names", "created_at": "2023-07-28T17:58:04Z", "state": "open", "labels": "bug, good first issue", "body": "Currently, the FIRRTL exporter will not properly unique names during emission (like what `ExportVerilog` does). Consider the following:\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo() {\r\n    %0 = firrtl.wire {name = \"a\"} : !firrtl.uint<1>\r\n    %1 = firrtl.wire {name = \"a\"} : !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nThis produces the following illegal FIRRTL (`circt-translate -export-firrtl Foo.mlir`):\r\n```\r\nFIRRTL version 3.1.0\r\ncircuit Foo :\r\n  module Foo : \r\n    wire a : UInt<1> \r\n    wire a : UInt<1> \r\n```\r\n\r\n`wire a` is defined twice.", "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo() {\r\n    %0 = firrtl.wire {name = \"a\"} : !firrtl.uint<1>\r\n    %1 = firrtl.wire {name = \"a\"} : !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_02": "FIRRTL version 3.1.0\r\ncircuit Foo :\r\n  module Foo : \r\n    wire a : UInt<1> \r\n    wire a : UInt<1>"}, {"number": 5665, "title": "[SVExtractTestCode] Instance inlining doesn't update inner symbols and clone sv.bind", "created_at": "2023-07-24T11:37:59Z", "state": "closed", "labels": "bug, Verilog/SystemVerilog", "body": "```scala\r\ncircuit Top:\r\n  module Assert:\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    assert(clock, a, a, \"foo\")\r\n\r\n  module Top:\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    input b: UInt<1>\r\n    inst a1 of Assert\r\n    a1.a <= a\r\n    a1.clock <= clock\r\n    inst a2 of Assert\r\n    a2.a <= b\r\n    a2.clock <= clock\r\n```\r\n\r\nThe current output with `firtool -extract-test-code`. \r\n\r\n```verilog\r\n// Generated by CIRCT firtool-1.48.0-44-gf453a87cd\r\n// VCS coverage exclude_file\r\nmodule Assert_assert(\r\n  input a,\r\n        clock\r\n);\r\n\r\n  always @(posedge clock) begin\r\n    if (a)\r\n      assert(a) else $error(\"foo\");\r\n  end // always @(posedge)\r\nendmodule\r\n\r\nmodule Top(\r\n  input clock,\r\n        a,\r\n        b\r\n);\r\n\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"bindfile.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT firtool-1.48.0-44-gf453a87cd\r\nbind Top Assert_assert Assert_assert (\r\n  .a     (a),\r\n  .clock (clock)\r\n);\r\n```\r\n\r\nThe second assertion is not emitted in the bind file. This is because bind op is not cloned properly when input only modules are inlined and the first instance (in the instance graph ndoe iterator) is preserved.  This bug was first introduced by https://github.com/llvm/circt/commit/0d5cf22e970a4085488fafd472aa51517c360312 which was included in 1.17.0.", "code_snippet_01": "circuit Top:\r\n  module Assert:\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    assert(clock, a, a, \"foo\")\r\n\r\n  module Top:\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    input b: UInt<1>\r\n    inst a1 of Assert\r\n    a1.a <= a\r\n    a1.clock <= clock\r\n    inst a2 of Assert\r\n    a2.a <= b\r\n    a2.clock <= clock", "code_snippet_02": "// Generated by CIRCT firtool-1.48.0-44-gf453a87cd\r\n// VCS coverage exclude_file\r\nmodule Assert_assert(\r\n  input a,\r\n        clock\r\n);\r\n\r\n  always @(posedge clock) begin\r\n    if (a)\r\n      assert(a) else $error(\"foo\");\r\n  end // always @(posedge)\r\nendmodule\r\n\r\nmodule Top(\r\n  input clock,\r\n        a,\r\n        b\r\n);\r\n\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"bindfile.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT firtool-1.48.0-44-gf453a87cd\r\nbind Top Assert_assert Assert_assert (\r\n  .a     (a),\r\n  .clock (clock)\r\n);"}, {"number": 5650, "title": "[FIRRTL] Canonicalizer creates invalid StrictConnect", "created_at": "2023-07-21T12:50:50Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Input:\r\n```\r\nfirrtl.circuit \"Child\" {\r\nfirrtl.module @Child(in %io_y: !firrtl.uint<1>, out %io_x: !firrtl.uint<1>) {\r\n  %io = firrtl.wire : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n  %2 = firrtl.subfield %io[y] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n  firrtl.strictconnect %2, %io_y : !firrtl.uint<1>\r\n  %3 = firrtl.subfield %io[x] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n  firrtl.strictconnect %io_x, %3 : !firrtl.uint<1>\r\n  firrtl.strictconnect %3, %2 : !firrtl.uint<1>\r\n}\r\n}\r\n```\r\n\r\n```\r\n$ circt-opt -canonicalize canonicalize_flips_strictconnect.mlir -mlir-print-ir-after-failure -mlir-print-assume-verified\r\ncanonicalize_flips_strictconnect.mlir:3:9: error: 'firrtl.strictconnect' op operand #0 must be a sized passive base type (contains no uninferred widths, or flips) or foreign type, but got '!firrtl.bundle<y flip: uint<1>, x: uint<1>>'\r\n  %io = firrtl.wire : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n        ^\r\ncanonicalize_flips_strictconnect.mlir:3:9: note: see current operation: \"firrtl.strictconnect\"(%0, %3) : (!firrtl.bundle<y flip: uint<1>, x: uint<1>>, !firrtl.bundle<y flip: uint<1>, x: uint<1>>) -> ()\r\n// -----// IR Dump After Canonicalizer Failed (canonicalize) //----- //\r\nmodule {\r\n  firrtl.circuit \"Child\" {\r\n    firrtl.module @Child(in %io_y: !firrtl.uint<1>, out %io_x: !firrtl.uint<1>) {\r\n      %io = firrtl.wire : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n      %0 = firrtl.subfield %io[y] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n      %1 = firrtl.subfield %io[x] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n      firrtl.strictconnect %io_x, %1 : !firrtl.uint<1>\r\n      %2 = firrtl.bundlecreate %io_y, %0 : (!firrtl.uint<1>, !firrtl.uint<1>) -> !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n      firrtl.strictconnect %io, %2 : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n    }\r\n  }\r\n}\r\n```", "code_snippet_01": "firrtl.circuit \"Child\" {\r\nfirrtl.module @Child(in %io_y: !firrtl.uint<1>, out %io_x: !firrtl.uint<1>) {\r\n  %io = firrtl.wire : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n  %2 = firrtl.subfield %io[y] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n  firrtl.strictconnect %2, %io_y : !firrtl.uint<1>\r\n  %3 = firrtl.subfield %io[x] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n  firrtl.strictconnect %io_x, %3 : !firrtl.uint<1>\r\n  firrtl.strictconnect %3, %2 : !firrtl.uint<1>\r\n}\r\n}", "code_snippet_02": "$ circt-opt -canonicalize canonicalize_flips_strictconnect.mlir -mlir-print-ir-after-failure -mlir-print-assume-verified\r\ncanonicalize_flips_strictconnect.mlir:3:9: error: 'firrtl.strictconnect' op operand #0 must be a sized passive base type (contains no uninferred widths, or flips) or foreign type, but got '!firrtl.bundle<y flip: uint<1>, x: uint<1>>'\r\n  %io = firrtl.wire : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n        ^\r\ncanonicalize_flips_strictconnect.mlir:3:9: note: see current operation: \"firrtl.strictconnect\"(%0, %3) : (!firrtl.bundle<y flip: uint<1>, x: uint<1>>, !firrtl.bundle<y flip: uint<1>, x: uint<1>>) -> ()\r\n// -----// IR Dump After Canonicalizer Failed (canonicalize) //----- //\r\nmodule {\r\n  firrtl.circuit \"Child\" {\r\n    firrtl.module @Child(in %io_y: !firrtl.uint<1>, out %io_x: !firrtl.uint<1>) {\r\n      %io = firrtl.wire : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n      %0 = firrtl.subfield %io[y] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n      %1 = firrtl.subfield %io[x] : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n      firrtl.strictconnect %io_x, %1 : !firrtl.uint<1>\r\n      %2 = firrtl.bundlecreate %io_y, %0 : (!firrtl.uint<1>, !firrtl.uint<1>) -> !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n      firrtl.strictconnect %io, %2 : !firrtl.bundle<y flip: uint<1>, x: uint<1>>\r\n    }\r\n  }\r\n}"}, {"number": 5613, "title": "[ExportVerilog] Prepare for emission crashes on test in regression suit", "created_at": "2023-07-18T04:41:22Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Input:\r\n```mlir\r\nhw.module @LowerIntrinsicStyle(%a: i1, %b: i1) {\r\n  verif.assert %2 : !ltl.sequence\r\n  %0 = ltl.implication %2, %1 : !ltl.sequence, !ltl.property\r\n  %1 = ltl.or %b, %3 : i1, !ltl.property\r\n  %2 = ltl.and %b, %4 : i1, !ltl.sequence\r\n  %3 = ltl.not %b : i1\r\n  %4 = ltl.delay %a, 42 : i1\r\n  hw.output\r\n}\r\n```\r\n\r\nCommand:\r\n`./build/bin/circt-opt --pass-pipeline='builtin.module(hw.module(prepare-for-emission))'`", "code_snippet_01": "hw.module @LowerIntrinsicStyle(%a: i1, %b: i1) {\r\n  verif.assert %2 : !ltl.sequence\r\n  %0 = ltl.implication %2, %1 : !ltl.sequence, !ltl.property\r\n  %1 = ltl.or %b, %3 : i1, !ltl.property\r\n  %2 = ltl.and %b, %4 : i1, !ltl.sequence\r\n  %3 = ltl.not %b : i1\r\n  %4 = ltl.delay %a, 42 : i1\r\n  hw.output\r\n}"}, {"number": 5605, "title": "[ExportVerilog] Prepare for Emission Assertion Failure", "created_at": "2023-07-17T15:20:33Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The composition of `PrepareForEmission` and `ExportVerilog` can cause assertion failures for certain IR. Consider the example below. Here, `sv.system.sampled` is used twice. This needs to get duplicated so it is inlined into its assertion use sites. The `concat` will then throw an assertion during `ExportVerilog` as it was not spilled to a wire:\r\n\r\n```mlir\r\nhw.module @Foo(%foo: i25, %bar: i12, %clock: i1, %reset: i1) {\r\n    %concat = comb.concat %foo, %bar : i25, i12\r\n    %415 = sv.system.sampled %concat : i37\r\n    sv.assert.concurrent posedge %clock, %reset label \"assert__verif\" message \"foo\"(%415) : i37\r\n    sv.assert.concurrent posedge %clock, %reset label \"assert__verif\" message \"bar\"(%415) : i37\r\n    hw.output\r\n  }\r\n```\r\n\r\nIt is reasonable if either the concat is inline into both use sites or if a temporary wire is created.\r\n\r\nThis hints at some problems with forward pass approach of `PrepareForEmission`. E.g., for the wire emission case, the concat should be spilled to a wire if it has more than one use. However, it only has more than one use if its one user becomes two. This is only know after visiting the sampled op which requires backtracking.\r\n\r\nIt would likely be cleaner to structure `PrepareForEmission` as a backwards pass over the IR as the logic for duplicating or wire spilling is all dependent on users.", "code_snippet_01": "hw.module @Foo(%foo: i25, %bar: i12, %clock: i1, %reset: i1) {\r\n    %concat = comb.concat %foo, %bar : i25, i12\r\n    %415 = sv.system.sampled %concat : i37\r\n    sv.assert.concurrent posedge %clock, %reset label \"assert__verif\" message \"foo\"(%415) : i37\r\n    sv.assert.concurrent posedge %clock, %reset label \"assert__verif\" message \"bar\"(%415) : i37\r\n    hw.output\r\n  }"}, {"number": 5598, "title": "[FIRRTL][Inliner] Handle inner symbols with fieldID != 0", "created_at": "2023-07-15T00:27:52Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Inliner only handles top-level symbols.  Consider this small example modified from its lit test on renaming scenarios:\r\n\r\n```mlir\r\nfirrtl.circuit \"CollidingSymbolsFields\" {\r\n  hw.hierpath private @nla1 [@CollidingSymbolsFields::@foo, @Foo::@bar, @Bar]\r\n  firrtl.module @Bar() attributes {annotations = [{circt.nonlocal = @nla1, class = \"nla1\"}]} {}\r\n  firrtl.module @Foo() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n    %b = firrtl.wire sym [<@b,1,public>] : !firrtl.bundle<a: uint<1>, b: uint<1>>\r\n    firrtl.instance bar sym @bar @Bar()\r\n  }\r\n  firrtl.module @CollidingSymbolsFields() {\r\n    firrtl.instance foo sym @foo @Foo()\r\n    %collision_b = firrtl.wire sym @b : !firrtl.uint<1>\r\n    %collision_bar = firrtl.wire sym [<@bar,1,public>] : !firrtl.bundle<a: uint<1>, b: uint<1>>\r\n  }\r\n}\r\n```\r\n\r\nPoint inliner at it (` circt-opt -firrtl-inliner`) to see the resulting failure due to not understanding/inspecting/handling symbols that aren't on fieldID=0:\r\n\r\n```\r\ninliner-perfield-nocheck.mlir:10:20: error: redefinition of inner symbol named 'b'\r\n    %collision_b = firrtl.wire sym @b : !firrtl.uint<1>\r\n                   ^\r\ninliner-perfield-nocheck.mlir:10:20: note: see current operation: %1 = \"firrtl.wire\"() {annotations = [], inner_sym = #hw<innerSym@b>, name = \"collision_b\", nameKind = #firrtl<name_kind droppable_name>} : () -> !firrtl.uint<1>\r\ninliner-perfield-nocheck.mlir:5:10: note: see existing inner symbol definition here\r\n    %b = firrtl.wire sym [<@b,1,public>] : !firrtl.bundle<a: uint<1>, b: uint<1>>\r\n```", "code_snippet_01": "firrtl.circuit \"CollidingSymbolsFields\" {\r\n  hw.hierpath private @nla1 [@CollidingSymbolsFields::@foo, @Foo::@bar, @Bar]\r\n  firrtl.module @Bar() attributes {annotations = [{circt.nonlocal = @nla1, class = \"nla1\"}]} {}\r\n  firrtl.module @Foo() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n    %b = firrtl.wire sym [<@b,1,public>] : !firrtl.bundle<a: uint<1>, b: uint<1>>\r\n    firrtl.instance bar sym @bar @Bar()\r\n  }\r\n  firrtl.module @CollidingSymbolsFields() {\r\n    firrtl.instance foo sym @foo @Foo()\r\n    %collision_b = firrtl.wire sym @b : !firrtl.uint<1>\r\n    %collision_bar = firrtl.wire sym [<@bar,1,public>] : !firrtl.bundle<a: uint<1>, b: uint<1>>\r\n  }\r\n}", "code_snippet_02": "inliner-perfield-nocheck.mlir:10:20: error: redefinition of inner symbol named 'b'\r\n    %collision_b = firrtl.wire sym @b : !firrtl.uint<1>\r\n                   ^\r\ninliner-perfield-nocheck.mlir:10:20: note: see current operation: %1 = \"firrtl.wire\"() {annotations = [], inner_sym = #hw<innerSym@b>, name = \"collision_b\", nameKind = #firrtl<name_kind droppable_name>} : () -> !firrtl.uint<1>\r\ninliner-perfield-nocheck.mlir:5:10: note: see existing inner symbol definition here\r\n    %b = firrtl.wire sym [<@b,1,public>] : !firrtl.bundle<a: uint<1>, b: uint<1>>"}, {"number": 5592, "title": "[FIRRTL][LowerTypes] Memory with symbols blindly drops symbol, spawns new ones?", "created_at": "2023-07-14T18:14:11Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Code path not under test, should probably be an error (?).\r\n\r\nInput:\r\n```\r\nfirrtl.circuit \"Mem2\" {\r\n  firrtl.module @Mem2(in %clock: !firrtl.clock, in %rAddr: !firrtl.uint<4>, in %rEn: !firrtl.uint<1>, out %rData: !firrtl.bundle<a: uint<8>, b: uint<8>>, in %wAddr: !firrtl.uint<4>, in %wEn: !firrtl.uint<1>, in %wMask: !firrtl.bundle<a: uint<1>, b: uint<1>>, in %wData: !firrtl.bundle<a: uint<8>, b: uint<8>>) {\r\n    %memory_r, %memory_w = firrtl.mem sym @X Undefined {depth = 16 : i64, name = \"memory\", portNames = [\"r\", \"w\"], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>, !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>\r\n    %0 = firrtl.subfield %memory_r[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>\r\n    firrtl.connect %0, %clock : !firrtl.clock, !firrtl.clock\r\n    %1 = firrtl.subfield %memory_r[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>\r\n    firrtl.connect %1, %rEn : !firrtl.uint<1>, !firrtl.uint<1>\r\n    %2 = firrtl.subfield %memory_r[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>\r\n    firrtl.connect %2, %rAddr : !firrtl.uint<4>, !firrtl.uint<4>\r\n    %3 = firrtl.subfield %memory_r[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>\r\n    firrtl.connect %rData, %3 : !firrtl.bundle<a: uint<8>, b: uint<8>>, !firrtl.bundle<a: uint<8>, b: uint<8>>\r\n    %4 = firrtl.subfield %memory_w[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>\r\n    firrtl.connect %4, %clock : !firrtl.clock, !firrtl.clock\r\n    %5 = firrtl.subfield %memory_w[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>\r\n    firrtl.connect %5, %wEn : !firrtl.uint<1>, !firrtl.uint<1>\r\n    %6 = firrtl.subfield %memory_w[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>\r\n    firrtl.connect %6, %wAddr : !firrtl.uint<4>, !firrtl.uint<4>\r\n    %7 = firrtl.subfield %memory_w[mask] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>\r\n    firrtl.connect %7, %wMask : !firrtl.bundle<a: uint<1>, b: uint<1>>, !firrtl.bundle<a: uint<1>, b: uint<1>>\r\n    %8 = firrtl.subfield %memory_w[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>\r\n    firrtl.connect %8, %wData : !firrtl.bundle<a: uint<8>, b: uint<8>>, !firrtl.bundle<a: uint<8>, b: uint<8>>\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@Mem2::@X>]}\r\n}\r\n```\r\n\r\n(Verbatim as generic inner-sym user that would be broken by this behavior)\r\n\r\nRunning through ` circt-opt --firrtl-lower-types memsym.mlir` produces the following invalid IR (not caught by verified presently but it should):\r\n\r\n```\r\nmodule {\r\n  firrtl.circuit \"Mem2\" {\r\n    firrtl.module @Mem2(in %clock: !firrtl.clock, in %rAddr: !firrtl.uint<4>, in %rEn: !firrtl.uint<1>, out %rData_a: !firrtl.uint<8>, out %rData_b: !firrtl.uint<8>, in %wAddr: !firrtl.uint<4>, in %wEn: !firrtl.uint<1>, in %wMask_a: !firrtl.uint<1>, in %wMask_b: !firrtl.uint<1>, in %wData_a: !firrtl.uint<8>, in %wData_b: !firrtl.uint<8>) {\r\n      %memory_r_addr = firrtl.wire : !firrtl.uint<4>\r\n      %memory_r_en = firrtl.wire : !firrtl.uint<1>\r\n      %memory_r_clk = firrtl.wire : !firrtl.clock\r\n      %memory_r_data_a = firrtl.wire : !firrtl.uint<8>\r\n      %memory_r_data_b = firrtl.wire : !firrtl.uint<8>\r\n      %memory_w_addr = firrtl.wire : !firrtl.uint<4>\r\n      %memory_w_en = firrtl.wire : !firrtl.uint<1>\r\n      %memory_w_clk = firrtl.wire : !firrtl.clock\r\n      %memory_w_data_a = firrtl.wire : !firrtl.uint<8>\r\n      %memory_w_data_b = firrtl.wire : !firrtl.uint<8>\r\n      %memory_w_mask_a = firrtl.wire : !firrtl.uint<1>\r\n      %memory_w_mask_b = firrtl.wire : !firrtl.uint<1>\r\n      %memory_a_r, %memory_a_w = firrtl.mem sym @Xmemory_a Undefined {depth = 16 : i64, name = \"memory_a\", portNames = [\"r\", \"w\"], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>, !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      %memory_b_r, %memory_b_w = firrtl.mem sym @Xmemory_b Undefined {depth = 16 : i64, name = \"memory_b\", portNames = [\"r\", \"w\"], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>, !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      %0 = firrtl.subfield %memory_a_r[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %0, %memory_r_addr : !firrtl.uint<4>\r\n      %1 = firrtl.subfield %memory_b_r[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %1, %memory_r_addr : !firrtl.uint<4>\r\n      %2 = firrtl.subfield %memory_a_r[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %2, %memory_r_en : !firrtl.uint<1>\r\n      %3 = firrtl.subfield %memory_b_r[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %3, %memory_r_en : !firrtl.uint<1>\r\n      %4 = firrtl.subfield %memory_a_r[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %4, %memory_r_clk : !firrtl.clock\r\n      %5 = firrtl.subfield %memory_b_r[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %5, %memory_r_clk : !firrtl.clock\r\n      %6 = firrtl.subfield %memory_a_r[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %memory_r_data_a, %6 : !firrtl.uint<8>\r\n      %7 = firrtl.subfield %memory_b_r[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %memory_r_data_b, %7 : !firrtl.uint<8>\r\n      %8 = firrtl.subfield %memory_a_w[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %8, %memory_w_addr : !firrtl.uint<4>\r\n      %9 = firrtl.subfield %memory_b_w[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %9, %memory_w_addr : !firrtl.uint<4>\r\n      %10 = firrtl.subfield %memory_a_w[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %10, %memory_w_en : !firrtl.uint<1>\r\n      %11 = firrtl.subfield %memory_b_w[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %11, %memory_w_en : !firrtl.uint<1>\r\n      %12 = firrtl.subfield %memory_a_w[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %12, %memory_w_clk : !firrtl.clock\r\n      %13 = firrtl.subfield %memory_b_w[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %13, %memory_w_clk : !firrtl.clock\r\n      %14 = firrtl.subfield %memory_a_w[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %14, %memory_w_data_a : !firrtl.uint<8>\r\n      %15 = firrtl.subfield %memory_b_w[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %15, %memory_w_data_b : !firrtl.uint<8>\r\n      %16 = firrtl.subfield %memory_a_w[mask] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %16, %memory_w_mask_a : !firrtl.uint<1>\r\n      %17 = firrtl.subfield %memory_b_w[mask] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %17, %memory_w_mask_b : !firrtl.uint<1>\r\n      firrtl.connect %memory_r_clk, %clock : !firrtl.clock, !firrtl.clock\r\n      firrtl.connect %memory_r_en, %rEn : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %memory_r_addr, %rAddr : !firrtl.uint<4>, !firrtl.uint<4>\r\n      firrtl.strictconnect %rData_a, %memory_r_data_a : !firrtl.uint<8>\r\n      firrtl.strictconnect %rData_b, %memory_r_data_b : !firrtl.uint<8>\r\n      firrtl.connect %memory_w_clk, %clock : !firrtl.clock, !firrtl.clock\r\n      firrtl.connect %memory_w_en, %wEn : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %memory_w_addr, %wAddr : !firrtl.uint<4>, !firrtl.uint<4>\r\n      firrtl.strictconnect %memory_w_mask_a, %wMask_a : !firrtl.uint<1>\r\n      firrtl.strictconnect %memory_w_mask_b, %wMask_b : !firrtl.uint<1>\r\n      firrtl.strictconnect %memory_w_data_a, %wData_a : !firrtl.uint<8>\r\n      firrtl.strictconnect %memory_w_data_b, %wData_b : !firrtl.uint<8>\r\n    }\r\n    sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@Mem2::@X>]}\r\n  }\r\n}\r\n```\r\n\r\nCode: https://github.com/llvm/circt/blob/db3918a3797ae1a9e066468b63a052a3678a51f1/lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp#L279 .", "code_snippet_01": "firrtl.circuit \"Mem2\" {\r\n  firrtl.module @Mem2(in %clock: !firrtl.clock, in %rAddr: !firrtl.uint<4>, in %rEn: !firrtl.uint<1>, out %rData: !firrtl.bundle<a: uint<8>, b: uint<8>>, in %wAddr: !firrtl.uint<4>, in %wEn: !firrtl.uint<1>, in %wMask: !firrtl.bundle<a: uint<1>, b: uint<1>>, in %wData: !firrtl.bundle<a: uint<8>, b: uint<8>>) {\r\n    %memory_r, %memory_w = firrtl.mem sym @X Undefined {depth = 16 : i64, name = \"memory\", portNames = [\"r\", \"w\"], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>, !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>\r\n    %0 = firrtl.subfield %memory_r[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>\r\n    firrtl.connect %0, %clock : !firrtl.clock, !firrtl.clock\r\n    %1 = firrtl.subfield %memory_r[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>\r\n    firrtl.connect %1, %rEn : !firrtl.uint<1>, !firrtl.uint<1>\r\n    %2 = firrtl.subfield %memory_r[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>\r\n    firrtl.connect %2, %rAddr : !firrtl.uint<4>, !firrtl.uint<4>\r\n    %3 = firrtl.subfield %memory_r[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: bundle<a: uint<8>, b: uint<8>>>\r\n    firrtl.connect %rData, %3 : !firrtl.bundle<a: uint<8>, b: uint<8>>, !firrtl.bundle<a: uint<8>, b: uint<8>>\r\n    %4 = firrtl.subfield %memory_w[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>\r\n    firrtl.connect %4, %clock : !firrtl.clock, !firrtl.clock\r\n    %5 = firrtl.subfield %memory_w[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>\r\n    firrtl.connect %5, %wEn : !firrtl.uint<1>, !firrtl.uint<1>\r\n    %6 = firrtl.subfield %memory_w[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>\r\n    firrtl.connect %6, %wAddr : !firrtl.uint<4>, !firrtl.uint<4>\r\n    %7 = firrtl.subfield %memory_w[mask] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>\r\n    firrtl.connect %7, %wMask : !firrtl.bundle<a: uint<1>, b: uint<1>>, !firrtl.bundle<a: uint<1>, b: uint<1>>\r\n    %8 = firrtl.subfield %memory_w[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: bundle<a: uint<8>, b: uint<8>>, mask: bundle<a: uint<1>, b: uint<1>>>\r\n    firrtl.connect %8, %wData : !firrtl.bundle<a: uint<8>, b: uint<8>>, !firrtl.bundle<a: uint<8>, b: uint<8>>\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@Mem2::@X>]}\r\n}", "code_snippet_02": "module {\r\n  firrtl.circuit \"Mem2\" {\r\n    firrtl.module @Mem2(in %clock: !firrtl.clock, in %rAddr: !firrtl.uint<4>, in %rEn: !firrtl.uint<1>, out %rData_a: !firrtl.uint<8>, out %rData_b: !firrtl.uint<8>, in %wAddr: !firrtl.uint<4>, in %wEn: !firrtl.uint<1>, in %wMask_a: !firrtl.uint<1>, in %wMask_b: !firrtl.uint<1>, in %wData_a: !firrtl.uint<8>, in %wData_b: !firrtl.uint<8>) {\r\n      %memory_r_addr = firrtl.wire : !firrtl.uint<4>\r\n      %memory_r_en = firrtl.wire : !firrtl.uint<1>\r\n      %memory_r_clk = firrtl.wire : !firrtl.clock\r\n      %memory_r_data_a = firrtl.wire : !firrtl.uint<8>\r\n      %memory_r_data_b = firrtl.wire : !firrtl.uint<8>\r\n      %memory_w_addr = firrtl.wire : !firrtl.uint<4>\r\n      %memory_w_en = firrtl.wire : !firrtl.uint<1>\r\n      %memory_w_clk = firrtl.wire : !firrtl.clock\r\n      %memory_w_data_a = firrtl.wire : !firrtl.uint<8>\r\n      %memory_w_data_b = firrtl.wire : !firrtl.uint<8>\r\n      %memory_w_mask_a = firrtl.wire : !firrtl.uint<1>\r\n      %memory_w_mask_b = firrtl.wire : !firrtl.uint<1>\r\n      %memory_a_r, %memory_a_w = firrtl.mem sym @Xmemory_a Undefined {depth = 16 : i64, name = \"memory_a\", portNames = [\"r\", \"w\"], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>, !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      %memory_b_r, %memory_b_w = firrtl.mem sym @Xmemory_b Undefined {depth = 16 : i64, name = \"memory_b\", portNames = [\"r\", \"w\"], readLatency = 0 : i32, writeLatency = 1 : i32} : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>, !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      %0 = firrtl.subfield %memory_a_r[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %0, %memory_r_addr : !firrtl.uint<4>\r\n      %1 = firrtl.subfield %memory_b_r[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %1, %memory_r_addr : !firrtl.uint<4>\r\n      %2 = firrtl.subfield %memory_a_r[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %2, %memory_r_en : !firrtl.uint<1>\r\n      %3 = firrtl.subfield %memory_b_r[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %3, %memory_r_en : !firrtl.uint<1>\r\n      %4 = firrtl.subfield %memory_a_r[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %4, %memory_r_clk : !firrtl.clock\r\n      %5 = firrtl.subfield %memory_b_r[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %5, %memory_r_clk : !firrtl.clock\r\n      %6 = firrtl.subfield %memory_a_r[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %memory_r_data_a, %6 : !firrtl.uint<8>\r\n      %7 = firrtl.subfield %memory_b_r[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data flip: uint<8>>\r\n      firrtl.strictconnect %memory_r_data_b, %7 : !firrtl.uint<8>\r\n      %8 = firrtl.subfield %memory_a_w[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %8, %memory_w_addr : !firrtl.uint<4>\r\n      %9 = firrtl.subfield %memory_b_w[addr] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %9, %memory_w_addr : !firrtl.uint<4>\r\n      %10 = firrtl.subfield %memory_a_w[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %10, %memory_w_en : !firrtl.uint<1>\r\n      %11 = firrtl.subfield %memory_b_w[en] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %11, %memory_w_en : !firrtl.uint<1>\r\n      %12 = firrtl.subfield %memory_a_w[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %12, %memory_w_clk : !firrtl.clock\r\n      %13 = firrtl.subfield %memory_b_w[clk] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %13, %memory_w_clk : !firrtl.clock\r\n      %14 = firrtl.subfield %memory_a_w[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %14, %memory_w_data_a : !firrtl.uint<8>\r\n      %15 = firrtl.subfield %memory_b_w[data] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %15, %memory_w_data_b : !firrtl.uint<8>\r\n      %16 = firrtl.subfield %memory_a_w[mask] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %16, %memory_w_mask_a : !firrtl.uint<1>\r\n      %17 = firrtl.subfield %memory_b_w[mask] : !firrtl.bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>\r\n      firrtl.strictconnect %17, %memory_w_mask_b : !firrtl.uint<1>\r\n      firrtl.connect %memory_r_clk, %clock : !firrtl.clock, !firrtl.clock\r\n      firrtl.connect %memory_r_en, %rEn : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %memory_r_addr, %rAddr : !firrtl.uint<4>, !firrtl.uint<4>\r\n      firrtl.strictconnect %rData_a, %memory_r_data_a : !firrtl.uint<8>\r\n      firrtl.strictconnect %rData_b, %memory_r_data_b : !firrtl.uint<8>\r\n      firrtl.connect %memory_w_clk, %clock : !firrtl.clock, !firrtl.clock\r\n      firrtl.connect %memory_w_en, %wEn : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %memory_w_addr, %wAddr : !firrtl.uint<4>, !firrtl.uint<4>\r\n      firrtl.strictconnect %memory_w_mask_a, %wMask_a : !firrtl.uint<1>\r\n      firrtl.strictconnect %memory_w_mask_b, %wMask_b : !firrtl.uint<1>\r\n      firrtl.strictconnect %memory_w_data_a, %wData_a : !firrtl.uint<8>\r\n      firrtl.strictconnect %memory_w_data_b, %wData_b : !firrtl.uint<8>\r\n    }\r\n    sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@Mem2::@X>]}\r\n  }\r\n}"}, {"number": 5590, "title": "[FIRRTL][LowerToHW] Zero-width signals with inner symbol are silently deleted, breaking users", "created_at": "2023-07-14T17:16:38Z", "state": "open", "labels": "bug, FIRRTL", "body": "Consider this MLIR example:\r\n\r\n```\r\nmodule {\r\n  firrtl.circuit \"OMIRField\" {\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0>, out %y_b: !firrtl.uint<0>) {\r\n      %n_b = firrtl.node sym @omir_sym %x_b : !firrtl.uint<0>\r\n      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>\r\n    }\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n}\r\n```\r\n\r\nFeeding through LowerToHW: `circt-opt --lower-firrtl-to-hw` produces:\r\n\r\n```\r\nmodule {\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n  hw.module @OMIRField() {\r\n    hw.output\r\n  }\r\n}\r\n```\r\n\r\nAnd if run through `firtool` directly, produces:\r\n```\r\nomir_zw_field_issue.mlir:8:3: error: cannot get name for symbol #hw.innerNameRef<@OMIRField::@omir_sym>\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n  ^\r\nomir_zw_field_issue.mlir:8:3: note: see current operation: \"sv.verbatim\"() {format_string = \"Testing {{0}}\", symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]} : () -> ()\r\n// Generated by CIRCT 1.46.0g20230714_98d0bf5\r\nTesting <INVALID>\t// omir_zw_field_issue.mlir:8:3\r\nmodule OMIRField();\t// omir_zw_field_issue.mlir:3:5\r\nendmodule\r\n```\r\n\r\nThe non-failing error isn't great and should be fixed (cc #4770 for similar in adjacent code).\r\nAlso, this should be caught by the verifier in HW but that support isn't in place yet (cc #3526).\r\n\r\n---\r\n\r\nMoving the symbol to a port produces an error, modified input:\r\n\r\n```\r\nmodule {\r\n  firrtl.circuit \"OMIRField\" {\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {\r\n      %n_b = firrtl.node %x_b : !firrtl.uint<0>\r\n      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>\r\n    }\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n}\r\n```\r\n\r\nError:\r\n```\r\nomir_zw_field_issue.mlir:3:33: error: zero width port \"x_b\" is referenced by name [#hw<innerSym@omir_sym>] (e.g. in an XMR) but must be removed\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {\r\n                                ^\r\n```", "code_snippet_01": "module {\r\n  firrtl.circuit \"OMIRField\" {\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0>, out %y_b: !firrtl.uint<0>) {\r\n      %n_b = firrtl.node sym @omir_sym %x_b : !firrtl.uint<0>\r\n      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>\r\n    }\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n}", "code_snippet_02": "module {\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n  hw.module @OMIRField() {\r\n    hw.output\r\n  }\r\n}", "code_snippet_03": "omir_zw_field_issue.mlir:8:3: error: cannot get name for symbol #hw.innerNameRef<@OMIRField::@omir_sym>\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n  ^\r\nomir_zw_field_issue.mlir:8:3: note: see current operation: \"sv.verbatim\"() {format_string = \"Testing {{0}}\", symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]} : () -> ()\r\n// Generated by CIRCT 1.46.0g20230714_98d0bf5\r\nTesting <INVALID>\t// omir_zw_field_issue.mlir:8:3\r\nmodule OMIRField();\t// omir_zw_field_issue.mlir:3:5\r\nendmodule", "code_snippet_04": "module {\r\n  firrtl.circuit \"OMIRField\" {\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {\r\n      %n_b = firrtl.node %x_b : !firrtl.uint<0>\r\n      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>\r\n    }\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n}", "code_snippet_05": "omir_zw_field_issue.mlir:3:33: error: zero width port \"x_b\" is referenced by name [#hw<innerSym@omir_sym>] (e.g. in an XMR) but must be removed\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {\r\n                                ^"}, {"number": 5566, "title": "[SV] Crash in `P/BPAssignOp` verifiers for `hw.inout` ports", "created_at": "2023-07-12T07:32:39Z", "state": "open", "labels": "bug, good first issue, Verilog/SystemVerilog", "body": "[In the SV `P/BPAssignOp` verifiers](https://github.com/llvm/circt/blob/main/lib/Dialect/SV/SVOps.cpp#L1142-L1156) it is assumed that the target argument is defined by an op (`isa` used on `getDefiningOp`). Hence, in the case of a `hw.inout` input port, the verifier crashes.\r\n\r\ni.e.:\r\n```mlir\r\nhw.module @unsupported(%a: !hw.inout<i42>) {\r\n  %clock = hw.constant 1 : i1\r\n  %c42 = hw.constant 42 : i42\r\n  sv.alwaysff(posedge %clock) {\r\n    sv.passign %a, %c42 : i42\r\n  }\r\n}\r\n```\r\n\r\n", "code_snippet_01": "hw.module @unsupported(%a: !hw.inout<i42>) {\r\n  %clock = hw.constant 1 : i1\r\n  %c42 = hw.constant 42 : i42\r\n  sv.alwaysff(posedge %clock) {\r\n    sv.passign %a, %c42 : i42\r\n  }\r\n}"}, {"number": 5562, "title": "[FIRRTL][LowerToHW] An uninstantiated module can crash LowerToHW", "created_at": "2023-07-10T23:17:06Z", "state": "open", "labels": "bug, FIRRTL", "body": "I came across the following failure. The problem occurs if a module which is not under the main module in the instance graph includes reference type ports:\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo() {}\r\n  firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.probe<uint<1>>) {\r\n    %0 = firrtl.ref.send %a : !firrtl.uint<1>\r\n    firrtl.ref.define %b, %0 : !firrtl.probe<uint<1>>\r\n  }\r\n}\r\n```\r\n\r\nThe failure trips an assert in `LowerToHW` [here](https://github.com/llvm/circt/blob/main/lib/Conversion/FIRRTLToHW/LowerToHW.cpp#L2337):\r\n\r\n```\r\nAssertion failed: ((!result || !isa<FIRRTLType>(result.getType())) && \"Lowering didn't turn a FIRRTL value into a non-FIRRTL value\"), function setLowering, file LowerToHW.cpp, line 2338.\r\n```", "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo() {}\r\n  firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.probe<uint<1>>) {\r\n    %0 = firrtl.ref.send %a : !firrtl.uint<1>\r\n    firrtl.ref.define %b, %0 : !firrtl.probe<uint<1>>\r\n  }\r\n}", "code_snippet_02": "Assertion failed: ((!result || !isa<FIRRTLType>(result.getType())) && \"Lowering didn't turn a FIRRTL value into a non-FIRRTL value\"), function setLowering, file LowerToHW.cpp, line 2338."}, {"number": 5552, "title": "[FIRRTL] handle zero-width deletion: rwprobe/forceable, force+friends", "created_at": "2023-07-07T18:16:27Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Consider:\r\n\r\n```\r\ncircuit Foo:\r\n  module Foo:\r\n    wire x : UInt<0>\r\n    x <= UInt(0)\r\n    force_initial(rwprobe(x), UInt<0>(0))\r\n```\r\n\r\nPresently this dies in LowerToHW.  Presently LowerXMR is responsible for examining all ref uses and dropping if zero-width, so bug (I think) is LowerXMR preserving the force operation and keeps declarations forceable.", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    wire x : UInt<0>\r\n    x <= UInt(0)\r\n    force_initial(rwprobe(x), UInt<0>(0))"}, {"number": 5524, "title": "[FIRRTL] AndCvtU canonicalization crash, wrong result (when widths aren't same)", "created_at": "2023-06-30T05:09:45Z", "state": "closed", "labels": "bug, FIRRTL", "body": "```\r\ncircuit Top:\r\n  module Top:\r\n    input x: UInt<1>\r\n    output out: UInt<2>\r\n    out <= and(cvt(x), SInt<4>(2))\r\n```\r\n\r\n```\r\n[firtool] Running \"firrtl.module(canonicalize{  max-iterations=10 max-num-rewrites=-1 region-simplify=false test-convergence=false top-down=true},firrtl-infer-rw)\"\r\nfirtool: /scratch/hidetou/circt/llvm/llvm/lib/Support/APInt.cpp:973: llvm::APInt llvm::APInt::zext(unsigned int) const: Assertion `width >= BitWidth && \"Invalid APInt ZeroExtend request\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\n #0 0x0000000000450677 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x000000000044e800 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x0000000000450f8f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007f56ed87acf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)\r\n #4 0x00007f56ec705aff raise (/lib64/libc.so.6+0x4eaff)\r\n #5 0x00007f56ec6d8ea5 abort (/lib64/libc.so.6+0x21ea5)\r\n #6 0x00007f56ec6d8d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)\r\n #7 0x00007f56ec6fe456 (/lib64/libc.so.6+0x47456)\r\n #8 0x000000000045becf (/scratch/hidetou/circt/build/bin/firtool+0x45becf)\r\n #9 0x000000000088652f circt::firrtl::patterns::AndCvtU::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/FIRRTL/FIRRTLCanonicalization.h.inc:0:167\r\n#10 0x0000000000b03131 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>)::$\r\n```", "code_snippet_01": "circuit Top:\r\n  module Top:\r\n    input x: UInt<1>\r\n    output out: UInt<2>\r\n    out <= and(cvt(x), SInt<4>(2))", "code_snippet_02": "[firtool] Running \"firrtl.module(canonicalize{  max-iterations=10 max-num-rewrites=-1 region-simplify=false test-convergence=false top-down=true},firrtl-infer-rw)\"\r\nfirtool: /scratch/hidetou/circt/llvm/llvm/lib/Support/APInt.cpp:973: llvm::APInt llvm::APInt::zext(unsigned int) const: Assertion `width >= BitWidth && \"Invalid APInt ZeroExtend request\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\n #0 0x0000000000450677 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x000000000044e800 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x0000000000450f8f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007f56ed87acf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)\r\n #4 0x00007f56ec705aff raise (/lib64/libc.so.6+0x4eaff)\r\n #5 0x00007f56ec6d8ea5 abort (/lib64/libc.so.6+0x21ea5)\r\n #6 0x00007f56ec6d8d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)\r\n #7 0x00007f56ec6fe456 (/lib64/libc.so.6+0x47456)\r\n #8 0x000000000045becf (/scratch/hidetou/circt/build/bin/firtool+0x45becf)\r\n #9 0x000000000088652f circt::firrtl::patterns::AndCvtU::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/FIRRTL/FIRRTLCanonicalization.h.inc:0:167\r\n#10 0x0000000000b03131 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>)::$"}, {"number": 5506, "title": "[FIRRTL] Bundle-of-alias crashes", "created_at": "2023-06-28T14:09:55Z", "state": "closed", "labels": "bug, FIRRTL", "body": "```\r\ncircuit AliasBundle:\r\n  type Foo = { a : UInt<1> }\r\n  type Bar = { a : Foo }\r\n  module AliasBundle:\r\n     input b : Bar\r\n```\r\n\r\nWhich crashes presently, in InferWidths, in debug builds, reporting unsupported type encountered (Alias).", "code_snippet_01": "circuit AliasBundle:\r\n  type Foo = { a : UInt<1> }\r\n  type Bar = { a : Foo }\r\n  module AliasBundle:\r\n     input b : Bar"}, {"number": 5494, "title": "[FIRRTL] Crash parsing agg-of-properties or non-FieldIDTypeInterface", "created_at": "2023-06-27T16:09:03Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Sample input:\r\n\r\n```firrtl\r\ncircuit BundleOfProps:\r\n  module BundleOfProps:\r\n    input x : {a : String}\r\n```\r\n\r\nWe require all elements of aggregates to also be FieldIDTypeInterface's, should be verifier and/or checked when parsing.\r\n\r\nPresently the above crashes.", "code_snippet_01": "circuit BundleOfProps:\r\n  module BundleOfProps:\r\n    input x : {a : String}"}, {"number": 5483, "title": "[ExportVerilog] Missing `hw.struct_explode` support?", "created_at": "2023-06-26T22:23:43Z", "state": "open", "labels": "bug, HW", "body": "Running `circt-opt <file.mlir> --export-verilog` with `file.mlir` having the following content:\r\n```mlir\r\nmodule {\r\n  hw.module @EXPLODE(%0: i64, %1: i64) -> (arg1: i64, arg2: i64) {\r\n    %2 = hw.struct_create (%0, %1) : !hw.struct<arg1: i64, arg2: i64>\r\n    %arg1, %arg2 = hw.struct_explode %2 : !hw.struct<arg1: i64, arg2: i64>\r\n\r\n    hw.output %arg1, %arg2 : i64, i64\r\n  }\r\n}\r\n```\r\ntriggers the following assertion:\r\n```\r\ncirct-opt: circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:3295:\r\nvoid (anonymous namespace)::NameCollector::collectNames(mlir::Block &): \r\nAssertion `(!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options))\r\n && \"If 'op' is a verilog expression, the expression must be inlinable. \" \r\n \"Otherwise, it is a bug of PrepareForEmission\"' failed.\r\n```\r\n\r\nThis seems to be strongly related to the `hw.struct_explode` operation, because replacing it with `hw.struct_extract` ops works just fine.\r\n\r\n(Yes, I know that in this case, the canonicalizer would optimize `hw.struct_create` and `hw.struct_explode` away. But this is the smallest example that I could come up with to reproduce the bug.)", "code_snippet_01": "module {\r\n  hw.module @EXPLODE(%0: i64, %1: i64) -> (arg1: i64, arg2: i64) {\r\n    %2 = hw.struct_create (%0, %1) : !hw.struct<arg1: i64, arg2: i64>\r\n    %arg1, %arg2 = hw.struct_explode %2 : !hw.struct<arg1: i64, arg2: i64>\r\n\r\n    hw.output %arg1, %arg2 : i64, i64\r\n  }\r\n}", "code_snippet_02": "circt-opt: circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:3295:\r\nvoid (anonymous namespace)::NameCollector::collectNames(mlir::Block &): \r\nAssertion `(!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options))\r\n && \"If 'op' is a verilog expression, the expression must be inlinable. \" \r\n \"Otherwise, it is a bug of PrepareForEmission\"' failed."}, {"number": 5462, "title": "[FIRRTL][CheckCombCycles] Missed cycles, sensitive to presence of node?", "created_at": "2023-06-22T23:52:10Z", "state": "open", "labels": "bug, FIRRTL", "body": "Input, `--preserve-aggregate=all`:\r\n\r\n```firrtl\r\ncircuit Loop:\r\n  module Loop:\r\n    wire w : {a: UInt<8>}\r\n    node n = w\r\n    w <= n\r\n```\r\n\r\nFor some reason the node is needed for this to be missed (?).\r\n\r\nThis was reduced from slightly more complicated interprocedural inputs like:\r\n\r\n```firrtl\r\ncircuit Loop:\r\n  module Child:\r\n    input bundle : { a : UInt<1>, b : UInt<1> }\r\n    output p : {a : UInt<1>, b : UInt<1> }\r\n\r\n    node n = bundle\r\n\r\n    p <= n\r\n  module Loop:\r\n    input x : UInt<1>\r\n\r\n    inst c of Child\r\n    c.bundle.a <= x\r\n    c.bundle.b <= c.p.b\r\n```\r\n\r\n----\r\n\r\nDoes not appear to be limited to cycles entirely unreachable/disconnected from the rest of the design/ports, FWIW, consider:\r\n\r\n```firrtl\r\ncircuit Loop:\r\n  module Loop:\r\n    input in : {a: UInt<8>}\r\n    output out : {a: UInt<8>}\r\n    input c : UInt<1>\r\n\r\n    wire w : {a: UInt<8>}\r\n    node n = w\r\n    w <= mux(c, n, in)\r\n\r\n    out <= w\r\n```", "code_snippet_01": "circuit Loop:\r\n  module Loop:\r\n    wire w : {a: UInt<8>}\r\n    node n = w\r\n    w <= n", "code_snippet_02": "circuit Loop:\r\n  module Child:\r\n    input bundle : { a : UInt<1>, b : UInt<1> }\r\n    output p : {a : UInt<1>, b : UInt<1> }\r\n\r\n    node n = bundle\r\n\r\n    p <= n\r\n  module Loop:\r\n    input x : UInt<1>\r\n\r\n    inst c of Child\r\n    c.bundle.a <= x\r\n    c.bundle.b <= c.p.b", "code_snippet_03": "circuit Loop:\r\n  module Loop:\r\n    input in : {a: UInt<8>}\r\n    output out : {a: UInt<8>}\r\n    input c : UInt<1>\r\n\r\n    wire w : {a: UInt<8>}\r\n    node n = w\r\n    w <= mux(c, n, in)\r\n\r\n    out <= w"}, {"number": 5447, "title": "[FIRRTL][InferWidths] Make checkCycles Iterative", "created_at": "2023-06-21T15:58:20Z", "state": "open", "labels": "bug, FIRRTL", "body": "The method `InferWidths::checkCycles` is currently recursive. If `firtool` is spawned in a thread which has an abnormally low stack size (i.e., on MacOS running Chisel tests using Scalatest), this can result in stack overflows. Fix this method to make it recursive. This is similar to https://github.com/llvm/circt/pull/5305."}, {"number": 5391, "title": "[FIRRTL] Width inference bug as of 1.40.0", "created_at": "2023-06-13T14:15:35Z", "state": "closed", "labels": "bug, FIRRTL, infer width", "body": "Input:\r\n\r\n```firrtl\r\ncircuit Widths:\r\n  module Widths:\r\n    input x : UInt<1>\r\n    input y : UInt<2>\r\n    output out1 : UInt\r\n    output out2 : UInt\r\n\r\n    wire w : UInt\r\n    w <= x\r\n    w <= y\r\n\r\n    out1 <= w\r\n\r\n    wire wx : UInt\r\n    wx <= x\r\n\r\n    out2 <= wx\r\n```\r\n\r\nfirtool:\r\n\r\n```systemverilog\r\n// Generated by CIRCT firtool-1.43.0-53-g60763f2c0\r\nmodule Widths(\r\n  input        x,\r\n  input  [1:0] y,\r\n  output [1:0] out1,\r\n               out2\r\n);\r\n\r\n  assign out1 = y;\r\n  assign out2 = {1'h0, x};\r\nendmodule\r\n```\r\n\r\nNote that `wx` / `out2` are inferred to have width 2 instead of the expected 1.\r\n\r\nfirtool 1.39.0 infers this correctly: (1.40.0 does not-- first release w/uninferred width cast FWIW)\r\n```systemverilog\r\n// Generated by CIRCT firtool-1.39.0\r\nmodule Widths(\r\n  input        x,\r\n  input  [1:0] y,\r\n  output [1:0] out1,\r\n  output       out2\r\n);\r\n\r\n  assign out1 = y;\r\n  assign out2 = x;\r\nendmodule\r\n```", "code_snippet_01": "circuit Widths:\r\n  module Widths:\r\n    input x : UInt<1>\r\n    input y : UInt<2>\r\n    output out1 : UInt\r\n    output out2 : UInt\r\n\r\n    wire w : UInt\r\n    w <= x\r\n    w <= y\r\n\r\n    out1 <= w\r\n\r\n    wire wx : UInt\r\n    wx <= x\r\n\r\n    out2 <= wx", "code_snippet_02": "// Generated by CIRCT firtool-1.43.0-53-g60763f2c0\r\nmodule Widths(\r\n  input        x,\r\n  input  [1:0] y,\r\n  output [1:0] out1,\r\n               out2\r\n);\r\n\r\n  assign out1 = y;\r\n  assign out2 = {1'h0, x};\r\nendmodule", "code_snippet_03": "// Generated by CIRCT firtool-1.39.0\r\nmodule Widths(\r\n  input        x,\r\n  input  [1:0] y,\r\n  output [1:0] out1,\r\n  output       out2\r\n);\r\n\r\n  assign out1 = y;\r\n  assign out2 = x;\r\nendmodule"}, {"number": 5355, "title": "[HWLegalizeModules] Legalize array concat op", "created_at": "2023-06-10T10:18:04Z", "state": "open", "labels": "bug, HW", "body": "Support hw.array_concat in HWLegalizeModules\r\n```mlir\r\n$ ./build/bin/firtool perf/regress/chipyard.TestHarness.RocketSmall1Medium1Big1_BoomMedium1Large1Mega1.top.v.hi.fir -o foo.sv --lowering-options=disallowLocalVariables,disallowPackedArrays\r\nArbiters.scala:42:16: error: unsupported packed array expression\r\nArbiters.scala:42:16: note: see current operation: %57 = \"hw.array_concat\"(%3, %56) : (!hw.array<3xi1>, !hw.array<5xi1>) -> !hw.array<8xi1>\r\n```\r\n", "code_snippet_01": "$ ./build/bin/firtool perf/regress/chipyard.TestHarness.RocketSmall1Medium1Big1_BoomMedium1Large1Mega1.top.v.hi.fir -o foo.sv --lowering-options=disallowLocalVariables,disallowPackedArrays\r\nArbiters.scala:42:16: error: unsupported packed array expression\r\nArbiters.scala:42:16: note: see current operation: %57 = \"hw.array_concat\"(%3, %56) : (!hw.array<3xi1>, !hw.array<5xi1>) -> !hw.array<8xi1>"}, {"number": 5333, "title": "[FIRRTL] infer resets doesn't work with const-cast of aggregates", "created_at": "2023-06-07T14:52:37Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Input:\r\n\r\n```\r\nmodule {\r\n  firrtl.circuit \"ConstReset\" {\r\n    firrtl.module @ConstReset(in %in: !firrtl.const.bundle<a: reset, b: uint<1>>, out %out: !firrtl.bundle<a: asyncreset>, out %out2: !firrtl.bundle<a: reset, b: uint<1>>) {\r\n      %out_a = firrtl.subfield %out[a] : !firrtl.bundle<a: asyncreset>\r\n      %in_a = firrtl.subfield %in[a] : !firrtl.const.bundle<a: reset, b: uint<1>>\r\n      %in_a_asyncreset = firrtl.resetCast %in_a : (!firrtl.const.reset) -> !firrtl.const.asyncreset\r\n      %in_a_asyncreset_noconst = firrtl.constCast %in_a_asyncreset : (!firrtl.const.asyncreset) -> !firrtl.asyncreset\r\n      firrtl.strictconnect %out_a, %in_a_asyncreset_noconst : !firrtl.asyncreset\r\n\r\n      %in_noconst = firrtl.constCast %in : (!firrtl.const.bundle<a: reset, b: uint<1>>) -> !firrtl.bundle<a: reset, b : uint<1>>\r\n      firrtl.strictconnect %out2, %in_noconst : !firrtl.bundle<a: reset, b: uint<1>>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nLooks like InferResets only updates the constcast types if they're ground reset types?\r\n\r\nError after InferResets:\r\n\r\n```\r\n$ ./build/bin/firtool const-reset.mlir --mlir-print-ir-before=firrtl-infer-resets\r\n// -----// IR Dump Before InferResets (firrtl-infer-resets) //----- //\r\nfirrtl.circuit \"ConstReset\" {\r\n  firrtl.module @ConstReset(in %in: !firrtl.const.bundle<a: reset, b: uint<1>>, out %out: !firrtl.bundle<a: asyncreset>, out %out2: !firrtl.bundle<a: reset, b: uint<1>>) {\r\n    %0 = firrtl.subfield %out[a] : !firrtl.bundle<a: asyncreset>\r\n    %1 = firrtl.subfield %in[a] : !firrtl.const.bundle<a: reset, b: uint<1>>\r\n    %2 = firrtl.resetCast %1 : (!firrtl.const.reset) -> !firrtl.const.asyncreset\r\n    %3 = firrtl.constCast %2 : (!firrtl.const.asyncreset) -> !firrtl.asyncreset\r\n    firrtl.strictconnect %0, %3 : !firrtl.asyncreset\r\n    %4 = firrtl.constCast %in : (!firrtl.const.bundle<a: reset, b: uint<1>>) -> !firrtl.bundle<a: reset, b: uint<1>>\r\n    firrtl.strictconnect %out2, %4 : !firrtl.bundle<a: reset, b: uint<1>>\r\n  }\r\n}\r\n\r\nconst-reset.mlir:10:21: error: 'firrtl.constCast' op '!firrtl.const.bundle<a: asyncreset, b: uint<1>>' is not 'const'-castable to '!firrtl.bundle<a: reset, b: uint<1>>'\r\n      %in_noconst = firrtl.constCast %in : (!firrtl.const.bundle<a: reset, b: uint<1>>) -> !firrtl.bundle<a: reset, b : uint<1>>\r\n                    ^\r\nconst-reset.mlir:10:21: note: see current operation: %3 = \"firrtl.constCast\"(%arg0) : (!firrtl.const.bundle<a: asyncreset, b: uint<1>>) -> !firrtl.bundle<a: reset, b: uint<1>>\r\n```", "code_snippet_01": "module {\r\n  firrtl.circuit \"ConstReset\" {\r\n    firrtl.module @ConstReset(in %in: !firrtl.const.bundle<a: reset, b: uint<1>>, out %out: !firrtl.bundle<a: asyncreset>, out %out2: !firrtl.bundle<a: reset, b: uint<1>>) {\r\n      %out_a = firrtl.subfield %out[a] : !firrtl.bundle<a: asyncreset>\r\n      %in_a = firrtl.subfield %in[a] : !firrtl.const.bundle<a: reset, b: uint<1>>\r\n      %in_a_asyncreset = firrtl.resetCast %in_a : (!firrtl.const.reset) -> !firrtl.const.asyncreset\r\n      %in_a_asyncreset_noconst = firrtl.constCast %in_a_asyncreset : (!firrtl.const.asyncreset) -> !firrtl.asyncreset\r\n      firrtl.strictconnect %out_a, %in_a_asyncreset_noconst : !firrtl.asyncreset\r\n\r\n      %in_noconst = firrtl.constCast %in : (!firrtl.const.bundle<a: reset, b: uint<1>>) -> !firrtl.bundle<a: reset, b : uint<1>>\r\n      firrtl.strictconnect %out2, %in_noconst : !firrtl.bundle<a: reset, b: uint<1>>\r\n    }\r\n  }\r\n}", "code_snippet_02": "$ ./build/bin/firtool const-reset.mlir --mlir-print-ir-before=firrtl-infer-resets\r\n// -----// IR Dump Before InferResets (firrtl-infer-resets) //----- //\r\nfirrtl.circuit \"ConstReset\" {\r\n  firrtl.module @ConstReset(in %in: !firrtl.const.bundle<a: reset, b: uint<1>>, out %out: !firrtl.bundle<a: asyncreset>, out %out2: !firrtl.bundle<a: reset, b: uint<1>>) {\r\n    %0 = firrtl.subfield %out[a] : !firrtl.bundle<a: asyncreset>\r\n    %1 = firrtl.subfield %in[a] : !firrtl.const.bundle<a: reset, b: uint<1>>\r\n    %2 = firrtl.resetCast %1 : (!firrtl.const.reset) -> !firrtl.const.asyncreset\r\n    %3 = firrtl.constCast %2 : (!firrtl.const.asyncreset) -> !firrtl.asyncreset\r\n    firrtl.strictconnect %0, %3 : !firrtl.asyncreset\r\n    %4 = firrtl.constCast %in : (!firrtl.const.bundle<a: reset, b: uint<1>>) -> !firrtl.bundle<a: reset, b: uint<1>>\r\n    firrtl.strictconnect %out2, %4 : !firrtl.bundle<a: reset, b: uint<1>>\r\n  }\r\n}\r\n\r\nconst-reset.mlir:10:21: error: 'firrtl.constCast' op '!firrtl.const.bundle<a: asyncreset, b: uint<1>>' is not 'const'-castable to '!firrtl.bundle<a: reset, b: uint<1>>'\r\n      %in_noconst = firrtl.constCast %in : (!firrtl.const.bundle<a: reset, b: uint<1>>) -> !firrtl.bundle<a: reset, b : uint<1>>\r\n                    ^\r\nconst-reset.mlir:10:21: note: see current operation: %3 = \"firrtl.constCast\"(%arg0) : (!firrtl.const.bundle<a: asyncreset, b: uint<1>>) -> !firrtl.bundle<a: reset, b: uint<1>>"}, {"number": 5324, "title": "[FIRRTL] crash, need getFieldName (and friends?) support for enums", "created_at": "2023-06-06T22:10:53Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Following input crashes due to getFieldName not being supported (used to report error in InferWidths):\r\n\r\n```firrtl\r\ncircuit NoWidthEnum:\r\n  module NoWidthEnum:\r\n    output o : {| Some : UInt, None |}\r\n```\r\n\r\n", "code_snippet_01": "circuit NoWidthEnum:\r\n  module NoWidthEnum:\r\n    output o : {| Some : UInt, None |}"}, {"number": 5322, "title": "[FIRRTL] Assertion failure parsing input connecting compatible (?) enums of different width inferred-ness", "created_at": "2023-06-06T20:17:16Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Input:\r\n\r\n```firrtl\r\ncircuit EnumWidths:\r\n  module EnumWidths:\r\n    input i : {| Some : UInt<8>, None |}\r\n    input i2 : {| Some : UInt, None |}\r\n    output o : {| Some : UInt, None |}\r\n    output o2 : {| Some : UInt<8>, None |}\r\n    o <= i\r\n    o2 <= i2\r\n```\r\n\r\nEither connection causes an assertion failure during parsing (as of 6ff3acee7):\r\n\r\n```\r\nfirtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::detail::TypedValue<circt::firrtl::IntType>, From = mlir::OpResult]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool ./enum-widths.fir\r\n #0 0x000055778c477435 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x000055778c475550 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x000055778c477aad SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007f22f9308d60 __restore_rt (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x38d60)\r\n #4 0x00007f22f9357adc __pthread_kill_implementation (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x87adc)\r\n #5 0x00007f22f9308cb6 gsignal (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x38cb6)\r\n #6 0x00007f22f92f28ba abort (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x228ba)\r\n #7 0x00007f22f92f27d9 _nl_load_domain.cold (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x227d9)\r\n #8 0x00007f22f93019c6 (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x319c6)\r\n #9 0x000055778ca660c4 circt::firrtl::emitConnect(mlir::ImplicitLocOpBuilder&, mlir::Value, mlir::Value) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLUtils.cpp:134:3\r\n#10 0x000055778c4e1b89 (anonymous namespace)::FIRStmtParser::parseLeadingExpStmt(mlir::Value) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:0:5\r\n#11 0x000055778c4db18e (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:0:0\r\n#12 0x000055778c4dab35 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2111:17\r\n#13 0x000055778c4dab35 (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2104:9\r\n#14 0x000055778c4da5df mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#15 0x000055778c4da5df mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#16 0x000055778c4da5df (anonymous namespace)::FIRCircuitParser::parseModuleBody((anonymous namespace)::FIRCircuitParser::DeferredModuleToParse&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4077:7\r\n#17 0x000055778c4da5df (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14::operator()(unsigned long) const /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4237:13\r\n#18 0x000055778c4d5b01 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#19 0x000055778c4d5b01 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#20 0x000055778c4d5b01 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:11\r\n#21 0x000055778c4d5b01 mlir::LogicalResult mlir::failableParallelForEach<llvm::iota_range<unsigned long>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14>(mlir::MLIRContext*, llvm::iota_range<unsigned long>&&, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#22 0x000055778c4d5b01 mlir::LogicalResult mlir::failableParallelForEachN<(anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14>(mlir::MLIRContext*, unsigned long, unsigned long, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:107:10\r\n#23 0x000055778c4d5b01 (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4235:20\r\n#24 0x000055778c4d5b01 circt::firrtl::importFIRFile(llvm::SourceMgr&, mlir::MLIRContext*, mlir::TimingScope&, circt::firrtl::FIRParserOptions) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4305:12\r\n#25 0x000055778c3cbb62 std::enable_if<__and_<std::__not_<std::__is_tuple_like<mlir::ModuleOp>>, std::is_move_constructible<mlir::ModuleOp>, std::is_move_assignable<mlir::ModuleOp>>::value, void>::type std::swap<mlir::ModuleOp>(mlir::ModuleOp&, mlir::ModuleOp&) /nix/store/aafdki1nf49k5vxq6gx2yabiybk2bjmw-gcc-12.2.0/include/c++/12.2.0/bits/move.h:205:11\r\n#26 0x000055778c3cbb62 mlir::OwningOpRef<mlir::ModuleOp>::release() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OwningOpRef.h:68:5\r\n#27 0x000055778c3cbb62 mlir::OwningOpRef<mlir::ModuleOp>::operator=(mlir::OwningOpRef<mlir::ModuleOp>&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OwningOpRef.h:45:16\r\n#28 0x000055778c3cbb62 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:286:12\r\n#29 0x000055778c3cb56f processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:452:12\r\n#30 0x000055778c3cb105 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:468:12\r\n#31 0x000055778c3cb105 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:552:14\r\n#32 0x000055778c3cace6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#33 0x000055778c3cace6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#34 0x000055778c3cace6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:616:8\r\n#35 0x00007f22f92f3ace __libc_start_call_main (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x23ace)\r\n#36 0x00007f22f92f3b89 __libc_start_main@GLIBC_2.2.5 (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x23b89)\r\n#37 0x000055778c3cab15 _start (./build/bin/firtool+0x50db15)\r\nzsh: IOT instruction (core dumped)  ./build/bin/firtool ./enum-widths.fir\r\n```", "code_snippet_01": "circuit EnumWidths:\r\n  module EnumWidths:\r\n    input i : {| Some : UInt<8>, None |}\r\n    input i2 : {| Some : UInt, None |}\r\n    output o : {| Some : UInt, None |}\r\n    output o2 : {| Some : UInt<8>, None |}\r\n    o <= i\r\n    o2 <= i2", "code_snippet_02": "firtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::detail::TypedValue<circt::firrtl::IntType>, From = mlir::OpResult]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool ./enum-widths.fir\r\n #0 0x000055778c477435 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x000055778c475550 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x000055778c477aad SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007f22f9308d60 __restore_rt (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x38d60)\r\n #4 0x00007f22f9357adc __pthread_kill_implementation (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x87adc)\r\n #5 0x00007f22f9308cb6 gsignal (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x38cb6)\r\n #6 0x00007f22f92f28ba abort (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x228ba)\r\n #7 0x00007f22f92f27d9 _nl_load_domain.cold (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x227d9)\r\n #8 0x00007f22f93019c6 (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x319c6)\r\n #9 0x000055778ca660c4 circt::firrtl::emitConnect(mlir::ImplicitLocOpBuilder&, mlir::Value, mlir::Value) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLUtils.cpp:134:3\r\n#10 0x000055778c4e1b89 (anonymous namespace)::FIRStmtParser::parseLeadingExpStmt(mlir::Value) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:0:5\r\n#11 0x000055778c4db18e (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:0:0\r\n#12 0x000055778c4dab35 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2111:17\r\n#13 0x000055778c4dab35 (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2104:9\r\n#14 0x000055778c4da5df mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#15 0x000055778c4da5df mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#16 0x000055778c4da5df (anonymous namespace)::FIRCircuitParser::parseModuleBody((anonymous namespace)::FIRCircuitParser::DeferredModuleToParse&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4077:7\r\n#17 0x000055778c4da5df (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14::operator()(unsigned long) const /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4237:13\r\n#18 0x000055778c4d5b01 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#19 0x000055778c4d5b01 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#20 0x000055778c4d5b01 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:11\r\n#21 0x000055778c4d5b01 mlir::LogicalResult mlir::failableParallelForEach<llvm::iota_range<unsigned long>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14>(mlir::MLIRContext*, llvm::iota_range<unsigned long>&&, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#22 0x000055778c4d5b01 mlir::LogicalResult mlir::failableParallelForEachN<(anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14>(mlir::MLIRContext*, unsigned long, unsigned long, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&)::$_14&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:107:10\r\n#23 0x000055778c4d5b01 (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, llvm::SmallVectorImpl<llvm::MemoryBuffer const*>&, mlir::TimingScope&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4235:20\r\n#24 0x000055778c4d5b01 circt::firrtl::importFIRFile(llvm::SourceMgr&, mlir::MLIRContext*, mlir::TimingScope&, circt::firrtl::FIRParserOptions) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:4305:12\r\n#25 0x000055778c3cbb62 std::enable_if<__and_<std::__not_<std::__is_tuple_like<mlir::ModuleOp>>, std::is_move_constructible<mlir::ModuleOp>, std::is_move_assignable<mlir::ModuleOp>>::value, void>::type std::swap<mlir::ModuleOp>(mlir::ModuleOp&, mlir::ModuleOp&) /nix/store/aafdki1nf49k5vxq6gx2yabiybk2bjmw-gcc-12.2.0/include/c++/12.2.0/bits/move.h:205:11\r\n#26 0x000055778c3cbb62 mlir::OwningOpRef<mlir::ModuleOp>::release() /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OwningOpRef.h:68:5\r\n#27 0x000055778c3cbb62 mlir::OwningOpRef<mlir::ModuleOp>::operator=(mlir::OwningOpRef<mlir::ModuleOp>&&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OwningOpRef.h:45:16\r\n#28 0x000055778c3cbb62 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:286:12\r\n#29 0x000055778c3cb56f processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:452:12\r\n#30 0x000055778c3cb105 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile>>>&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:468:12\r\n#31 0x000055778c3cb105 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:552:14\r\n#32 0x000055778c3cace6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#33 0x000055778c3cace6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#34 0x000055778c3cace6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:616:8\r\n#35 0x00007f22f92f3ace __libc_start_call_main (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x23ace)\r\n#36 0x00007f22f92f3b89 __libc_start_main@GLIBC_2.2.5 (/nix/store/1n2l5law9g3b77hcfyp50vrhhssbrj5g-glibc-2.37-8/lib/libc.so.6+0x23b89)\r\n#37 0x000055778c3cab15 _start (./build/bin/firtool+0x50db15)\r\nzsh: IOT instruction (core dumped)  ./build/bin/firtool ./enum-widths.fir"}, {"number": 5312, "title": "[Pipeline] Valgrind/ASAN error in StageSeparatorToStage", "created_at": "2023-06-05T15:05:35Z", "state": "closed", "labels": "bug, Pipeline", "body": "<details>\r\n<summary>From Nightly CI -- valgrind report</summary>\r\n\r\nhttps://github.com/llvm/circt/actions/runs/5176839396/jobs/9326172211:\r\n```\r\nFAIL: CIRCT :: Dialect/Pipeline/Transforms/stagesep-to-stages.mlir (423 of 535)\r\n******************** TEST 'CIRCT :: Dialect/Pipeline/Transforms/stagesep-to-stages.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 1';   /__w/circt/circt/build/bin/circt-opt -pass-pipeline='builtin.module(hw.module(pipeline.pipeline(pipeline-stagesep-to-stage)))' /__w/circt/circt/test/Dialect/Pipeline/Transforms/stagesep-to-stages.mlir | /__w/circt/circt/build/bin/FileCheck /__w/circt/circt/test/Dialect/Pipeline/Transforms/stagesep-to-stages.mlir\r\n--\r\nExit Code: 123\r\n\r\nCommand Output (stderr):\r\n--\r\n==12804== Thread 2 llvm-worker-0:\r\n==12804== Invalid read of size 1\r\n==12804==    at 0x14D6B13: circt::pipeline::StageSeparatingRegOp::getInputs() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDD8F: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD75E1: llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Address 0x6a5282e is 94 bytes inside a block of size 224 free'd\r\n==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Block was alloc'd at\r\n==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804== \r\n==12804== Invalid read of size 4\r\n==12804==    at 0x14D6B19: circt::pipeline::StageSeparatingRegOp::getInputs() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDD8F: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD75E1: llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Address 0x6a52844 is 116 bytes inside a block of size 224 free'd\r\n==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Block was alloc'd at\r\n==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804== \r\n==12804== Invalid read of size 8\r\n==12804==    at 0x14D6B1C: circt::pipeline::StageSeparatingRegOp::getInputs() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDD8F: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD75E1: llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Address 0x6a52848 is 120 bytes inside a block of size 224 free'd\r\n==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Block was alloc'd at\r\n==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804== \r\n==12804== Invalid read of size 8\r\n==12804==    at 0x16CF019: mlir::detail::OperandStorage::setOperands(mlir::Operation*, unsigned int, unsigned int, mlir::ValueRange) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14D2E46: circt::pipeline::StageReturnOp::setOperands(mlir::Value, mlir::ValueRange, mlir::ValueRange) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDDE0: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Address 0x6a52868 is 152 bytes inside a block of size 224 free'd\r\n==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Block was alloc'd at\r\n==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804== \r\n\r\n--\r\n```\r\n</details>", "code_snippet_01": "FAIL: CIRCT :: Dialect/Pipeline/Transforms/stagesep-to-stages.mlir (423 of 535)\r\n******************** TEST 'CIRCT :: Dialect/Pipeline/Transforms/stagesep-to-stages.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 1';   /__w/circt/circt/build/bin/circt-opt -pass-pipeline='builtin.module(hw.module(pipeline.pipeline(pipeline-stagesep-to-stage)))' /__w/circt/circt/test/Dialect/Pipeline/Transforms/stagesep-to-stages.mlir | /__w/circt/circt/build/bin/FileCheck /__w/circt/circt/test/Dialect/Pipeline/Transforms/stagesep-to-stages.mlir\r\n--\r\nExit Code: 123\r\n\r\nCommand Output (stderr):\r\n--\r\n==12804== Thread 2 llvm-worker-0:\r\n==12804== Invalid read of size 1\r\n==12804==    at 0x14D6B13: circt::pipeline::StageSeparatingRegOp::getInputs() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDD8F: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD75E1: llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Address 0x6a5282e is 94 bytes inside a block of size 224 free'd\r\n==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Block was alloc'd at\r\n==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804== \r\n==12804== Invalid read of size 4\r\n==12804==    at 0x14D6B19: circt::pipeline::StageSeparatingRegOp::getInputs() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDD8F: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD75E1: llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Address 0x6a52844 is 116 bytes inside a block of size 224 free'd\r\n==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Block was alloc'd at\r\n==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804== \r\n==12804== Invalid read of size 8\r\n==12804==    at 0x14D6B1C: circt::pipeline::StageSeparatingRegOp::getInputs() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDD8F: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD75E1: llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Address 0x6a52848 is 120 bytes inside a block of size 224 free'd\r\n==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Block was alloc'd at\r\n==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804== \r\n==12804== Invalid read of size 8\r\n==12804==    at 0x16CF019: mlir::detail::OperandStorage::setOperands(mlir::Operation*, unsigned int, unsigned int, mlir::ValueRange) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14D2E46: circt::pipeline::StageReturnOp::setOperands(mlir::Value, mlir::ValueRange, mlir::ValueRange) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDDE0: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Address 0x6a52868 is 152 bytes inside a block of size 224 free'd\r\n==12804==    at 0x483CA3F: free (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16CC4D9: llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14EDAEA: (anonymous namespace)::StageSeparatorToStagePass::runOnOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D933AB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D9522A: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D934CB: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D93B11: mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D993CF: mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D994CE: std::_Function_handler<void (), mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0xCD2FAB: std::_Function_handler<void (), llvm::ThreadPool::createTaskAndFuture(std::function<void ()>)::{lambda()#1}>::_M_invoke(std::_Any_data const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==  Block was alloc'd at\r\n==12804==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)\r\n==12804==    by 0x16C441E: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::BlockRange, unsigned int) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3FE6: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::NamedAttrList&&, mlir::OpaqueProperties, mlir::BlockRange, mlir::RegionRange) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x16C3EA3: mlir::Operation::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x163656F: mlir::OpBuilder::create(mlir::OperationState const&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D926: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D69148: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D6671A: (anonymous namespace)::OperationParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D64A98: (anonymous namespace)::CustomOpAsmParser::parseRegion(mlir::Region&, llvm::ArrayRef<mlir::OpAsmParser::Argument>, bool) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x14D394A: circt::pipeline::PipelineOp::parse(mlir::OpAsmParser&, mlir::OperationState&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D5D76D: (anonymous namespace)::OperationParser::parseOperation() (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804==    by 0x1D68F70: (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) (in /__w/circt/circt/build/bin/circt-opt)\r\n==12804== \r\n\r\n--"}, {"number": 5284, "title": "[DependenceAnalysis] Analysis indiscriminately gathers loop nests", "created_at": "2023-05-26T21:33:33Z", "state": "closed", "labels": "bug, Scheduling", "body": "Within `MemoryDependenceAnalysis`, I think the affine analysis API is being misused given a certain type of input IR. Initially, the memory ops within a function are gathered:\r\n\r\nhttps://github.com/llvm/circt/blob/e5312a24e51a6027e936de00287c17f33380c797/lib/Analysis/DependenceAnalysis.cpp#L136-L140\r\n\r\nThis becomes a problem one step deeper in the call stack at `checkMemrefAccessDependence()`, because the memory ops `src` and `dst` have not been separated by the loop nesting they belong to.\r\nhttps://github.com/llvm/circt/blob/e5312a24e51a6027e936de00287c17f33380c797/lib/Analysis/DependenceAnalysis.cpp#L47-L48\r\n\r\nThe code gets confused because the other memory op in the dependence is not in the same nesting, and it throws the error I think being seen in #4814.\r\n\r\nThis becomes a problem as soon as there are nests of `affine.for` in parallel like such:\r\n```\r\naffine.for %arg2 = 0 to 270 {\r\n  affine.for %arg3 = 0 to 474 {\r\n    affine.for %arg4 = 0 to 7 {\r\n      ...\r\n}}}\r\naffine.for %arg2 = 0 to 270 {\r\n  affine.for %arg3 = 0 to 474 {\r\n    affine.for %arg4 = 0 to 7 {\r\n      ...\r\n}}}\r\n```", "code_snippet_01": "affine.for %arg2 = 0 to 270 {\r\n  affine.for %arg3 = 0 to 474 {\r\n    affine.for %arg4 = 0 to 7 {\r\n      ...\r\n}}}\r\naffine.for %arg2 = 0 to 270 {\r\n  affine.for %arg3 = 0 to 474 {\r\n    affine.for %arg4 = 0 to 7 {\r\n      ...\r\n}}}"}, {"number": 5242, "title": "ESI Cosim CMakeLists.txt updates not compatible with older CMake versions", "created_at": "2023-05-22T19:16:27Z", "state": "closed", "labels": "bug, ESI", "body": "It looks like https://github.com/llvm/circt/commit/f0bfdf6c79a128db85af362395f28544a303fd59 added the use of `FILE_SET` to some ESI Cosim related CMakeLists.txt files.\r\n\r\nThis feature appears to have been added to the `target_sources` and `install` CMake commands in version 3.23: https://cmake.org/cmake/help/latest/command/target_sources.html#file-sets.\r\n\r\nBut we only declare a minimum CMake version of 3.13: https://github.com/llvm/circt/blob/c7100bed69631f6ee4849c1e0a5f73d4aa926c15/CMakeLists.txt#L7\r\n\r\nLooks like we are using CMake 3.23 in CI, so this wasn't caught. I noticed because I happen to use 3.22 locally, and build with ESI Cosim enabled. Can we either make the CMakeLists.txt compatible with the declared minimum CMake version, or bump that minimum?\r\n\r\nCMake 3.23 is fairly recent, but I guess we could consider requiring a newer version. That might cause friction on users who will need to install a newer CMake than their platform's default to use CIRCT, so I think it might be preferable to achieve the goal without use of `FILE_SET`.\r\n\r\n@teqdruid what do you think?"}, {"number": 5231, "title": "[ExportVerilog] Indenting/formatting wrong after macro def", "created_at": "2023-05-19T16:09:25Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Input:\r\n\r\n```\r\nsv.macro.decl @TEST_COND\r\n\r\nhw.module @TestCond() {\r\n  sv.ifdef \"TEST_COND_\" {\r\n   sv.macro.def @TEST_COND \"TEST_COND_\"\r\n  } else {\r\n   sv.macro.def @TEST_COND \"1\"\r\n  }\r\n  hw.output\r\n}\r\n```\r\n\r\nCurrent output:\r\n\r\n```\r\n// Generated by CIRCT 1.42.0g20230517_6043aa4\r\nmodule TestCond();\t// macro.mlir:3:1\r\n  `ifdef TEST_COND_\t// macro.mlir:4:3\r\n    `define TEST_COND TEST_COND_\r\n    `else  // TEST_COND_\r\n    `define TEST_COND 1\r\n    `endif // TEST_COND_\r\nendmodule\r\n```\r\n\r\nShould be:\r\n```\r\nmodule TestCond();\t// macro.mlir:3:1\r\n  `ifdef TEST_COND_\t// macro.mlir:4:3\r\n    `define TEST_COND TEST_COND_\r\n  `else  // TEST_COND_\r\n    `define TEST_COND 1\r\n  `endif // TEST_COND_\r\nendmodule\r\n```", "code_snippet_01": "sv.macro.decl @TEST_COND\r\n\r\nhw.module @TestCond() {\r\n  sv.ifdef \"TEST_COND_\" {\r\n   sv.macro.def @TEST_COND \"TEST_COND_\"\r\n  } else {\r\n   sv.macro.def @TEST_COND \"1\"\r\n  }\r\n  hw.output\r\n}", "code_snippet_02": "// Generated by CIRCT 1.42.0g20230517_6043aa4\r\nmodule TestCond();\t// macro.mlir:3:1\r\n  `ifdef TEST_COND_\t// macro.mlir:4:3\r\n    `define TEST_COND TEST_COND_\r\n    `else  // TEST_COND_\r\n    `define TEST_COND 1\r\n    `endif // TEST_COND_\r\nendmodule", "code_snippet_03": "module TestCond();\t// macro.mlir:3:1\r\n  `ifdef TEST_COND_\t// macro.mlir:4:3\r\n    `define TEST_COND TEST_COND_\r\n  `else  // TEST_COND_\r\n    `define TEST_COND 1\r\n  `endif // TEST_COND_\r\nendmodule"}, {"number": 5205, "title": "[FIRRTL] Exporter prints invalid probe of constant (, inline expressions?)", "created_at": "2023-05-16T15:34:54Z", "state": "open", "labels": "bug, FIRRTL", "body": "Cannot probe inline expressions, probe target must be a static reference to a declaration (in current spec anyway).\r\n\r\nConsider:\r\n\r\n```mlir\r\nfirrtl.circuit \"ProbeConstant\" {\r\n  firrtl.module @ProbeConstant(out %bore: !firrtl.probe<uint<1>>) {\r\n    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1> {name = \"internalWire\"}\r\n    %0 = firrtl.ref.send %c0_ui1 : !firrtl.uint<1>\r\n    firrtl.ref.define %bore, %0 : !firrtl.probe<uint<1>>\r\n  }\r\n}\r\n```\r\n\r\nWhich becomes:\r\n\r\n```firrtl\r\ncircuit ProbeConstant :\r\n  module ProbeConstant :\r\n    output bore : Probe<UInt<1>>\r\n\r\n    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]\r\n```\r\n\r\nWhich is invalid and does not parse:\r\n\r\n```\r\n<stdin>:5:25: error: use of unknown declaration 'UInt'\r\n    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]\r\n```\r\n\r\nNot sure what approach works best with Exporter, but strategies such as giving expression a name with a node (or wire if non-passive) would give something to probe.", "code_snippet_01": "firrtl.circuit \"ProbeConstant\" {\r\n  firrtl.module @ProbeConstant(out %bore: !firrtl.probe<uint<1>>) {\r\n    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1> {name = \"internalWire\"}\r\n    %0 = firrtl.ref.send %c0_ui1 : !firrtl.uint<1>\r\n    firrtl.ref.define %bore, %0 : !firrtl.probe<uint<1>>\r\n  }\r\n}", "code_snippet_02": "circuit ProbeConstant :\r\n  module ProbeConstant :\r\n    output bore : Probe<UInt<1>>\r\n\r\n    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]", "code_snippet_03": "<stdin>:5:25: error: use of unknown declaration 'UInt'\r\n    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]"}, {"number": 5204, "title": "[FIRRTL] Register with Self Connection Crashes Exporter", "created_at": "2023-05-16T02:21:20Z", "state": "open", "labels": "bug, FIRRTL", "body": "Consider the following FIRRTL Dialect:\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(in %clock: !firrtl.clock, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>\r\n    %0 = firrtl.wire : !firrtl.uint<1>\r\n    %r = firrtl.regreset interesting_name %clock, %c1_ui1, %0 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.strictconnect %0, %r : !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nThis produces a nice crash in the exporter (`circt-translate -export-firrtl Bar.mlir`):\r\n\r\n```\r\nAssertion failed: (!s->text().empty() && \"empty string token\"), function operator(), file PrettyPrinter.cpp, line 91.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: circt-translate -export-firrtl Bar.mlir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  circt-translate          0x00000001079167ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  circt-translate          0x0000000107916d5b PrintStackTraceSignalHandler(void*) + 27\r\n2  circt-translate          0x0000000107914896 llvm::sys::RunSignalHandlers() + 134\r\n3  circt-translate          0x0000000107918b8f SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff81820c5ed _sigtramp + 29\r\n5  libsystem_platform.dylib 0x00007ff7b877dd20 _sigtramp + 18446744072104646480\r\n6  libsystem_c.dylib        0x00007ff818105b45 abort + 123\r\n7  libsystem_c.dylib        0x00007ff818104e5e err + 0\r\n8  circt-translate          0x0000000108746000 circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1::operator()(circt::pretty::StringToken*) const + 176\r\n9  circt-translate          0x0000000108745ee8 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::TypeSwitch<circt::pretty::Token*, void>::Case<circt::pretty::StringToken, circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 88\r\n10 circt-translate          0x0000000108744af5 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<circt::pretty::Token*, void>, circt::pretty::Token*>::Case<circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 53\r\n11 circt-translate          0x0000000108744a03 circt::pretty::PrettyPrinter::add(circt::pretty::Token) + 99\r\n12 circt-translate          0x000000010819d235 std::__1::enable_if<std::is_base_of_v<circt::pretty::Token, circt::pretty::StringToken>, void>::type circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::add<circt::pretty::StringToken, llvm::StringRef&>(llvm::StringRef&) + 101\r\n13 circt-translate          0x000000010819d1c1 circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::literal(llvm::StringRef) + 33\r\n14 circt-translate          0x000000010819c118 circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::operator<<(circt::pretty::PPExtString const&) + 56\r\n15 circt-translate          0x00000001081c2fa8 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5::operator()() const + 104\r\n16 circt-translate          0x00000001081c2f35 decltype(static_cast<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(fp)()) std::__1::__invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 21\r\n17 circt-translate          0x00000001081c2e5d std::__1::invoke_result<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>::type std::__1::invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 29\r\n18 circt-translate          0x00000001081c2d96 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(circt::pretty::PP&&, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&, circt::pretty::Token) + 102\r\n19 circt-translate          0x00000001081c2d13 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp) + 179\r\n20 circt-translate          0x00000001081c2808 auto (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16::operator()<circt::firrtl::WireOp>(circt::firrtl::WireOp) const + 40\r\n21 circt-translate          0x00000001081c278b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::WireOp, (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&>((anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&) + 107\r\n22 circt-translate          0x000000010819ea0d (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&) + 365\r\n23 circt-translate          0x000000010819e669 (anonymous namespace)::Emitter::emitModule(circt::firrtl::FModuleOp)::$_1::operator()() const + 217\r\n```", "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(in %clock: !firrtl.clock, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>\r\n    %0 = firrtl.wire : !firrtl.uint<1>\r\n    %r = firrtl.regreset interesting_name %clock, %c1_ui1, %0 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.strictconnect %0, %r : !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_02": "Assertion failed: (!s->text().empty() && \"empty string token\"), function operator(), file PrettyPrinter.cpp, line 91.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: circt-translate -export-firrtl Bar.mlir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  circt-translate          0x00000001079167ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  circt-translate          0x0000000107916d5b PrintStackTraceSignalHandler(void*) + 27\r\n2  circt-translate          0x0000000107914896 llvm::sys::RunSignalHandlers() + 134\r\n3  circt-translate          0x0000000107918b8f SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff81820c5ed _sigtramp + 29\r\n5  libsystem_platform.dylib 0x00007ff7b877dd20 _sigtramp + 18446744072104646480\r\n6  libsystem_c.dylib        0x00007ff818105b45 abort + 123\r\n7  libsystem_c.dylib        0x00007ff818104e5e err + 0\r\n8  circt-translate          0x0000000108746000 circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1::operator()(circt::pretty::StringToken*) const + 176\r\n9  circt-translate          0x0000000108745ee8 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::TypeSwitch<circt::pretty::Token*, void>::Case<circt::pretty::StringToken, circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 88\r\n10 circt-translate          0x0000000108744af5 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<circt::pretty::Token*, void>, circt::pretty::Token*>::Case<circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 53\r\n11 circt-translate          0x0000000108744a03 circt::pretty::PrettyPrinter::add(circt::pretty::Token) + 99\r\n12 circt-translate          0x000000010819d235 std::__1::enable_if<std::is_base_of_v<circt::pretty::Token, circt::pretty::StringToken>, void>::type circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::add<circt::pretty::StringToken, llvm::StringRef&>(llvm::StringRef&) + 101\r\n13 circt-translate          0x000000010819d1c1 circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::literal(llvm::StringRef) + 33\r\n14 circt-translate          0x000000010819c118 circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::operator<<(circt::pretty::PPExtString const&) + 56\r\n15 circt-translate          0x00000001081c2fa8 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5::operator()() const + 104\r\n16 circt-translate          0x00000001081c2f35 decltype(static_cast<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(fp)()) std::__1::__invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 21\r\n17 circt-translate          0x00000001081c2e5d std::__1::invoke_result<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>::type std::__1::invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 29\r\n18 circt-translate          0x00000001081c2d96 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(circt::pretty::PP&&, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&, circt::pretty::Token) + 102\r\n19 circt-translate          0x00000001081c2d13 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp) + 179\r\n20 circt-translate          0x00000001081c2808 auto (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16::operator()<circt::firrtl::WireOp>(circt::firrtl::WireOp) const + 40\r\n21 circt-translate          0x00000001081c278b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::WireOp, (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&>((anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&) + 107\r\n22 circt-translate          0x000000010819ea0d (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&) + 365\r\n23 circt-translate          0x000000010819e669 (anonymous namespace)::Emitter::emitModule(circt::firrtl::FModuleOp)::$_1::operator()() const + 217"}, {"number": 5202, "title": "[FIRRTL] Incorrect Register Parsing", "created_at": "2023-05-15T21:22:04Z", "state": "open", "labels": "bug, FIRRTL", "body": "The FIRRTL parser uses the reset initial value being the reset as a shorthand for \"this is a reset-less register\". However, it only narrowly means that if the reset signal is `UInt<1>(0)`. Consider the following:\r\n\r\n```\r\ncircuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    reg r: UInt<1>, clock with: (reset => (UInt<1>(1), r))\r\n\r\n    r <= a\r\n    b <= r\r\n```\r\n\r\nThis register never exits an indeterminate state and can be optimized to some constant. CIRCT currently thinks this is a reset-less register:\r\n\r\n```verilog\r\nmodule Foo(\r\n  input  clock,\r\n         a,\r\n  output b\r\n);\r\n\r\n  reg r;\r\n  always @(posedge clock)\r\n    r <= a;\r\n  assign b = r;\r\nendmodule\r\n```\r\n\r\nSFC will produce:\r\n```verilog\r\nmodule Foo(\r\n  input   clock,\r\n  input   a,\r\n  output  b\r\n);\r\n  assign b = 1'h0;\r\nendmodule\r\n```\r\n\r\nNote: this code is impossible to emit from Chisel due to limitations of how it works.", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    reg r: UInt<1>, clock with: (reset => (UInt<1>(1), r))\r\n\r\n    r <= a\r\n    b <= r", "code_snippet_02": "module Foo(\r\n  input  clock,\r\n         a,\r\n  output b\r\n);\r\n\r\n  reg r;\r\n  always @(posedge clock)\r\n    r <= a;\r\n  assign b = r;\r\nendmodule", "code_snippet_03": "module Foo(\r\n  input   clock,\r\n  input   a,\r\n  output  b\r\n);\r\n  assign b = 1'h0;\r\nendmodule"}, {"number": 5031, "title": "[scf-to-calyx] Mark `cf` operations illegal", "created_at": "2023-04-13T16:30:52Z", "state": "open", "labels": "bug, Calyx", "body": "Hi! I just posted on the #circt channel on discord about a model I had that I tried to pass to CIRCT to lower to Calyx via `-lower-scf-to-calyx`. It seems like it takes a few hours at least, and sometime just crashes my machine - which is very strange, since the model is pretty simple with mostly arithmetic operations and 163 if statements that are represented with conditional branches (they were `scf.if` statements, but converted to `cf` with [convert-scf-to-cf](https://mlir.llvm.org/docs/Passes/#-convert-scf-to-cf-convert-scf-dialect-to-controlflow-dialect-replacing-structured-control-flow-with-a-cfg). \r\n\r\nThis is the model: https://gist.github.com/asraa/93f10e86abcc3fe386eec172cb918e5c\r\n\r\nI'll be poking around the conversion code near the conditional branch handling, just in case, and if I see something suspicious I'll update this thread. https://github.com/llvm/circt/blob/4a2ae91b421c71841c69153f81fc4277fe5409ef/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp#L1016\r\n\r\nThank you!\r\n\r\n@mikeurbach for CC, thank you for responding in the chat!\r\n"}, {"number": 5011, "title": "[FIRRTL] LowerToHW replaces uses of output ports and doesn't preserve dontTouch (symbol)", "created_at": "2023-04-11T22:10:30Z", "state": "closed", "labels": "bug, FIRRTL", "body": "More unexpected behavior with output ports, dontTouch, and reading them within a module.\r\n\r\nSimilar to #5008 .\r\n\r\nConsider this FIRRTL input:\r\n\r\n```firrtl\r\ncircuit Producer : %[[\r\n { \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n   \"target\": \"~Producer|Producer>out\" },\r\n { \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n   \"target\": \"~Producer|Producer>n\" }\r\n]]\r\n  module Producer:\r\n    input clock: Clock\r\n    output out: UInt<5>\r\n\r\n    ; Simple constant output.\r\n    node n = UInt<5>(1)\r\n    out <= n\r\n\r\n    assert(clock, neq(out, UInt<5>(3)), UInt<1>(1), \"out was changed\")\r\n```\r\n\r\nWhich w/`-ir-fir` we get (good so far):\r\n\r\n```mlir\r\nmodule {\r\n  firrtl.circuit \"Producer\" {\r\n    firrtl.module @Producer(in %clock: !firrtl.clock, out %out: !firrtl.uint<5> [{class = \"firrtl.transforms.DontTouchAnnotation\"}]) attributes {convention = #firrtl<convention scalarized>} {\r\n      %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>\r\n      %c3_ui5 = firrtl.constant 3 : !firrtl.uint<5>\r\n      %c1_ui5 = firrtl.constant 1 : !firrtl.uint<5>\r\n      %n = firrtl.node %c1_ui5 {annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}]} : !firrtl.uint<5>\r\n      firrtl.strictconnect %out, %n : !firrtl.uint<5>\r\n      %0 = firrtl.neq %out, %c3_ui5 : (!firrtl.uint<5>, !firrtl.uint<5>) -> !firrtl.uint<1>\r\n      firrtl.assert %clock, %0, %c1_ui1, \"out was changed\" : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>  {eventControl = 0 : i32, isConcurrent = false}\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nPiping the above through `circt-opt --lower-firrtl-to-hw` yields:\r\n\r\n```mlir\r\nmodule {\r\n  hw.module @Producer(%clock: i1) -> (out: i5 {hw.exportPort = #hw<innerSym@__Producer__out>}) {\r\n    %c1_i5 = hw.constant 1 : i5\r\n    %c3_i5 = hw.constant 3 : i5\r\n    %true = hw.constant true\r\n    %.out.output = hw.wire %n  : i5\r\n    %n = hw.wire %c1_i5 sym @__Producer__n  : i5\r\n    %0 = comb.icmp bin ne %.out.output, %c3_i5 : i5\r\n    sv.always posedge %clock {\r\n      sv.if %true {\r\n        sv.assert %0, immediate message \"out was changed\"\r\n      }\r\n    }\r\n    hw.output %.out.output : i5\r\n  }\r\n}\r\n```\r\n\r\nWhere the use of the output port is replaced with a wire (`%.out.output`) which lacks the \"dontTouch\"-y symbol.\r\n\r\nAs a result, running this input through the pipeline currently produces:\r\n\r\n```systemverilog\r\n// Generated by CIRCT 1.37.0g20230411_c9c3591\r\nmodule Producer(\r\n  input        clock,\r\n  output [4:0] out\r\n);\r\n\r\n  wire [4:0] n = 5'h1;\r\n  always @(posedge clock)\r\n    assert(n != 5'h3) else $error(\"out was changed\");\r\n  assign out = n;\r\nendmodule\r\n```", "code_snippet_01": "circuit Producer : %[[\r\n { \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n   \"target\": \"~Producer|Producer>out\" },\r\n { \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n   \"target\": \"~Producer|Producer>n\" }\r\n]]\r\n  module Producer:\r\n    input clock: Clock\r\n    output out: UInt<5>\r\n\r\n    ; Simple constant output.\r\n    node n = UInt<5>(1)\r\n    out <= n\r\n\r\n    assert(clock, neq(out, UInt<5>(3)), UInt<1>(1), \"out was changed\")", "code_snippet_02": "module {\r\n  firrtl.circuit \"Producer\" {\r\n    firrtl.module @Producer(in %clock: !firrtl.clock, out %out: !firrtl.uint<5> [{class = \"firrtl.transforms.DontTouchAnnotation\"}]) attributes {convention = #firrtl<convention scalarized>} {\r\n      %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>\r\n      %c3_ui5 = firrtl.constant 3 : !firrtl.uint<5>\r\n      %c1_ui5 = firrtl.constant 1 : !firrtl.uint<5>\r\n      %n = firrtl.node %c1_ui5 {annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}]} : !firrtl.uint<5>\r\n      firrtl.strictconnect %out, %n : !firrtl.uint<5>\r\n      %0 = firrtl.neq %out, %c3_ui5 : (!firrtl.uint<5>, !firrtl.uint<5>) -> !firrtl.uint<1>\r\n      firrtl.assert %clock, %0, %c1_ui1, \"out was changed\" : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>  {eventControl = 0 : i32, isConcurrent = false}\r\n    }\r\n  }\r\n}", "code_snippet_03": "module {\r\n  hw.module @Producer(%clock: i1) -> (out: i5 {hw.exportPort = #hw<innerSym@__Producer__out>}) {\r\n    %c1_i5 = hw.constant 1 : i5\r\n    %c3_i5 = hw.constant 3 : i5\r\n    %true = hw.constant true\r\n    %.out.output = hw.wire %n  : i5\r\n    %n = hw.wire %c1_i5 sym @__Producer__n  : i5\r\n    %0 = comb.icmp bin ne %.out.output, %c3_i5 : i5\r\n    sv.always posedge %clock {\r\n      sv.if %true {\r\n        sv.assert %0, immediate message \"out was changed\"\r\n      }\r\n    }\r\n    hw.output %.out.output : i5\r\n  }\r\n}", "code_snippet_04": "// Generated by CIRCT 1.37.0g20230411_c9c3591\r\nmodule Producer(\r\n  input        clock,\r\n  output [4:0] out\r\n);\r\n\r\n  wire [4:0] n = 5'h1;\r\n  always @(posedge clock)\r\n    assert(n != 5'h3) else $error(\"out was changed\");\r\n  assign out = n;\r\nendmodule"}, {"number": 5008, "title": "[FIRRTL][IMCP] Don't const-prop through read of dontTouch'd output port", "created_at": "2023-04-11T21:30:50Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Example input:\r\n\r\n```firrtl\r\ncircuit Producer : %[[\r\n { \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n   \"target\": \"~Producer|Producer>foo\" },\r\n { \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n   \"target\": \"~Producer|Producer>out\" }\r\n]]\r\n  module Producer:\r\n    output out: UInt<5>\r\n    \r\n    ; Simple constant output.\r\n    node n = UInt<5>(1)\r\n    out <= n\r\n\r\n    ; Output port drives internal wire.\r\n    wire foo : UInt<5>\r\n    foo <= out\r\n```\r\n\r\nCurrent output (as well as back to, randomly, 1.25.0):\r\n\r\n```systemverilog\r\n// Generated by CIRCT 1.37.0g20230411_c9c3591\r\nmodule Producer(\r\n  output [4:0] out\r\n);\r\n\r\n  wire [4:0] foo = 5'h1;\r\n  assign out = 5'h1;\r\nendmodule\r\n```", "code_snippet_01": "circuit Producer : %[[\r\n { \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n   \"target\": \"~Producer|Producer>foo\" },\r\n { \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n   \"target\": \"~Producer|Producer>out\" }\r\n]]\r\n  module Producer:\r\n    output out: UInt<5>\r\n    \r\n    ; Simple constant output.\r\n    node n = UInt<5>(1)\r\n    out <= n\r\n\r\n    ; Output port drives internal wire.\r\n    wire foo : UInt<5>\r\n    foo <= out", "code_snippet_02": "// Generated by CIRCT 1.37.0g20230411_c9c3591\r\nmodule Producer(\r\n  output [4:0] out\r\n);\r\n\r\n  wire [4:0] foo = 5'h1;\r\n  assign out = 5'h1;\r\nendmodule"}, {"number": 4941, "title": "[FIRRTL] plusarg intrinsics should lower to a register.", "created_at": "2023-04-05T15:48:07Z", "state": "closed", "labels": "bug, FIRRTL", "body": "plusargs should cache in a register loaded from an initial block like this:\r\n```\r\nmodule PlusArgsValueTop(\r\n  input         clock,\r\n                reset,\r\n  output        io_wf,\r\n  output [31:0] io_wv,\r\n  output        io_xf,\r\n  output [15:0] io_xv_a,\r\n                io_xv_b\r\n);\r\n\r\n  logic [31:0]                                     _pargs;\r\n  struct packed {logic [15:0] a; logic [15:0] b; } _pargs_0;\r\n  logic _pf, _pf_0;\r\n  initial begin\r\n    _pf = $value$plusargs(\"FOO=%d\", _pargs);\r\n    _pf_0 = $value$plusargs(\"BAR=%d\", _pargs_0);\r\n  end\r\n  assign io_wf = _pf;\r\n  assign io_wv = _pargs;\r\n  assign io_xf = _pf_0;\r\n  assign io_xv_a = _pargs_0.a;\r\n  assign io_xv_b = _pargs_0.b;\r\nendmodule\r\n```\r\n\r\nrather than trying to be an inline expression.  This will make lint checking easier.", "code_snippet_01": "module PlusArgsValueTop(\r\n  input         clock,\r\n                reset,\r\n  output        io_wf,\r\n  output [31:0] io_wv,\r\n  output        io_xf,\r\n  output [15:0] io_xv_a,\r\n                io_xv_b\r\n);\r\n\r\n  logic [31:0]                                     _pargs;\r\n  struct packed {logic [15:0] a; logic [15:0] b; } _pargs_0;\r\n  logic _pf, _pf_0;\r\n  initial begin\r\n    _pf = $value$plusargs(\"FOO=%d\", _pargs);\r\n    _pf_0 = $value$plusargs(\"BAR=%d\", _pargs_0);\r\n  end\r\n  assign io_wf = _pf;\r\n  assign io_wv = _pargs;\r\n  assign io_xf = _pf_0;\r\n  assign io_xv_a = _pargs_0.a;\r\n  assign io_xv_b = _pargs_0.b;\r\nendmodule"}, {"number": 4921, "title": "[FIRRTL][Inliner] UNREACHABLE \"the default constructor for MutableNLA should never be used\"", "created_at": "2023-04-03T14:08:13Z", "state": "open", "labels": "bug, FIRRTL", "body": "Variant of inliner crash test case in #4920 .  This crashes on 1.35.0 and 1.37.0:\r\n\r\n```firrtl\r\nmodule {\r\n  firrtl.circuit \"Unreachable\" {\r\n    hw.hierpath private @nla_5560 [@Unreachable::@w, @Bar2]\r\n    hw.hierpath private @nla_5561 [@Bar1::@w, @Bar3]\r\n    firrtl.module private @Bar2() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      %x = firrtl.wire sym @x {annotations = [{circt.nonlocal = @nla_5560, class = \"test0\"}]} : !firrtl.uint<8>\r\n      firrtl.instance no sym @no @Bar1()\r\n    }\r\n    firrtl.module private @Bar1() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      firrtl.instance bar3 sym @w @Bar3()\r\n    }\r\n    firrtl.module private @Bar3() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @nla_5561, class = \"test0\"}]} : !firrtl.uint<8>\r\n    }\r\n    firrtl.module @Unreachable() {\r\n      firrtl.instance no sym @no @Bar1()\r\n      firrtl.instance bar2 sym @w @Bar2()\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nError:\r\n\r\n```\r\nthe default constructor for MutableNLA should never be used\r\nUNREACHABLE executed at /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:130!\r\n```\r\n\r\nBacktrace:\r\n\r\n```\r\n* thread #1, name = 'circt-opt', stop reason = signal SIGABRT\r\n  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295\r\n    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22\r\n    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215\r\n    frame #3: 0x00005555561857bf circt-opt`llvm::llvm_unreachable_internal(msg=<unavailable>, file=<unavailable>, line=<unavailable>) at ErrorHandling.cpp:212:3\r\n    frame #4: 0x0000555556788dba circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] (anonymous namespace)::MutableNLA::MutableNLA(this=<unavailable>) at ModuleInliner.cpp:129:5\r\n    frame #5: 0x0000555556788d2e circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>* llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (this=<unavailable>, TheBucket=<unavailable>, Key=0x00007fffffff3db8)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::InsertIntoBucket<mlir::Attribute const&>(llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>*, mlir::Attribute const&) at DenseMap.h:563:37\r\n    frame #6: 0x0000555556788d20 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::FindAndConstruct(this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:339:13\r\n    frame #7: 0x0000555556788ce2 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:343:12\r\n    frame #8: 0x0000555556789f68 circt-opt`(anonymous namespace)::Inliner::setActiveHierPaths(this=0x00007fffffff4588, moduleName=StringAttr @ rbx, instInnerSym=StringAttr @ scalar) at ModuleInliner.cpp:596:11\r\n    frame #9: 0x000055555678e194 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=(Data = \"bar2_\", Length = 5), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, beb=0x00007fffffff41a0, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3f18, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1094:5\r\n    frame #10: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7\r\n    frame #11: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7\r\n    frame #12: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13\r\n    frame #13: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17\r\n    frame #14: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #15: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #16: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000330afe0, irUnits=ArrayRef<mlir::IRUnit> @ 0x000000000331dee0, args=0x0000555557bfe4f0)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #17: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfe4f0, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #18: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be0d10, op=0x0000555557bfd560, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16\r\n    frame #19: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557c00380)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36\r\n    frame #20: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18\r\n    frame #21: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10\r\n    frame #22: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14\r\n    frame #23: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5\r\n    frame #24: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20\r\n    frame #25: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #26: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #27: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003435460, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000038b4fc0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #28: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #29: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16\r\n    frame #30: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfd5c0, am=AnalysisManager @ scalar) at Pass.cpp:857:10\r\n    frame #31: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfd5c0) at Pass.cpp:837:60\r\n    frame #32: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc9000, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17\r\n    frame #33: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12\r\n    frame #34: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12\r\n    frame #35: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12\r\n    frame #36: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12\r\n    frame #37: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12\r\n    frame #38: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10\r\n    frame #39: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14\r\n    frame #40: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23\r\n    frame #41: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126\r\n    frame #42: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137\r\n    frame #43: 0x0000555556160415 circt-opt`_start + 37\r\n```", "code_snippet_01": "module {\r\n  firrtl.circuit \"Unreachable\" {\r\n    hw.hierpath private @nla_5560 [@Unreachable::@w, @Bar2]\r\n    hw.hierpath private @nla_5561 [@Bar1::@w, @Bar3]\r\n    firrtl.module private @Bar2() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      %x = firrtl.wire sym @x {annotations = [{circt.nonlocal = @nla_5560, class = \"test0\"}]} : !firrtl.uint<8>\r\n      firrtl.instance no sym @no @Bar1()\r\n    }\r\n    firrtl.module private @Bar1() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      firrtl.instance bar3 sym @w @Bar3()\r\n    }\r\n    firrtl.module private @Bar3() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @nla_5561, class = \"test0\"}]} : !firrtl.uint<8>\r\n    }\r\n    firrtl.module @Unreachable() {\r\n      firrtl.instance no sym @no @Bar1()\r\n      firrtl.instance bar2 sym @w @Bar2()\r\n    }\r\n  }\r\n}", "code_snippet_02": "the default constructor for MutableNLA should never be used\r\nUNREACHABLE executed at /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:130!", "code_snippet_03": "* thread #1, name = 'circt-opt', stop reason = signal SIGABRT\r\n  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295\r\n    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22\r\n    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215\r\n    frame #3: 0x00005555561857bf circt-opt`llvm::llvm_unreachable_internal(msg=<unavailable>, file=<unavailable>, line=<unavailable>) at ErrorHandling.cpp:212:3\r\n    frame #4: 0x0000555556788dba circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] (anonymous namespace)::MutableNLA::MutableNLA(this=<unavailable>) at ModuleInliner.cpp:129:5\r\n    frame #5: 0x0000555556788d2e circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>* llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (this=<unavailable>, TheBucket=<unavailable>, Key=0x00007fffffff3db8)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::InsertIntoBucket<mlir::Attribute const&>(llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>*, mlir::Attribute const&) at DenseMap.h:563:37\r\n    frame #6: 0x0000555556788d20 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::FindAndConstruct(this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:339:13\r\n    frame #7: 0x0000555556788ce2 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:343:12\r\n    frame #8: 0x0000555556789f68 circt-opt`(anonymous namespace)::Inliner::setActiveHierPaths(this=0x00007fffffff4588, moduleName=StringAttr @ rbx, instInnerSym=StringAttr @ scalar) at ModuleInliner.cpp:596:11\r\n    frame #9: 0x000055555678e194 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=(Data = \"bar2_\", Length = 5), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, beb=0x00007fffffff41a0, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3f18, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1094:5\r\n    frame #10: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7\r\n    frame #11: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7\r\n    frame #12: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13\r\n    frame #13: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17\r\n    frame #14: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #15: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #16: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000330afe0, irUnits=ArrayRef<mlir::IRUnit> @ 0x000000000331dee0, args=0x0000555557bfe4f0)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #17: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfe4f0, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #18: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be0d10, op=0x0000555557bfd560, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16\r\n    frame #19: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557c00380)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36\r\n    frame #20: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18\r\n    frame #21: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10\r\n    frame #22: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14\r\n    frame #23: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5\r\n    frame #24: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20\r\n    frame #25: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #26: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #27: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003435460, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000038b4fc0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #28: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #29: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16\r\n    frame #30: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfd5c0, am=AnalysisManager @ scalar) at Pass.cpp:857:10\r\n    frame #31: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfd5c0) at Pass.cpp:837:60\r\n    frame #32: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc9000, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17\r\n    frame #33: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12\r\n    frame #34: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12\r\n    frame #35: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12\r\n    frame #36: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12\r\n    frame #37: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12\r\n    frame #38: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10\r\n    frame #39: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14\r\n    frame #40: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23\r\n    frame #41: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126\r\n    frame #42: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137\r\n    frame #43: 0x0000555556160415 circt-opt`_start + 37"}, {"number": 4920, "title": "[FIRRTL][Inliner] Mutable NLA did not contain symbol", "created_at": "2023-04-03T13:59:00Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Test case:\r\n```firrtl\r\nmodule {\r\n  firrtl.circuit \"DidNotContainSymbol\" {\r\n    hw.hierpath private @path [@Bar1::@w, @Bar3]\r\n    firrtl.module private @Bar2() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      firrtl.instance no sym @no @Bar1()\r\n    }\r\n    firrtl.module private @Bar1() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      firrtl.instance bar3 sym @w @Bar3()\r\n    }\r\n    firrtl.module private @Bar3() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @path , class = \"test0\"}]} : !firrtl.uint<8>\r\n    }\r\n    firrtl.module @DidNotContainSymbol() {\r\n      firrtl.instance bar2 sym @w @Bar2()\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAssertion failure:\r\n\r\n```\r\nlib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:384: void (anonymous namespace)::MutableNLA::setInnerSym(mlir::Attribute, mlir::StringAttr): Assertion `symIdx.count(module) && \"Mutable NLA did not contain symbol\"' failed.\r\n```\r\n\r\n```\r\n* thread #1, name = 'circt-opt', stop reason = signal SIGABRT\r\n  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295\r\n    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22\r\n    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215\r\n    frame #3: 0x00007ffff7a283d9 libc.so.6`__assert_fail_base.cold.0 + 15\r\n    frame #4: 0x00007ffff7a367b6 libc.so.6`__assert_fail + 70\r\n    frame #5: 0x000055555678c03c circt-opt`(anonymous namespace)::MutableNLA::setInnerSym(this=<unavailable>, module=<unavailable>, innerSym=<unavailable>) at ModuleInliner.cpp:384:5\r\n    frame #6: 0x000055555678d4d7 circt-opt`(anonymous namespace)::Inliner::rename(this=0x00007fffffff4588, prefix=<unavailable>, op=0x0000555557c073a0, moduleNamespace=<unavailable>) at ModuleInliner.cpp:673:14\r\n    frame #7: 0x000055555678c7d3 circt-opt`void llvm::function_ref<void (mlir::Operation*)>::callback_fn<(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2>(long, mlir::Operation*) at ModuleInliner.cpp:880:7\r\n    frame #8: 0x000055555678c6e8 circt-opt`void llvm::function_ref<void (mlir::Operation*)>::callback_fn<(anonymous namespace)::Inliner::cloneAndRename(callable=140737488304200, params=0x0000555557bfa070)::$_2>(long, mlir::Operation*) at STLFunctionalExtras.h:45:12\r\n    frame #9: 0x0000555556214546 circt-opt`void mlir::detail::walk<mlir::ForwardIterator>(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) [inlined] llvm::function_ref<void (mlir::Operation*)>::operator(this=<unavailable>, params=0x0000555557bfa070)(mlir::Operation*) const at STLFunctionalExtras.h:68:12\r\n    frame #10: 0x000055555621453d circt-opt`void mlir::detail::walk<mlir::ForwardIterator>(op=0x0000555557bfa070, callback=mlir::function_ref<void (mlir::Operation *)> @ 0x0000000003b98e80, order=PreOrder)>, mlir::WalkOrder) at Visitors.h:174:5\r\n    frame #11: 0x000055555678c5ad circt-opt`(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&) [inlined] std::enable_if<llvm::is_one_of<mlir::Operation*, mlir::Operation*, mlir::Region*, mlir::Block*>::value, void>::type mlir::detail::walk<(op=0x0000555557bfa070, callback=0x00007fffffff3848)0, mlir::ForwardIterator, (anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2, mlir::Operation*, void>(mlir::Operation*, (anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2&&) at Visitors.h:313:10\r\n    frame #12: 0x000055555678c597 circt-opt`(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&) [inlined] std::enable_if<(llvm::function_traits<std::decay<(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2>::type>::num_args) == (1), void>::type mlir::Operation::walk<(this=0x0000555557bfa070, callback=0x00007fffffff3848)0, mlir::ForwardIterator, (anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2, void>((anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2&&) at Operation.h:641:12\r\n    frame #13: 0x000055555678c597 circt-opt`(anonymous namespace)::Inliner::cloneAndRename(this=0x00007fffffff4588, prefix=(Data = \"bar2_no_bar3_\", Length = 13), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, op=0x0000555557bfa070, symbolRenames=0x00007fffffff3d60, localSymbols=0x00007fffffff3b40, moduleNamespace=0x00007fffffff4510) at ModuleInliner.cpp:866:6\r\n    frame #14: 0x000055555678dafc circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=<unavailable>, b=<unavailable>, mapper=<unavailable>, beb=<unavailable>, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff39f8, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at SmallVector.h:0:10\r\n    frame #15: 0x000055555678e593 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=<unavailable>, b=<unavailable>, mapper=<unavailable>, beb=<unavailable>, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3c78, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1109:7\r\n    frame #16: 0x000055555678e593 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=<unavailable>, b=<unavailable>, mapper=<unavailable>, beb=<unavailable>, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3ef8, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1109:7\r\n    frame #17: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7\r\n    frame #18: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7\r\n    frame #19: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13\r\n    frame #20: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17\r\n    frame #21: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #22: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #23: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003d9ef60, irUnits=ArrayRef<mlir::IRUnit> @ 0x0000000003e53480, args=0x0000555557bfcc80)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #24: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfcc80, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #25: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be10c0, op=0x0000555557bfbcf0, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16\r\n    frame #26: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557bfeb30)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36\r\n    frame #27: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18\r\n    frame #28: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10\r\n    frame #29: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14\r\n    frame #30: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5\r\n    frame #31: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20\r\n    frame #32: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #33: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #34: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000411f1f0, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000041820c0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #35: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #36: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16\r\n    frame #37: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfbd50, am=AnalysisManager @ scalar) at Pass.cpp:857:10\r\n    frame #38: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfbd50) at Pass.cpp:837:60\r\n    frame #39: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc93b0, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17\r\n    frame #40: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12\r\n    frame #41: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12\r\n    frame #42: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12\r\n    frame #43: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12\r\n    frame #44: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12\r\n    frame #45: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10\r\n    frame #46: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14\r\n    frame #47: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23\r\n    frame #48: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126\r\n    frame #49: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137\r\n    frame #50: 0x0000555556160415 circt-opt`_start + 37\r\n```\r\n\r\ncc #4915 .", "code_snippet_01": "module {\r\n  firrtl.circuit \"DidNotContainSymbol\" {\r\n    hw.hierpath private @path [@Bar1::@w, @Bar3]\r\n    firrtl.module private @Bar2() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      firrtl.instance no sym @no @Bar1()\r\n    }\r\n    firrtl.module private @Bar1() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      firrtl.instance bar3 sym @w @Bar3()\r\n    }\r\n    firrtl.module private @Bar3() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @path , class = \"test0\"}]} : !firrtl.uint<8>\r\n    }\r\n    firrtl.module @DidNotContainSymbol() {\r\n      firrtl.instance bar2 sym @w @Bar2()\r\n    }\r\n  }\r\n}", "code_snippet_02": "lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:384: void (anonymous namespace)::MutableNLA::setInnerSym(mlir::Attribute, mlir::StringAttr): Assertion `symIdx.count(module) && \"Mutable NLA did not contain symbol\"' failed.", "code_snippet_03": "* thread #1, name = 'circt-opt', stop reason = signal SIGABRT\r\n  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295\r\n    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22\r\n    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215\r\n    frame #3: 0x00007ffff7a283d9 libc.so.6`__assert_fail_base.cold.0 + 15\r\n    frame #4: 0x00007ffff7a367b6 libc.so.6`__assert_fail + 70\r\n    frame #5: 0x000055555678c03c circt-opt`(anonymous namespace)::MutableNLA::setInnerSym(this=<unavailable>, module=<unavailable>, innerSym=<unavailable>) at ModuleInliner.cpp:384:5\r\n    frame #6: 0x000055555678d4d7 circt-opt`(anonymous namespace)::Inliner::rename(this=0x00007fffffff4588, prefix=<unavailable>, op=0x0000555557c073a0, moduleNamespace=<unavailable>) at ModuleInliner.cpp:673:14\r\n    frame #7: 0x000055555678c7d3 circt-opt`void llvm::function_ref<void (mlir::Operation*)>::callback_fn<(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2>(long, mlir::Operation*) at ModuleInliner.cpp:880:7\r\n    frame #8: 0x000055555678c6e8 circt-opt`void llvm::function_ref<void (mlir::Operation*)>::callback_fn<(anonymous namespace)::Inliner::cloneAndRename(callable=140737488304200, params=0x0000555557bfa070)::$_2>(long, mlir::Operation*) at STLFunctionalExtras.h:45:12\r\n    frame #9: 0x0000555556214546 circt-opt`void mlir::detail::walk<mlir::ForwardIterator>(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) [inlined] llvm::function_ref<void (mlir::Operation*)>::operator(this=<unavailable>, params=0x0000555557bfa070)(mlir::Operation*) const at STLFunctionalExtras.h:68:12\r\n    frame #10: 0x000055555621453d circt-opt`void mlir::detail::walk<mlir::ForwardIterator>(op=0x0000555557bfa070, callback=mlir::function_ref<void (mlir::Operation *)> @ 0x0000000003b98e80, order=PreOrder)>, mlir::WalkOrder) at Visitors.h:174:5\r\n    frame #11: 0x000055555678c5ad circt-opt`(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&) [inlined] std::enable_if<llvm::is_one_of<mlir::Operation*, mlir::Operation*, mlir::Region*, mlir::Block*>::value, void>::type mlir::detail::walk<(op=0x0000555557bfa070, callback=0x00007fffffff3848)0, mlir::ForwardIterator, (anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2, mlir::Operation*, void>(mlir::Operation*, (anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2&&) at Visitors.h:313:10\r\n    frame #12: 0x000055555678c597 circt-opt`(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&) [inlined] std::enable_if<(llvm::function_traits<std::decay<(anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2>::type>::num_args) == (1), void>::type mlir::Operation::walk<(this=0x0000555557bfa070, callback=0x00007fffffff3848)0, mlir::ForwardIterator, (anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2, void>((anonymous namespace)::Inliner::cloneAndRename(llvm::StringRef, mlir::OpBuilder&, mlir::IRMapping&, mlir::Operation&, llvm::DenseMap<mlir::Attribute, mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, mlir::Attribute> > const&, llvm::DenseSet<mlir::Attribute, llvm::DenseMapInfo<mlir::Attribute, void> > const&, circt::firrtl::ModuleNamespace&)::$_2&&) at Operation.h:641:12\r\n    frame #13: 0x000055555678c597 circt-opt`(anonymous namespace)::Inliner::cloneAndRename(this=0x00007fffffff4588, prefix=(Data = \"bar2_no_bar3_\", Length = 13), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, op=0x0000555557bfa070, symbolRenames=0x00007fffffff3d60, localSymbols=0x00007fffffff3b40, moduleNamespace=0x00007fffffff4510) at ModuleInliner.cpp:866:6\r\n    frame #14: 0x000055555678dafc circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=<unavailable>, b=<unavailable>, mapper=<unavailable>, beb=<unavailable>, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff39f8, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at SmallVector.h:0:10\r\n    frame #15: 0x000055555678e593 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=<unavailable>, b=<unavailable>, mapper=<unavailable>, beb=<unavailable>, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3c78, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1109:7\r\n    frame #16: 0x000055555678e593 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=<unavailable>, b=<unavailable>, mapper=<unavailable>, beb=<unavailable>, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3ef8, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1109:7\r\n    frame #17: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7\r\n    frame #18: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7\r\n    frame #19: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13\r\n    frame #20: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17\r\n    frame #21: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #22: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #23: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003d9ef60, irUnits=ArrayRef<mlir::IRUnit> @ 0x0000000003e53480, args=0x0000555557bfcc80)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #24: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfcc80, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #25: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be10c0, op=0x0000555557bfbcf0, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16\r\n    frame #26: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557bfeb30)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36\r\n    frame #27: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18\r\n    frame #28: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10\r\n    frame #29: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14\r\n    frame #30: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5\r\n    frame #31: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20\r\n    frame #32: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #33: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #34: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000411f1f0, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000041820c0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #35: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #36: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16\r\n    frame #37: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfbd50, am=AnalysisManager @ scalar) at Pass.cpp:857:10\r\n    frame #38: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfbd50) at Pass.cpp:837:60\r\n    frame #39: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc93b0, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17\r\n    frame #40: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12\r\n    frame #41: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12\r\n    frame #42: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12\r\n    frame #43: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12\r\n    frame #44: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12\r\n    frame #45: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10\r\n    frame #46: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14\r\n    frame #47: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23\r\n    frame #48: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126\r\n    frame #49: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137\r\n    frame #50: 0x0000555556160415 circt-opt`_start + 37"}, {"number": 4896, "title": "[FIRRTL] Verify annotation symbol uses!", "created_at": "2023-03-28T00:07:06Z", "state": "open", "labels": "bug, good first issue, FIRRTL", "body": "Currently there is no verification that the symbols used by annotations exist at all, nevermind any sense of being appropriate/correct.  This should be fixed.  Example:\r\n\r\n```firrtl\r\nmodule {\r\n  firrtl.circuit \"Oops\" {\r\n    firrtl.module private @Child() attributes {annotations = [{circt.nonlocal = @nla, class = \"circt.test\"}]} {\r\n    }\r\n    firrtl.module @Oops() {\r\n      firrtl.instance child @Child()\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nPresently, `circt-opt` round-trips this, and `firtool` makes it all the way to `PrefixModules` before something notices.\r\n\r\nThere may be support for Attribute symbol-use verification, so look for such as that would be ideal.  Otherwise we may need to find a way to expose the uses to the symbol verifier, there are interfaces for exposing subelement's that may be appropriate here.  A final but offhand seemingly less-than-ideal approach to consider would be SymbolUserOpInterface's `verifySymbolUses` (I suppose on all our operations that take annotations).", "code_snippet_01": "module {\r\n  firrtl.circuit \"Oops\" {\r\n    firrtl.module private @Child() attributes {annotations = [{circt.nonlocal = @nla, class = \"circt.test\"}]} {\r\n    }\r\n    firrtl.module @Oops() {\r\n      firrtl.instance child @Child()\r\n    }\r\n  }\r\n}"}, {"number": 4886, "title": "[FIRRTL] InferResets Not Duplicating Modules When Necessary", "created_at": "2023-03-24T22:32:02Z", "state": "open", "labels": "bug, FIRRTL", "body": "In the following FIRRTL, we have a module instantiated twice, once in a FullAsyncReset domain, and once not in any domain.\r\n\r\n```\r\ncircuit Top : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.FullAsyncResetAnnotation\",\r\n    \"target\":\"~Top|FullAsyncWrapper>rf_reset\"\r\n  }\r\n]]\r\n  module Child :\r\n    input clock : Clock\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    reg r : UInt<8>, clock\r\n    r <= foo\r\n    bar <= r\r\n\r\n  module FullAsyncWrapper :\r\n    input clock : Clock\r\n    input rf_reset : AsyncReset\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    inst c of Child\r\n    c.clock <= clock\r\n    c.foo <= foo\r\n    bar <= c.bar\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input rf_reset : AsyncReset\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    inst wrap of FullAsyncWrapper\r\n    wrap.clock <= clock\r\n    wrap.rf_reset <= rf_reset\r\n    wrap.foo <= foo\r\n\r\n    inst child of Child\r\n    child.clock <= clock\r\n    child.foo <= foo\r\n\r\n    bar <= and(wrap.bar, child.bar)\r\n```\r\n\r\nRun this with firtool 1.36.0 and you will get\r\n```\r\ntest.fir:7:10: error: module 'Child' instantiated in different reset domains\r\n  module Child :\r\n         ^\r\ntest.fir:7:10: note: see current operation: \r\n\"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<8>, %arg2: !firrtl.uint<8>):\r\n  %0 = \"firrtl.reg\"(%arg0) {annotations = [], name = \"r\", nameKind = #firrtl<name_kind droppable_name>} : (!firrtl.clock) -> !firrtl.uint<8>\r\n  \"firrtl.strictconnect\"(%0, %arg1) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()\r\n  \"firrtl.strictconnect\"(%arg2, %0) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()\r\n}) {annotations = [], portAnnotations = [], portDirections = -4 : i3, portLocations = [loc(\"test.fir\":8:11), loc(\"test.fir\":9:11), loc(\"test.fir\":10:12)], portNames = [\"clock\", \"foo\", \"bar\"], portSyms = [], portTypes = [!firrtl.clock, !firrtl.uint<8>, !firrtl.uint<8>], sym_name = \"Child\", sym_visibility = \"private\"} : () -> ()\r\ntest.fir:22:5: note: instance 'wrap/c' is in reset domain rooted at 'rf_reset' of module 'FullAsyncWrapper'\r\n    inst c of Child\r\n    ^\r\ntest.fir:18:11: note: reset domain 'rf_reset' of module 'FullAsyncWrapper' declared here:\r\n    input rf_reset : AsyncReset\r\n          ^\r\ntest.fir:38:5: note: instance 'child' is in no reset domain\r\n    inst child of Child\r\n    ^\r\n```\r\n\r\nThis is a very similar issue to https://github.com/llvm/circt/issues/4586", "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.FullAsyncResetAnnotation\",\r\n    \"target\":\"~Top|FullAsyncWrapper>rf_reset\"\r\n  }\r\n]]\r\n  module Child :\r\n    input clock : Clock\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    reg r : UInt<8>, clock\r\n    r <= foo\r\n    bar <= r\r\n\r\n  module FullAsyncWrapper :\r\n    input clock : Clock\r\n    input rf_reset : AsyncReset\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    inst c of Child\r\n    c.clock <= clock\r\n    c.foo <= foo\r\n    bar <= c.bar\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input rf_reset : AsyncReset\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    inst wrap of FullAsyncWrapper\r\n    wrap.clock <= clock\r\n    wrap.rf_reset <= rf_reset\r\n    wrap.foo <= foo\r\n\r\n    inst child of Child\r\n    child.clock <= clock\r\n    child.foo <= foo\r\n\r\n    bar <= and(wrap.bar, child.bar)", "code_snippet_02": "test.fir:7:10: error: module 'Child' instantiated in different reset domains\r\n  module Child :\r\n         ^\r\ntest.fir:7:10: note: see current operation: \r\n\"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<8>, %arg2: !firrtl.uint<8>):\r\n  %0 = \"firrtl.reg\"(%arg0) {annotations = [], name = \"r\", nameKind = #firrtl<name_kind droppable_name>} : (!firrtl.clock) -> !firrtl.uint<8>\r\n  \"firrtl.strictconnect\"(%0, %arg1) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()\r\n  \"firrtl.strictconnect\"(%arg2, %0) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()\r\n}) {annotations = [], portAnnotations = [], portDirections = -4 : i3, portLocations = [loc(\"test.fir\":8:11), loc(\"test.fir\":9:11), loc(\"test.fir\":10:12)], portNames = [\"clock\", \"foo\", \"bar\"], portSyms = [], portTypes = [!firrtl.clock, !firrtl.uint<8>, !firrtl.uint<8>], sym_name = \"Child\", sym_visibility = \"private\"} : () -> ()\r\ntest.fir:22:5: note: instance 'wrap/c' is in reset domain rooted at 'rf_reset' of module 'FullAsyncWrapper'\r\n    inst c of Child\r\n    ^\r\ntest.fir:18:11: note: reset domain 'rf_reset' of module 'FullAsyncWrapper' declared here:\r\n    input rf_reset : AsyncReset\r\n          ^\r\ntest.fir:38:5: note: instance 'child' is in no reset domain\r\n    inst child of Child\r\n    ^"}, {"number": 4862, "title": "[Arc] Simple input crashes SplitLoops", "created_at": "2023-03-20T20:30:36Z", "state": "closed", "labels": "bug, Arc", "body": "The following input crashes `circt-opt --arc-split-loops`:\r\n```mlir\r\narc.define @Rocket_arc(%arg0: i1, %arg1: i1, %arg2: i1) -> (i1, i1) {\r\n  %0 = comb.xor %arg0, %arg1 : i1\r\n  %1 = comb.xor %arg2, %arg1 : i1\r\n  %2 = comb.xor %0, %1 : i1\r\n  arc.output %1, %2 : i1, i1\r\n}\r\nhw.module @Rocket(%a: i1) -> (x: i1, y: i1) {\r\n  %0, %1 = arc.state @Rocket_arc(%a, %a, %a) lat 0 : (i1, i1, i1) -> (i1, i1)\r\n  hw.output %0, %1 : i1, i1\r\n}\r\n```", "code_snippet_01": "arc.define @Rocket_arc(%arg0: i1, %arg1: i1, %arg2: i1) -> (i1, i1) {\r\n  %0 = comb.xor %arg0, %arg1 : i1\r\n  %1 = comb.xor %arg2, %arg1 : i1\r\n  %2 = comb.xor %0, %1 : i1\r\n  arc.output %1, %2 : i1, i1\r\n}\r\nhw.module @Rocket(%a: i1) -> (x: i1, y: i1) {\r\n  %0, %1 = arc.state @Rocket_arc(%a, %a, %a) lat 0 : (i1, i1, i1) -> (i1, i1)\r\n  hw.output %0, %1 : i1, i1\r\n}"}, {"number": 4859, "title": "[FIRRTL][InferWidths] Uninferred uint vector in invalidvalue op triggers assertion", "created_at": "2023-03-20T17:38:28Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following reduced version of some input seen in the wild (BOOM core) trips up width inferences:\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo() {\r\n    %invalid = firrtl.invalidvalue : !firrtl.bundle<a: vector<uint, 2>>\r\n    %0 = firrtl.subfield %invalid[a] : !firrtl.bundle<a: vector<uint, 2>>\r\n    %1 = firrtl.subindex %0[0] : !firrtl.vector<uint, 2>\r\n  }\r\n}\r\n```\r\nRunning this through `circt-opt --firrtl-infer-widths` produces:\r\n```\r\ncirct-opt: lib/Dialect/FIRRTL/Transforms/InferWidths.cpp:1780:\r\n  (anonymous namespace)::Expr *(anonymous namespace)::InferenceMapping::getExpr(circt::FieldRef):\r\n  Assertion `expr && \"constraint expr should have been constructed for value\"' failed.\r\n```", "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo() {\r\n    %invalid = firrtl.invalidvalue : !firrtl.bundle<a: vector<uint, 2>>\r\n    %0 = firrtl.subfield %invalid[a] : !firrtl.bundle<a: vector<uint, 2>>\r\n    %1 = firrtl.subindex %0[0] : !firrtl.vector<uint, 2>\r\n  }\r\n}", "code_snippet_02": "circt-opt: lib/Dialect/FIRRTL/Transforms/InferWidths.cpp:1780:\r\n  (anonymous namespace)::Expr *(anonymous namespace)::InferenceMapping::getExpr(circt::FieldRef):\r\n  Assertion `expr && \"constraint expr should have been constructed for value\"' failed."}, {"number": 4849, "title": "[ExportVerilog][SV] sv.interface instance name not Verilog-keyword mangled", "created_at": "2023-03-17T21:27:52Z", "state": "open", "labels": "bug, ExportVerilog", "body": "The instance name of an SV interface op is not mangled if it collides with a Verilog keyword when it should be.\r\n\r\nConsider:\r\n\r\n```mlir\r\nmodule {\r\n  sv.interface @wire {}\r\n  hw.module private @Foo() {\r\n    %module = sv.interface.instance : !sv.interface<@wire>\r\n    hw.output\r\n  }\r\n}\r\n```\r\n\r\nThis is being output as the following when using `circt-opt -export-verilog Foo.mlir`:\r\n\r\n```verilog\r\n// Generated by CIRCT unknown git version\r\ninterface module_0;\r\nendinterface\r\n\r\nmodule Foo();\t// Foo.mlir:3:3\r\n  wire_0 module();\t// Foo.mlir:4:15\r\nendmodule\r\n```", "code_snippet_01": "module {\r\n  sv.interface @wire {}\r\n  hw.module private @Foo() {\r\n    %module = sv.interface.instance : !sv.interface<@wire>\r\n    hw.output\r\n  }\r\n}", "code_snippet_02": "// Generated by CIRCT unknown git version\r\ninterface module_0;\r\nendinterface\r\n\r\nmodule Foo();\t// Foo.mlir:3:3\r\n  wire_0 module();\t// Foo.mlir:4:15\r\nendmodule"}, {"number": 4842, "title": "[Lower Calyx to FSM] Pass can fail if not canonicalized before running", "created_at": "2023-03-16T16:28:01Z", "state": "open", "labels": "bug, Calyx, need triage", "body": "This works:\r\n```bash\r\n$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --canonicalize --lower-calyx-to-fsm\r\n```\r\n\r\nBut the following (without the `--canonicalize`) triggers an assertion:\r\n```bash\r\n$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm\r\ncirct-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed\r\n```\r\n\r\n`simple_arith.mlir` can be found [here](https://github.com/llvm/circt/blob/main/integration_test/Dialect/Calyx/simple_arith.mlir).\r\n\r\nBacktrace:\r\n```\r\ncirct-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm   \r\ncirct-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ../../circt/build/bin/circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm\r\n #0 0x000055d161ee52d4 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:22\r\n #1 0x000055d161ee56a6 PrintStackTraceSignalHandler(void*) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:676:1\r\n #2 0x000055d161ee2d57 llvm::sys::RunSignalHandlers() /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Signals.cpp:104:20\r\n #3 0x000055d161ee4c32 SignalHandler(int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #4 0x00007f117de51f50 (/usr/lib/libc.so.6+0x38f50)\r\n #5 0x00007f117dea08ec (/usr/lib/libc.so.6+0x878ec)\r\n #6 0x00007f117de51ea8 raise (/usr/lib/libc.so.6+0x38ea8)\r\n #7 0x00007f117de3b53d abort (/usr/lib/libc.so.6+0x2253d)\r\n #8 0x00007f117de3b45c (/usr/lib/libc.so.6+0x2245c)\r\n #9 0x00007f117de4a9f6 (/usr/lib/libc.so.6+0x319f6)\r\n#10 0x000055d1621313f5 llvm::SmallVectorTemplateCommon<std::pair<mlir::Operation*, circt::fsm::StateOp>, void>::front() /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:304:17\r\n#11 0x000055d16212bf8b (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:196:26\r\n#12 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#13 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#14 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#15 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#16 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#17 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#18 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#19 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#20 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#21 0x000055d16212b958 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp)::'lambda'(mlir::Value, llvm::StringRef, bool, mlir::Operation*)::operator()(mlir::Value, llvm::StringRef, bool, mlir::Operation*) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:147:15\r\n#22 0x000055d16212bb0e (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:153:13\r\n#23 0x000055d16212dbe3 auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::IfOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#24 0x000055d16212dc60 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::IfOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#25 0x000055d16212b320 Case<circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#26 0x000055d16212b320 Case<circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42\r\n#27 0x000055d16212b320 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42\r\n#28 0x000055d16212b320 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#29 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#30 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#31 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#32 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#33 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#34 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#35 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#36 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#37 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#38 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#39 0x000055d16212cada (anonymous namespace)::CalyxToFSMPass::runOnOperation() /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:307:13\r\n#40 0x000055d164764cc4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:471:27\r\n#41 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15\r\n#42 0x000055d1647660e8 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:754:47\r\n#43 0x000055d164768e17 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:46:17\r\n#44 0x000055d1647681df mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:94:1\r\n#45 0x000055d164766627 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:764:13\r\n#46 0x000055d164765ab9 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:658:1\r\n#47 0x000055d164764ca5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:468:28\r\n#48 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15\r\n#49 0x000055d164766e06 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:843:40\r\n#50 0x000055d164766c66 mlir::PassManager::run(mlir::Operation*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:823:69\r\n#51 0x000055d16397c887 performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:175:13\r\n#52 0x000055d16397ccf5 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPool*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:221:26\r\n#53 0x000055d16397ce21 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:262:25\r\n#54 0x000055d16397dcd2 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:52\r\n#55 0x000055d1639bae6b llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n#56 0x000055d1639ba6ff mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:28:30\r\n#57 0x000055d16397cfd2 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:265:31\r\n#58 0x000055d16397d8cf mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:354:13\r\n#59 0x000055d161ddc13e main /home/xerpi/Desktop/Research/circt/tools/circt-opt/circt-opt.cpp:70:22\r\n#60 0x00007f117de3c790 (/usr/lib/libc.so.6+0x23790)\r\n#61 0x00007f117de3c84a __libc_start_main (/usr/lib/libc.so.6+0x2384a)\r\n#62 0x000055d161ddbec5 _start (../../circt/build/bin/circt-opt+0x119ec5)\r\nAborted (core dumped)\r\n```", "code_snippet_01": "$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --canonicalize --lower-calyx-to-fsm", "code_snippet_02": "$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm\r\ncirct-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed", "code_snippet_03": "circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm   \r\ncirct-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ../../circt/build/bin/circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm\r\n #0 0x000055d161ee52d4 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:22\r\n #1 0x000055d161ee56a6 PrintStackTraceSignalHandler(void*) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:676:1\r\n #2 0x000055d161ee2d57 llvm::sys::RunSignalHandlers() /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Signals.cpp:104:20\r\n #3 0x000055d161ee4c32 SignalHandler(int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #4 0x00007f117de51f50 (/usr/lib/libc.so.6+0x38f50)\r\n #5 0x00007f117dea08ec (/usr/lib/libc.so.6+0x878ec)\r\n #6 0x00007f117de51ea8 raise (/usr/lib/libc.so.6+0x38ea8)\r\n #7 0x00007f117de3b53d abort (/usr/lib/libc.so.6+0x2253d)\r\n #8 0x00007f117de3b45c (/usr/lib/libc.so.6+0x2245c)\r\n #9 0x00007f117de4a9f6 (/usr/lib/libc.so.6+0x319f6)\r\n#10 0x000055d1621313f5 llvm::SmallVectorTemplateCommon<std::pair<mlir::Operation*, circt::fsm::StateOp>, void>::front() /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:304:17\r\n#11 0x000055d16212bf8b (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:196:26\r\n#12 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#13 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#14 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#15 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#16 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#17 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#18 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#19 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#20 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#21 0x000055d16212b958 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp)::'lambda'(mlir::Value, llvm::StringRef, bool, mlir::Operation*)::operator()(mlir::Value, llvm::StringRef, bool, mlir::Operation*) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:147:15\r\n#22 0x000055d16212bb0e (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:153:13\r\n#23 0x000055d16212dbe3 auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::IfOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#24 0x000055d16212dc60 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::IfOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#25 0x000055d16212b320 Case<circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#26 0x000055d16212b320 Case<circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42\r\n#27 0x000055d16212b320 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42\r\n#28 0x000055d16212b320 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#29 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#30 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#31 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#32 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#33 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#34 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#35 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#36 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#37 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#38 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#39 0x000055d16212cada (anonymous namespace)::CalyxToFSMPass::runOnOperation() /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:307:13\r\n#40 0x000055d164764cc4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:471:27\r\n#41 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15\r\n#42 0x000055d1647660e8 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:754:47\r\n#43 0x000055d164768e17 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:46:17\r\n#44 0x000055d1647681df mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:94:1\r\n#45 0x000055d164766627 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:764:13\r\n#46 0x000055d164765ab9 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:658:1\r\n#47 0x000055d164764ca5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:468:28\r\n#48 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15\r\n#49 0x000055d164766e06 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:843:40\r\n#50 0x000055d164766c66 mlir::PassManager::run(mlir::Operation*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:823:69\r\n#51 0x000055d16397c887 performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:175:13\r\n#52 0x000055d16397ccf5 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPool*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:221:26\r\n#53 0x000055d16397ce21 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:262:25\r\n#54 0x000055d16397dcd2 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:52\r\n#55 0x000055d1639bae6b llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n#56 0x000055d1639ba6ff mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:28:30\r\n#57 0x000055d16397cfd2 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:265:31\r\n#58 0x000055d16397d8cf mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:354:13\r\n#59 0x000055d161ddc13e main /home/xerpi/Desktop/Research/circt/tools/circt-opt/circt-opt.cpp:70:22\r\n#60 0x00007f117de3c790 (/usr/lib/libc.so.6+0x23790)\r\n#61 0x00007f117de3c84a __libc_start_main (/usr/lib/libc.so.6+0x2384a)\r\n#62 0x000055d161ddbec5 _start (../../circt/build/bin/circt-opt+0x119ec5)\r\nAborted (core dumped)"}, {"number": 4835, "title": "[FIRRTL][Seq] Running without randomization needs Async Reset reg initialization", "created_at": "2023-03-15T21:28:07Z", "state": "closed", "labels": "bug, good first issue, FIRRTL, Seq", "body": "The following FIRRTL compiled to Verilog needs to have an `initial` block that does a reset if reset is asserted. This happens without randomization, but not with:\r\n\r\n```\r\ncircuit Foo :\r\n  module Foo :\r\n    input clock : Clock\r\n    input reset : AsyncReset\r\n    input d : UInt<1>\r\n    output q : UInt<1>\r\n\r\n    reg q_REG : UInt<1>, clock with :\r\n      reset => (reset, UInt<1>(\"h0\"))\r\n    q_REG <= d\r\n    q <= q_REG\r\n```\r\n\r\nThis compiles to:\r\n\r\n```Verilog\r\n// Generated by CIRCT unknown git version\r\nmodule Foo(\r\n  input  clock,\r\n         reset,\r\n         d,\r\n  output q\r\n);\r\n\r\n  reg q_REG;\r\n  always @(posedge clock or posedge reset) begin\r\n    if (reset)\r\n      q_REG <= 1'h0;\r\n    else\r\n      q_REG <= d;\r\n  end // always @(posedge, posedge)\r\n  assign q = q_REG;\r\nendmodule\r\n```\r\n\r\nThis should have the following, possibly guarded only by `ifndef SYNTHESIS`:\r\n```\r\ninitial begin\r\n  if (reset)\r\n    q_REG = 1'h0;\r\nend\r\n```", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input clock : Clock\r\n    input reset : AsyncReset\r\n    input d : UInt<1>\r\n    output q : UInt<1>\r\n\r\n    reg q_REG : UInt<1>, clock with :\r\n      reset => (reset, UInt<1>(\"h0\"))\r\n    q_REG <= d\r\n    q <= q_REG", "code_snippet_02": "// Generated by CIRCT unknown git version\r\nmodule Foo(\r\n  input  clock,\r\n         reset,\r\n         d,\r\n  output q\r\n);\r\n\r\n  reg q_REG;\r\n  always @(posedge clock or posedge reset) begin\r\n    if (reset)\r\n      q_REG <= 1'h0;\r\n    else\r\n      q_REG <= d;\r\n  end // always @(posedge, posedge)\r\n  assign q = q_REG;\r\nendmodule", "code_snippet_03": "initial begin\r\n  if (reset)\r\n    q_REG = 1'h0;\r\nend"}, {"number": 4834, "title": "[FIRRTL] Inline + MarkDUT + MemTap crasher", "created_at": "2023-03-15T17:12:30Z", "state": "open", "labels": "bug, FIRRTL", "body": "Inline+MarkDUTAnnotation already don't seem compatible, but FWIW we crash in LowerToHW on this input.\r\n\r\nInput:\r\n```firrtl\r\ncircuit Top : %[[\r\n  {\r\n    \"class\": \"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"~Top|DUTModule\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top>memTap\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.MemTapAnnotation\",\r\n    \"source\":\"~Top|DUTModule>rf\",\r\n    \"sink\":[\r\n      \"~Top|Top>memTap[0]\",\r\n      \"~Top|Top>memTap[1]\",\r\n      \"~Top|Top>memTap[2]\",\r\n      \"~Top|Top>memTap[3]\",\r\n      \"~Top|Top>memTap[4]\",\r\n      \"~Top|Top>memTap[5]\",\r\n      \"~Top|Top>memTap[6]\",\r\n      \"~Top|Top>memTap[7]\"\r\n    ]\r\n  },\r\n  {\r\n    \"class\": \"firrtl.passes.InlineAnnotation\",\r\n    \"target\": \"~Top|DUTModule\"\r\n  }\r\n]]\r\n  module DUTModule :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    cmem rf : UInt<8> [8]\r\n    infer mport read = rf[io.addr], clock\r\n    io.dataOut <= read\r\n    when io.wen :\r\n      infer mport write = rf[io.addr], clock\r\n      write <= io.dataIn\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    inst dut of DUTModule\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    wire memTap : UInt<8>[8]\r\n    memTap is invalid\r\n    io.dataOut <= dut.io.dataOut\r\n    dut.io.wen <= io.wen\r\n    dut.io.dataIn <= io.dataIn\r\n    dut.io.addr <= io.addr\r\n```\r\n\r\nThis is basically our `mem-taps.fir` lit test with the Inline annotation added.\r\n\r\nWith threading disabled, see the following error: `invalid element for hw.inout type '!firrtl.ref<uint<8>>'`, FWIW.", "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\": \"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"~Top|DUTModule\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top>memTap\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.MemTapAnnotation\",\r\n    \"source\":\"~Top|DUTModule>rf\",\r\n    \"sink\":[\r\n      \"~Top|Top>memTap[0]\",\r\n      \"~Top|Top>memTap[1]\",\r\n      \"~Top|Top>memTap[2]\",\r\n      \"~Top|Top>memTap[3]\",\r\n      \"~Top|Top>memTap[4]\",\r\n      \"~Top|Top>memTap[5]\",\r\n      \"~Top|Top>memTap[6]\",\r\n      \"~Top|Top>memTap[7]\"\r\n    ]\r\n  },\r\n  {\r\n    \"class\": \"firrtl.passes.InlineAnnotation\",\r\n    \"target\": \"~Top|DUTModule\"\r\n  }\r\n]]\r\n  module DUTModule :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    cmem rf : UInt<8> [8]\r\n    infer mport read = rf[io.addr], clock\r\n    io.dataOut <= read\r\n    when io.wen :\r\n      infer mport write = rf[io.addr], clock\r\n      write <= io.dataIn\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    inst dut of DUTModule\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    wire memTap : UInt<8>[8]\r\n    memTap is invalid\r\n    io.dataOut <= dut.io.dataOut\r\n    dut.io.wen <= io.wen\r\n    dut.io.dataIn <= io.dataIn\r\n    dut.io.addr <= io.addr"}, {"number": 4816, "title": "Late pipeline passes should not be doing type coercion.", "created_at": "2023-03-13T23:26:33Z", "state": "open", "labels": "bug", "body": "              Please do not do this.  The goal is to remove this logic entirely and stop duplicating it in every pass.  We should never get to this point in the pass with the register reset value being the wrong type for the register.  That should be fixed in parsing.\r\n\r\n_Originally posted by @darthscsi in https://github.com/llvm/circt/pull/4788#pullrequestreview-1338110528_\r\n            "}, {"number": 4796, "title": "[FIRRTL][InferWidths] Honor upper bounds on AttachOp", "created_at": "2023-03-09T18:00:45Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Fix an issue in `InferWidths` where analog values attached to each other would not produce proper errors if the widths are unsatisfiable. For example, the following is unsatisfiable but successfully infers to an incorrect width:\r\n\r\n```\r\nfirrtl.module @AnalogWidths(\r\n  in %a: !firrtl.analog,\r\n  out %b: !firrtl.analog<2>,\r\n  out %c: !firrtl.analog<1>\r\n) {\r\n  firrtl.attach %a, %b : !firrtl.analog, !firrtl.analog<2>\r\n  firrtl.attach %a, %c : !firrtl.analog, !firrtl.analog<1>\r\n}\r\n```\r\n\r\nThe `AttachOp` imposes a `lhs >= rhs` *and* `lhs <= rhs` constraint, which is supposed to devolve into `lhs == rhs`. However, `InferWidths` ignores upper bound constraints like `expr <= 42` since the original Scala implementation used to violate upper bounds in obscure and wild ways (see #1088).\r\n\r\nThis commit adds an optional upper bound to variables which is checked after width inference. Specifically `AttachOp` is made to generate these upper bound constraints. Proper error messages on unsatisfiable widths should now be produced.\r\n\r\nFixes #4786.", "code_snippet_01": "firrtl.module @AnalogWidths(\r\n  in %a: !firrtl.analog,\r\n  out %b: !firrtl.analog<2>,\r\n  out %c: !firrtl.analog<1>\r\n) {\r\n  firrtl.attach %a, %b : !firrtl.analog, !firrtl.analog<2>\r\n  firrtl.attach %a, %c : !firrtl.analog, !firrtl.analog<1>\r\n}"}, {"number": 4785, "title": "[Scheduling] ModuloSimplex crashes with operator limits", "created_at": "2023-03-08T21:35:11Z", "state": "closed", "labels": "bug, Scheduling", "body": "The following SSP program crashes when run with `circt-opt -ssp-schedule=scheduler=simplex`:\r\n\r\n```\r\n  ssp.instance @test1 of \"ModuloProblem\" {\r\n    library {\r\n      operator_type @port0 [latency<1>, limit<1>]\r\n      operator_type @port1 [latency<1>, limit<1>]\r\n      operator_type @port2 [latency<1>, limit<1>]\r\n      operator_type @comb [latency<0>]\r\n    }\r\n    graph {\r\n      %0 = operation<@port0>()\r\n      %1 = operation<@port1>()\r\n      %2 = operation<@comb>(%0, %1)\r\n      %3 = operation<@port2>(%2)\r\n      operation<@comb>()\r\n    }\r\n  }\r\n```\r\n\r\nbut the same problem without limits on the operator types does not crash. It seems there are still some bugs in the ModuloSimplex scheduler even after the overhaul.", "code_snippet_01": "ssp.instance @test1 of \"ModuloProblem\" {\r\n    library {\r\n      operator_type @port0 [latency<1>, limit<1>]\r\n      operator_type @port1 [latency<1>, limit<1>]\r\n      operator_type @port2 [latency<1>, limit<1>]\r\n      operator_type @comb [latency<0>]\r\n    }\r\n    graph {\r\n      %0 = operation<@port0>()\r\n      %1 = operation<@port1>()\r\n      %2 = operation<@comb>(%0, %1)\r\n      %3 = operation<@port2>(%2)\r\n      operation<@comb>()\r\n    }\r\n  }"}, {"number": 4781, "title": "[FIRRTL] comb cycle error has too many entries (?)", "created_at": "2023-03-08T02:33:20Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Consider this input:\r\n```firrtl\r\ncircuit wut :\r\n   module wut :\r\n\r\n     wire x : UInt<8>\r\n     wire y : UInt<8>\r\n     x <= y\r\n     y <= x\r\n```\r\n\r\nWe currently produce this error:\r\n\r\n```\r\nwut.fir:2:11: error: detected combinational cycle in a FIRRTL module, sample path: wut.x <- wut.y <- wut.x <- wut.x\r\n   module wut :\r\n          ^\r\n```\r\n\r\nFrom brief testing, seems we print the beginning/end an extra time?  As shown here, that last `<- wut.x` is not actually present and describes a connection that doesn't exist (not directly anyway).\r\n\r\nAs a nit, it would be nice to point to one of the signals involved instead of the module?  If we are intentionally avoiding printing all the signals to avoid being too verbose that makes sense, but may be useful to enable as a debugging aid.", "code_snippet_01": "circuit wut :\r\n   module wut :\r\n\r\n     wire x : UInt<8>\r\n     wire y : UInt<8>\r\n     x <= y\r\n     y <= x", "code_snippet_02": "wut.fir:2:11: error: detected combinational cycle in a FIRRTL module, sample path: wut.x <- wut.y <- wut.x <- wut.x\r\n   module wut :\r\n          ^"}, {"number": 4780, "title": "[FIRRTL] Missed comb cycle, crash in canonicalizer", "created_at": "2023-03-08T02:24:27Z", "state": "open", "labels": "bug, FIRRTL", "body": "Input:\r\n\r\n```firrtl\r\ncircuit wut :\r\n   module wut :\r\n     output rwDataOut : UInt<8>\r\n\r\n     rwDataOut <= rwDataOut\r\n```\r\n\r\n<details>\r\n<summary>Crashes after making it to HW dialect:</summary>\r\n\r\n```\r\nfirtool: /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:190: void mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith(ValueT &&) [OperandType = mlir::OpOperand, ValueT = mlir::Value &]: Assertion `(!newValue || this != OperandType::getUseList(newValue)) && \"cannot RAUW a value with itself\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool wut.fir\r\n #0 0x00000000006c71bb llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x00000000006c5450 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x00000000006c786d SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007f882063dbf0 __restore_rt (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3dbf0)\r\n #4 0x00007f882068abc7 __pthread_kill_implementation (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x8abc7)\r\n #5 0x00007f882063db46 gsignal (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3db46)\r\n #6 0x00007f88206284b5 abort (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x284b5)\r\n #7 0x00007f88206283d9 _nl_load_domain.cold.0 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x283d9)\r\n #8 0x00007f88206367b6 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x367b6)\r\n #9 0x0000000000a5476c std::enable_if<!(std::is_convertible<mlir::ValueRange&, mlir::Operation*>::value), void>::type mlir::ResultRange::replaceAllUsesWith<mlir::ValueRange&>(mlir::ValueRange&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/ValueRange.h:271:5\r\n#10 0x0000000000a52ec3 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:275:61\r\n#11 0x0000000000c31cb7 circt::sv::WireOp::canonicalize(circt::sv::WireOp, mlir::PatternRewriter&) /home/will/src/sifive/circt/lib/Dialect/SV/SVOps.cpp:1460:18\r\n#12 0x0000000000e0ccb7 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25\r\n#13 0x0000000000dd93ed (anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:229:19\r\n#14 0x0000000000dd702d (anonymous namespace)::RegionPatternRewriteDriver::simplify() && /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:458:15\r\n#15 0x0000000000dd702d mlir::applyPatternsAndFoldGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:487:47\r\n#16 0x0000000000a66148 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#17 0x0000000000a66148 mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:115:70\r\n#18 0x0000000000a66148 (anonymous namespace)::Canonicalizer::runOnOperation() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:61:9\r\n#19 0x0000000000ee9829 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11\r\n#20 0x0000000000ee9e61 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#21 0x0000000000ee9e61 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#22 0x0000000000ee9e61 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#23 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::size() const /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:919:66\r\n#24 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1045:2\r\n#25 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5\r\n#26 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18\r\n#27 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#28 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14\r\n#29 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5\r\n#30 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14\r\n#31 0x0000000000eec3a3 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#32 0x0000000000eec3a3 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#33 0x0000000000eec3a3 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#34 0x0000000000eec3a3 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:843:10\r\n#35 0x0000000000eec3a3 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:823:60\r\n#36 0x000000000061a57b mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#37 0x000000000061a57b mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#38 0x000000000061a57b processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:856:7\r\n#39 0x00000000006182bf processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:12\r\n#40 0x0000000000617f42 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:968:12\r\n#41 0x0000000000617f42 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1058:14\r\n#42 0x00000000006179f6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#43 0x00000000006179f6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#44 0x00000000006179f6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1122:8\r\n#45 0x00007f882062924e __libc_start_call_main (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x2924e)\r\n#46 0x00007f8820629309 __libc_start_main@GLIBC_2.2.5 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x29309)\r\n#47 0x0000000000617825 _start (./build/bin/firtool+0x617825)\r\nzsh: IOT instruction (core dumped)  ./build/bin/firtool wut.fir\r\n```\r\n\r\n</details>\r\n\r\nDumping the IR shows this before the crash:\r\n\r\n```\r\n// -----// IR Dump Before Canonicalizer (canonicalize) //----- //\r\nhw.module @wut() -> (rwDataOut: i8) {\r\n  %.rwDataOut.output = sv.wire : !hw.inout<i8>\r\n  %0 = sv.read_inout %.rwDataOut.output : !hw.inout<i8>\r\n  sv.assign %.rwDataOut.output, %0 : i8\r\n  hw.output %0 : i8\r\n}\r\n```", "code_snippet_01": "circuit wut :\r\n   module wut :\r\n     output rwDataOut : UInt<8>\r\n\r\n     rwDataOut <= rwDataOut", "code_snippet_02": "firtool: /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:190: void mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith(ValueT &&) [OperandType = mlir::OpOperand, ValueT = mlir::Value &]: Assertion `(!newValue || this != OperandType::getUseList(newValue)) && \"cannot RAUW a value with itself\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool wut.fir\r\n #0 0x00000000006c71bb llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x00000000006c5450 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x00000000006c786d SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007f882063dbf0 __restore_rt (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3dbf0)\r\n #4 0x00007f882068abc7 __pthread_kill_implementation (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x8abc7)\r\n #5 0x00007f882063db46 gsignal (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3db46)\r\n #6 0x00007f88206284b5 abort (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x284b5)\r\n #7 0x00007f88206283d9 _nl_load_domain.cold.0 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x283d9)\r\n #8 0x00007f88206367b6 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x367b6)\r\n #9 0x0000000000a5476c std::enable_if<!(std::is_convertible<mlir::ValueRange&, mlir::Operation*>::value), void>::type mlir::ResultRange::replaceAllUsesWith<mlir::ValueRange&>(mlir::ValueRange&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/ValueRange.h:271:5\r\n#10 0x0000000000a52ec3 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:275:61\r\n#11 0x0000000000c31cb7 circt::sv::WireOp::canonicalize(circt::sv::WireOp, mlir::PatternRewriter&) /home/will/src/sifive/circt/lib/Dialect/SV/SVOps.cpp:1460:18\r\n#12 0x0000000000e0ccb7 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25\r\n#13 0x0000000000dd93ed (anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:229:19\r\n#14 0x0000000000dd702d (anonymous namespace)::RegionPatternRewriteDriver::simplify() && /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:458:15\r\n#15 0x0000000000dd702d mlir::applyPatternsAndFoldGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:487:47\r\n#16 0x0000000000a66148 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#17 0x0000000000a66148 mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:115:70\r\n#18 0x0000000000a66148 (anonymous namespace)::Canonicalizer::runOnOperation() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:61:9\r\n#19 0x0000000000ee9829 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11\r\n#20 0x0000000000ee9e61 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#21 0x0000000000ee9e61 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#22 0x0000000000ee9e61 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#23 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::size() const /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:919:66\r\n#24 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1045:2\r\n#25 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5\r\n#26 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18\r\n#27 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#28 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14\r\n#29 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5\r\n#30 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14\r\n#31 0x0000000000eec3a3 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#32 0x0000000000eec3a3 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#33 0x0000000000eec3a3 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#34 0x0000000000eec3a3 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:843:10\r\n#35 0x0000000000eec3a3 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:823:60\r\n#36 0x000000000061a57b mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#37 0x000000000061a57b mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#38 0x000000000061a57b processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:856:7\r\n#39 0x00000000006182bf processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:12\r\n#40 0x0000000000617f42 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:968:12\r\n#41 0x0000000000617f42 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1058:14\r\n#42 0x00000000006179f6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#43 0x00000000006179f6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#44 0x00000000006179f6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1122:8\r\n#45 0x00007f882062924e __libc_start_call_main (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x2924e)\r\n#46 0x00007f8820629309 __libc_start_main@GLIBC_2.2.5 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x29309)\r\n#47 0x0000000000617825 _start (./build/bin/firtool+0x617825)\r\nzsh: IOT instruction (core dumped)  ./build/bin/firtool wut.fir", "code_snippet_03": "// -----// IR Dump Before Canonicalizer (canonicalize) //----- //\r\nhw.module @wut() -> (rwDataOut: i8) {\r\n  %.rwDataOut.output = sv.wire : !hw.inout<i8>\r\n  %0 = sv.read_inout %.rwDataOut.output : !hw.inout<i8>\r\n  sv.assign %.rwDataOut.output, %0 : i8\r\n  hw.output %0 : i8\r\n}"}, {"number": 4771, "title": "[FIRRTL] attach of analog under when (+ subaccess)?", "created_at": "2023-03-06T14:58:23Z", "state": "open", "labels": "bug, FIRRTL", "body": "Generally, this may be more of a FIRRTL-spec consideration, but the following is accepted and only is rejected late in the pipeline:\r\n\r\n```firrtl\r\ncircuit Foo :\r\n  module Foo :\r\n    output d : { a: UInt<2>, b: Analog<1>}\r\n    input c : UInt<1>\r\n    d is invalid\r\n    when c :\r\n      inst b of Bar\r\n      attach(d.b, b.b.b[c])\r\n    else :\r\n      inst b2 of Bar\r\n      attach(d.b, b2.b.b[c])\r\n\r\n  extmodule Bar :\r\n    output b : { a : UInt<2>, b : Analog<1>[2]}\r\n ```\r\n \r\n Output:\r\n \r\n ```\r\nanalog.fir:11:11: error: operand isn't an inout type\r\n      d.b <- b2.b.b[c]\r\n          ^\r\nanalog.fir:11:11: note: see current operation: \"firrtl.attach\"(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()\r\nanalog.fir:11:11: error: 'firrtl.attach' op LowerToHW couldn't handle this operation\r\n      d.b <- b2.b.b[c]\r\n          ^\r\nanalog.fir:11:11: note: see current operation: \"firrtl.attach\"(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> () \r\n ```\r\n \r\n*Does conditional attach make sense?* (is it unconditional even under `when`?)\r\n", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    output d : { a: UInt<2>, b: Analog<1>}\r\n    input c : UInt<1>\r\n    d is invalid\r\n    when c :\r\n      inst b of Bar\r\n      attach(d.b, b.b.b[c])\r\n    else :\r\n      inst b2 of Bar\r\n      attach(d.b, b2.b.b[c])\r\n\r\n  extmodule Bar :\r\n    output b : { a : UInt<2>, b : Analog<1>[2]}", "code_snippet_02": "analog.fir:11:11: error: operand isn't an inout type\r\n      d.b <- b2.b.b[c]\r\n          ^\r\nanalog.fir:11:11: note: see current operation: \"firrtl.attach\"(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()\r\nanalog.fir:11:11: error: 'firrtl.attach' op LowerToHW couldn't handle this operation\r\n      d.b <- b2.b.b[c]\r\n          ^\r\nanalog.fir:11:11: note: see current operation: \"firrtl.attach\"(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()"}, {"number": 4770, "title": "[ExportVerilog] \"$name is not allowed in Verilog output\" error does not fail pass", "created_at": "2023-03-06T14:37:28Z", "state": "open", "labels": "bug, ExportVerilog", "body": "Encountered crafting test over here: https://github.com/llvm/circt/pull/4589#discussion_r1126488967 .\r\n\r\nIs currently reachable + executed as part of the `verilog-errors.mlir` test case:\r\n\r\n```mlir\r\nhw.module.extern @parameter ()\r\n```\r\n\r\n=>\r\n\r\n```\r\nverilog-error.mlir:4:1: error: name \"parameter\" is not allowed in Verilog output\r\nhw.module.extern @parameter ()\r\n^\r\nverilog-error.mlir:4:1: note: see current operation: \r\n\"hw.module.extern\"() ({\r\n}) {argLocs = [], argNames = [], comment = \"\", function_type = () -> (), parameters = [], resultLocs = [], resultNames = [], sym_name = \"parameter\"} : () -> ()\r\n// Generated by CIRCT 1.34.0g20230304_3ddf879\r\n// external module parameter\r\n```\r\n\r\nAs an aside, getting our error tests to check that pass/execution is not successful would be great, cc #4553 .", "code_snippet_01": "hw.module.extern @parameter ()", "code_snippet_02": "verilog-error.mlir:4:1: error: name \"parameter\" is not allowed in Verilog output\r\nhw.module.extern @parameter ()\r\n^\r\nverilog-error.mlir:4:1: note: see current operation: \r\n\"hw.module.extern\"() ({\r\n}) {argLocs = [], argNames = [], comment = \"\", function_type = () -> (), parameters = [], resultLocs = [], resultNames = [], sym_name = \"parameter\"} : () -> ()\r\n// Generated by CIRCT 1.34.0g20230304_3ddf879\r\n// external module parameter"}, {"number": 4753, "title": "[FIRRTL] Crash with out-of-bounds Index", "created_at": "2023-03-02T16:55:07Z", "state": "open", "labels": "bug, FIRRTL", "body": "I noticed that the following is crashing:\r\n\r\n```\r\ncircuit Foo:\r\n  module Foo:\r\n    input a: UInt<8>[3]\r\n    output b: UInt<8>\r\n\r\n    b <= a[UInt<99>(300)]\r\n```\r\n\r\nThis throws an error (doesn't exit) and then crashes (`firtool Foo.fir`):\r\n\r\n```\r\nFoo.fir:6:12: error: out of range index '300' in vector type '!firrtl.vector<uint<8>, 3>'\r\n    b <= a[UInt<99>(300)]\r\n           ^\r\nLLVM ERROR: Failed to infer result type(s).\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: firtool Foo.fir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x00000001039cf21d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x00000001039cf79b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x00000001039cd566 llvm::sys::RunSignalHandlers() + 134\r\n3  firtool                  0x00000001039d14cf SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff80f497dfd _sigtramp + 29\r\n5  firtool                  0x00000001037856e5 std::__1::__libcpp_deallocate(void*, unsigned long, unsigned long) + 85\r\n6  libsystem_c.dylib        0x00007ff80f3cdd24 abort + 123\r\n7  firtool                  0x000000010389f2d4 llvm::report_fatal_error(llvm::Twine const&, bool) + 388\r\n8  firtool                  0x000000010389f145 llvm::report_fatal_error(char const*, bool) + 53\r\n9  firtool                  0x000000010479c065 circt::firrtl::SubindexOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Value, unsigned int) + 533\r\n10 firtool                  0x0000000103ed526c circt::firrtl::SubindexOp mlir::OpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::Location, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 220\r\n11 firtool                  0x0000000103ed4fd1 circt::firrtl::SubindexOp mlir::ImplicitLocOpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 81\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input a: UInt<8>[3]\r\n    output b: UInt<8>\r\n\r\n    b <= a[UInt<99>(300)]", "code_snippet_02": "Foo.fir:6:12: error: out of range index '300' in vector type '!firrtl.vector<uint<8>, 3>'\r\n    b <= a[UInt<99>(300)]\r\n           ^\r\nLLVM ERROR: Failed to infer result type(s).\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: firtool Foo.fir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x00000001039cf21d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x00000001039cf79b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x00000001039cd566 llvm::sys::RunSignalHandlers() + 134\r\n3  firtool                  0x00000001039d14cf SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff80f497dfd _sigtramp + 29\r\n5  firtool                  0x00000001037856e5 std::__1::__libcpp_deallocate(void*, unsigned long, unsigned long) + 85\r\n6  libsystem_c.dylib        0x00007ff80f3cdd24 abort + 123\r\n7  firtool                  0x000000010389f2d4 llvm::report_fatal_error(llvm::Twine const&, bool) + 388\r\n8  firtool                  0x000000010389f145 llvm::report_fatal_error(char const*, bool) + 53\r\n9  firtool                  0x000000010479c065 circt::firrtl::SubindexOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Value, unsigned int) + 533\r\n10 firtool                  0x0000000103ed526c circt::firrtl::SubindexOp mlir::OpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::Location, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 220\r\n11 firtool                  0x0000000103ed4fd1 circt::firrtl::SubindexOp mlir::ImplicitLocOpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 81"}, {"number": 4734, "title": "[FIRRTL] Incorrect behavior for size == 1 CHIRRTL smems with write first read-under-write behavior", "created_at": "2023-02-28T00:06:36Z", "state": "closed", "labels": "bug, FIRRTL", "body": "h/t to @seldridge for helping me debug this.\r\n\r\n[Chisel is unable to use firtool v1.32.0](https://github.com/chipsalliance/chisel3/pull/3040) because of this change in behavior from firtool v1.31.0, presumably this is due to https://github.com/llvm/circt/pull/4687. According to https://github.com/llvm/circt/issues/4588, firtool officially does not support read-under-write modifiers for CHIRRTL mem constructs. But in practice, it implements all CHIRRTL smems as \"write first\". This behavior is relied upon by Chisel Queue and is the current behavior of firtool with the exception of when they have a size == 1.\r\n\r\nConsider the following simplified FIRRTL output from Chisel Queue with size == 1:\r\n```\r\ncircuit Queue :\r\n  module Queue :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}\r\n\r\n    smem ram : UInt<1> [1] new\r\n    reg full : UInt<1>, clock with :\r\n      reset => (reset, UInt<1>(\"h0\"))\r\n    io.count <= full\r\n    io.enq.ready <= not(full)\r\n    io.deq.valid <= full\r\n\r\n    node do_enq = and(io.enq.ready, io.enq.valid)\r\n    node do_deq = and(io.deq.ready, io.deq.valid)\r\n\r\n    when full :\r\n      full <= not(io.deq.ready)\r\n    else :\r\n      full <= io.enq.valid\r\n\r\n    when do_enq :\r\n      infer mport MPORT = ram[UInt<1>(\"h0\")], clock\r\n      MPORT <= io.enq.bits\r\n\r\n    read mport io_deq_bits_MPORT = ram[UInt<1>(\"h0\")], clock\r\n    io.deq.bits <= io_deq_bits_MPORT\r\n```\r\n\r\nUsing firtool 1.31.0 this compiles to\r\n```verilog\r\n// Generated by CIRCT firtool-1.31.0\r\nmodule ram_combMem(\r\n  input  R0_addr,\r\n         R0_en,\r\n         R0_clk,\r\n         W0_addr,\r\n         W0_en,\r\n         W0_clk,\r\n         W0_data,\r\n  output R0_data\r\n);\r\n\r\n  reg Memory[0:0];\r\n  reg _GEN;\r\n  reg _GEN_0;\r\n  always @(posedge R0_clk) begin\r\n    _GEN <= R0_en;\r\n    _GEN_0 <= R0_addr;\r\n  end // always @(posedge)\r\n  always @(posedge W0_clk) begin\r\n    if (W0_en)\r\n      Memory[W0_addr] <= W0_data;\r\n  end // always @(posedge)\r\n  assign R0_data = _GEN ? Memory[_GEN_0] : 1'bx;\r\nendmodule\r\n\r\nmodule Queue(\r\n  input  clock,\r\n         reset,\r\n         io_enq_valid,\r\n         io_enq_bits,\r\n         io_deq_ready,\r\n  output io_enq_ready,\r\n         io_deq_valid,\r\n         io_deq_bits,\r\n         io_count\r\n);\r\n\r\n  reg full;\r\n  always @(posedge clock) begin\r\n    if (reset)\r\n      full <= 1'h0;\r\n    else if (full)\r\n      full <= ~io_deq_ready;\r\n    else\r\n      full <= io_enq_valid;\r\n  end // always @(posedge)\r\n  ram_combMem ram_ext (\r\n    .R0_addr (1'h0),\r\n    .R0_en   (1'h1),\r\n    .R0_clk  (clock),\r\n    .W0_addr (1'h0),\r\n    .W0_en   (~full & io_enq_valid),\r\n    .W0_clk  (clock),\r\n    .W0_data (io_enq_bits),\r\n    .R0_data (io_deq_bits)\r\n  );\r\n  assign io_enq_ready = ~full;\r\n  assign io_deq_valid = full;\r\n  assign io_count = full;\r\nendmodule\r\n```\r\n\r\nUsing firtool 1.32.0 this compiles to:\r\n```verilog\r\n// Generated by CIRCT firtool-1.32.0\r\nmodule Queue(\r\n  input  clock,\r\n         reset,\r\n         io_enq_valid,\r\n         io_enq_bits,\r\n         io_deq_ready,\r\n  output io_enq_ready,\r\n         io_deq_valid,\r\n         io_deq_bits,\r\n         io_count\r\n);\r\n\r\n  reg ram;\r\n  reg ram_data_0;\r\n  reg full;\r\n  always @(posedge clock) begin\r\n    if (~full & io_enq_valid)\r\n      ram <= io_enq_bits;\r\n    ram_data_0 <= ram;\r\n    if (reset)\r\n      full <= 1'h0;\r\n    else if (full)\r\n      full <= ~io_deq_ready;\r\n    else\r\n      full <= io_enq_valid;\r\n  end // always @(posedge)\r\n  assign io_enq_ready = ~full;\r\n  assign io_deq_valid = full;\r\n  assign io_deq_bits = ram_data_0;\r\n  assign io_count = full;\r\nendmodule\r\n```\r\n\r\nThe firtool 1.32.0 output is much nicer but is not semantically equivalent since it is adding an extra cycle of latency from `io_enq_bits` to `io_deq_bits`.\r\n\r\nIt can also be nice to look at this change as a diff:\r\n```diff\r\ndiff --git a/test.1.31.0.v b/test.1.32.0.v\r\nindex 4569e6e48..3aa05a4a9 100644\r\n--- a/test.1.31.0.v\r\n+++ b/test.1.32.0.v\r\n@@ -1,29 +1,4 @@\r\n-// Generated by CIRCT firtool-1.31.0\r\n-module ram_combMem(\r\n-  input  R0_addr,\r\n-         R0_en,\r\n-         R0_clk,\r\n-         W0_addr,\r\n-         W0_en,\r\n-         W0_clk,\r\n-         W0_data,\r\n-  output R0_data\r\n-);\r\n-\r\n-  reg Memory[0:0];\r\n-  reg _GEN;\r\n-  reg _GEN_0;\r\n-  always @(posedge R0_clk) begin\r\n-    _GEN <= R0_en;\r\n-    _GEN_0 <= R0_addr;\r\n-  end // always @(posedge)\r\n-  always @(posedge W0_clk) begin\r\n-    if (W0_en)\r\n-      Memory[W0_addr] <= W0_data;\r\n-  end // always @(posedge)\r\n-  assign R0_data = _GEN ? Memory[_GEN_0] : 1'bx;\r\n-endmodule\r\n-\r\n+// Generated by CIRCT firtool-1.32.0\r\n module Queue(\r\n   input  clock,\r\n          reset,\r\n@@ -36,8 +11,13 @@ module Queue(\r\n          io_count\r\n );\r\n \r\n+  reg ram;\r\n+  reg ram_data_0;\r\n   reg full;\r\n   always @(posedge clock) begin\r\n+    if (~full & io_enq_valid)\r\n+      ram <= io_enq_bits;\r\n+    ram_data_0 <= ram;\r\n     if (reset)\r\n       full <= 1'h0;\r\n     else if (full)\r\n@@ -45,18 +25,9 @@ module Queue(\r\n     else\r\n       full <= io_enq_valid;\r\n   end // always @(posedge)\r\n-  ram_combMem ram_ext (\r\n-    .R0_addr (1'h0),\r\n-    .R0_en   (1'h1),\r\n-    .R0_clk  (clock),\r\n-    .W0_addr (1'h0),\r\n-    .W0_en   (~full & io_enq_valid),\r\n-    .W0_clk  (clock),\r\n-    .W0_data (io_enq_bits),\r\n-    .R0_data (io_deq_bits)\r\n-  );\r\n   assign io_enq_ready = ~full;\r\n   assign io_deq_valid = full;\r\n+  assign io_deq_bits = ram_data_0;\r\n   assign io_count = full;\r\n endmodule\r\n ```", "code_snippet_01": "circuit Queue :\r\n  module Queue :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output io : { flip enq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, deq : { flip ready : UInt<1>, valid : UInt<1>, bits : UInt<1>}, count : UInt<1>}\r\n\r\n    smem ram : UInt<1> [1] new\r\n    reg full : UInt<1>, clock with :\r\n      reset => (reset, UInt<1>(\"h0\"))\r\n    io.count <= full\r\n    io.enq.ready <= not(full)\r\n    io.deq.valid <= full\r\n\r\n    node do_enq = and(io.enq.ready, io.enq.valid)\r\n    node do_deq = and(io.deq.ready, io.deq.valid)\r\n\r\n    when full :\r\n      full <= not(io.deq.ready)\r\n    else :\r\n      full <= io.enq.valid\r\n\r\n    when do_enq :\r\n      infer mport MPORT = ram[UInt<1>(\"h0\")], clock\r\n      MPORT <= io.enq.bits\r\n\r\n    read mport io_deq_bits_MPORT = ram[UInt<1>(\"h0\")], clock\r\n    io.deq.bits <= io_deq_bits_MPORT", "code_snippet_02": "// Generated by CIRCT firtool-1.31.0\r\nmodule ram_combMem(\r\n  input  R0_addr,\r\n         R0_en,\r\n         R0_clk,\r\n         W0_addr,\r\n         W0_en,\r\n         W0_clk,\r\n         W0_data,\r\n  output R0_data\r\n);\r\n\r\n  reg Memory[0:0];\r\n  reg _GEN;\r\n  reg _GEN_0;\r\n  always @(posedge R0_clk) begin\r\n    _GEN <= R0_en;\r\n    _GEN_0 <= R0_addr;\r\n  end // always @(posedge)\r\n  always @(posedge W0_clk) begin\r\n    if (W0_en)\r\n      Memory[W0_addr] <= W0_data;\r\n  end // always @(posedge)\r\n  assign R0_data = _GEN ? Memory[_GEN_0] : 1'bx;\r\nendmodule\r\n\r\nmodule Queue(\r\n  input  clock,\r\n         reset,\r\n         io_enq_valid,\r\n         io_enq_bits,\r\n         io_deq_ready,\r\n  output io_enq_ready,\r\n         io_deq_valid,\r\n         io_deq_bits,\r\n         io_count\r\n);\r\n\r\n  reg full;\r\n  always @(posedge clock) begin\r\n    if (reset)\r\n      full <= 1'h0;\r\n    else if (full)\r\n      full <= ~io_deq_ready;\r\n    else\r\n      full <= io_enq_valid;\r\n  end // always @(posedge)\r\n  ram_combMem ram_ext (\r\n    .R0_addr (1'h0),\r\n    .R0_en   (1'h1),\r\n    .R0_clk  (clock),\r\n    .W0_addr (1'h0),\r\n    .W0_en   (~full & io_enq_valid),\r\n    .W0_clk  (clock),\r\n    .W0_data (io_enq_bits),\r\n    .R0_data (io_deq_bits)\r\n  );\r\n  assign io_enq_ready = ~full;\r\n  assign io_deq_valid = full;\r\n  assign io_count = full;\r\nendmodule", "code_snippet_03": "// Generated by CIRCT firtool-1.32.0\r\nmodule Queue(\r\n  input  clock,\r\n         reset,\r\n         io_enq_valid,\r\n         io_enq_bits,\r\n         io_deq_ready,\r\n  output io_enq_ready,\r\n         io_deq_valid,\r\n         io_deq_bits,\r\n         io_count\r\n);\r\n\r\n  reg ram;\r\n  reg ram_data_0;\r\n  reg full;\r\n  always @(posedge clock) begin\r\n    if (~full & io_enq_valid)\r\n      ram <= io_enq_bits;\r\n    ram_data_0 <= ram;\r\n    if (reset)\r\n      full <= 1'h0;\r\n    else if (full)\r\n      full <= ~io_deq_ready;\r\n    else\r\n      full <= io_enq_valid;\r\n  end // always @(posedge)\r\n  assign io_enq_ready = ~full;\r\n  assign io_deq_valid = full;\r\n  assign io_deq_bits = ram_data_0;\r\n  assign io_count = full;\r\nendmodule", "code_snippet_04": "diff --git a/test.1.31.0.v b/test.1.32.0.v\r\nindex 4569e6e48..3aa05a4a9 100644\r\n--- a/test.1.31.0.v\r\n+++ b/test.1.32.0.v\r\n@@ -1,29 +1,4 @@\r\n-// Generated by CIRCT firtool-1.31.0\r\n-module ram_combMem(\r\n-  input  R0_addr,\r\n-         R0_en,\r\n-         R0_clk,\r\n-         W0_addr,\r\n-         W0_en,\r\n-         W0_clk,\r\n-         W0_data,\r\n-  output R0_data\r\n-);\r\n-\r\n-  reg Memory[0:0];\r\n-  reg _GEN;\r\n-  reg _GEN_0;\r\n-  always @(posedge R0_clk) begin\r\n-    _GEN <= R0_en;\r\n-    _GEN_0 <= R0_addr;\r\n-  end // always @(posedge)\r\n-  always @(posedge W0_clk) begin\r\n-    if (W0_en)\r\n-      Memory[W0_addr] <= W0_data;\r\n-  end // always @(posedge)\r\n-  assign R0_data = _GEN ? Memory[_GEN_0] : 1'bx;\r\n-endmodule\r\n-\r\n+// Generated by CIRCT firtool-1.32.0\r\n module Queue(\r\n   input  clock,\r\n          reset,\r\n@@ -36,8 +11,13 @@ module Queue(\r\n          io_count\r\n );\r\n \r\n+  reg ram;\r\n+  reg ram_data_0;\r\n   reg full;\r\n   always @(posedge clock) begin\r\n+    if (~full & io_enq_valid)\r\n+      ram <= io_enq_bits;\r\n+    ram_data_0 <= ram;\r\n     if (reset)\r\n       full <= 1'h0;\r\n     else if (full)\r\n@@ -45,18 +25,9 @@ module Queue(\r\n     else\r\n       full <= io_enq_valid;\r\n   end // always @(posedge)\r\n-  ram_combMem ram_ext (\r\n-    .R0_addr (1'h0),\r\n-    .R0_en   (1'h1),\r\n-    .R0_clk  (clock),\r\n-    .W0_addr (1'h0),\r\n-    .W0_en   (~full & io_enq_valid),\r\n-    .W0_clk  (clock),\r\n-    .W0_data (io_enq_bits),\r\n-    .R0_data (io_deq_bits)\r\n-  );\r\n   assign io_enq_ready = ~full;\r\n   assign io_deq_valid = full;\r\n+  assign io_deq_bits = ram_data_0;\r\n   assign io_count = full;\r\n endmodule"}, {"number": 4680, "title": "Fix Combinational Component Builder", "created_at": "2023-02-19T21:59:03Z", "state": "closed", "labels": "bug, Calyx", "body": "This llvm bump [commit](https://github.com/llvm/circt/commit/88c5572224dcc4a631c22a197f2d2714bad33a30#diff-bbfc48ed5eafd91f51b04a279d09004575d95b14c830dbff851af86fc2169c94) broke building CombComponentOps using the `buildComponentLike` function. This PR fixes the issue by deciding to call a different `getFunctionTypeAttrName` function based on whether we are building a comb or regular component."}, {"number": 4634, "title": "[firtool] Stripping debug info causes \"block argument locations should match signature\"", "created_at": "2023-02-07T01:08:23Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Consider this dummy input:\r\n```mlir\r\n// loc-issue.mlir\r\nhw.module @Foo(%a: i1) -> () {}\r\n```\r\n\r\nRunning this through `firtool --strip-debug-info loc-issue.mlir` produces the error:\r\n```\r\n<unknown>:0: error: 'hw.module' op block argument locations should match signature locations\r\n<unknown>:0: note: see current operation:\r\n\"hw.module\"() ({\r\n^bb0(%arg0: i1):\r\n  \"hw.output\"() : () -> ()\r\n}) {\r\n  argLocs = [loc(\"loc-issue.mlir\":1:16)],\r\n  argNames = [\"a\"],\r\n  comment = \"\",\r\n  function_type = (i1) -> (),\r\n  parameters = [],\r\n  resultLocs = [],\r\n  resultNames = [],\r\n  sym_name = \"Foo\"\r\n} : () -> ()\r\n```\r\n(Stripping removes all the locations, but leaves the `argLocs` and `resultLocs` attributes unmodified.)\r\n\r\nRunning this through `firtool loc-issue.mlir` works and produces the expected:\r\n```verilog\r\n// Generated by CIRCT unknown git version\r\nmodule Foo(\t// loc-issue.mlir:1:1\r\n  input a\t// loc-issue.mlir:1:16\r\n);\r\n\r\nendmodule\r\n```", "code_snippet_01": "// loc-issue.mlir\r\nhw.module @Foo(%a: i1) -> () {}", "code_snippet_02": "<unknown>:0: error: 'hw.module' op block argument locations should match signature locations\r\n<unknown>:0: note: see current operation:\r\n\"hw.module\"() ({\r\n^bb0(%arg0: i1):\r\n  \"hw.output\"() : () -> ()\r\n}) {\r\n  argLocs = [loc(\"loc-issue.mlir\":1:16)],\r\n  argNames = [\"a\"],\r\n  comment = \"\",\r\n  function_type = (i1) -> (),\r\n  parameters = [],\r\n  resultLocs = [],\r\n  resultNames = [],\r\n  sym_name = \"Foo\"\r\n} : () -> ()", "code_snippet_03": "// Generated by CIRCT unknown git version\r\nmodule Foo(\t// loc-issue.mlir:1:1\r\n  input a\t// loc-issue.mlir:1:16\r\n);\r\n\r\nendmodule"}, {"number": 4631, "title": "[firtool] Strip Debug Info Crashing", "created_at": "2023-02-06T17:21:07Z", "state": "closed", "labels": "bug", "body": "FIRRTL source locators which do not match the debug info stripping predicate (\"ends with .fir\") seem to cause a crash.\r\n\r\nConsider:\r\n\r\n```\r\ncircuit Foo:\r\n  module Foo:\r\n    input a: UInt<1> @[Foo.scala 1:1]\r\n    output b: UInt<1> @[Foo.scala 2:1]\r\n\r\n    b <= a\r\n```\r\n\r\nRunning with `firtool -strip-debug-info Foo.fir` produces:\r\n\r\n```\r\n<unknown>:0: error: 'hw.module' op block argument locations should match signature locations\r\n<unknown>:0: note: see current operation: \r\n\"hw.module\"() ({\r\n^bb0(%arg0: i1):\r\n  \"hw.output\"(%arg0) : (i1) -> ()\r\n}) {argLocs = [loc(\"Foo.scala\":1:1)], argNames = [\"a\"], arg_attrs = [{}], comment = \"\", function_type = (i1) -> i1, parameters = [], res_attrs = [{}], resultLocs = [loc(\"Foo.scala\":2:1)], resultNames = [\"b\"], sym_name = \"Foo\"} : () -> ()\r\n```\r\n\r\nThe generic MLIR before the pass is:\r\n\r\n```mlir\r\n#loc = loc(\"Foo.scala\":1:1)\r\n#loc1 = loc(\"Foo.scala\":2:1)\r\n\"builtin.module\"() ({\r\n  \"hw.module\"() ({\r\n  ^bb0(%arg0: i1):\r\n    \"hw.output\"(%arg0) : (i1) -> ()\r\n  }) {argLocs = [#loc], argNames = [\"a\"], arg_attrs = [{}], comment = \"\", function_type = (i1) -> i1, parameters = [], res_attrs = [{}], resultLocs = [#loc1], resultNames = [\"b\"], sym_name = \"Foo\"} : () -> ()\r\n}) : () -> ()\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input a: UInt<1> @[Foo.scala 1:1]\r\n    output b: UInt<1> @[Foo.scala 2:1]\r\n\r\n    b <= a", "code_snippet_02": "<unknown>:0: error: 'hw.module' op block argument locations should match signature locations\r\n<unknown>:0: note: see current operation: \r\n\"hw.module\"() ({\r\n^bb0(%arg0: i1):\r\n  \"hw.output\"(%arg0) : (i1) -> ()\r\n}) {argLocs = [loc(\"Foo.scala\":1:1)], argNames = [\"a\"], arg_attrs = [{}], comment = \"\", function_type = (i1) -> i1, parameters = [], res_attrs = [{}], resultLocs = [loc(\"Foo.scala\":2:1)], resultNames = [\"b\"], sym_name = \"Foo\"} : () -> ()", "code_snippet_03": "#loc = loc(\"Foo.scala\":1:1)\r\n#loc1 = loc(\"Foo.scala\":2:1)\r\n\"builtin.module\"() ({\r\n  \"hw.module\"() ({\r\n  ^bb0(%arg0: i1):\r\n    \"hw.output\"(%arg0) : (i1) -> ()\r\n  }) {argLocs = [#loc], argNames = [\"a\"], arg_attrs = [{}], comment = \"\", function_type = (i1) -> i1, parameters = [], res_attrs = [{}], resultLocs = [#loc1], resultNames = [\"b\"], sym_name = \"Foo\"} : () -> ()\r\n}) : () -> ()"}, {"number": 4620, "title": "[FIRRTL] \"exprInEventControl\" not working for big designs", "created_at": "2023-02-03T23:04:24Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Hi, while we was trying to compile CY designs using CIRCT & push it through tools (Genus), we found bugs in CIRCT that prevents us from doing this : async resets are being emitted in a way that synthesis tools like Genus do not like.\r\nSpecifically, we get something of the form:\r\n```\r\n wire reset = ~_some_reset;\r\n always @(posedge clock or posedge reset)\r\n \tif (~_some_reset)\r\n \t\t...\r\n```\r\neven though we are using the `exprInEventControl` flag (related to ucb-bar/chipyard#1324)\r\n\r\nDo you have any ideas on how we can fix this issue?\r\n\r\nHere are the input files & commands to reproduce the issue.\r\n- Link to FIRRTL file\r\n(https://drive.google.com/file/d/1PVcPzgWd6xWPN7_rEkfovpgSWH6E6LBS/view?usp=share_link).\r\n\r\n- Compile command\r\n```\r\nfirtool \\\r\n   --lowering-options=emittedLineLength=2048,noAlwaysComb,exprInEventControl,disallowPackedArrays,disallowLocalVariables,explicitBitcast,verifLabels,locationInfoStyle=wrapInAtSquareBracket \\\r\n  chipyard.TestHarness.TinyRocketConfig.sfc.fir\r\n```\r\n\r\n- Problematic code is (120th line below the ChipTop module)\r\n```\r\n  wire        debug_reset_syncd = ~_debug_reset_syncd_debug_reset_sync_io_q;\t// @[Periphery.scala:288:40, ShiftReg.scala:45:23]\r\n  always @(posedge _system_auto_subsystem_cbus_fixedClockNode_out_clock or posedge debug_reset_syncd) begin\t// @[ChipTop.scala:28:35, Periphery.scala:288:40]\r\n    if (~_debug_reset_syncd_debug_reset_sync_io_q)\t// @[ChipTop.scala:28:35, Periphery.scala:288:40, ShiftReg.scala:45:23]\r\n      clock_en <= 1'h1;\t// @[Periphery.scala:296:29]\r\n    else\t// @[ChipTop.scala:28:35]\r\n      clock_en <= _dmactiveAck_dmactiveAck_io_q;\t// @[Periphery.scala:296:29, ShiftReg.scala:45:23]\r\n  end // always @(posedge, posedge)\r\n```", "code_snippet_01": "wire reset = ~_some_reset;\r\n always @(posedge clock or posedge reset)\r\n \tif (~_some_reset)\r\n \t\t...", "code_snippet_02": "firtool \\\r\n   --lowering-options=emittedLineLength=2048,noAlwaysComb,exprInEventControl,disallowPackedArrays,disallowLocalVariables,explicitBitcast,verifLabels,locationInfoStyle=wrapInAtSquareBracket \\\r\n  chipyard.TestHarness.TinyRocketConfig.sfc.fir", "code_snippet_03": "wire        debug_reset_syncd = ~_debug_reset_syncd_debug_reset_sync_io_q;\t// @[Periphery.scala:288:40, ShiftReg.scala:45:23]\r\n  always @(posedge _system_auto_subsystem_cbus_fixedClockNode_out_clock or posedge debug_reset_syncd) begin\t// @[ChipTop.scala:28:35, Periphery.scala:288:40]\r\n    if (~_debug_reset_syncd_debug_reset_sync_io_q)\t// @[ChipTop.scala:28:35, Periphery.scala:288:40, ShiftReg.scala:45:23]\r\n      clock_en <= 1'h1;\t// @[Periphery.scala:296:29]\r\n    else\t// @[ChipTop.scala:28:35]\r\n      clock_en <= _dmactiveAck_dmactiveAck_io_q;\t// @[Periphery.scala:296:29, ShiftReg.scala:45:23]\r\n  end // always @(posedge, posedge)"}, {"number": 4586, "title": "[FIRRTL] PrefixModules Not Duplicating Modules When Necessary", "created_at": "2023-01-25T01:29:48Z", "state": "open", "labels": "bug, FIRRTL", "body": "I hit a situation where `PrefixModules` should be duplicating modules, but it is not.\r\n\r\nConsider the following:\r\n\r\n```\r\ncircuit Top : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"target\":\"~Top|Foo\",\r\n    \"prefix\":\"A_\",\r\n    \"inclusive\":true\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"target\":\"~Top|Foo_1\",\r\n    \"prefix\":\"B_\",\r\n    \"inclusive\":true\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|Foo>in\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|Foo_1>in\"\r\n  }\r\n]]\r\n  module Foo :\r\n    input in : UInt<8>\r\n\r\n  module Foo_1 :\r\n    input in : UInt<8>\r\n\r\n  module Top :\r\n    input in : UInt<8>\r\n\r\n    inst f1 of Foo\r\n    inst f2 of Foo_1\r\n    f1.in <= in\r\n    f2.in <= in\r\n```\r\n\r\nIf I run this with `firtool -dedup`, I get the following Verilog:\r\n\r\n```verilog\r\nmodule A_Foo(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule Top(\r\n  input [7:0] in);\r\n\r\n  A_Foo f1 (\r\n    .in (in)\r\n  );\r\n  A_Foo f2 (\r\n    .in (in)\r\n  );\r\nendmodule\r\n```\r\n\r\nIf I run without dedup, I get two modules (expectedly):\r\n\r\n```verilog\r\nmodule A_Foo(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule B_Foo_1(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule Top(\r\n  input [7:0] in);\r\n\r\n  A_Foo f1 (\r\n    .in (in)\r\n  );\r\n  B_Foo_1 f2 (\r\n    .in (in)\r\n  );\r\nendmodule\r\n```\r\n\r\nBasically, I'm expecting to see both an `A_` and `B_` prefix in the output and I only get an `A_` prefix.", "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"target\":\"~Top|Foo\",\r\n    \"prefix\":\"A_\",\r\n    \"inclusive\":true\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"target\":\"~Top|Foo_1\",\r\n    \"prefix\":\"B_\",\r\n    \"inclusive\":true\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|Foo>in\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|Foo_1>in\"\r\n  }\r\n]]\r\n  module Foo :\r\n    input in : UInt<8>\r\n\r\n  module Foo_1 :\r\n    input in : UInt<8>\r\n\r\n  module Top :\r\n    input in : UInt<8>\r\n\r\n    inst f1 of Foo\r\n    inst f2 of Foo_1\r\n    f1.in <= in\r\n    f2.in <= in", "code_snippet_02": "module A_Foo(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule Top(\r\n  input [7:0] in);\r\n\r\n  A_Foo f1 (\r\n    .in (in)\r\n  );\r\n  A_Foo f2 (\r\n    .in (in)\r\n  );\r\nendmodule", "code_snippet_03": "module A_Foo(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule B_Foo_1(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule Top(\r\n  input [7:0] in);\r\n\r\n  A_Foo f1 (\r\n    .in (in)\r\n  );\r\n  B_Foo_1 f2 (\r\n    .in (in)\r\n  );\r\nendmodule"}, {"number": 4584, "title": "[FIRRTL] Raw Param Difference vs. SFC", "created_at": "2023-01-24T22:34:55Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Currently, CIRCT will squash \"raw\" FIRRTL external module parameters into string parameters. This produces a difference with the SFC. Consider:\r\n\r\n```\r\ncircuit Foo:\r\n  extmodule Bar:\r\n    output a: UInt<1>\r\n    parameter foo = 'hello'\r\n    parameter bar = \"world\"\r\n\r\n  module Foo:\r\n    output a: UInt<1>\r\n\r\n    inst bar of Bar\r\n    a <= bar.a\r\n```\r\n\r\nThis compiles with CIRCT to:\r\n\r\n```verilog\r\nmodule Foo(\r\n  output a);\r\n\r\n  Bar #(\r\n    .foo(\"hello\"),\r\n    .bar(\"world\")\r\n  ) bar (\r\n    .a (a)\r\n  );\r\nendmodule\r\n```\r\n\r\nWith SFC, this produces:\r\n\r\n```verilog\r\nmodule Foo(\r\n  output  a\r\n);\r\n  wire  bar_a;\r\n  Bar #(.foo(hello), .bar(\"world\")) bar (\r\n    .a(bar_a)\r\n  );\r\n  assign a = bar_a;\r\nendmodule\r\n```", "code_snippet_01": "circuit Foo:\r\n  extmodule Bar:\r\n    output a: UInt<1>\r\n    parameter foo = 'hello'\r\n    parameter bar = \"world\"\r\n\r\n  module Foo:\r\n    output a: UInt<1>\r\n\r\n    inst bar of Bar\r\n    a <= bar.a", "code_snippet_02": "module Foo(\r\n  output a);\r\n\r\n  Bar #(\r\n    .foo(\"hello\"),\r\n    .bar(\"world\")\r\n  ) bar (\r\n    .a (a)\r\n  );\r\nendmodule", "code_snippet_03": "module Foo(\r\n  output  a\r\n);\r\n  wire  bar_a;\r\n  Bar #(.foo(hello), .bar(\"world\")) bar (\r\n    .a(bar_a)\r\n  );\r\n  assign a = bar_a;\r\nendmodule"}, {"number": 4564, "title": "[FIRRTL] Parsing broken for \"an instance called module\"", "created_at": "2023-01-20T23:43:10Z", "state": "closed", "labels": "bug, FIRRTL", "body": "FIRRTL parsing is broken for the following circuit:\r\n\r\n```\r\ncircuit Foo:\r\n  module Bar:\r\n    skip\r\n\r\n  module Foo:\r\n\r\n    inst module of Bar\r\n```\r\n\r\nThe parser thinks that `module` has to be the first token when it can be an identifier:\r\n\r\n```\r\nbuild/Bar.fir:7:10: error: 'module' must be first token on its line\r\n    inst module of Bar\r\n         ^\r\n```\r\n\r\nh/t @chick for finding this one.", "code_snippet_01": "circuit Foo:\r\n  module Bar:\r\n    skip\r\n\r\n  module Foo:\r\n\r\n    inst module of Bar", "code_snippet_02": "build/Bar.fir:7:10: error: 'module' must be first token on its line\r\n    inst module of Bar\r\n         ^"}, {"number": 4554, "title": "[FIRRTL] Mark DUT AddSeqMemPorts ports dontTouch", "created_at": "2023-01-18T21:27:32Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Change the AddSeqMemPorts pass to mark ports created on the DUT (or the\r\ntop module) with DontTouchAnnotations.  This is done to avoid having\r\nthese ports be deleted.  This is currently a problem for output ports\r\nthat the pass creates and bores upwards.  The final instance port of the\r\nDUT does not have a user which causes all the ports (except the one on\r\nthe memory) to be deletion candidates.\r\n\r\nSigned-off-by: Schuyler Eldridge <schuyler.eldridge@sifive.com>\r\n\r\n### Example\r\n\r\nAn end-to-end example showing the problem is the following circuit:\r\n\r\n```firrtl\r\ncircuit TestHarness : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"TestHarness.DUTModule\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.AddSeqMemPortsFileAnnotation\",\r\n    \"filename\":\"SeqMems.txt\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.AddSeqMemPortAnnotation\",\r\n    \"name\":\"foo\",\r\n    \"input\":false,\r\n    \"width\":16\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.AddSeqMemPortAnnotation\",\r\n    \"name\":\"bar\",\r\n    \"input\":true,\r\n    \"width\":32\r\n  }\r\n]]\r\n  module DUTModule :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    smem mem : UInt<8> [8]\r\n    infer mport read = mem[io.addr], clock\r\n    io.dataOut <= read\r\n    when io.wen :\r\n      infer mport write = mem[io.addr], clock\r\n      write <= io.dataIn\r\n\r\n  module TestHarness :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    inst dut of DUTModule\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    io.dataOut <= dut.io.dataOut\r\n    dut.io.wen <= io.wen\r\n    dut.io.dataIn <= io.dataIn\r\n    dut.io.addr <= io.addr\r\n```\r\n\r\nWithout this PR, this compiles to:\r\n\r\n```verilog\r\n// Generated by CIRCT unknown git version\r\nmodule DUTModule(\r\n  input         clock,\r\n  input  [2:0]  io_addr,\r\n  input  [7:0]  io_dataIn,\r\n  input         io_wen,\r\n  input  [31:0] sram_0_bar,\r\n  output [7:0]  io_dataOut);\r\n\r\n  mem mem (\r\n    .R0_addr    (io_addr),\r\n    .R0_clk     (clock),\r\n    .W0_addr    (io_addr),\r\n    .W0_en      (io_wen),\r\n    .W0_clk     (clock),\r\n    .W0_data    (io_dataIn),\r\n    .sram_0_bar (sram_0_bar),\r\n    .R0_data    (io_dataOut)\r\n  );\r\nendmodule\r\n\r\nmodule TestHarness(\r\n  input        clock,\r\n               reset,\r\n  input  [2:0] io_addr,\r\n  input  [7:0] io_dataIn,\r\n  input        io_wen,\r\n  output [7:0] io_dataOut);\r\n\r\n  DUTModule dut (\r\n    .clock      (clock),\r\n    .io_addr    (io_addr),\r\n    .io_dataIn  (io_dataIn),\r\n    .io_wen     (io_wen),\r\n    .sram_0_bar (32'h0),\r\n    .io_dataOut (io_dataOut)\r\n  );\r\nendmodule\r\n\r\nmodule mem(\r\n  input  [2:0]  R0_addr,\r\n  input         R0_clk,\r\n  input  [2:0]  W0_addr,\r\n  input         W0_en,\r\n                W0_clk,\r\n  input  [7:0]  W0_data,\r\n  input  [31:0] sram_0_bar,\r\n  output [7:0]  R0_data);\r\n\r\n  wire [15:0] _mem_ext_foo;\r\n  mem_ext mem_ext (\r\n    .R0_addr (R0_addr),\r\n    .R0_en   (1'h1),\r\n    .R0_clk  (R0_clk),\r\n    .W0_addr (W0_addr),\r\n    .W0_en   (W0_en),\r\n    .W0_clk  (W0_clk),\r\n    .W0_data (W0_data),\r\n    .bar     (sram_0_bar),\r\n    .R0_data (R0_data),\r\n    .foo     (_mem_ext_foo)\r\n  );\r\nendmodule\r\n\r\n// external module mem_ext\r\n```\r\n\r\nWith this PR, this compiles to:\r\n```verilog\r\n// Generated by CIRCT unknown git version\r\nmodule DUTModule(\r\n  input         clock,\r\n  input  [2:0]  io_addr,\r\n  input  [7:0]  io_dataIn,\r\n  input         io_wen,\r\n  input  [31:0] sram_0_bar,\r\n  output [7:0]  io_dataOut,\r\n  output [15:0] sram_0_foo);\r\n\r\n  mem mem (\r\n    .R0_addr    (io_addr),\r\n    .R0_clk     (clock),\r\n    .W0_addr    (io_addr),\r\n    .W0_en      (io_wen),\r\n    .W0_clk     (clock),\r\n    .W0_data    (io_dataIn),\r\n    .sram_0_bar (sram_0_bar),\r\n    .R0_data    (io_dataOut),\r\n    .sram_0_foo (sram_0_foo)\r\n  );\r\nendmodule\r\n\r\nmodule TestHarness(\r\n  input        clock,\r\n               reset,\r\n  input  [2:0] io_addr,\r\n  input  [7:0] io_dataIn,\r\n  input        io_wen,\r\n  output [7:0] io_dataOut);\r\n\r\n  wire [15:0] _dut_sram_0_foo;\r\n  DUTModule dut (\r\n    .clock      (clock),\r\n    .io_addr    (io_addr),\r\n    .io_dataIn  (io_dataIn),\r\n    .io_wen     (io_wen),\r\n    .sram_0_bar (32'h0),\r\n    .io_dataOut (io_dataOut),\r\n    .sram_0_foo (_dut_sram_0_foo)\r\n  );\r\nendmodule\r\n\r\nmodule mem(\r\n  input  [2:0]  R0_addr,\r\n  input         R0_clk,\r\n  input  [2:0]  W0_addr,\r\n  input         W0_en,\r\n                W0_clk,\r\n  input  [7:0]  W0_data,\r\n  input  [31:0] sram_0_bar,\r\n  output [7:0]  R0_data,\r\n  output [15:0] sram_0_foo);\r\n\r\n  mem_ext mem_ext (\r\n    .R0_addr (R0_addr),\r\n    .R0_en   (1'h1),\r\n    .R0_clk  (R0_clk),\r\n    .W0_addr (W0_addr),\r\n    .W0_en   (W0_en),\r\n    .W0_clk  (W0_clk),\r\n    .W0_data (W0_data),\r\n    .bar     (sram_0_bar),\r\n    .R0_data (R0_data),\r\n    .foo     (sram_0_foo)\r\n  );\r\nendmodule\r\n\r\n// external module mem_ext\r\n```\r\n\r\nDiff:\r\n\r\n```diff\r\ndiff --git a/Foo.old.sv b/Foo.new.sv\r\nindex aab54df64..beb951ea0 100644\r\n--- a/Foo.old.sv\r\n+++ b/Foo.new.sv\r\n@@ -5,7 +5,8 @@ module DUTModule(\r\n   input  [7:0]  io_dataIn,\r\n   input         io_wen,\r\n   input  [31:0] sram_0_bar,\r\n-  output [7:0]  io_dataOut);\r\n+  output [7:0]  io_dataOut,\r\n+  output [15:0] sram_0_foo);\r\n \r\n   mem mem (\r\n     .R0_addr    (io_addr),\r\n@@ -15,7 +16,8 @@ module DUTModule(\r\n     .W0_clk     (clock),\r\n     .W0_data    (io_dataIn),\r\n     .sram_0_bar (sram_0_bar),\r\n-    .R0_data    (io_dataOut)\r\n+    .R0_data    (io_dataOut),\r\n+    .sram_0_foo (sram_0_foo)\r\n   );\r\n endmodule\r\n \r\n@@ -27,13 +29,15 @@ module TestHarness(\r\n   input        io_wen,\r\n   output [7:0] io_dataOut);\r\n \r\n+  wire [15:0] _dut_sram_0_foo;\r\n   DUTModule dut (\r\n     .clock      (clock),\r\n     .io_addr    (io_addr),\r\n     .io_dataIn  (io_dataIn),\r\n     .io_wen     (io_wen),\r\n     .sram_0_bar (32'h0),\r\n-    .io_dataOut (io_dataOut)\r\n+    .io_dataOut (io_dataOut),\r\n+    .sram_0_foo (_dut_sram_0_foo)\r\n   );\r\n endmodule\r\n \r\n@@ -45,9 +49,9 @@ module mem(\r\n                 W0_clk,\r\n   input  [7:0]  W0_data,\r\n   input  [31:0] sram_0_bar,\r\n-  output [7:0]  R0_data);\r\n+  output [7:0]  R0_data,\r\n+  output [15:0] sram_0_foo);\r\n \r\n-  wire [15:0] _mem_ext_foo;\r\n   mem_ext mem_ext (\r\n     .R0_addr (R0_addr),\r\n     .R0_en   (1'h1),\r\n@@ -58,7 +62,7 @@ module mem(\r\n     .W0_data (W0_data),\r\n     .bar     (sram_0_bar),\r\n     .R0_data (R0_data),\r\n-    .foo     (_mem_ext_foo)\r\n+    .foo     (sram_0_foo)\r\n   );\r\n endmodule\r\n```", "code_snippet_01": "circuit TestHarness : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"TestHarness.DUTModule\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.AddSeqMemPortsFileAnnotation\",\r\n    \"filename\":\"SeqMems.txt\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.AddSeqMemPortAnnotation\",\r\n    \"name\":\"foo\",\r\n    \"input\":false,\r\n    \"width\":16\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.AddSeqMemPortAnnotation\",\r\n    \"name\":\"bar\",\r\n    \"input\":true,\r\n    \"width\":32\r\n  }\r\n]]\r\n  module DUTModule :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    smem mem : UInt<8> [8]\r\n    infer mport read = mem[io.addr], clock\r\n    io.dataOut <= read\r\n    when io.wen :\r\n      infer mport write = mem[io.addr], clock\r\n      write <= io.dataIn\r\n\r\n  module TestHarness :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    inst dut of DUTModule\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    io.dataOut <= dut.io.dataOut\r\n    dut.io.wen <= io.wen\r\n    dut.io.dataIn <= io.dataIn\r\n    dut.io.addr <= io.addr", "code_snippet_02": "// Generated by CIRCT unknown git version\r\nmodule DUTModule(\r\n  input         clock,\r\n  input  [2:0]  io_addr,\r\n  input  [7:0]  io_dataIn,\r\n  input         io_wen,\r\n  input  [31:0] sram_0_bar,\r\n  output [7:0]  io_dataOut);\r\n\r\n  mem mem (\r\n    .R0_addr    (io_addr),\r\n    .R0_clk     (clock),\r\n    .W0_addr    (io_addr),\r\n    .W0_en      (io_wen),\r\n    .W0_clk     (clock),\r\n    .W0_data    (io_dataIn),\r\n    .sram_0_bar (sram_0_bar),\r\n    .R0_data    (io_dataOut)\r\n  );\r\nendmodule\r\n\r\nmodule TestHarness(\r\n  input        clock,\r\n               reset,\r\n  input  [2:0] io_addr,\r\n  input  [7:0] io_dataIn,\r\n  input        io_wen,\r\n  output [7:0] io_dataOut);\r\n\r\n  DUTModule dut (\r\n    .clock      (clock),\r\n    .io_addr    (io_addr),\r\n    .io_dataIn  (io_dataIn),\r\n    .io_wen     (io_wen),\r\n    .sram_0_bar (32'h0),\r\n    .io_dataOut (io_dataOut)\r\n  );\r\nendmodule\r\n\r\nmodule mem(\r\n  input  [2:0]  R0_addr,\r\n  input         R0_clk,\r\n  input  [2:0]  W0_addr,\r\n  input         W0_en,\r\n                W0_clk,\r\n  input  [7:0]  W0_data,\r\n  input  [31:0] sram_0_bar,\r\n  output [7:0]  R0_data);\r\n\r\n  wire [15:0] _mem_ext_foo;\r\n  mem_ext mem_ext (\r\n    .R0_addr (R0_addr),\r\n    .R0_en   (1'h1),\r\n    .R0_clk  (R0_clk),\r\n    .W0_addr (W0_addr),\r\n    .W0_en   (W0_en),\r\n    .W0_clk  (W0_clk),\r\n    .W0_data (W0_data),\r\n    .bar     (sram_0_bar),\r\n    .R0_data (R0_data),\r\n    .foo     (_mem_ext_foo)\r\n  );\r\nendmodule\r\n\r\n// external module mem_ext", "code_snippet_03": "// Generated by CIRCT unknown git version\r\nmodule DUTModule(\r\n  input         clock,\r\n  input  [2:0]  io_addr,\r\n  input  [7:0]  io_dataIn,\r\n  input         io_wen,\r\n  input  [31:0] sram_0_bar,\r\n  output [7:0]  io_dataOut,\r\n  output [15:0] sram_0_foo);\r\n\r\n  mem mem (\r\n    .R0_addr    (io_addr),\r\n    .R0_clk     (clock),\r\n    .W0_addr    (io_addr),\r\n    .W0_en      (io_wen),\r\n    .W0_clk     (clock),\r\n    .W0_data    (io_dataIn),\r\n    .sram_0_bar (sram_0_bar),\r\n    .R0_data    (io_dataOut),\r\n    .sram_0_foo (sram_0_foo)\r\n  );\r\nendmodule\r\n\r\nmodule TestHarness(\r\n  input        clock,\r\n               reset,\r\n  input  [2:0] io_addr,\r\n  input  [7:0] io_dataIn,\r\n  input        io_wen,\r\n  output [7:0] io_dataOut);\r\n\r\n  wire [15:0] _dut_sram_0_foo;\r\n  DUTModule dut (\r\n    .clock      (clock),\r\n    .io_addr    (io_addr),\r\n    .io_dataIn  (io_dataIn),\r\n    .io_wen     (io_wen),\r\n    .sram_0_bar (32'h0),\r\n    .io_dataOut (io_dataOut),\r\n    .sram_0_foo (_dut_sram_0_foo)\r\n  );\r\nendmodule\r\n\r\nmodule mem(\r\n  input  [2:0]  R0_addr,\r\n  input         R0_clk,\r\n  input  [2:0]  W0_addr,\r\n  input         W0_en,\r\n                W0_clk,\r\n  input  [7:0]  W0_data,\r\n  input  [31:0] sram_0_bar,\r\n  output [7:0]  R0_data,\r\n  output [15:0] sram_0_foo);\r\n\r\n  mem_ext mem_ext (\r\n    .R0_addr (R0_addr),\r\n    .R0_en   (1'h1),\r\n    .R0_clk  (R0_clk),\r\n    .W0_addr (W0_addr),\r\n    .W0_en   (W0_en),\r\n    .W0_clk  (W0_clk),\r\n    .W0_data (W0_data),\r\n    .bar     (sram_0_bar),\r\n    .R0_data (R0_data),\r\n    .foo     (sram_0_foo)\r\n  );\r\nendmodule\r\n\r\n// external module mem_ext", "code_snippet_04": "diff --git a/Foo.old.sv b/Foo.new.sv\r\nindex aab54df64..beb951ea0 100644\r\n--- a/Foo.old.sv\r\n+++ b/Foo.new.sv\r\n@@ -5,7 +5,8 @@ module DUTModule(\r\n   input  [7:0]  io_dataIn,\r\n   input         io_wen,\r\n   input  [31:0] sram_0_bar,\r\n-  output [7:0]  io_dataOut);\r\n+  output [7:0]  io_dataOut,\r\n+  output [15:0] sram_0_foo);\r\n \r\n   mem mem (\r\n     .R0_addr    (io_addr),\r\n@@ -15,7 +16,8 @@ module DUTModule(\r\n     .W0_clk     (clock),\r\n     .W0_data    (io_dataIn),\r\n     .sram_0_bar (sram_0_bar),\r\n-    .R0_data    (io_dataOut)\r\n+    .R0_data    (io_dataOut),\r\n+    .sram_0_foo (sram_0_foo)\r\n   );\r\n endmodule\r\n \r\n@@ -27,13 +29,15 @@ module TestHarness(\r\n   input        io_wen,\r\n   output [7:0] io_dataOut);\r\n \r\n+  wire [15:0] _dut_sram_0_foo;\r\n   DUTModule dut (\r\n     .clock      (clock),\r\n     .io_addr    (io_addr),\r\n     .io_dataIn  (io_dataIn),\r\n     .io_wen     (io_wen),\r\n     .sram_0_bar (32'h0),\r\n-    .io_dataOut (io_dataOut)\r\n+    .io_dataOut (io_dataOut),\r\n+    .sram_0_foo (_dut_sram_0_foo)\r\n   );\r\n endmodule\r\n \r\n@@ -45,9 +49,9 @@ module mem(\r\n                 W0_clk,\r\n   input  [7:0]  W0_data,\r\n   input  [31:0] sram_0_bar,\r\n-  output [7:0]  R0_data);\r\n+  output [7:0]  R0_data,\r\n+  output [15:0] sram_0_foo);\r\n \r\n-  wire [15:0] _mem_ext_foo;\r\n   mem_ext mem_ext (\r\n     .R0_addr (R0_addr),\r\n     .R0_en   (1'h1),\r\n@@ -58,7 +62,7 @@ module mem(\r\n     .W0_data (W0_data),\r\n     .bar     (sram_0_bar),\r\n     .R0_data (R0_data),\r\n-    .foo     (_mem_ext_foo)\r\n+    .foo     (sram_0_foo)\r\n   );\r\n endmodule"}, {"number": 4485, "title": "[ExportVerilog] Assertion Firing for icmp -> sampled", "created_at": "2022-12-24T01:34:15Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "I stumbled across the following assertion failure due to prepare for emission not generating a wire for an `icmp` operation.\r\n\r\nConsider:\r\n\r\n```mlir\r\nmodule {\r\n  hw.module @Top() {\r\n    %c0_i4 = hw.constant 0 : i4\r\n    %v = sv.reg  {sv.namehint = \"value\"} : !hw.inout<i4>\r\n    %0 = sv.read_inout %v : !hw.inout<i4>\r\n    %1 = comb.icmp eq %0, %c0_i4 {sv.namehint = \"foo\"} : i4\r\n    %2 = sv.system.sampled %1 : i1\r\n    hw.output\r\n  }\r\n}\r\n```\r\n\r\nCompiling this with `circt-opt Tmp.mlir -export-verilog` produces a nice crash:\r\n\r\n```\r\n# circt-opt Tmp.mlir -export-verilog\r\nAssertion failed: ((!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options)) && \"If 'op' is a verilog expression, the expression must be inlinable. \" \"Otherwise, it is a bug of PrepareForEmission\"), function collectNames, file ExportVerilog.cpp, line 2895.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  circt-opt                0x0000000102eb930d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  circt-opt                0x0000000102eb988b PrintStackTraceSignalHandler(void*) + 27\r\n2  circt-opt                0x0000000102eb7696 llvm::sys::RunSignalHandlers() + 134\r\n3  circt-opt                0x0000000102ebb5bf SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff81f38fdfd _sigtramp + 29\r\n5  circt-opt                0x0000000104f1b3cd std::__1::__optional_storage_base<mlir::RegisteredOperationName, false>::__optional_storage_base<mlir::RegisteredOperationName>(std::__1::in_place_t, mlir::RegisteredOperationName&&) + 29\r\n6  libsystem_c.dylib        0x00007ff81f2c5d24 abort + 123\r\n7  libsystem_c.dylib        0x00007ff81f2c50cb err + 0\r\n8  circt-opt                0x0000000103213bb3 (anonymous namespace)::NameCollector::collectNames(mlir::Block&) + 947\r\n9  circt-opt                0x0000000103213576 (anonymous namespace)::StmtEmitter::collectNamesAndCalculateDeclarationWidths(mlir::Block&) + 54\r\n10 circt-opt                0x0000000103213483 (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31::operator()() const + 115\r\n11 circt-opt                0x0000000103213405 decltype(static_cast<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>(fp)()) std::__1::__invoke<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>((anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31&&) + 21\r\n12 circt-opt                0x000000010321332d std::__1::invoke_result<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>::type std::__1::invoke<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>((anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31&&) + 29\r\n13 circt-opt                0x00000001032132b6 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>(circt::pretty::PP&&, (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31&&, circt::pretty::Token) + 102\r\n14 circt-opt                0x0000000103203cc4 (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&) + 116\r\n15 circt-opt                0x00000001032027b1 (anonymous namespace)::ModuleEmitter::emitHWModule(circt::hw::HWModuleOp) + 2897\r\n16 circt-opt                0x0000000103201c14 auto emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*)::$_101::operator()<circt::hw::HWModuleOp>(circt::hw::HWModuleOp) const + 68\r\n17 circt-opt                0x000000010320186b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::hw::HWModuleOp, emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*)::$_101>(emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*)::$_101&&) + 107\r\n18 circt-opt                0x00000001031fa415 emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*) + 53\r\n19 circt-opt                0x0000000103277586 circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46::operator()(circt::ExportVerilog::StringOrOpToEmit&) const + 278\r\n20 circt-opt                0x0000000103277380 auto void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)::operator()<circt::ExportVerilog::StringOrOpToEmit&>(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&) const + 48\r\n21 circt-opt                0x0000000103279259 mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()::operator()() const + 169\r\n22 circt-opt                0x00000001032791a5 decltype(static_cast<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>>(fp)()) std::__1::__invoke<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()&>(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&) + 21\r\n23 circt-opt                0x000000010327915d void std::__1::__invoke_void_return_wrapper<void, true>::__call<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()&>(mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()&) + 29\r\n24 circt-opt                0x000000010327912d std::__1::__function::__alloc_func<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()>, void ()>::operator()() + 29\r\n25 circt-opt                0x0000000103278179 std::__1::__function::__func<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()>, void ()>::operator()() + 25\r\n26 circt-opt                0x0000000104fea852 std::__1::__function::__value_func<void ()>::operator()() const + 50\r\n27 circt-opt                0x0000000104fea815 std::__1::function<void ()>::operator()() const + 21\r\n28 circt-opt                0x0000000104fea7dd llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()::operator()() const + 29\r\n29 circt-opt                0x0000000104fea7a5 decltype(static_cast<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(fp)()) std::__1::__invoke<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 21\r\n30 circt-opt                0x0000000104fea75d void std::__1::__invoke_void_return_wrapper<void, true>::__call<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 29\r\n31 circt-opt                0x0000000104fea72d std::__1::__function::__alloc_func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 29\r\n32 circt-opt                0x0000000104fe9519 std::__1::__function::__func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 25\r\n33 circt-opt                0x0000000104fea852 std::__1::__function::__value_func<void ()>::operator()() const + 50\r\n34 circt-opt                0x0000000104fea815 std::__1::function<void ()>::operator()() const + 21\r\n35 circt-opt                0x0000000102e0cc92 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) + 546\r\n36 circt-opt                0x0000000102e10373 llvm::ThreadPool::grow(int)::$_0::operator()() const + 51\r\n37 circt-opt                0x0000000102e10305 void llvm::thread::Apply<llvm::ThreadPool::grow(int)::$_0>(std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::__1::integer_sequence<unsigned long>) + 37\r\n38 circt-opt                0x0000000102e102c3 void llvm::thread::GenericThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 51\r\n39 circt-opt                0x0000000102e0fff5 void* llvm::thread::ThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 21\r\n40 libsystem_pthread.dylib  0x00007ff81f37a4e1 _pthread_start + 125\r\n41 libsystem_pthread.dylib  0x00007ff81f375f6b thread_start + 15\r\n```", "code_snippet_01": "module {\r\n  hw.module @Top() {\r\n    %c0_i4 = hw.constant 0 : i4\r\n    %v = sv.reg  {sv.namehint = \"value\"} : !hw.inout<i4>\r\n    %0 = sv.read_inout %v : !hw.inout<i4>\r\n    %1 = comb.icmp eq %0, %c0_i4 {sv.namehint = \"foo\"} : i4\r\n    %2 = sv.system.sampled %1 : i1\r\n    hw.output\r\n  }\r\n}", "code_snippet_02": "# circt-opt Tmp.mlir -export-verilog\r\nAssertion failed: ((!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options)) && \"If 'op' is a verilog expression, the expression must be inlinable. \" \"Otherwise, it is a bug of PrepareForEmission\"), function collectNames, file ExportVerilog.cpp, line 2895.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  circt-opt                0x0000000102eb930d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  circt-opt                0x0000000102eb988b PrintStackTraceSignalHandler(void*) + 27\r\n2  circt-opt                0x0000000102eb7696 llvm::sys::RunSignalHandlers() + 134\r\n3  circt-opt                0x0000000102ebb5bf SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff81f38fdfd _sigtramp + 29\r\n5  circt-opt                0x0000000104f1b3cd std::__1::__optional_storage_base<mlir::RegisteredOperationName, false>::__optional_storage_base<mlir::RegisteredOperationName>(std::__1::in_place_t, mlir::RegisteredOperationName&&) + 29\r\n6  libsystem_c.dylib        0x00007ff81f2c5d24 abort + 123\r\n7  libsystem_c.dylib        0x00007ff81f2c50cb err + 0\r\n8  circt-opt                0x0000000103213bb3 (anonymous namespace)::NameCollector::collectNames(mlir::Block&) + 947\r\n9  circt-opt                0x0000000103213576 (anonymous namespace)::StmtEmitter::collectNamesAndCalculateDeclarationWidths(mlir::Block&) + 54\r\n10 circt-opt                0x0000000103213483 (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31::operator()() const + 115\r\n11 circt-opt                0x0000000103213405 decltype(static_cast<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>(fp)()) std::__1::__invoke<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>((anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31&&) + 21\r\n12 circt-opt                0x000000010321332d std::__1::invoke_result<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>::type std::__1::invoke<(anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>((anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31&&) + 29\r\n13 circt-opt                0x00000001032132b6 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31>(circt::pretty::PP&&, (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&)::$_31&&, circt::pretty::Token) + 102\r\n14 circt-opt                0x0000000103203cc4 (anonymous namespace)::StmtEmitter::emitStatementBlock(mlir::Block&) + 116\r\n15 circt-opt                0x00000001032027b1 (anonymous namespace)::ModuleEmitter::emitHWModule(circt::hw::HWModuleOp) + 2897\r\n16 circt-opt                0x0000000103201c14 auto emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*)::$_101::operator()<circt::hw::HWModuleOp>(circt::hw::HWModuleOp) const + 68\r\n17 circt-opt                0x000000010320186b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::hw::HWModuleOp, emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*)::$_101>(emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*)::$_101&&) + 107\r\n18 circt-opt                0x00000001031fa415 emitOperation((anonymous namespace)::VerilogEmitterState&, mlir::Operation*) + 53\r\n19 circt-opt                0x0000000103277586 circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46::operator()(circt::ExportVerilog::StringOrOpToEmit&) const + 278\r\n20 circt-opt                0x0000000103277380 auto void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)::operator()<circt::ExportVerilog::StringOrOpToEmit&>(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&) const + 48\r\n21 circt-opt                0x0000000103279259 mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()::operator()() const + 169\r\n22 circt-opt                0x00000001032791a5 decltype(static_cast<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>>(fp)()) std::__1::__invoke<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()&>(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&) + 21\r\n23 circt-opt                0x000000010327915d void std::__1::__invoke_void_return_wrapper<void, true>::__call<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()&>(mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()&) + 29\r\n24 circt-opt                0x000000010327912d std::__1::__function::__alloc_func<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()>, void ()>::operator()() + 29\r\n25 circt-opt                0x0000000103278179 std::__1::__function::__func<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, void mlir::parallelForEach<std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'(std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>&&)>(mlir::MLIRContext*, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, std::__1::__wrap_iter<circt::ExportVerilog::StringOrOpToEmit*>, circt::ExportVerilog::SharedEmitterState::emitOps(std::__1::vector<circt::ExportVerilog::StringOrOpToEmit, std::__1::allocator<circt::ExportVerilog::StringOrOpToEmit>>&, llvm::raw_ostream&, bool)::$_46&&)::'lambda'()>, void ()>::operator()() + 25\r\n26 circt-opt                0x0000000104fea852 std::__1::__function::__value_func<void ()>::operator()() const + 50\r\n27 circt-opt                0x0000000104fea815 std::__1::function<void ()>::operator()() const + 21\r\n28 circt-opt                0x0000000104fea7dd llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()::operator()() const + 29\r\n29 circt-opt                0x0000000104fea7a5 decltype(static_cast<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(fp)()) std::__1::__invoke<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 21\r\n30 circt-opt                0x0000000104fea75d void std::__1::__invoke_void_return_wrapper<void, true>::__call<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 29\r\n31 circt-opt                0x0000000104fea72d std::__1::__function::__alloc_func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 29\r\n32 circt-opt                0x0000000104fe9519 std::__1::__function::__func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 25\r\n33 circt-opt                0x0000000104fea852 std::__1::__function::__value_func<void ()>::operator()() const + 50\r\n34 circt-opt                0x0000000104fea815 std::__1::function<void ()>::operator()() const + 21\r\n35 circt-opt                0x0000000102e0cc92 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) + 546\r\n36 circt-opt                0x0000000102e10373 llvm::ThreadPool::grow(int)::$_0::operator()() const + 51\r\n37 circt-opt                0x0000000102e10305 void llvm::thread::Apply<llvm::ThreadPool::grow(int)::$_0>(std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::__1::integer_sequence<unsigned long>) + 37\r\n38 circt-opt                0x0000000102e102c3 void llvm::thread::GenericThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 51\r\n39 circt-opt                0x0000000102e0fff5 void* llvm::thread::ThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 21\r\n40 libsystem_pthread.dylib  0x00007ff81f37a4e1 _pthread_start + 125\r\n41 libsystem_pthread.dylib  0x00007ff81f375f6b thread_start + 15"}, {"number": 4456, "title": "Signedness-related failures on \"test2.fir\", \"test3.fir\" during IMCP", "created_at": "2022-12-16T01:22:52Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Looks like we're failing/asserting out with signedness-related errors in IMCP on both [test2.fir](https://github.com/circt/perf/blob/trunk/regress/test2.fir) and [test3.fir](https://github.com/circt/perf/blob/trunk/regress/test3.fir) from the perf regression tests, starting 2022-11-24:\r\n\r\nhttps://github.com/circt/perf/blob/gh-pages/test2-2022-11-24.log\r\nhttps://github.com/circt/perf/blob/gh-pages/test3-2022-11-24.log\r\n\r\nReproduced both on latest master.\r\n\r\nSince test2.fir crashes instead of a diagnostic, here's a more complete backtrace:\r\n<details>\r\n<summary>test2 backtrace</summary>\r\n\r\n```\r\nfirtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APSInt.h:129: llvm::APSInt llvm::APSInt::operator%(const llvm::APSInt &) const: Assertion `IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ../build/bin/firtool /home/will/src/sifive/perf/regress/test2.fir -o /dev/null\r\n #0 0x00000000006593e6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:567:13\r\n #1 0x0000000000657895 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x000000000065977f SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007f65a2a3dbf0 __restore_rt (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x3dbf0)\r\n #4 0x00007f65a2a8abc7 __pthread_kill_implementation (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x8abc7)\r\n #5 0x00007f65a2a3db46 gsignal (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x3db46)\r\n #6 0x00007f65a2a284b5 abort (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x284b5)\r\n #7 0x00007f65a2a283d9 _nl_load_domain.cold.0 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x283d9)\r\n #8 0x00007f65a2a367b6 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x367b6)\r\n #9 0x0000000000a590b9 llvm::APInt llvm::function_ref<llvm::APInt (llvm::APSInt, llvm::APSInt)>::callback_fn<circt::firrtl::RemPrimOp::fold(llvm::ArrayRef<mlir::Attribute>)::$_4>(long, llvm::APSInt, llvm::APSInt) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:0:0\r\n#10 0x0000000000a4b385 llvm::APInt::isSingleWord() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APInt.h:305:47\r\n#11 0x0000000000a4b385 llvm::APInt::needsCleanup() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APInt.h:1837:39\r\n#12 0x0000000000a4b385 llvm::APInt::~APInt() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APInt.h:168:9\r\n#13 0x0000000000a4b385 llvm::function_ref<llvm::APInt (llvm::APSInt, llvm::APSInt)>::operator()(llvm::APSInt, llvm::APSInt) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:5\r\n#14 0x0000000000a4b385 constFoldFIRRTLBinaryOp(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, BinOpKind, llvm::function_ref<llvm::APInt (llvm::APSInt, llvm::APSInt)> const&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:249:23\r\n#15 0x0000000000a4bc91 circt::firrtl::RemPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:0:10\r\n#16 0x0000000000a40a58 llvm::PointerUnion<mlir::Attribute, mlir::Value>::isNull() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:142:33\r\n#17 0x0000000000a40a58 llvm::PointerUnion<mlir::Attribute, mlir::Value>::operator bool() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:144:44\r\n#18 0x0000000000a40a58 mlir::LogicalResult mlir::Op<circt::firrtl::RemPrimOp, mlir::OpTrait::ZeroRegions, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::IntType>::Impl, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::NOperands<2u>::Impl, mlir::OpTrait::OpInvariants, circt::firrtl::SameOperandsIntTypeKind, mlir::OpAsmOpInterface::Trait, mlir::InferTypeOpInterface::Trait, mlir::ConditionallySpeculatable::Trait, mlir::OpTrait::AlwaysSpeculatableImplTrait, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::RemPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1779:10\r\n#19 0x00000000009affe3 llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>::operator()(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:409:12\r\n#20 0x00000000009affe3 mlir::RegisteredOperationName::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:334:12\r\n#21 0x00000000009affe3 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:495:31\r\n#22 0x00000000007b192b (anonymous namespace)::IMConstPropPass::visitOperation(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:0:0\r\n#23 0x00000000007b192b (anonymous namespace)::IMConstPropPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:346:9\r\n#24 0x0000000000dd7900 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11\r\n#25 0x0000000000dd7f57 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#26 0x0000000000dd7f57 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#27 0x0000000000dd7f57 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:9\r\n#28 0x0000000000dd960d std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/8xmmwmb6r6hc6f3cdh64mbi138p96vpg-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1046:25\r\n#29 0x0000000000dd960d mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:754:5\r\n#30 0x0000000000dd960d mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18\r\n#31 0x0000000000dd960d mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#32 0x0000000000dd960d mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:14\r\n#33 0x0000000000dd793e mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5\r\n#34 0x0000000000dd793e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:463:14\r\n#35 0x0000000000dda3a1 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#36 0x0000000000dda3a1 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#37 0x0000000000dda3a1 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:9\r\n#38 0x0000000000dda3a1 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:834:10\r\n#39 0x0000000000dda3a1 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:814:60\r\n#40 0x000000000059f627 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#41 0x000000000059f627 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#42 0x000000000059f627 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:841:7\r\n#43 0x000000000059d5f8 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:935:12\r\n#44 0x000000000059d1d1 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:951:12\r\n#45 0x000000000059d1d1 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1035:14\r\n#46 0x000000000059cdc1 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#47 0x000000000059cdc1 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#48 0x000000000059cdc1 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1099:8\r\n#49 0x00007f65a2a2924e __libc_start_call_main (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x2924e)\r\n#50 0x00007f65a2a29309 __libc_start_main@GLIBC_2.2.5 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x29309)\r\n#51 0x000000000059cbf5 _start (../build/bin/firtool+0x59cbf5)\r\n```\r\n</details>\r\n\r\nAnd for test3.fir sometimes there are multiple errors, for example:\r\n\r\n```\r\n/home/will/src/sifive/perf/regress/test3.fir:166372:5: error: firrtl.constant attribute has wrong sign\r\n    wire _tmp3120: UInt<15>\r\n    ^\r\n\r\n/home/will/src/sifive/perf/regress/test3.fir:166372:5: note: see current operation: %8 = \"firrtl.constant\"() {value = -12133 : si15} : () -> !firrtl.uint<15>\r\n/home/will/src/sifive/perf/regress/test3.fir:864443:16: error: firrtl.constant attribute has wrong sign\r\n    tmp4132 <= cat(asSInt(UInt<28>(\"o1046442110\")), inp_c.inp_hd.inp_oi)\r\n               ^\r\n```\r\n\r\nSomething wonky re:folds happening around then, maybe?", "code_snippet_01": "firtool: /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APSInt.h:129: llvm::APSInt llvm::APSInt::operator%(const llvm::APSInt &) const: Assertion `IsUnsigned == RHS.IsUnsigned && \"Signedness mismatch!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ../build/bin/firtool /home/will/src/sifive/perf/regress/test2.fir -o /dev/null\r\n #0 0x00000000006593e6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:567:13\r\n #1 0x0000000000657895 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x000000000065977f SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007f65a2a3dbf0 __restore_rt (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x3dbf0)\r\n #4 0x00007f65a2a8abc7 __pthread_kill_implementation (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x8abc7)\r\n #5 0x00007f65a2a3db46 gsignal (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x3db46)\r\n #6 0x00007f65a2a284b5 abort (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x284b5)\r\n #7 0x00007f65a2a283d9 _nl_load_domain.cold.0 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x283d9)\r\n #8 0x00007f65a2a367b6 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x367b6)\r\n #9 0x0000000000a590b9 llvm::APInt llvm::function_ref<llvm::APInt (llvm::APSInt, llvm::APSInt)>::callback_fn<circt::firrtl::RemPrimOp::fold(llvm::ArrayRef<mlir::Attribute>)::$_4>(long, llvm::APSInt, llvm::APSInt) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:0:0\r\n#10 0x0000000000a4b385 llvm::APInt::isSingleWord() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APInt.h:305:47\r\n#11 0x0000000000a4b385 llvm::APInt::needsCleanup() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APInt.h:1837:39\r\n#12 0x0000000000a4b385 llvm::APInt::~APInt() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/APInt.h:168:9\r\n#13 0x0000000000a4b385 llvm::function_ref<llvm::APInt (llvm::APSInt, llvm::APSInt)>::operator()(llvm::APSInt, llvm::APSInt) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:5\r\n#14 0x0000000000a4b385 constFoldFIRRTLBinaryOp(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, BinOpKind, llvm::function_ref<llvm::APInt (llvm::APSInt, llvm::APSInt)> const&) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:249:23\r\n#15 0x0000000000a4bc91 circt::firrtl::RemPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:0:10\r\n#16 0x0000000000a40a58 llvm::PointerUnion<mlir::Attribute, mlir::Value>::isNull() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:142:33\r\n#17 0x0000000000a40a58 llvm::PointerUnion<mlir::Attribute, mlir::Value>::operator bool() const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:144:44\r\n#18 0x0000000000a40a58 mlir::LogicalResult mlir::Op<circt::firrtl::RemPrimOp, mlir::OpTrait::ZeroRegions, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::IntType>::Impl, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::NOperands<2u>::Impl, mlir::OpTrait::OpInvariants, circt::firrtl::SameOperandsIntTypeKind, mlir::OpAsmOpInterface::Trait, mlir::InferTypeOpInterface::Trait, mlir::ConditionallySpeculatable::Trait, mlir::OpTrait::AlwaysSpeculatableImplTrait, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::RemPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1779:10\r\n#19 0x00000000009affe3 llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>::operator()(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:409:12\r\n#20 0x00000000009affe3 mlir::RegisteredOperationName::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:334:12\r\n#21 0x00000000009affe3 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:495:31\r\n#22 0x00000000007b192b (anonymous namespace)::IMConstPropPass::visitOperation(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:0:0\r\n#23 0x00000000007b192b (anonymous namespace)::IMConstPropPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:346:9\r\n#24 0x0000000000dd7900 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11\r\n#25 0x0000000000dd7f57 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#26 0x0000000000dd7f57 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#27 0x0000000000dd7f57 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:9\r\n#28 0x0000000000dd960d std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/8xmmwmb6r6hc6f3cdh64mbi138p96vpg-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1046:25\r\n#29 0x0000000000dd960d mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:754:5\r\n#30 0x0000000000dd960d mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18\r\n#31 0x0000000000dd960d mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#32 0x0000000000dd960d mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:14\r\n#33 0x0000000000dd793e mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5\r\n#34 0x0000000000dd793e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:463:14\r\n#35 0x0000000000dda3a1 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#36 0x0000000000dda3a1 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#37 0x0000000000dda3a1 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:9\r\n#38 0x0000000000dda3a1 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:834:10\r\n#39 0x0000000000dda3a1 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:814:60\r\n#40 0x000000000059f627 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#41 0x000000000059f627 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#42 0x000000000059f627 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:841:7\r\n#43 0x000000000059d5f8 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:935:12\r\n#44 0x000000000059d1d1 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:951:12\r\n#45 0x000000000059d1d1 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1035:14\r\n#46 0x000000000059cdc1 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#47 0x000000000059cdc1 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#48 0x000000000059cdc1 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1099:8\r\n#49 0x00007f65a2a2924e __libc_start_call_main (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x2924e)\r\n#50 0x00007f65a2a29309 __libc_start_main@GLIBC_2.2.5 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x29309)\r\n#51 0x000000000059cbf5 _start (../build/bin/firtool+0x59cbf5)", "code_snippet_02": "/home/will/src/sifive/perf/regress/test3.fir:166372:5: error: firrtl.constant attribute has wrong sign\r\n    wire _tmp3120: UInt<15>\r\n    ^\r\n\r\n/home/will/src/sifive/perf/regress/test3.fir:166372:5: note: see current operation: %8 = \"firrtl.constant\"() {value = -12133 : si15} : () -> !firrtl.uint<15>\r\n/home/will/src/sifive/perf/regress/test3.fir:864443:16: error: firrtl.constant attribute has wrong sign\r\n    tmp4132 <= cat(asSInt(UInt<28>(\"o1046442110\")), inp_c.inp_hd.inp_oi)\r\n               ^"}, {"number": 4448, "title": "[FIRRTL] WireDFT Needs Hardening", "created_at": "2022-12-14T16:38:05Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The `WireDFT` pass makes some assumptions about the structure of modules with the `EICG_wrapper` name. Specifically, I think it assumes that any module that starts with `EICG_wrapper` has a second port that is supposed to be hooked up. I _don't_ think this validates the name, type, or directionality.\r\n\r\nConsider:\r\n\r\n```\r\ncircuit Top: %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"~Top|Top\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.DFTTestModeEnableAnnotation\",\r\n    \"target\":\"~Top|Top>test_en\"\r\n    },\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top>test_en\"\r\n  }\r\n]]\r\n  extmodule EICG_wrapper_Bar:\r\n    output a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n  module Foo:\r\n    inst bar of EICG_wrapper_Bar\r\n\r\n  module Top:\r\n    wire test_en: UInt<1>\r\n    test_en is invalid\r\n\r\n    inst foo of Foo\r\n```\r\n\r\nRunning this with `firtool Foo.fir` produces:\r\n\r\n```\r\n# firtool Tmp.fir -mlir-print-ir-after=firrtl-dft                       \r\nTmp.fir:19:10: error: connect has invalid flow: the destination expression \"bar.b\" has source flow, expected sink or duplex flow\r\n  module Foo:\r\n         ^\r\nTmp.fir:20:5: note: the destination was defined here\r\n    inst bar of EICG_wrapper_Bar\r\n    ^\r\n```\r\n\r\nThe output MLIR is:\r\n\r\n```mlir\r\n\"firrtl.circuit\"() ({\r\n  \"firrtl.extmodule\"() ({\r\n  }) {annotations = [], internalPaths = [], parameters = [], portAnnotations = [], portDirections = -1 : i2, portNames = [\"a\", \"b\"], portSyms = [], portTypes = [!firrtl.uint<1>, !firrtl.uint<1>], sym_name = \"EICG_wrapper_Bar\", sym_visibility = \"private\"} : () -> ()\r\n  \"firrtl.module\"() ({\r\n  ^bb0(%arg0: !firrtl.uint<1>):\r\n    %0:2 = \"firrtl.instance\"() {annotations = [], moduleName = @EICG_wrapper_Bar, name = \"bar\", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [[], []], portDirections = -1 : i2, portNames = [\"a\", \"b\"]} : () -> (!firrtl.uint<1>, !firrtl.uint<1>)\r\n    \"firrtl.connect\"(%0#1, %arg0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  }) {annotations = [], portAnnotations = [], portDirections = false, portNames = [\"test_en\"], portSyms = [], portTypes = [!firrtl.uint<1>], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\n  \"firrtl.module\"() ({\r\n    %0 = \"firrtl.wire\"() {annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}], name = \"test_en\", nameKind = #firrtl<name_kind droppable_name>} : () -> !firrtl.uint<1>\r\n    %1 = \"firrtl.invalidvalue\"() : () -> !firrtl.uint<1>\r\n    \"firrtl.strictconnect\"(%0, %1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n    %2 = \"firrtl.instance\"() {annotations = [], moduleName = @Foo, name = \"foo\", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [[]], portDirections = false, portNames = [\"test_en\"]} : () -> !firrtl.uint<1>\r\n    \"firrtl.connect\"(%2, %0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  }) {annotations = [{class = \"sifive.enterprise.firrtl.MarkDUTAnnotation\"}], portAnnotations = [], portDirections = 0 : i0, portNames = [], portSyms = [], portTypes = [], sym_name = \"Top\"} : () -> ()\r\n}) {annotations = [], name = \"Top\"} : () -> ()\r\n```", "code_snippet_01": "circuit Top: %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"~Top|Top\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.DFTTestModeEnableAnnotation\",\r\n    \"target\":\"~Top|Top>test_en\"\r\n    },\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top>test_en\"\r\n  }\r\n]]\r\n  extmodule EICG_wrapper_Bar:\r\n    output a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n  module Foo:\r\n    inst bar of EICG_wrapper_Bar\r\n\r\n  module Top:\r\n    wire test_en: UInt<1>\r\n    test_en is invalid\r\n\r\n    inst foo of Foo", "code_snippet_02": "# firtool Tmp.fir -mlir-print-ir-after=firrtl-dft                       \r\nTmp.fir:19:10: error: connect has invalid flow: the destination expression \"bar.b\" has source flow, expected sink or duplex flow\r\n  module Foo:\r\n         ^\r\nTmp.fir:20:5: note: the destination was defined here\r\n    inst bar of EICG_wrapper_Bar\r\n    ^", "code_snippet_03": "\"firrtl.circuit\"() ({\r\n  \"firrtl.extmodule\"() ({\r\n  }) {annotations = [], internalPaths = [], parameters = [], portAnnotations = [], portDirections = -1 : i2, portNames = [\"a\", \"b\"], portSyms = [], portTypes = [!firrtl.uint<1>, !firrtl.uint<1>], sym_name = \"EICG_wrapper_Bar\", sym_visibility = \"private\"} : () -> ()\r\n  \"firrtl.module\"() ({\r\n  ^bb0(%arg0: !firrtl.uint<1>):\r\n    %0:2 = \"firrtl.instance\"() {annotations = [], moduleName = @EICG_wrapper_Bar, name = \"bar\", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [[], []], portDirections = -1 : i2, portNames = [\"a\", \"b\"]} : () -> (!firrtl.uint<1>, !firrtl.uint<1>)\r\n    \"firrtl.connect\"(%0#1, %arg0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  }) {annotations = [], portAnnotations = [], portDirections = false, portNames = [\"test_en\"], portSyms = [], portTypes = [!firrtl.uint<1>], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\n  \"firrtl.module\"() ({\r\n    %0 = \"firrtl.wire\"() {annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}], name = \"test_en\", nameKind = #firrtl<name_kind droppable_name>} : () -> !firrtl.uint<1>\r\n    %1 = \"firrtl.invalidvalue\"() : () -> !firrtl.uint<1>\r\n    \"firrtl.strictconnect\"(%0, %1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n    %2 = \"firrtl.instance\"() {annotations = [], moduleName = @Foo, name = \"foo\", nameKind = #firrtl<name_kind droppable_name>, portAnnotations = [[]], portDirections = false, portNames = [\"test_en\"]} : () -> !firrtl.uint<1>\r\n    \"firrtl.connect\"(%2, %0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  }) {annotations = [{class = \"sifive.enterprise.firrtl.MarkDUTAnnotation\"}], portAnnotations = [], portDirections = 0 : i0, portNames = [], portSyms = [], portTypes = [], sym_name = \"Top\"} : () -> ()\r\n}) {annotations = [], name = \"Top\"} : () -> ()"}, {"number": 4447, "title": "[FIRRTL] Verifier Crash from Invalid WireDFT Circuit", "created_at": "2022-12-14T16:34:42Z", "state": "closed", "labels": "bug, FIRRTL", "body": "I was able to get the verifier to crash with a circuit that is unanticipated by the `WireDFT` pass. Consider:\r\n\r\n```\r\ncircuit Top: %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"~Top|Top\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.DFTTestModeEnableAnnotation\",\r\n    \"target\":\"~Top|Top>test_en\"\r\n    },\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top>test_en\"\r\n  }\r\n]]\r\n  extmodule EICG_wrapper_Bar:\r\n\r\n  module Foo:\r\n    inst bar of EICG_wrapper_Bar\r\n\r\n  module Top:\r\n    wire test_en: UInt<1>\r\n    test_en is invalid\r\n\r\n    inst foo of Foo\r\n```\r\n\r\nThis produces with `firtool Foo.fir`:\r\n\r\n```\r\n# firtool Tmp.fir\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x000000010fdc97fd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x000000010fdc9d7b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x000000010fdc7b66 llvm::sys::RunSignalHandlers() + 134\r\n3  firtool                  0x000000010fdcb9bf SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff81f38fdfd _sigtramp + 29\r\n5  libsystem_platform.dylib 0x00007ff5df040000 _sigtramp + 18446744064042402336\r\n6  firtool                  0x000000011057e328 mlir::Type::getDialect() const + 24\r\n7  firtool                  0x0000000110b2df35 circt::firrtl::FIRRTLBaseType::classof(mlir::Type) + 21\r\n8  firtool                  0x0000000110b2df0d llvm::CastInfo<circt::firrtl::FIRRTLBaseType, mlir::Type const, void>::isPossible(mlir::Type) + 29\r\n9  firtool                  0x0000000110b2dee0 bool llvm::isa<circt::firrtl::FIRRTLBaseType, mlir::Type>(mlir::Type const&) + 32\r\n10 firtool                  0x0000000110b2db75 bool mlir::Type::isa<circt::firrtl::FIRRTLBaseType>() const + 21\r\n11 firtool                  0x0000000110a9abc8 circt::firrtl::__mlir_ods_local_type_constraint_FIRRTL12(mlir::Operation*, mlir::Type, llvm::StringRef, unsigned int) + 72\r\n12 firtool                  0x0000000110a9a9e6 circt::firrtl::ConnectOp::verifyInvariantsImpl() + 214\r\n13 firtool                  0x0000000110939ab2 mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>::verifyTrait(mlir::Operation*) + 34\r\n14 firtool                  0x0000000110939985 std::__1::enable_if<detect_has_verify_trait<mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>>::value, mlir::LogicalResult>::type mlir::op_definition_impl::verifyTrait<mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>>(mlir::Operation*) + 21\r\n15 firtool                  0x000000011093983d mlir::LogicalResult mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<circt::firrtl::ConnectOp>, mlir::OpTrait::ZeroResults<circt::firrtl::ConnectOp>, mlir::OpTrait::ZeroSuccessors<circt::firrtl::ConnectOp>, mlir::OpTrait::NOperands<2u>::Impl<circt::firrtl::ConnectOp>, mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>, circt::firrtl::FConnectLike::Trait<circt::firrtl::ConnectOp>>(mlir::Operation*) + 189\r\n16 firtool                  0x0000000110939725 mlir::Op<circt::firrtl::ConnectOp, mlir::OpTrait::ZeroRegions, mlir::OpTrait::ZeroResults, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::NOperands<2u>::Impl, mlir::OpTrait::OpInvariants, circt::firrtl::FConnectLike::Trait>::verifyInvariants(mlir::Operation*) + 21\r\n17 firtool                  0x0000000110db1e28 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*>::CallImpl<mlir::LogicalResult (* const)(mlir::Operation*)>(void*, mlir::Operation*) + 56\r\n18 firtool                  0x0000000110864757 llvm::unique_function<mlir::LogicalResult (mlir::Operation*) const>::operator()(mlir::Operation*) const + 55\r\n19 firtool                  0x0000000110863457 mlir::RegisteredOperationName::verifyInvariants(mlir::Operation*) const + 39\r\n20 firtool                  0x00000001108629de (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) + 734\r\n21 firtool                  0x000000011086386e (anonymous namespace)::OperationVerifier::verifyBlock(mlir::Block&, llvm::SmallVectorImpl<mlir::Operation*>&) + 878\r\n22 firtool                  0x0000000110862d13 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) + 1555\r\n23 firtool                  0x0000000110862611 (anonymous namespace)::OperationVerifier::verifyOpAndDominance(mlir::Operation&) + 33\r\n24 firtool                  0x0000000110865430 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0::operator()(mlir::Operation*) const + 32\r\n25 firtool                  0x000000011086ae44 mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()::operator()() const + 148\r\n26 firtool                  0x000000011086ada5 decltype(static_cast<mlir::Operation**>(fp)()) std::__1::__invoke<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()&>(mlir::Operation**&&) + 21\r\n27 firtool                  0x000000011086ad5d void std::__1::__invoke_void_return_wrapper<void, true>::__call<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()&>(mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()&) + 29\r\n28 firtool                  0x000000011086ad2d std::__1::__function::__alloc_func<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()>, void ()>::operator()() + 29\r\n29 firtool                  0x0000000110869d79 std::__1::__function::__func<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()>, void ()>::operator()() + 25\r\n30 firtool                  0x00000001111a4052 std::__1::__function::__value_func<void ()>::operator()() const + 50\r\n31 firtool                  0x00000001111a4015 std::__1::function<void ()>::operator()() const + 21\r\n32 firtool                  0x00000001111a3fdd llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()::operator()() const + 29\r\n33 firtool                  0x00000001111a3fa5 decltype(static_cast<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(fp)()) std::__1::__invoke<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 21\r\n34 firtool                  0x00000001111a3f5d void std::__1::__invoke_void_return_wrapper<void, true>::__call<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 29\r\n35 firtool                  0x00000001111a3f2d std::__1::__function::__alloc_func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 29\r\n36 firtool                  0x00000001111a2d19 std::__1::__function::__func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 25\r\n37 firtool                  0x00000001111a4052 std::__1::__function::__value_func<void ()>::operator()() const + 50\r\n38 firtool                  0x00000001111a4015 std::__1::function<void ()>::operator()() const + 21\r\n39 firtool                  0x000000010fcffd12 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) + 546\r\n40 firtool                  0x000000010fd033f3 llvm::ThreadPool::grow(int)::$_0::operator()() const + 51\r\n41 firtool                  0x000000010fd03385 void llvm::thread::Apply<llvm::ThreadPool::grow(int)::$_0>(std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::__1::integer_sequence<unsigned long>) + 37\r\n42 firtool                  0x000000010fd03343 void llvm::thread::GenericThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 51\r\n43 firtool                  0x000000010fd03075 void* llvm::thread::ThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 21\r\n44 libsystem_pthread.dylib  0x00007ff81f37a4e1 _pthread_start + 125\r\n45 libsystem_pthread.dylib  0x00007ff81f375f6b thread_start + 15\r\n```", "code_snippet_01": "circuit Top: %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"~Top|Top\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.DFTTestModeEnableAnnotation\",\r\n    \"target\":\"~Top|Top>test_en\"\r\n    },\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top>test_en\"\r\n  }\r\n]]\r\n  extmodule EICG_wrapper_Bar:\r\n\r\n  module Foo:\r\n    inst bar of EICG_wrapper_Bar\r\n\r\n  module Top:\r\n    wire test_en: UInt<1>\r\n    test_en is invalid\r\n\r\n    inst foo of Foo", "code_snippet_02": "# firtool Tmp.fir\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x000000010fdc97fd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x000000010fdc9d7b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x000000010fdc7b66 llvm::sys::RunSignalHandlers() + 134\r\n3  firtool                  0x000000010fdcb9bf SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff81f38fdfd _sigtramp + 29\r\n5  libsystem_platform.dylib 0x00007ff5df040000 _sigtramp + 18446744064042402336\r\n6  firtool                  0x000000011057e328 mlir::Type::getDialect() const + 24\r\n7  firtool                  0x0000000110b2df35 circt::firrtl::FIRRTLBaseType::classof(mlir::Type) + 21\r\n8  firtool                  0x0000000110b2df0d llvm::CastInfo<circt::firrtl::FIRRTLBaseType, mlir::Type const, void>::isPossible(mlir::Type) + 29\r\n9  firtool                  0x0000000110b2dee0 bool llvm::isa<circt::firrtl::FIRRTLBaseType, mlir::Type>(mlir::Type const&) + 32\r\n10 firtool                  0x0000000110b2db75 bool mlir::Type::isa<circt::firrtl::FIRRTLBaseType>() const + 21\r\n11 firtool                  0x0000000110a9abc8 circt::firrtl::__mlir_ods_local_type_constraint_FIRRTL12(mlir::Operation*, mlir::Type, llvm::StringRef, unsigned int) + 72\r\n12 firtool                  0x0000000110a9a9e6 circt::firrtl::ConnectOp::verifyInvariantsImpl() + 214\r\n13 firtool                  0x0000000110939ab2 mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>::verifyTrait(mlir::Operation*) + 34\r\n14 firtool                  0x0000000110939985 std::__1::enable_if<detect_has_verify_trait<mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>>::value, mlir::LogicalResult>::type mlir::op_definition_impl::verifyTrait<mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>>(mlir::Operation*) + 21\r\n15 firtool                  0x000000011093983d mlir::LogicalResult mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<circt::firrtl::ConnectOp>, mlir::OpTrait::ZeroResults<circt::firrtl::ConnectOp>, mlir::OpTrait::ZeroSuccessors<circt::firrtl::ConnectOp>, mlir::OpTrait::NOperands<2u>::Impl<circt::firrtl::ConnectOp>, mlir::OpTrait::OpInvariants<circt::firrtl::ConnectOp>, circt::firrtl::FConnectLike::Trait<circt::firrtl::ConnectOp>>(mlir::Operation*) + 189\r\n16 firtool                  0x0000000110939725 mlir::Op<circt::firrtl::ConnectOp, mlir::OpTrait::ZeroRegions, mlir::OpTrait::ZeroResults, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::NOperands<2u>::Impl, mlir::OpTrait::OpInvariants, circt::firrtl::FConnectLike::Trait>::verifyInvariants(mlir::Operation*) + 21\r\n17 firtool                  0x0000000110db1e28 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*>::CallImpl<mlir::LogicalResult (* const)(mlir::Operation*)>(void*, mlir::Operation*) + 56\r\n18 firtool                  0x0000000110864757 llvm::unique_function<mlir::LogicalResult (mlir::Operation*) const>::operator()(mlir::Operation*) const + 55\r\n19 firtool                  0x0000000110863457 mlir::RegisteredOperationName::verifyInvariants(mlir::Operation*) const + 39\r\n20 firtool                  0x00000001108629de (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) + 734\r\n21 firtool                  0x000000011086386e (anonymous namespace)::OperationVerifier::verifyBlock(mlir::Block&, llvm::SmallVectorImpl<mlir::Operation*>&) + 878\r\n22 firtool                  0x0000000110862d13 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) + 1555\r\n23 firtool                  0x0000000110862611 (anonymous namespace)::OperationVerifier::verifyOpAndDominance(mlir::Operation&) + 33\r\n24 firtool                  0x0000000110865430 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0::operator()(mlir::Operation*) const + 32\r\n25 firtool                  0x000000011086ae44 mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()::operator()() const + 148\r\n26 firtool                  0x000000011086ada5 decltype(static_cast<mlir::Operation**>(fp)()) std::__1::__invoke<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()&>(mlir::Operation**&&) + 21\r\n27 firtool                  0x000000011086ad5d void std::__1::__invoke_void_return_wrapper<void, true>::__call<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()&>(mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()&) + 29\r\n28 firtool                  0x000000011086ad2d std::__1::__function::__alloc_func<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()>, void ()>::operator()() + 29\r\n29 firtool                  0x0000000110869d79 std::__1::__function::__func<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0>(mlir::MLIRContext*, mlir::Operation**, mlir::Operation**, (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&)::$_0&&)::'lambda'()>, void ()>::operator()() + 25\r\n30 firtool                  0x00000001111a4052 std::__1::__function::__value_func<void ()>::operator()() const + 50\r\n31 firtool                  0x00000001111a4015 std::__1::function<void ()>::operator()() const + 21\r\n32 firtool                  0x00000001111a3fdd llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()::operator()() const + 29\r\n33 firtool                  0x00000001111a3fa5 decltype(static_cast<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(fp)()) std::__1::__invoke<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 21\r\n34 firtool                  0x00000001111a3f5d void std::__1::__invoke_void_return_wrapper<void, true>::__call<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 29\r\n35 firtool                  0x00000001111a3f2d std::__1::__function::__alloc_func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 29\r\n36 firtool                  0x00000001111a2d19 std::__1::__function::__func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 25\r\n37 firtool                  0x00000001111a4052 std::__1::__function::__value_func<void ()>::operator()() const + 50\r\n38 firtool                  0x00000001111a4015 std::__1::function<void ()>::operator()() const + 21\r\n39 firtool                  0x000000010fcffd12 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) + 546\r\n40 firtool                  0x000000010fd033f3 llvm::ThreadPool::grow(int)::$_0::operator()() const + 51\r\n41 firtool                  0x000000010fd03385 void llvm::thread::Apply<llvm::ThreadPool::grow(int)::$_0>(std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::__1::integer_sequence<unsigned long>) + 37\r\n42 firtool                  0x000000010fd03343 void llvm::thread::GenericThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 51\r\n43 firtool                  0x000000010fd03075 void* llvm::thread::ThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 21\r\n44 libsystem_pthread.dylib  0x00007ff81f37a4e1 _pthread_start + 125\r\n45 libsystem_pthread.dylib  0x00007ff81f375f6b thread_start + 15"}, {"number": 4378, "title": "[Calyx][ASAN] heap-use-after-free in lit tests", "created_at": "2022-11-30T15:43:01Z", "state": "closed", "labels": "bug, Calyx", "body": "Five lit tests, mostly SFCToCalyx, newly fail with heap-use-after-free.  cc #4353.\r\n\r\nAll error reports: https://gist.github.com/dtzSiFive/4561baec40ea6926de513c460cc6d19f .\r\n\r\nFirst one is included below:\r\n<details>\r\n<summary>convert_pipeline.mlir</summary>\r\n\r\n```\r\nFAIL: CIRCT :: Conversion/PipelineToCalyx/convert_pipeline.mlir (490 of 494)\r\n******************** TEST 'CIRCT :: Conversion/PipelineToCalyx/convert_pipeline.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 1';   /build/sifive/asan/bin/circt-opt /home/will/src/sifive/circt/test/Conversion/PipelineToCalyx/convert_pipeline.mlir -lower-static-logic-to-calyx -split-input-file | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Conversion/PipelineToCalyx/convert_pipeline.mlir\r\n--\r\nExit Code: 2\r\n\r\nCommand Output (stderr):\r\n--\r\n=================================================================\r\n==1442208==ERROR: AddressSanitizer: heap-use-after-free on address 0x6080000019c4 at pc 0x000002379ef0 bp 0x7fff22ee1f90 sp 0x7fff22ee1f88\r\nREAD of size 4 at 0x6080000019c4 thread T0\r\n    #0 0x2379eef in mlir::Operation::getResults() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:333:12\r\n    #1 0x2379eef in mlir::Operation::use_empty() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:629:29\r\n    #2 0x5beb22a in mlir::isOpTriviallyDead(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Interfaces/SideEffectInterfaces.cpp:35:14\r\n    #3 0x5865c88 in (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:211:11\r\n    #4 0x5865c88 in mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:417:27\r\n    #5 0x39389f7 in mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:71:10\r\n    #6 0x39389f7 in circt::pipelinetocalyx::PipelineToCalyxPass::runPartialPattern(mlir::RewritePatternSet&, bool) /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1488:11\r\n    #7 0x39250b9 in circt::pipelinetocalyx::PipelineToCalyxPass::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1602:39\r\n    #8 0x5b4f689 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:465:11\r\n    #9 0x5b508d5 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:16\r\n    #10 0x5b555a9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:834:10\r\n    #11 0x5b552ef in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:814:60\r\n    #12 0x46557b2 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17\r\n    #13 0x4654f21 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12\r\n    #14 0x4654f21 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12\r\n    #15 0x4654f21 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #16 0x46aaf96 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #17 0x46aace2 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16\r\n    #18 0x46aa3b3 in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2045:3\r\n    #19 0x46aa3b3 in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2067:3\r\n    #20 0x46aa3b3 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3\r\n    #21 0x465299f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10\r\n    #22 0x4652cac in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:209:10\r\n    #23 0x465365e in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:306:14\r\n    #24 0x1f24651 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:70:23\r\n    #25 0x7feae7e2924d in __libc_start_call_main (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 1433936b3a4bd2e8bc1129b0563f1c826138656f)\r\n    #26 0x7feae7e29308 in __libc_start_main@GLIBC_2.2.5 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x29308) (BuildId: 1433936b3a4bd2e8bc1129b0563f1c826138656f)\r\n    #27 0x1e2d424 in _start (/build/sifive/asan/bin/circt-opt+0x1e2d424)\r\n\r\n0x6080000019c4 is located 36 bytes inside of 88-byte region [0x6080000019a0,0x6080000019f8)\r\nfreed by thread T0 here:\r\nLLVMSymbolizer: error reading file: No such file or directory\r\n    #0 0x1edca47 in __interceptor_free.part.0 (/build/sifive/asan/bin/circt-opt+0x1edca47)\r\n    #1 0x3f1e1e0 in mlir::Operation::destroy() /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:171:3\r\n    #2 0x3f315dc in llvm::ilist_traits<mlir::Operation>::deleteNode(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:371:7\r\n    #3 0x3f315dc in llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation>>::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:269:5\r\n    #4 0x3f315dc in llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation>>::erase(mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:273:39\r\n    #5 0x3f1fdf2 in mlir::Operation::erase() /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:420:29\r\n    #6 0x3f50de9 in mlir::RewriterBase::eraseOp(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:278:7\r\n    #7 0x5868a72 in (anonymous namespace)::GreedyPatternRewriteDriver::eraseOp(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:379:20\r\n    #8 0x397494f in circt::pipelinetocalyx::CleanupFuncOps::partiallyLowerFuncToComp(mlir::func::FuncOp, mlir::PatternRewriter&) const /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1356:14\r\n    #9 0x3752c69 in circt::calyx::FuncOpPartialLoweringPattern::partiallyLower(mlir::func::FuncOp, mlir::PatternRewriter&) const /home/will/src/sifive/circt/lib/Dialect/Calyx/Transforms/CalyxLoweringUtils.cpp:390:10\r\n    #10 0x371fa23 in circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const::'lambda'()::operator()() const /home/will/src/sifive/circt/include/circt/Dialect/Calyx/CalyxLoweringUtils.h:486:39\r\n    #11 0x371fa23 in void mlir::RewriterBase::updateRootInPlace<circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const::'lambda'()>(mlir::Operation*, circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const::'lambda'()&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/PatternMatch.h:501:5\r\n    #12 0x371d24f in circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const /home/will/src/sifive/circt/include/circt/Dialect/Calyx/CalyxLoweringUtils.h:485:14\r\n    #13 0x371cf60 in mlir::detail::OpOrInterfaceRewritePatternBase<mlir::func::FuncOp>::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/PatternMatch.h:329:12\r\n    #14 0x58f2a50 in mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25\r\n    #15 0x58661aa in (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:274:19\r\n    #16 0x58661aa in mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:417:27\r\n    #17 0x39389f7 in mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:71:10\r\n    #18 0x39389f7 in circt::pipelinetocalyx::PipelineToCalyxPass::runPartialPattern(mlir::RewritePatternSet&, bool) /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1488:11\r\n    #19 0x39250b9 in circt::pipelinetocalyx::PipelineToCalyxPass::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1602:39\r\n    #20 0x5b4f689 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:465:11\r\n    #21 0x5b508d5 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:16\r\n    #22 0x5b555a9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:834:10\r\n    #23 0x5b552ef in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:814:60\r\n    #24 0x46557b2 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17\r\n    #25 0x4654f21 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12\r\n    #26 0x4654f21 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12\r\n    #27 0x4654f21 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #28 0x46aaf96 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #29 0x46aace2 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16\r\n    #30 0x46aa3b3 in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2045:3\r\n    #31 0x46aa3b3 in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2067:3\r\n    #32 0x46aa3b3 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3\r\n    #33 0x465299f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10\r\n    #34 0x4652cac in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:209:10\r\n    #35 0x465365e in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:306:14\r\n    #36 0x1f24651 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:70:23\r\n    #37 0x7feae7e2924d in __libc_start_call_main (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 1433936b3a4bd2e8bc1129b0563f1c826138656f)\r\n    #38 0x7fff22ee72ee  ([stack]+0x202ee)\r\n\r\n```\r\n</details>\r\n\r\n", "code_snippet_01": "FAIL: CIRCT :: Conversion/PipelineToCalyx/convert_pipeline.mlir (490 of 494)\r\n******************** TEST 'CIRCT :: Conversion/PipelineToCalyx/convert_pipeline.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 1';   /build/sifive/asan/bin/circt-opt /home/will/src/sifive/circt/test/Conversion/PipelineToCalyx/convert_pipeline.mlir -lower-static-logic-to-calyx -split-input-file | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Conversion/PipelineToCalyx/convert_pipeline.mlir\r\n--\r\nExit Code: 2\r\n\r\nCommand Output (stderr):\r\n--\r\n=================================================================\r\n==1442208==ERROR: AddressSanitizer: heap-use-after-free on address 0x6080000019c4 at pc 0x000002379ef0 bp 0x7fff22ee1f90 sp 0x7fff22ee1f88\r\nREAD of size 4 at 0x6080000019c4 thread T0\r\n    #0 0x2379eef in mlir::Operation::getResults() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:333:12\r\n    #1 0x2379eef in mlir::Operation::use_empty() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:629:29\r\n    #2 0x5beb22a in mlir::isOpTriviallyDead(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Interfaces/SideEffectInterfaces.cpp:35:14\r\n    #3 0x5865c88 in (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:211:11\r\n    #4 0x5865c88 in mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:417:27\r\n    #5 0x39389f7 in mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:71:10\r\n    #6 0x39389f7 in circt::pipelinetocalyx::PipelineToCalyxPass::runPartialPattern(mlir::RewritePatternSet&, bool) /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1488:11\r\n    #7 0x39250b9 in circt::pipelinetocalyx::PipelineToCalyxPass::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1602:39\r\n    #8 0x5b4f689 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:465:11\r\n    #9 0x5b508d5 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:16\r\n    #10 0x5b555a9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:834:10\r\n    #11 0x5b552ef in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:814:60\r\n    #12 0x46557b2 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17\r\n    #13 0x4654f21 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12\r\n    #14 0x4654f21 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12\r\n    #15 0x4654f21 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #16 0x46aaf96 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #17 0x46aace2 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16\r\n    #18 0x46aa3b3 in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2045:3\r\n    #19 0x46aa3b3 in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2067:3\r\n    #20 0x46aa3b3 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3\r\n    #21 0x465299f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10\r\n    #22 0x4652cac in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:209:10\r\n    #23 0x465365e in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:306:14\r\n    #24 0x1f24651 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:70:23\r\n    #25 0x7feae7e2924d in __libc_start_call_main (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 1433936b3a4bd2e8bc1129b0563f1c826138656f)\r\n    #26 0x7feae7e29308 in __libc_start_main@GLIBC_2.2.5 (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x29308) (BuildId: 1433936b3a4bd2e8bc1129b0563f1c826138656f)\r\n    #27 0x1e2d424 in _start (/build/sifive/asan/bin/circt-opt+0x1e2d424)\r\n\r\n0x6080000019c4 is located 36 bytes inside of 88-byte region [0x6080000019a0,0x6080000019f8)\r\nfreed by thread T0 here:\r\nLLVMSymbolizer: error reading file: No such file or directory\r\n    #0 0x1edca47 in __interceptor_free.part.0 (/build/sifive/asan/bin/circt-opt+0x1edca47)\r\n    #1 0x3f1e1e0 in mlir::Operation::destroy() /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:171:3\r\n    #2 0x3f315dc in llvm::ilist_traits<mlir::Operation>::deleteNode(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:371:7\r\n    #3 0x3f315dc in llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation>>::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false>) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:269:5\r\n    #4 0x3f315dc in llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>, llvm::ilist_traits<mlir::Operation>>::erase(mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:273:39\r\n    #5 0x3f1fdf2 in mlir::Operation::erase() /home/will/src/sifive/circt/llvm/mlir/lib/IR/Operation.cpp:420:29\r\n    #6 0x3f50de9 in mlir::RewriterBase::eraseOp(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:278:7\r\n    #7 0x5868a72 in (anonymous namespace)::GreedyPatternRewriteDriver::eraseOp(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:379:20\r\n    #8 0x397494f in circt::pipelinetocalyx::CleanupFuncOps::partiallyLowerFuncToComp(mlir::func::FuncOp, mlir::PatternRewriter&) const /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1356:14\r\n    #9 0x3752c69 in circt::calyx::FuncOpPartialLoweringPattern::partiallyLower(mlir::func::FuncOp, mlir::PatternRewriter&) const /home/will/src/sifive/circt/lib/Dialect/Calyx/Transforms/CalyxLoweringUtils.cpp:390:10\r\n    #10 0x371fa23 in circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const::'lambda'()::operator()() const /home/will/src/sifive/circt/include/circt/Dialect/Calyx/CalyxLoweringUtils.h:486:39\r\n    #11 0x371fa23 in void mlir::RewriterBase::updateRootInPlace<circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const::'lambda'()>(mlir::Operation*, circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const::'lambda'()&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/PatternMatch.h:501:5\r\n    #12 0x371d24f in circt::calyx::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const /home/will/src/sifive/circt/include/circt/Dialect/Calyx/CalyxLoweringUtils.h:485:14\r\n    #13 0x371cf60 in mlir::detail::OpOrInterfaceRewritePatternBase<mlir::func::FuncOp>::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/PatternMatch.h:329:12\r\n    #14 0x58f2a50 in mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25\r\n    #15 0x58661aa in (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:274:19\r\n    #16 0x58661aa in mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:417:27\r\n    #17 0x39389f7 in mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:71:10\r\n    #18 0x39389f7 in circt::pipelinetocalyx::PipelineToCalyxPass::runPartialPattern(mlir::RewritePatternSet&, bool) /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1488:11\r\n    #19 0x39250b9 in circt::pipelinetocalyx::PipelineToCalyxPass::runOnOperation() /home/will/src/sifive/circt/lib/Conversion/PipelineToCalyx/PipelineToCalyx.cpp:1602:39\r\n    #20 0x5b4f689 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:465:11\r\n    #21 0x5b508d5 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:529:16\r\n    #22 0x5b555a9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:834:10\r\n    #23 0x5b552ef in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:814:60\r\n    #24 0x46557b2 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17\r\n    #25 0x4654f21 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12\r\n    #26 0x4654f21 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12\r\n    #27 0x4654f21 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #28 0x46aaf96 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #29 0x46aace2 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16\r\n    #30 0x46aa3b3 in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2045:3\r\n    #31 0x46aa3b3 in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:2067:3\r\n    #32 0x46aa3b3 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3\r\n    #33 0x465299f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10\r\n    #34 0x4652cac in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:209:10\r\n    #35 0x465365e in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:306:14\r\n    #36 0x1f24651 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:70:23\r\n    #37 0x7feae7e2924d in __libc_start_call_main (/nix/store/ynn1by1qdl16q6qwwh2h7zkgrn36c6i8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 1433936b3a4bd2e8bc1129b0563f1c826138656f)\r\n    #38 0x7fff22ee72ee  ([stack]+0x202ee)"}, {"number": 4375, "title": "[Scheduling] ModuloSimplexScheduler fails to resolve resource conflicts", "created_at": "2022-11-30T03:11:56Z", "state": "closed", "labels": "bug, Scheduling", "body": "*(initially reported by @matth2k in #4374)*\r\n\r\nThe following instance triggers an assertion while re-entering the scheduled operations after the II was increased to resolve a resource conflict.\r\n\r\n```mlir\r\nssp.instance of \"ModuloProblem\" {\r\n  library {\r\n    operator_type @unlimited [latency<1>]\r\n    operator_type @limited [latency<1>, limit<1>]\r\n  }\r\n  graph {\r\n    %0 = operation<@unlimited>()\r\n    %1 = operation<@limited>(%0)\r\n    %2 = operation<@limited>(%0)\r\n    %3 = operation<@limited>(%0)\r\n    %4 = operation<@limited>(%0)\r\n    operation<@unlimited>(%1, %2, %3, %4)\r\n  }\r\n}\r\n```\r\n\r\nCuriously, the bug is not triggered if we had only 3 limited operations. Hence, this could be about moving ops across the next multiple of the II, but further investigation is needed.", "code_snippet_01": "ssp.instance of \"ModuloProblem\" {\r\n  library {\r\n    operator_type @unlimited [latency<1>]\r\n    operator_type @limited [latency<1>, limit<1>]\r\n  }\r\n  graph {\r\n    %0 = operation<@unlimited>()\r\n    %1 = operation<@limited>(%0)\r\n    %2 = operation<@limited>(%0)\r\n    %3 = operation<@limited>(%0)\r\n    %4 = operation<@limited>(%0)\r\n    operation<@unlimited>(%1, %2, %3, %4)\r\n  }\r\n}"}, {"number": 4357, "title": "[FIRRTL][LowerToHW] ForceNameAnnotation Not Working on Extmodule Instances", "created_at": "2022-11-23T15:59:20Z", "state": "closed", "labels": "bug, good first issue, FIRRTL", "body": "A `ForceNameAnnotation` on a module instance works, but an extmodule doesn't. Consider:\r\n\r\n```mlir\r\nfirrtl.circuit \"ForceNameTop\" {\r\n  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]\r\n  firrtl.hierpath private @nla_3 [@ForceNameTop::@sym_baz, @ForceNameExtmodule]\r\n  firrtl.module private @ForceNameSubmodule() attributes {annotations = [\r\n    {circt.nonlocal = @nla_1,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Foo\"}\r\n  ]} {}\r\n  firrtl.extmodule private @ForceNameExtmodule() attributes {annotations = [\r\n    {circt.nonlocal = @nla_3,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Bar\"}\r\n  ]}\r\n  firrtl.module @ForceNameTop() {\r\n    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()\r\n    firrtl.instance baz sym @sym_baz @ForceNameExtmodule()\r\n  }\r\n}\r\n```\r\n\r\nAfter lower-to-hw:\r\n\r\n```mlir\r\nmodule {\r\n  hw.module private @ForceNameSubmodule() {\r\n    hw.output\r\n  }\r\n  hw.module.extern private @ForceNameExtmodule()\r\n  hw.module @ForceNameTop() {\r\n    hw.instance \"foo\" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = \"Foo\"}\r\n    hw.instance \"baz\" sym @sym_baz @ForceNameExtmodule() -> ()\r\n    hw.output\r\n  }\r\n}\r\n```\r\n\r\nThis should add a `hw.verilogName = \"Bar\"` attribute to the \"baz\" instance.", "code_snippet_01": "firrtl.circuit \"ForceNameTop\" {\r\n  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]\r\n  firrtl.hierpath private @nla_3 [@ForceNameTop::@sym_baz, @ForceNameExtmodule]\r\n  firrtl.module private @ForceNameSubmodule() attributes {annotations = [\r\n    {circt.nonlocal = @nla_1,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Foo\"}\r\n  ]} {}\r\n  firrtl.extmodule private @ForceNameExtmodule() attributes {annotations = [\r\n    {circt.nonlocal = @nla_3,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Bar\"}\r\n  ]}\r\n  firrtl.module @ForceNameTop() {\r\n    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()\r\n    firrtl.instance baz sym @sym_baz @ForceNameExtmodule()\r\n  }\r\n}", "code_snippet_02": "module {\r\n  hw.module private @ForceNameSubmodule() {\r\n    hw.output\r\n  }\r\n  hw.module.extern private @ForceNameExtmodule()\r\n  hw.module @ForceNameTop() {\r\n    hw.instance \"foo\" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = \"Foo\"}\r\n    hw.instance \"baz\" sym @sym_baz @ForceNameExtmodule() -> ()\r\n    hw.output\r\n  }\r\n}"}, {"number": 4354, "title": "[LowerToHW] An Error Should Be Generated if ForceNameAnnotation Would Not Be Unique", "created_at": "2022-11-23T03:08:03Z", "state": "open", "labels": "bug, good first issue, FIRRTL", "body": "Currently, two `ForceNameAnnotation`s can set an instance within the same module to the same name. The later one will eventually lose when it is uniqued by `PrepareForEmission`/`ExporVerilog`. This should instead be an error:\r\n\r\nConsider the following which is trying to set all instances inside `ForceNameTop` to be called `Foo`:\r\n\r\n```mlir\r\nfirrtl.circuit \"ForceNameTop\" {\r\n  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]\r\n  firrtl.hierpath private @nla_2 [@ForceNameTop::@sym_bar, @ForceNameSubmodule]\r\n  firrtl.module private @ForceNameSubmodule() attributes {annotations = [\r\n    {circt.nonlocal = @nla_1,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Foo\"},\r\n    {circt.nonlocal = @nla_2,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Foo\"}\r\n  ]} {}\r\n  firrtl.module @ForceNameTop() {\r\n    firrtl.instance Foo @ForceNameSubmodule()\r\n    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()\r\n    firrtl.instance bar sym @sym_bar @ForceNameSubmodule()\r\n  }\r\n}\r\n```\r\n\r\nAfter `LowerToHW` this has two instances with the same `verilogName`:\r\n\r\n```mlir\r\nmodule {\r\n  hw.module private @ForceNameSubmodule() {\r\n    hw.output\r\n  }\r\n  hw.module @ForceNameTop() {\r\n    hw.instance \"Foo\" @ForceNameSubmodule() -> ()\r\n    hw.instance \"foo\" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = \"Foo\"}\r\n    hw.instance \"bar\" sym @sym_bar @ForceNameSubmodule() -> () {hw.verilogName = \"Foo\"}\r\n    hw.output\r\n  }\r\n}\r\n```\r\n\r\nThis is fine and will generate sane Verilog below. However, this may be surprising to a user. Verilog is:\r\n\r\n```verilog\r\n// Generated by CIRCT unknown git version\r\nmodule ForceNameSubmodule();\r\nendmodule\r\n\r\nmodule ForceNameTop();\r\n  ForceNameSubmodule Foo_0 ();\r\n  ForceNameSubmodule Foo ();\r\n  ForceNameSubmodule Foo_1 ();\r\nendmodule\r\n```", "code_snippet_01": "firrtl.circuit \"ForceNameTop\" {\r\n  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]\r\n  firrtl.hierpath private @nla_2 [@ForceNameTop::@sym_bar, @ForceNameSubmodule]\r\n  firrtl.module private @ForceNameSubmodule() attributes {annotations = [\r\n    {circt.nonlocal = @nla_1,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Foo\"},\r\n    {circt.nonlocal = @nla_2,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Foo\"}\r\n  ]} {}\r\n  firrtl.module @ForceNameTop() {\r\n    firrtl.instance Foo @ForceNameSubmodule()\r\n    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()\r\n    firrtl.instance bar sym @sym_bar @ForceNameSubmodule()\r\n  }\r\n}", "code_snippet_02": "module {\r\n  hw.module private @ForceNameSubmodule() {\r\n    hw.output\r\n  }\r\n  hw.module @ForceNameTop() {\r\n    hw.instance \"Foo\" @ForceNameSubmodule() -> ()\r\n    hw.instance \"foo\" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = \"Foo\"}\r\n    hw.instance \"bar\" sym @sym_bar @ForceNameSubmodule() -> () {hw.verilogName = \"Foo\"}\r\n    hw.output\r\n  }\r\n}", "code_snippet_03": "// Generated by CIRCT unknown git version\r\nmodule ForceNameSubmodule();\r\nendmodule\r\n\r\nmodule ForceNameTop();\r\n  ForceNameSubmodule Foo_0 ();\r\n  ForceNameSubmodule Foo ();\r\n  ForceNameSubmodule Foo_1 ();\r\nendmodule"}, {"number": 4342, "title": "[Scheduling][solver] Assertion failure \"result == MPSolver::OPTIMAL\"", "created_at": "2022-11-21T16:43:17Z", "state": "closed", "labels": "bug, Scheduling", "body": "When building w/or-tools, I'm seeing a lit test failure in `cyclic-problems.mlir` that occasionally doesn't happen but usually does.\r\n\r\n```\r\nlib/Scheduling/LPSchedulers.cpp:141: mlir::LogicalResult circt::scheduling::scheduleLP(circt::scheduling::CyclicProblem &, mlir::Operation *): Assertion `result == MPSolver::OPTIMAL' failed.\r\n```\r\n\r\n* or-tools: 9.4\r\n* cbc: 2.10.4\r\n\r\nFWIW also seeing Cbc print to stdout when run the circt-opt command manually:\r\n\r\n```\r\n/home/will/src/sifive/circt/test/Scheduling/or-tools/cyclic-problems.mlir:4:14: error: LP-LABEL: expected string not found in input\r\n// LP-LABEL: cyclic\r\n             ^\r\n<stdin>:1:1: note: scanning from here\r\nCoinSolver takes input from arguments ( - switches to stdin)\r\n^\r\n<stdin>:2:10: note: possible intended match here\r\nEnter ? for list of commands or help\r\n         ^\r\n\r\nInput file: <stdin>\r\nCheck file: /home/will/src/sifive/circt/test/Scheduling/or-tools/cyclic-problems.mlir\r\n\r\n-dump-input=help explains the following input dump.\r\n\r\nInput was:\r\n<<<<<<\r\n           1: CoinSolver takes input from arguments ( - switches to stdin) \r\nlabel:4'0     X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ error: no match found\r\n           2: Enter ? for list of commands or help \r\nlabel:4'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nlabel:4'1              ?                            possible intended match\r\n           3: Coin:Coin:Coin:\r\nlabel:4'0     ~~~~~~~~~~~~~~~\r\n>>>>>>\r\n```\r\n\r\nIt seems `--mlir-disable-threading` stops the test from failing AFAICT.\r\n\r\nI have not tried using `or-tools` built using our script, these are from my distribution.\r\n\r\nI thought perhaps `or-tools` was managing a `cbc` process given the REPL-y prompt it prints, but strace says its using cbc as a shared library.", "code_snippet_01": "lib/Scheduling/LPSchedulers.cpp:141: mlir::LogicalResult circt::scheduling::scheduleLP(circt::scheduling::CyclicProblem &, mlir::Operation *): Assertion `result == MPSolver::OPTIMAL' failed.", "code_snippet_02": "/home/will/src/sifive/circt/test/Scheduling/or-tools/cyclic-problems.mlir:4:14: error: LP-LABEL: expected string not found in input\r\n// LP-LABEL: cyclic\r\n             ^\r\n<stdin>:1:1: note: scanning from here\r\nCoinSolver takes input from arguments ( - switches to stdin)\r\n^\r\n<stdin>:2:10: note: possible intended match here\r\nEnter ? for list of commands or help\r\n         ^\r\n\r\nInput file: <stdin>\r\nCheck file: /home/will/src/sifive/circt/test/Scheduling/or-tools/cyclic-problems.mlir\r\n\r\n-dump-input=help explains the following input dump.\r\n\r\nInput was:\r\n<<<<<<\r\n           1: CoinSolver takes input from arguments ( - switches to stdin) \r\nlabel:4'0     X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ error: no match found\r\n           2: Enter ? for list of commands or help \r\nlabel:4'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\nlabel:4'1              ?                            possible intended match\r\n           3: Coin:Coin:Coin:\r\nlabel:4'0     ~~~~~~~~~~~~~~~\r\n>>>>>>"}, {"number": 4277, "title": "[FIRRTL] Grand Central Views with trivial connections are erroring", "created_at": "2022-11-09T02:35:32Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Grand Central Views are now throwing errors if the value driving the `node` source is not a `RefResolveOp` or a `ConstantOp`. However, you can wind up with arbitrary things here due to having a view inside a module that has a trivial connection.\r\n\r\nThis is a bug that showed up due to stricter checking and removal of a fallback code path in https://github.com/llvm/circt/commit/2d3a040f43053d10d195980626ed321a653a89f4.\r\n\r\nh/t @jackkoenig for finding this.\r\n\r\nThe following is a minimal example:\r\n\r\n```\r\ncircuit Bar:\r\n  module Companion:\r\n    input x: UInt<1>\r\n\r\n    node c = x\r\n\r\n  module Bar:\r\n    input x: UInt<1>\r\n\r\n    inst companion of Companion\r\n    companion.x <= x\r\n```\r\n\r\n```json\r\n[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"View\",\r\n    \"companion\": \"~Bar|Companion\",\r\n    \"parent\": \"~Bar|Bar\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"c\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"Bar\",\r\n              \"module\": \"Bar\",\r\n              \"path\": [\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"companion\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Companion\"\r\n                  }\r\n                }\r\n              ],\r\n              \"ref\": \"c\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Bar|Companion>c\"\r\n  }\r\n]\r\n```\r\n\r\nThis produces:\r\n\r\n```\r\n# firtool Bar.fir --annotation-file Bar.anno.json -mlir-print-ir-before=firrtl-grand-central -mlir-print-ir-after=firrtl-grand-central\r\n// -----// IR Dump Before GrandCentral (firrtl-grand-central) //----- //\r\nfirrtl.circuit \"Bar\"  attributes {annotations = [{class = \"sifive.enterprise.grandcentral.AugmentedBundleType\", defName = \"MyInterface\", elements = [{class = \"sifive.enterprise.grandcentral.AugmentedGroundType\", id = 1 : i64, name = \"c\"}], id = 0 : i64, name = \"View\"}]} {\r\n  firrtl.hierpath private @nla [@Bar::@companion, @Companion]\r\n  firrtl.module private @Companion(in %x: !firrtl.uint<1>) attributes {annotations = [{class = \"sifive.enterprise.grandcentral.ViewAnnotation.companion\", id = 0 : i64, name = \"View\"}]} {\r\n    %c = firrtl.node  %x  {annotations = [{circt.nonlocal = @nla, class = \"sifive.enterprise.grandcentral.AugmentedGroundType\", id = 1 : i64}, {class = \"firrtl.transforms.DontTouchAnnotation\"}]} : !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Bar(in %x: !firrtl.uint<1>) attributes {annotations = [{class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 0 : i64, name = \"View\"}]} {\r\n    %companion_x = firrtl.instance companion sym @companion  @Companion(in x: !firrtl.uint<1>)\r\n    firrtl.strictconnect %companion_x, %x : !firrtl.uint<1>\r\n  }\r\n}\r\n\r\nBar.fir:5:5: error: Grand Central View \"View\" has an invalid leaf value (this must be a node of a constant or reftype)\r\n    node c = x\r\n    ^\r\n// -----// IR Dump After GrandCentral Failed (firrtl-grand-central) //----- //\r\nfirrtl.circuit \"Bar\"  {\r\n  firrtl.hierpath private @nla [@Bar::@companion, @Companion]\r\n  firrtl.module private @Companion(in %x: !firrtl.uint<1>) {\r\n    %c = firrtl.node  %x  {annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}]} : !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Bar(in %x: !firrtl.uint<1>) {\r\n    %companion_x = firrtl.instance companion sym @companion  @Companion(in x: !firrtl.uint<1>)\r\n    firrtl.strictconnect %companion_x, %x : !firrtl.uint<1>\r\n  }\r\n  sv.interface @MyInterface attributes {comment = \"VCS coverage exclude_file\"} {\r\n  }\r\n}\r\n```", "code_snippet_01": "circuit Bar:\r\n  module Companion:\r\n    input x: UInt<1>\r\n\r\n    node c = x\r\n\r\n  module Bar:\r\n    input x: UInt<1>\r\n\r\n    inst companion of Companion\r\n    companion.x <= x", "code_snippet_02": "[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"View\",\r\n    \"companion\": \"~Bar|Companion\",\r\n    \"parent\": \"~Bar|Bar\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"c\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"Bar\",\r\n              \"module\": \"Bar\",\r\n              \"path\": [\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"companion\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Companion\"\r\n                  }\r\n                }\r\n              ],\r\n              \"ref\": \"c\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Bar|Companion>c\"\r\n  }\r\n]", "code_snippet_03": "# firtool Bar.fir --annotation-file Bar.anno.json -mlir-print-ir-before=firrtl-grand-central -mlir-print-ir-after=firrtl-grand-central\r\n// -----// IR Dump Before GrandCentral (firrtl-grand-central) //----- //\r\nfirrtl.circuit \"Bar\"  attributes {annotations = [{class = \"sifive.enterprise.grandcentral.AugmentedBundleType\", defName = \"MyInterface\", elements = [{class = \"sifive.enterprise.grandcentral.AugmentedGroundType\", id = 1 : i64, name = \"c\"}], id = 0 : i64, name = \"View\"}]} {\r\n  firrtl.hierpath private @nla [@Bar::@companion, @Companion]\r\n  firrtl.module private @Companion(in %x: !firrtl.uint<1>) attributes {annotations = [{class = \"sifive.enterprise.grandcentral.ViewAnnotation.companion\", id = 0 : i64, name = \"View\"}]} {\r\n    %c = firrtl.node  %x  {annotations = [{circt.nonlocal = @nla, class = \"sifive.enterprise.grandcentral.AugmentedGroundType\", id = 1 : i64}, {class = \"firrtl.transforms.DontTouchAnnotation\"}]} : !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Bar(in %x: !firrtl.uint<1>) attributes {annotations = [{class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 0 : i64, name = \"View\"}]} {\r\n    %companion_x = firrtl.instance companion sym @companion  @Companion(in x: !firrtl.uint<1>)\r\n    firrtl.strictconnect %companion_x, %x : !firrtl.uint<1>\r\n  }\r\n}\r\n\r\nBar.fir:5:5: error: Grand Central View \"View\" has an invalid leaf value (this must be a node of a constant or reftype)\r\n    node c = x\r\n    ^\r\n// -----// IR Dump After GrandCentral Failed (firrtl-grand-central) //----- //\r\nfirrtl.circuit \"Bar\"  {\r\n  firrtl.hierpath private @nla [@Bar::@companion, @Companion]\r\n  firrtl.module private @Companion(in %x: !firrtl.uint<1>) {\r\n    %c = firrtl.node  %x  {annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}]} : !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Bar(in %x: !firrtl.uint<1>) {\r\n    %companion_x = firrtl.instance companion sym @companion  @Companion(in x: !firrtl.uint<1>)\r\n    firrtl.strictconnect %companion_x, %x : !firrtl.uint<1>\r\n  }\r\n  sv.interface @MyInterface attributes {comment = \"VCS coverage exclude_file\"} {\r\n  }\r\n}"}, {"number": 4234, "title": "[FIRRTL] Grand Central Views Aliasing Sub-interfaces", "created_at": "2022-11-03T03:54:49Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Two Grand Central Views which have the same sub-interface can currently result in an alias where the first sub-interface is used in place of the second sub-interface. What this means is that Grand Central Views will produce invalid output Verilog for any two interfaces with the same sub-interface that is not identical, e.g., that is targeting two types with different widths.\r\n\r\nConsider the following circuit. This has two different fields of different widths: `a_w1` with width 1 and `a_w2` with width 2. These are targeted by two separate interfaces: `View_w1` targeting `a_w1` and `View_w2` targeting `a_w2`. Inside the interface, these have a sub-interface with a name conflict: `SameName`. When I compile it, the `SameName` of both views will point at the same sub-interface and result in a width error (trying to connect a width 2 thing to a width 1 thing):\r\n\r\n```\r\ncircuit Top :\r\n  module Companion_w1 :\r\n    skip\r\n\r\n  module Companion_w2 :\r\n    skip\r\n\r\n  module DUT :\r\n    wire a_w1 : UInt<1>\r\n    a_w1 is invalid\r\n\r\n    wire a_w2 : UInt<2>\r\n    a_w2 is invalid\r\n\r\n    inst companion_w1 of Companion_w1\r\n    inst companion_w2 of Companion_w2\r\n\r\n  module Top :\r\n    inst dut of DUT\r\n```\r\n\r\nAnd annotation file:\r\n```json\r\n[\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|DUT>a_w1\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|DUT>a_w2\"\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\": \"View_w1\",\r\n    \"companion\": \"~Top|Companion_w1\",\r\n    \"parent\": \"~Top|DUT\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"SameName\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n            \"defName\": \"SameName\",\r\n            \"elements\": [\r\n              {\r\n                \"name\": \"uint\",\r\n                \"tpe\": {\r\n                  \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n                  \"ref\": {\r\n                    \"circuit\": \"Top\",\r\n                    \"module\": \"Top\",\r\n                    \"path\": [\r\n                      {\r\n                        \"_1\": {\r\n                          \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                          \"value\": \"dut\"\r\n                        },\r\n                        \"_2\": {\r\n                          \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                          \"value\": \"DUT\"\r\n                        }\r\n                      }\r\n                    ],\r\n                    \"ref\": \"a_w1\",\r\n                    \"component\": []\r\n                  },\r\n                  \"tpe\": {\r\n                    \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n                  }\r\n                }\r\n              }\r\n            ]\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\": \"View_w2\",\r\n    \"companion\": \"~Top|Companion_w2\",\r\n    \"parent\": \"~Top|DUT\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"SameName\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n            \"defName\": \"SameName\",\r\n            \"elements\": [\r\n              {\r\n                \"name\": \"uint\",\r\n                \"tpe\": {\r\n                  \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n                  \"ref\": {\r\n                    \"circuit\": \"Top\",\r\n                    \"module\": \"Top\",\r\n                    \"path\": [\r\n                      {\r\n                        \"_1\": {\r\n                          \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                          \"value\": \"dut\"\r\n                        },\r\n                        \"_2\": {\r\n                          \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                          \"value\": \"DUT\"\r\n                        }\r\n                      }\r\n                    ],\r\n                    \"ref\": \"a_w2\",\r\n                    \"component\": []\r\n                  },\r\n                  \"tpe\": {\r\n                    \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n                  }\r\n                }\r\n              }\r\n            ]\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\": \"~Top|Companion_w1\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\": \"~Top|Companion_w2\"\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\": \".\",\r\n    \"filename\": \"bindings.sv\"\r\n  }\r\n]\r\n```\r\n\r\nCompiling and running through Verilator I get:\r\n\r\n```\r\n# firtool firrtl/Top.fir -annotation-file firrtl/Top.anno.json -split-verilog -o mfc && verilator --lint-only -Imfc Top.sv bindings.sv\r\n%Warning-WIDTH: mfc/Companion_w2.sv:5:32: Operator ASSIGNW expects 1 bits on the Assign RHS, but Assign RHS's VARXREF 'a_w2' generates 2 bits.\r\n                                        : ... In instance Top.dut.companion_w2\r\n    5 |   assign View_w2.SameName.uint = DUT.a_w2;\r\n      |                                ^\r\n                mfc/bindings.sv:5:1: ... note: In file included from bindings.sv\r\n                ... For warning description see https://verilator.org/warn/WIDTH?v=4.222\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.\r\n%Error: Exiting due to 1 warning(s)\r\n```\r\n\r\nIf I manually change the name of the second `SameName` to `SameName_w2`, then everything works.", "code_snippet_01": "circuit Top :\r\n  module Companion_w1 :\r\n    skip\r\n\r\n  module Companion_w2 :\r\n    skip\r\n\r\n  module DUT :\r\n    wire a_w1 : UInt<1>\r\n    a_w1 is invalid\r\n\r\n    wire a_w2 : UInt<2>\r\n    a_w2 is invalid\r\n\r\n    inst companion_w1 of Companion_w1\r\n    inst companion_w2 of Companion_w2\r\n\r\n  module Top :\r\n    inst dut of DUT", "code_snippet_02": "[\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|DUT>a_w1\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|DUT>a_w2\"\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\": \"View_w1\",\r\n    \"companion\": \"~Top|Companion_w1\",\r\n    \"parent\": \"~Top|DUT\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"SameName\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n            \"defName\": \"SameName\",\r\n            \"elements\": [\r\n              {\r\n                \"name\": \"uint\",\r\n                \"tpe\": {\r\n                  \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n                  \"ref\": {\r\n                    \"circuit\": \"Top\",\r\n                    \"module\": \"Top\",\r\n                    \"path\": [\r\n                      {\r\n                        \"_1\": {\r\n                          \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                          \"value\": \"dut\"\r\n                        },\r\n                        \"_2\": {\r\n                          \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                          \"value\": \"DUT\"\r\n                        }\r\n                      }\r\n                    ],\r\n                    \"ref\": \"a_w1\",\r\n                    \"component\": []\r\n                  },\r\n                  \"tpe\": {\r\n                    \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n                  }\r\n                }\r\n              }\r\n            ]\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\": \"View_w2\",\r\n    \"companion\": \"~Top|Companion_w2\",\r\n    \"parent\": \"~Top|DUT\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"SameName\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n            \"defName\": \"SameName\",\r\n            \"elements\": [\r\n              {\r\n                \"name\": \"uint\",\r\n                \"tpe\": {\r\n                  \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n                  \"ref\": {\r\n                    \"circuit\": \"Top\",\r\n                    \"module\": \"Top\",\r\n                    \"path\": [\r\n                      {\r\n                        \"_1\": {\r\n                          \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                          \"value\": \"dut\"\r\n                        },\r\n                        \"_2\": {\r\n                          \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                          \"value\": \"DUT\"\r\n                        }\r\n                      }\r\n                    ],\r\n                    \"ref\": \"a_w2\",\r\n                    \"component\": []\r\n                  },\r\n                  \"tpe\": {\r\n                    \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n                  }\r\n                }\r\n              }\r\n            ]\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\": \"~Top|Companion_w1\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\": \"~Top|Companion_w2\"\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\": \".\",\r\n    \"filename\": \"bindings.sv\"\r\n  }\r\n]", "code_snippet_03": "# firtool firrtl/Top.fir -annotation-file firrtl/Top.anno.json -split-verilog -o mfc && verilator --lint-only -Imfc Top.sv bindings.sv\r\n%Warning-WIDTH: mfc/Companion_w2.sv:5:32: Operator ASSIGNW expects 1 bits on the Assign RHS, but Assign RHS's VARXREF 'a_w2' generates 2 bits.\r\n                                        : ... In instance Top.dut.companion_w2\r\n    5 |   assign View_w2.SameName.uint = DUT.a_w2;\r\n      |                                ^\r\n                mfc/bindings.sv:5:1: ... note: In file included from bindings.sv\r\n                ... For warning description see https://verilator.org/warn/WIDTH?v=4.222\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.\r\n%Error: Exiting due to 1 warning(s)"}, {"number": 4108, "title": "[LLHD] refrence binding to misaligned address (ubsan)", "created_at": "2022-10-14T17:44:30Z", "state": "closed", "labels": "bug, LLHD", "body": "Here's the error:\r\n```\r\nThread 1 \"llhd-sim\" hit Breakpoint 1, 0x0000000004197ae0 in __ubsan_on_report ()\r\n(gdb) bt\r\n#0  0x0000000004197ae0 in __ubsan_on_report ()\r\n#1  0x0000000004191dcd in __ubsan::Diag::~Diag() ()\r\n#2  0x0000000004196073 in handleTypeMismatchImpl(__ubsan::TypeMismatchData*, unsigned long, __ubsan::ReportOptions) ()\r\n#3  0x00000000041971c7 in __ubsan_handle_type_mismatch_v1_abort ()\r\n#4  0x00007ffff7d7cad0 in llvm::ArrayRef<unsigned long>::operator[] (this=<optimized out>, Index=Index@entry=0) at /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:257\r\n#5  0x00007ffff7d6244b in llvm::APInt::initFromArray (this=<optimized out>, bigVal=...) at /home/will/src/sifive/circt/llvm/llvm/lib/Support/APInt.cpp:92\r\n#6  0x00007ffff7d626b9 in llvm::APInt::APInt (this=0x1000, numBits=<optimized out>, bigVal=...) at /home/will/src/sifive/circt/llvm/llvm/lib/Support/APInt.cpp:106\r\n#7  0x00007ffff7d56369 in circt::llhd::sim::Slot::insertChange (this=<optimized out>, index=<optimized out>, bitOffset=<optimized out>, bytes=<optimized out>, width=0) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/State.cpp:77\r\n#8  0x00007ffff7d5661a in circt::llhd::sim::UpdateQueue::insertOrUpdate (this=<optimized out>, time=..., index=<optimized out>, bitOffset=<optimized out>, bytes=<optimized out>, width=<optimized out>) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/State.cpp:99\r\n#9  0x00007ffff7d5459d in driveSignal (state=<optimized out>, detail=<optimized out>, value=<optimized out>, width=<optimized out>, time=<optimized out>, delta=<optimized out>, eps=<optimized out>) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/signals-runtime-wrappers.cpp:67\r\n#10 0x00007ffff6a02203 in _mlir_root ()\r\n#11 0x0000000004519ed7 in circt::llhd::sim::Engine::simulate (this=<optimized out>, n=<optimized out>, maxTime=<optimized out>) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/Engine.cpp:199\r\n#12 0x000000000419b77f in main (argc=<optimized out>, argv=<optimized out>) at /home/will/src/sifive/circt/tools/llhd-sim/llhd-sim.cpp:219\r\n(gdb) c\r\nContinuing.\r\n/home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:257:14: runtime error: reference binding to misaligned address 0x7ffffffef234 for type 'const unsigned long', which requires 8 byte alignment\r\n0x7ffffffef234: note: pointer points here\r\n  d0 f9 fe ff 00 00 ff ff  00 fb fe ff ff 7f 00 00  f0 f9 fe ff ff 7f 00 00  10 f9 fe ff ff 7f 00 00\r\n              ^ \r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:257:14 in \r\n[LWP 1951347 exited]\r\n[LWP 1951346 exited]\r\n[LWP 1951345 exited]\r\n[LWP 1951343 exited]\r\n[LWP 1951340 exited]\r\n[LWP 1951344 exited]\r\n[New process 1951340]\r\n[Inferior 1 (process 1951340) exited with code 01]\r\n(gdb) \r\n```\r\n\r\n(not sure why wasn't printing stack trace, so used gdb to grab it-- break on `__ubsan_on_report`)", "code_snippet_01": "Thread 1 \"llhd-sim\" hit Breakpoint 1, 0x0000000004197ae0 in __ubsan_on_report ()\r\n(gdb) bt\r\n#0  0x0000000004197ae0 in __ubsan_on_report ()\r\n#1  0x0000000004191dcd in __ubsan::Diag::~Diag() ()\r\n#2  0x0000000004196073 in handleTypeMismatchImpl(__ubsan::TypeMismatchData*, unsigned long, __ubsan::ReportOptions) ()\r\n#3  0x00000000041971c7 in __ubsan_handle_type_mismatch_v1_abort ()\r\n#4  0x00007ffff7d7cad0 in llvm::ArrayRef<unsigned long>::operator[] (this=<optimized out>, Index=Index@entry=0) at /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:257\r\n#5  0x00007ffff7d6244b in llvm::APInt::initFromArray (this=<optimized out>, bigVal=...) at /home/will/src/sifive/circt/llvm/llvm/lib/Support/APInt.cpp:92\r\n#6  0x00007ffff7d626b9 in llvm::APInt::APInt (this=0x1000, numBits=<optimized out>, bigVal=...) at /home/will/src/sifive/circt/llvm/llvm/lib/Support/APInt.cpp:106\r\n#7  0x00007ffff7d56369 in circt::llhd::sim::Slot::insertChange (this=<optimized out>, index=<optimized out>, bitOffset=<optimized out>, bytes=<optimized out>, width=0) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/State.cpp:77\r\n#8  0x00007ffff7d5661a in circt::llhd::sim::UpdateQueue::insertOrUpdate (this=<optimized out>, time=..., index=<optimized out>, bitOffset=<optimized out>, bytes=<optimized out>, width=<optimized out>) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/State.cpp:99\r\n#9  0x00007ffff7d5459d in driveSignal (state=<optimized out>, detail=<optimized out>, value=<optimized out>, width=<optimized out>, time=<optimized out>, delta=<optimized out>, eps=<optimized out>) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/signals-runtime-wrappers.cpp:67\r\n#10 0x00007ffff6a02203 in _mlir_root ()\r\n#11 0x0000000004519ed7 in circt::llhd::sim::Engine::simulate (this=<optimized out>, n=<optimized out>, maxTime=<optimized out>) at /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/Engine.cpp:199\r\n#12 0x000000000419b77f in main (argc=<optimized out>, argv=<optimized out>) at /home/will/src/sifive/circt/tools/llhd-sim/llhd-sim.cpp:219\r\n(gdb) c\r\nContinuing.\r\n/home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:257:14: runtime error: reference binding to misaligned address 0x7ffffffef234 for type 'const unsigned long', which requires 8 byte alignment\r\n0x7ffffffef234: note: pointer points here\r\n  d0 f9 fe ff 00 00 ff ff  00 fb fe ff ff 7f 00 00  f0 f9 fe ff ff 7f 00 00  10 f9 fe ff ff 7f 00 00\r\n              ^ \r\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ArrayRef.h:257:14 in \r\n[LWP 1951347 exited]\r\n[LWP 1951346 exited]\r\n[LWP 1951345 exited]\r\n[LWP 1951343 exited]\r\n[LWP 1951340 exited]\r\n[LWP 1951344 exited]\r\n[New process 1951340]\r\n[Inferior 1 (process 1951340) exited with code 01]\r\n(gdb)"}, {"number": 4107, "title": "[LLHD] alloc/dealloc mismatch (ASAN)", "created_at": "2022-10-14T17:39:53Z", "state": "closed", "labels": "bug, LLHD", "body": "A number of lit tests trigger alloc/dealloc mismatch errors, I think they're all the same here's one of them:\r\n\r\n```\r\n********************\r\nFAIL: CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir (26 of 495)\r\n******************** TEST 'CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 2';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=full -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=FULL\r\n: 'RUN: at line 3';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=reduced -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=REDUCED\r\n: 'RUN: at line 4';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=merged -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=MERGED\r\n: 'RUN: at line 5';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=merged-reduce -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=MERGEDRED\r\n: 'RUN: at line 6';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=named-only -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=NAMED\r\n--\r\nExit Code: 2\r\n\r\nCommand Output (stderr):\r\n--\r\nFinished at 5000ps 0d 2e (18 cycles)\r\n=================================================================\r\n==1941963==ERROR: AddressSanitizer: alloc-dealloc-mismatch (malloc vs operator delete) on 0x60200001cb10\r\n    #0 0x4198b27 in operator delete(void*) (/build/sifive/asan/bin/llhd-sim+0x4198b27)\r\n    #1 0x7f63d141ba46 in std::default_delete<unsigned char>::operator()(unsigned char*) const /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:85:2\r\n    #2 0x7f63d141ba46 in std::unique_ptr<unsigned char, std::default_delete<unsigned char> >::~unique_ptr() /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:361:4\r\n    #3 0x7f63d14285f4 in circt::llhd::sim::Instance::~Instance() /home/will/src/sifive/circt/include/circt/Dialect/LLHD/Simulator/State.h:276:8\r\n    #4 0x7f63d1421d74 in llvm::SmallVectorTemplateBase<circt::llhd::sim::Instance, false>::destroy_range(circt::llhd::sim::Instance*, circt::llhd::sim::Instance*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:344:11\r\n    #5 0x7f63d1421d74 in llvm::SmallVector<circt::llhd::sim::Instance, 0u>::~SmallVector() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:1206:5\r\n    #6 0x7f63d141eb60 in circt::llhd::sim::State::~State() /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/State.cpp:198:1\r\n    #7 0x451c592 in std::default_delete<circt::llhd::sim::State>::operator()(circt::llhd::sim::State*) const /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:85:2\r\n    #8 0x451c592 in std::unique_ptr<circt::llhd::sim::State, std::default_delete<circt::llhd::sim::State> >::~unique_ptr() /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:361:4\r\n    #9 0x45182aa in circt::llhd::sim::Engine::~Engine() /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/Engine.cpp:61:17\r\n    #10 0x419bb2e in main /home/will/src/sifive/circt/tools/llhd-sim/llhd-sim.cpp:223:1\r\n    #11 0x7f63d0c2924d in __libc_start_call_main (/nix/store/bzd91shky9j9d43girrrj6vmqlw7x9m8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 48753e3935872af81d27236b831592ed06e477fb)\r\n    #12 0x7f63d0c29308 in __libc_start_main@GLIBC_2.2.5 (/nix/store/bzd91shky9j9d43girrrj6vmqlw7x9m8-glibc-2.35-163/lib/libc.so.6+0x29308) (BuildId: 48753e3935872af81d27236b831592ed06e477fb)\r\n    #13 0x40a43a4 in _start (/build/sifive/asan/bin/llhd-sim+0x40a43a4)\r\n\r\n0x60200001cb10 is located 0 bytes inside of 1-byte region [0x60200001cb10,0x60200001cb11)\r\nallocated by thread T0 here:\r\nLLVMSymbolizer: error reading file: No such file or directory\r\n    #0 0x41548cf in malloc (/build/sifive/asan/bin/llhd-sim+0x41548cf)\r\n    #1 0x7f63d0204056  (<unknown module>)\r\n    #2 0x451875b in circt::llhd::sim::Engine::simulate(int, unsigned long) /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/Engine.cpp:76:35\r\n    #3 0x419b77e in main /home/will/src/sifive/circt/tools/llhd-sim/llhd-sim.cpp:219:10\r\n    #4 0x7f63d0c2924d in __libc_start_call_main (/nix/store/bzd91shky9j9d43girrrj6vmqlw7x9m8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 48753e3935872af81d27236b831592ed06e477fb)\r\n    #5 0x7ffd4db0030a  ([stack]+0x2130a)\r\n\r\nSUMMARY: AddressSanitizer: alloc-dealloc-mismatch (/build/sifive/asan/bin/llhd-sim+0x4198b27) in operator delete(void*)\r\n==1941963==HINT: if you don't care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\r\n==1941963==ABORTING\r\n```", "code_snippet_01": "********************\r\nFAIL: CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir (26 of 495)\r\n******************** TEST 'CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 2';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=full -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=FULL\r\n: 'RUN: at line 3';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=reduced -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=REDUCED\r\n: 'RUN: at line 4';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=merged -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=MERGED\r\n: 'RUN: at line 5';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=merged-reduce -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=MERGEDRED\r\n: 'RUN: at line 6';   /build/sifive/asan/bin/llhd-sim /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir -T 5000 --trace-format=named-only -shared-libs=/build/sifive/asan/./lib/libcirct-llhd-signals-runtime-wrappers.so | /build/sifive/asan/bin/FileCheck /home/will/src/sifive/circt/test/Dialect/LLHD/Simulator/sim_formats.mlir --check-prefix=NAMED\r\n--\r\nExit Code: 2\r\n\r\nCommand Output (stderr):\r\n--\r\nFinished at 5000ps 0d 2e (18 cycles)\r\n=================================================================\r\n==1941963==ERROR: AddressSanitizer: alloc-dealloc-mismatch (malloc vs operator delete) on 0x60200001cb10\r\n    #0 0x4198b27 in operator delete(void*) (/build/sifive/asan/bin/llhd-sim+0x4198b27)\r\n    #1 0x7f63d141ba46 in std::default_delete<unsigned char>::operator()(unsigned char*) const /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:85:2\r\n    #2 0x7f63d141ba46 in std::unique_ptr<unsigned char, std::default_delete<unsigned char> >::~unique_ptr() /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:361:4\r\n    #3 0x7f63d14285f4 in circt::llhd::sim::Instance::~Instance() /home/will/src/sifive/circt/include/circt/Dialect/LLHD/Simulator/State.h:276:8\r\n    #4 0x7f63d1421d74 in llvm::SmallVectorTemplateBase<circt::llhd::sim::Instance, false>::destroy_range(circt::llhd::sim::Instance*, circt::llhd::sim::Instance*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:344:11\r\n    #5 0x7f63d1421d74 in llvm::SmallVector<circt::llhd::sim::Instance, 0u>::~SmallVector() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:1206:5\r\n    #6 0x7f63d141eb60 in circt::llhd::sim::State::~State() /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/State.cpp:198:1\r\n    #7 0x451c592 in std::default_delete<circt::llhd::sim::State>::operator()(circt::llhd::sim::State*) const /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:85:2\r\n    #8 0x451c592 in std::unique_ptr<circt::llhd::sim::State, std::default_delete<circt::llhd::sim::State> >::~unique_ptr() /nix/store/l4dvshb0bw0ipyx17f6rknzk83mdx81y-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:361:4\r\n    #9 0x45182aa in circt::llhd::sim::Engine::~Engine() /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/Engine.cpp:61:17\r\n    #10 0x419bb2e in main /home/will/src/sifive/circt/tools/llhd-sim/llhd-sim.cpp:223:1\r\n    #11 0x7f63d0c2924d in __libc_start_call_main (/nix/store/bzd91shky9j9d43girrrj6vmqlw7x9m8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 48753e3935872af81d27236b831592ed06e477fb)\r\n    #12 0x7f63d0c29308 in __libc_start_main@GLIBC_2.2.5 (/nix/store/bzd91shky9j9d43girrrj6vmqlw7x9m8-glibc-2.35-163/lib/libc.so.6+0x29308) (BuildId: 48753e3935872af81d27236b831592ed06e477fb)\r\n    #13 0x40a43a4 in _start (/build/sifive/asan/bin/llhd-sim+0x40a43a4)\r\n\r\n0x60200001cb10 is located 0 bytes inside of 1-byte region [0x60200001cb10,0x60200001cb11)\r\nallocated by thread T0 here:\r\nLLVMSymbolizer: error reading file: No such file or directory\r\n    #0 0x41548cf in malloc (/build/sifive/asan/bin/llhd-sim+0x41548cf)\r\n    #1 0x7f63d0204056  (<unknown module>)\r\n    #2 0x451875b in circt::llhd::sim::Engine::simulate(int, unsigned long) /home/will/src/sifive/circt/lib/Dialect/LLHD/Simulator/Engine.cpp:76:35\r\n    #3 0x419b77e in main /home/will/src/sifive/circt/tools/llhd-sim/llhd-sim.cpp:219:10\r\n    #4 0x7f63d0c2924d in __libc_start_call_main (/nix/store/bzd91shky9j9d43girrrj6vmqlw7x9m8-glibc-2.35-163/lib/libc.so.6+0x2924d) (BuildId: 48753e3935872af81d27236b831592ed06e477fb)\r\n    #5 0x7ffd4db0030a  ([stack]+0x2130a)\r\n\r\nSUMMARY: AddressSanitizer: alloc-dealloc-mismatch (/build/sifive/asan/bin/llhd-sim+0x4198b27) in operator delete(void*)\r\n==1941963==HINT: if you don't care about these errors you may set ASAN_OPTIONS=alloc_dealloc_mismatch=0\r\n==1941963==ABORTING"}, {"number": 4097, "title": "[FIRRTL][SV] Grand Central w/ Extract Test Code Can Create Bind-under-bind", "created_at": "2022-10-13T21:36:28Z", "state": "open", "labels": "bug, FIRRTL", "body": "Nested binds are pedantically illegal SystemVerilog even though some tools support them. I have a situation where the combination of instantiating a module inside a Grand Central View that has assertions can result in extraction which produces a bind-under-bind.\r\n\r\nConsider the following FIRRTL text and annotation file:\r\n\r\n```\r\ncircuit Top :\r\n  extmodule DataTap_2 :\r\n    output _2 : UInt<1>\r\n    output _1 : UInt<1>\r\n    output _0 : Clock\r\n    defname = DataTap_2\r\n\r\n  module Wrapper :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n\r\n    node _T = asUInt(reset)\r\n    node _T_1 = eq(_T, UInt<1>(\"h0\"))\r\n    when _T_1 :\r\n      node _T_2 = eq(in, UInt<1>(\"h0\"))\r\n      when _T_2 :\r\n        printf(clock, UInt<1>(\"h1\"), \"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\") : printf\r\n      assert(clock, in, UInt<1>(\"h1\"), \"\") : assert\r\n\r\n\r\n  module MyView_companion :\r\n\r\n    wire _WIRE : UInt<1>\r\n    _WIRE <= UInt<1>(\"h0\")\r\n    wire clk : Clock\r\n    wire rst : UInt<1>\r\n    wire cond : UInt<1>\r\n    inst DataTap_2 of DataTap_2\r\n    DataTap_2._0 is invalid\r\n    DataTap_2._1 is invalid\r\n    DataTap_2._2 is invalid\r\n    clk <= DataTap_2._0\r\n    rst <= DataTap_2._1\r\n    cond <= DataTap_2._2\r\n    inst wrapper of Wrapper\r\n    wrapper.clock <= clk\r\n    wrapper.reset <= rst\r\n    wrapper.in <= cond\r\n\r\n  module DUT :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n\r\n    wire w : UInt<1>\r\n    w <= in\r\n    inst MyView_companion of MyView_companion\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input in : UInt<1>\r\n\r\n    inst dut of DUT\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    dut.in <= in\r\n```\r\n\r\n```json\r\n[\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\":\"~Top|DataTap_2\",\r\n    \"keys\":[\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>clock\",\r\n        \"portName\":\"~Top|DataTap_2>_0\"\r\n      },\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>reset\",\r\n        \"portName\":\"~Top|DataTap_2>_1\"\r\n      },\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>w\",\r\n        \"portName\":\"~Top|DataTap_2>_2\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\":\"MyView\",\r\n    \"companion\":\"~Top|MyView_companion\",\r\n    \"parent\":\"~Top|DUT\",\r\n    \"view\":\"{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedBundleType\\\",\\\"defName\\\":\\\"MyInterface\\\",\\\"elements\\\":[{\\\"name\\\":\\\"ground\\\",\\\"description\\\":\\\"a ground type port\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\",\\\"ref\\\":{\\\"circuit\\\":\\\"Top\\\",\\\"module\\\":\\\"Top\\\",\\\"path\\\":[{\\\"_1\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$Instance\\\",\\\"value\\\":\\\"dut\\\"},\\\"_2\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$OfModule\\\",\\\"value\\\":\\\"DUT\\\"}}],\\\"ref\\\":\\\"w\\\",\\\"component\\\":[]},\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\\\"}}}]}\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"Top.DUT\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"gct\",\r\n    \"filename\":\"bindings.sv\"\r\n  }\r\n]\r\n```\r\n\r\nCompiling this with `firtool Top.fir -annotation-file Top.anno.json -extract-test-code` produces the illegal:\r\n\r\n```\r\n// Generated by CIRCT unknown git version\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\n// VCS coverage exclude_file\r\nmodule Wrapper_assert(\r\n  input in,\r\n        reset,\r\n        clock);\r\n\r\n  `ifndef SYNTHESIS\r\n    always @(posedge clock) begin\r\n      if (~reset & ~in) begin\r\n        if (`ASSERT_VERBOSE_COND_)\r\n          $error(\"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\");\r\n        if (`STOP_COND_)\r\n          $fatal;\r\n      end\r\n    end // always @(posedge)\r\n  `endif // not def SYNTHESIS\r\nendmodule\r\n\r\nmodule DUT(\r\n  input clock,\r\n        reset,\r\n        in);\r\n\r\n  wire w = in;\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    MyView_companion MyView_companion ();\r\n  */\r\nendmodule\r\n\r\nmodule Top(\r\n  input clock,\r\n        reset,\r\n        in);\r\n\r\n  DUT dut (\r\n    .clock (clock),\r\n    .reset (reset),\r\n    .in    (in)\r\n  );\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"gct/DataTap_2_impl_0.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// VCS coverage exclude_file\r\nmodule DataTap_2_impl_0(\r\n  output _2,\r\n         _1,\r\n         _0);\r\n\r\n  assign _2 = DUT.w;\r\n  assign _1 = DUT.reset;\r\n  assign _0 = DUT.clock;\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"gct/MyView_companion.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\n// VCS coverage exclude_file\r\nmodule MyView_companion();\r\n  wire _DataTap_2__2;\r\n  wire _DataTap_2__1;\r\n  wire _DataTap_2__0;\r\n  MyInterface MyView();\r\n  `ifndef SYNTHESIS\r\n    always @(posedge _DataTap_2__0) begin\r\n      if (~_DataTap_2__1 & ~_DataTap_2__2) begin\r\n        if (`ASSERT_VERBOSE_COND_)\r\n          $error(\"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\");\r\n        if (`STOP_COND_)\r\n          $fatal;\r\n      end\r\n    end // always @(posedge)\r\n  `endif // not def SYNTHESIS\r\n  assign MyView.ground = DUT.w;\r\n  DataTap_2_impl_0 DataTap_2 (\r\n    ._2 (_DataTap_2__2),\r\n    ._1 (_DataTap_2__1),\r\n    ._0 (_DataTap_2__0)\r\n  );\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    Wrapper_assert Wrapper_assert (\r\n      .in    (_DataTap_2__2),\r\n      .reset (_DataTap_2__1),\r\n      .clock (_DataTap_2__0)\r\n    );\r\n  */\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"bindings.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\nbind DUT MyView_companion MyView_companion ();\r\n\r\n// ----- 8< ----- FILE \"gct/MyInterface.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// VCS coverage exclude_file\r\ninterface MyInterface;\r\n  // a ground type port\r\n  logic ground;\r\nendinterface\r\n\r\n\r\n// ----- 8< ----- FILE \"bindfile\" ----- 8< -----\r\n\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\nbind MyView_companion Wrapper_assert Wrapper_assert (\r\n  .in    (_DataTap_2__2),\r\n  .reset (_DataTap_2__1),\r\n  .clock (_DataTap_2__0)\r\n);\r\n```\r\n\r\nNotice that `MyView_companion` is bound into `DUT` and `Wrapper_assert` is bound into `MyView_companion`. Verilator happily accepts this, so I don't have a nice script to lint that this doesn't happen.", "code_snippet_01": "circuit Top :\r\n  extmodule DataTap_2 :\r\n    output _2 : UInt<1>\r\n    output _1 : UInt<1>\r\n    output _0 : Clock\r\n    defname = DataTap_2\r\n\r\n  module Wrapper :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n\r\n    node _T = asUInt(reset)\r\n    node _T_1 = eq(_T, UInt<1>(\"h0\"))\r\n    when _T_1 :\r\n      node _T_2 = eq(in, UInt<1>(\"h0\"))\r\n      when _T_2 :\r\n        printf(clock, UInt<1>(\"h1\"), \"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\") : printf\r\n      assert(clock, in, UInt<1>(\"h1\"), \"\") : assert\r\n\r\n\r\n  module MyView_companion :\r\n\r\n    wire _WIRE : UInt<1>\r\n    _WIRE <= UInt<1>(\"h0\")\r\n    wire clk : Clock\r\n    wire rst : UInt<1>\r\n    wire cond : UInt<1>\r\n    inst DataTap_2 of DataTap_2\r\n    DataTap_2._0 is invalid\r\n    DataTap_2._1 is invalid\r\n    DataTap_2._2 is invalid\r\n    clk <= DataTap_2._0\r\n    rst <= DataTap_2._1\r\n    cond <= DataTap_2._2\r\n    inst wrapper of Wrapper\r\n    wrapper.clock <= clk\r\n    wrapper.reset <= rst\r\n    wrapper.in <= cond\r\n\r\n  module DUT :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n\r\n    wire w : UInt<1>\r\n    w <= in\r\n    inst MyView_companion of MyView_companion\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input in : UInt<1>\r\n\r\n    inst dut of DUT\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    dut.in <= in", "code_snippet_02": "[\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\":\"~Top|DataTap_2\",\r\n    \"keys\":[\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>clock\",\r\n        \"portName\":\"~Top|DataTap_2>_0\"\r\n      },\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>reset\",\r\n        \"portName\":\"~Top|DataTap_2>_1\"\r\n      },\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>w\",\r\n        \"portName\":\"~Top|DataTap_2>_2\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\":\"MyView\",\r\n    \"companion\":\"~Top|MyView_companion\",\r\n    \"parent\":\"~Top|DUT\",\r\n    \"view\":\"{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedBundleType\\\",\\\"defName\\\":\\\"MyInterface\\\",\\\"elements\\\":[{\\\"name\\\":\\\"ground\\\",\\\"description\\\":\\\"a ground type port\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\",\\\"ref\\\":{\\\"circuit\\\":\\\"Top\\\",\\\"module\\\":\\\"Top\\\",\\\"path\\\":[{\\\"_1\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$Instance\\\",\\\"value\\\":\\\"dut\\\"},\\\"_2\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$OfModule\\\",\\\"value\\\":\\\"DUT\\\"}}],\\\"ref\\\":\\\"w\\\",\\\"component\\\":[]},\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\\\"}}}]}\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"Top.DUT\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"gct\",\r\n    \"filename\":\"bindings.sv\"\r\n  }\r\n]", "code_snippet_03": "// Generated by CIRCT unknown git version\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\n// VCS coverage exclude_file\r\nmodule Wrapper_assert(\r\n  input in,\r\n        reset,\r\n        clock);\r\n\r\n  `ifndef SYNTHESIS\r\n    always @(posedge clock) begin\r\n      if (~reset & ~in) begin\r\n        if (`ASSERT_VERBOSE_COND_)\r\n          $error(\"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\");\r\n        if (`STOP_COND_)\r\n          $fatal;\r\n      end\r\n    end // always @(posedge)\r\n  `endif // not def SYNTHESIS\r\nendmodule\r\n\r\nmodule DUT(\r\n  input clock,\r\n        reset,\r\n        in);\r\n\r\n  wire w = in;\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    MyView_companion MyView_companion ();\r\n  */\r\nendmodule\r\n\r\nmodule Top(\r\n  input clock,\r\n        reset,\r\n        in);\r\n\r\n  DUT dut (\r\n    .clock (clock),\r\n    .reset (reset),\r\n    .in    (in)\r\n  );\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"gct/DataTap_2_impl_0.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// VCS coverage exclude_file\r\nmodule DataTap_2_impl_0(\r\n  output _2,\r\n         _1,\r\n         _0);\r\n\r\n  assign _2 = DUT.w;\r\n  assign _1 = DUT.reset;\r\n  assign _0 = DUT.clock;\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"gct/MyView_companion.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\n// VCS coverage exclude_file\r\nmodule MyView_companion();\r\n  wire _DataTap_2__2;\r\n  wire _DataTap_2__1;\r\n  wire _DataTap_2__0;\r\n  MyInterface MyView();\r\n  `ifndef SYNTHESIS\r\n    always @(posedge _DataTap_2__0) begin\r\n      if (~_DataTap_2__1 & ~_DataTap_2__2) begin\r\n        if (`ASSERT_VERBOSE_COND_)\r\n          $error(\"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\");\r\n        if (`STOP_COND_)\r\n          $fatal;\r\n      end\r\n    end // always @(posedge)\r\n  `endif // not def SYNTHESIS\r\n  assign MyView.ground = DUT.w;\r\n  DataTap_2_impl_0 DataTap_2 (\r\n    ._2 (_DataTap_2__2),\r\n    ._1 (_DataTap_2__1),\r\n    ._0 (_DataTap_2__0)\r\n  );\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    Wrapper_assert Wrapper_assert (\r\n      .in    (_DataTap_2__2),\r\n      .reset (_DataTap_2__1),\r\n      .clock (_DataTap_2__0)\r\n    );\r\n  */\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"bindings.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\nbind DUT MyView_companion MyView_companion ();\r\n\r\n// ----- 8< ----- FILE \"gct/MyInterface.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// VCS coverage exclude_file\r\ninterface MyInterface;\r\n  // a ground type port\r\n  logic ground;\r\nendinterface\r\n\r\n\r\n// ----- 8< ----- FILE \"bindfile\" ----- 8< -----\r\n\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\nbind MyView_companion Wrapper_assert Wrapper_assert (\r\n  .in    (_DataTap_2__2),\r\n  .reset (_DataTap_2__1),\r\n  .clock (_DataTap_2__0)\r\n);"}, {"number": 4096, "title": "[FIRRTL][ExpandWhens] Add iterator to `HashTableStack`", "created_at": "2022-10-13T19:39:05Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The HashTableStack iterator was reusing the underlying data structure's (MapVector) iterator.  The `HashTableStack::end()` function would create a default constructed iterator which was not tied to any `MapVector`.  When comparing the default constructed iterator to a real iterator on Windows, this would crash.\r\n\r\nRunning a Windows test on this branch here: https://github.com/llvm/circt/actions/runs/3245347009"}, {"number": 4084, "title": "[ExportVerilog] Spill variable assigned but not declared", "created_at": "2022-10-12T01:52:00Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "I ran into this curious behavior of `ExportVerilog` where it would sometimes spill to a variable without actually declaring that variable. This seems to be very difficult to trigger -- I've had a hard time reducing this down since any small changes or shortening of the concats causes the issue to disappear.\r\n\r\nInput MLIR:\r\n```mlir\r\nhw.module public @Foo(%k0: i1, %k1: i1, %k2: i1) {\r\n  %0 = comb.concat %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0 : i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1\r\n  %1 = comb.concat %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1 : i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1\r\n  %2 = comb.concat %k2, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1 : i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1\r\n  %3 = comb.or %0, %1, %2 : i12\r\n  %r = sv.reg : !hw.inout<i12>\r\n  sv.initial {\r\n    sv.passign %r, %3 : i12\r\n  }\r\n}\r\n```\r\n\r\nRunning through firtool produces the following Verilog (my indentation for clarity):\r\n```systemverilog\r\nmodule Foo(input k0, k1, k2);\r\n  reg [11:0] r;\r\n  initial begin\r\n    automatic logic [11:0] _GEN =\r\n        {k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0};\r\n    automatic logic [11:0] _GEN_0 =\r\n        {k0, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1} |\r\n        {k2, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1};\r\n    automatic logic [11:0] _GEN_1 = _GEN_0;\r\n    _GEN_2 = {k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0};\r\n    // ^^^--- note how _GEN_2 has never been declared\r\n    r <= _GEN_2 | _GEN_0;\r\n  end\r\nendmodule\r\n```\r\n\r\nNo idea how this happens. (Hot, highly uneducated guess: something about spilling to a variable while already spilling to a variable, and somehow corrupting text buffer pointers.)", "code_snippet_01": "hw.module public @Foo(%k0: i1, %k1: i1, %k2: i1) {\r\n  %0 = comb.concat %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0 : i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1\r\n  %1 = comb.concat %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1 : i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1\r\n  %2 = comb.concat %k2, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1, %k0, %k1 : i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1, i1\r\n  %3 = comb.or %0, %1, %2 : i12\r\n  %r = sv.reg : !hw.inout<i12>\r\n  sv.initial {\r\n    sv.passign %r, %3 : i12\r\n  }\r\n}", "code_snippet_02": "module Foo(input k0, k1, k2);\r\n  reg [11:0] r;\r\n  initial begin\r\n    automatic logic [11:0] _GEN =\r\n        {k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0};\r\n    automatic logic [11:0] _GEN_0 =\r\n        {k0, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1} |\r\n        {k2, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1};\r\n    automatic logic [11:0] _GEN_1 = _GEN_0;\r\n    _GEN_2 = {k1, k0, k1, k0, k1, k0, k1, k0, k1, k0, k1, k0};\r\n    // ^^^--- note how _GEN_2 has never been declared\r\n    r <= _GEN_2 | _GEN_0;\r\n  end\r\nendmodule"}, {"number": 4081, "title": "[asan] hw-extract-test-code test triggers heap-user-after-free", "created_at": "2022-10-11T16:12:07Z", "state": "closed", "labels": "bug", "body": "Looks like we mutate the instance graph while iterating over it? Haven't investigated, here's the error:\r\n\r\n```\r\n==1579121==ERROR: AddressSanitizer: heap-use-after-free on address 0x606000010f10 at pc 0x00000284bd39 bp 0x7fffed234b40 sp 0x7fffed234b38\r\nREAD of size 8 at 0x606000010f10 thread T0\r\n    #0 0x284bd38 in circt::hw::InstanceGraphNode::UseIterator::operator++() /home/will/src/sifive/circt/include/circt/Dialect/HW/InstanceGraphBase.h:126:26\r\n    #1 0x377139d in inlineInputOnly(circt::hw::HWModuleOp, circt::hw::InstanceGraph&, llvm::DenseMap<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> >, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> > > >&) /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:383:32\r\n    #2 0x377139d in (anonymous namespace)::SVExtractTestCodeImplPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:639:9\r\n    #3 0x54bd7e9 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:469:11\r\n    #4 0x54bea35 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:533:16\r\n    #5 0x54c34e9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:836:10\r\n    #6 0x54c3242 in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:816:60\r\n    #7 0x40f6862 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17\r\n    #8 0x40f5fd1 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12\r\n    #9 0x40f5fd1 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12\r\n    #10 0x40f5fd1 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #11 0x414e1f6 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #12 0x414df42 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16\r\n    #13 0x414d67b in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1872:5\r\n    #14 0x414d67b in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1890:3\r\n    #15 0x414d67b in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3\r\n    #16 0x40f3e4f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10\r\n    #17 0x40f4123 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:205:10\r\n    #18 0x40f4972 in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:298:14\r\n    #19 0x1d660b5 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:64:23\r\n    #20 0x7f28279fb236 in __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29236) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)\r\n    #21 0x7f28279fb2f4 in __libc_start_main@GLIBC_2.2.5 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x292f4) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)\r\n    #22 0x1c6ee90 in _start /build/glibc-2.34/csu/../sysdeps/x86_64/start.S:116\r\n\r\n0x606000010f10 is located 48 bytes inside of 64-byte region [0x606000010ee0,0x606000010f20)\r\nfreed by thread T0 here:\r\nLLVMSymbolizer: error reading file: No such file or directory\r\n    #0 0x1d63617 in operator delete(void*) (/build/sifive/asan/bin/circt-opt+0x1d63617)\r\n    #1 0x32bc1c0 in llvm::ilist_alloc_traits<circt::hw::InstanceRecord>::deleteNode(circt::hw::InstanceRecord*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:42:39\r\n    #2 0x32bc1c0 in llvm::iplist_impl<llvm::simple_ilist<circt::hw::InstanceRecord>, llvm::ilist_traits<circt::hw::InstanceRecord> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<circt::hw::InstanceRecord, true, false, void>, false, false>) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:269:5\r\n    #3 0x32bc1c0 in llvm::iplist_impl<llvm::simple_ilist<circt::hw::InstanceRecord>, llvm::ilist_traits<circt::hw::InstanceRecord> >::erase(circt::hw::InstanceRecord*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:273:39\r\n    #4 0x32b774f in circt::hw::InstanceRecord::erase() /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:24:26\r\n    #5 0x377130e in inlineInputOnly(circt::hw::HWModuleOp, circt::hw::InstanceGraph&, llvm::DenseMap<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> >, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> > > >&) /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:431:10\r\n    #6 0x377130e in (anonymous namespace)::SVExtractTestCodeImplPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:639:9\r\n    #7 0x54bd7e9 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:469:11\r\n    #8 0x54bea35 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:533:16\r\n    #9 0x54c34e9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:836:10\r\n    #10 0x54c3242 in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:816:60\r\n    #11 0x40f6862 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17\r\n    #12 0x40f5fd1 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12\r\n    #13 0x40f5fd1 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12\r\n    #14 0x40f5fd1 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #15 0x414e1f6 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #16 0x414df42 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16\r\n    #17 0x414d67b in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1872:5\r\n    #18 0x414d67b in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1890:3\r\n    #19 0x414d67b in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3\r\n    #20 0x40f3e4f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10\r\n    #21 0x40f4123 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:205:10\r\n    #22 0x40f4972 in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:298:14\r\n    #23 0x1d660b5 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:64:23\r\n    #24 0x7f28279fb236 in __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29236) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)\r\n    #25 0x7fffed23a110  ([stack]+0x20110)\r\n    #26 0x73612f6576696668  (<unknown module>)\r\n\r\npreviously allocated by thread T0 here:\r\n    #0 0x1d62c47 in operator new(unsigned long) (/build/sifive/asan/bin/circt-opt+0x1d62c47)\r\n    #1 0x32b7803 in circt::hw::InstanceGraphNode::addInstance(circt::hw::HWInstanceLike, circt::hw::InstanceGraphNode*) /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:29:26\r\n    #2 0x32bb2d3 in circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)::operator()(circt::hw::HWInstanceLike) const /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:63:20\r\n    #3 0x32bb2d3 in std::enable_if<(!(llvm::is_one_of<circt::hw::HWInstanceLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), circt::hw::HWInstanceLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&)::'lambda'(mlir::Operation*)::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:195:7\r\n    #4 0x32bb2d3 in void llvm::function_ref<void (mlir::Operation*)>::callback_fn<std::enable_if<(!(llvm::is_one_of<circt::hw::HWInstanceLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), circt::hw::HWInstanceLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&)::'lambda'(mlir::Operation*)>(long, mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #5 0x3b4d0a2 in llvm::function_ref<void (mlir::Operation*)>::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #6 0x3b4d0a2 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:70:5\r\n    #7 0x3b4d008 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:65:9\r\n    #8 0x32baf26 in std::enable_if<(!(llvm::is_one_of<circt::hw::HWInstanceLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), circt::hw::HWInstanceLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:197:10\r\n    #9 0x32baf26 in std::enable_if<(llvm::function_traits<std::decay<circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)>::type>::num_args) == (1), void>::type mlir::Operation::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), void>(circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:575:12\r\n    #10 0x32baf26 in std::enable_if<(llvm::function_traits<std::decay<circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)>::type>::num_args) == (1), void>::type mlir::OpState::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), void>(circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/OpDefinition.h:153:19\r\n    #11 0x32baf26 in circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:60:12\r\n    #12 0x32baf26 in std::enable_if<(!(llvm::is_one_of<circt::hw::HWModuleLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, circt::hw::HWModuleLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&)::'lambda'(mlir::Operation*)::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:195:7\r\n    #13 0x32baf26 in void llvm::function_ref<void (mlir::Operation*)>::callback_fn<std::enable_if<(!(llvm::is_one_of<circt::hw::HWModuleLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, circt::hw::HWModuleLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&)::'lambda'(mlir::Operation*)>(long, mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #14 0x3b4d0a2 in llvm::function_ref<void (mlir::Operation*)>::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #15 0x3b4d0a2 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:70:5\r\n    #16 0x3b4d008 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:65:9\r\n    #17 0x32b7e8f in std::enable_if<(!(llvm::is_one_of<circt::hw::HWModuleLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, circt::hw::HWModuleLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:197:10\r\n    #18 0x32b7e8f in std::enable_if<(llvm::function_traits<std::decay<circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0>::type>::num_args) == (1), void>::type mlir::Operation::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, void>(circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:575:12\r\n    #19 0x32b7e8f in circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:54:11\r\n    #20 0x32053db in circt::hw::InstanceGraph::InstanceGraph(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/HW/HWInstanceGraph.cpp:15:7\r\n    #21 0x1f843c9 in mlir::detail::AnalysisModel<circt::hw::InstanceGraph>::AnalysisModel<mlir::ModuleOp&>(mlir::ModuleOp&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:119:9\r\n    #22 0x1f843c9 in std::_MakeUniq<mlir::detail::AnalysisModel<circt::hw::InstanceGraph> >::__single_object std::make_unique<mlir::detail::AnalysisModel<circt::hw::InstanceGraph>, mlir::ModuleOp&>(mlir::ModuleOp&) /nix/store/kiwdwd6zw4svi9jlr95yg1p5pgpjxn1v-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:962:34\r\n    #23 0x1f843c9 in auto mlir::detail::AnalysisMap::constructAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp, (void*)0>(mlir::AnalysisManager&, mlir::ModuleOp) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:232:12\r\n    #24 0x1f843c9 in circt::hw::InstanceGraph& mlir::detail::AnalysisMap::getAnalysisImpl<circt::hw::InstanceGraph, mlir::ModuleOp>(mlir::PassInstrumentor*, mlir::ModuleOp, mlir::AnalysisManager&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:210:32\r\n    #25 0x1f84103 in std::enable_if<(std::is_constructible<circt::hw::InstanceGraph, mlir::ModuleOp>::value) || (std::is_constructible<circt::hw::InstanceGraph, mlir::ModuleOp, mlir::AnalysisManager&>::value), circt::hw::InstanceGraph&>::type mlir::detail::AnalysisMap::getAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp>(mlir::PassInstrumentor*, mlir::AnalysisManager&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:166:12\r\n    #26 0x1f84096 in circt::hw::InstanceGraph& mlir::AnalysisManager::getAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp>() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:325:27\r\n    #27 0x1f83fdd in circt::hw::InstanceGraph& mlir::Pass::getAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp>() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/Pass.h:224:33\r\n    #28 0x376fdb0 in circt::hw::InstanceGraph& mlir::OperationPass<mlir::ModuleOp>::getAnalysis<circt::hw::InstanceGraph>() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/Pass.h:372:18\r\n    #29 0x376fdb0 in (anonymous namespace)::SVExtractTestCodeImplPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:610:25\r\n    #30 0x54bd7e9 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:469:11\r\n    #31 0x54bea35 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:533:16\r\n    #32 0x54c34e9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:836:10\r\n    #33 0x54c3242 in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:816:60\r\n    #34 0x40f6862 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17\r\n    #35 0x40f5fd1 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12\r\n    #36 0x40f5fd1 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12\r\n    #37 0x40f5fd1 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #38 0x414e1f6 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #39 0x414df42 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16\r\n    #40 0x414d67b in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1872:5\r\n    #41 0x414d67b in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1890:3\r\n    #42 0x414d67b in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3\r\n    #43 0x40f3e4f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10\r\n    #44 0x40f4123 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:205:10\r\n    #45 0x40f4972 in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:298:14\r\n    #46 0x1d660b5 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:64:23\r\n    #47 0x7f28279fb236 in __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29236) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)\r\n    #48 0x7fffed23a110  ([stack]+0x20110)\r\n\r\nSUMMARY: AddressSanitizer: heap-use-after-free /home/will/src/sifive/circt/include/circt/Dialect/HW/InstanceGraphBase.h:126:26 in circt::hw::InstanceGraphNode::UseIterator::operator++()\r\nShadow bytes around the buggy address:\r\n  0x0c0c7fffa190: fa fa fa fa 00 00 00 00 00 00 00 00 fa fa fa fa\r\n  0x0c0c7fffa1a0: 00 00 00 00 00 00 00 00 fa fa fa fa 00 00 00 00\r\n  0x0c0c7fffa1b0: 00 00 00 00 fa fa fa fa 00 00 00 00 00 00 00 fa\r\n  0x0c0c7fffa1c0: fa fa fa fa 00 00 00 00 00 00 00 fa fa fa fa fa\r\n  0x0c0c7fffa1d0: 00 00 00 00 00 00 00 fa fa fa fa fa fd fd fd fd\r\n=>0x0c0c7fffa1e0: fd fd[fd]fd fa fa fa fa 00 00 00 00 00 00 00 00\r\n  0x0c0c7fffa1f0: fa fa fa fa 00 00 00 00 00 00 00 00 fa fa fa fa\r\n  0x0c0c7fffa200: 00 00 00 00 00 00 00 00 fa fa fa fa 00 00 00 00\r\n  0x0c0c7fffa210: 00 00 00 00 fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c0c7fffa220: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c0c7fffa230: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07 \r\n  Heap left redzone:       fa\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n  Left alloca redzone:     ca\r\n  Right alloca redzone:    cb\r\n==1579121==ABORTING\r\n```\r\n", "code_snippet_01": "==1579121==ERROR: AddressSanitizer: heap-use-after-free on address 0x606000010f10 at pc 0x00000284bd39 bp 0x7fffed234b40 sp 0x7fffed234b38\r\nREAD of size 8 at 0x606000010f10 thread T0\r\n    #0 0x284bd38 in circt::hw::InstanceGraphNode::UseIterator::operator++() /home/will/src/sifive/circt/include/circt/Dialect/HW/InstanceGraphBase.h:126:26\r\n    #1 0x377139d in inlineInputOnly(circt::hw::HWModuleOp, circt::hw::InstanceGraph&, llvm::DenseMap<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> >, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> > > >&) /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:383:32\r\n    #2 0x377139d in (anonymous namespace)::SVExtractTestCodeImplPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:639:9\r\n    #3 0x54bd7e9 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:469:11\r\n    #4 0x54bea35 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:533:16\r\n    #5 0x54c34e9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:836:10\r\n    #6 0x54c3242 in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:816:60\r\n    #7 0x40f6862 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17\r\n    #8 0x40f5fd1 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12\r\n    #9 0x40f5fd1 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12\r\n    #10 0x40f5fd1 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #11 0x414e1f6 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #12 0x414df42 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16\r\n    #13 0x414d67b in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1872:5\r\n    #14 0x414d67b in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1890:3\r\n    #15 0x414d67b in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3\r\n    #16 0x40f3e4f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10\r\n    #17 0x40f4123 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:205:10\r\n    #18 0x40f4972 in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:298:14\r\n    #19 0x1d660b5 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:64:23\r\n    #20 0x7f28279fb236 in __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29236) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)\r\n    #21 0x7f28279fb2f4 in __libc_start_main@GLIBC_2.2.5 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x292f4) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)\r\n    #22 0x1c6ee90 in _start /build/glibc-2.34/csu/../sysdeps/x86_64/start.S:116\r\n\r\n0x606000010f10 is located 48 bytes inside of 64-byte region [0x606000010ee0,0x606000010f20)\r\nfreed by thread T0 here:\r\nLLVMSymbolizer: error reading file: No such file or directory\r\n    #0 0x1d63617 in operator delete(void*) (/build/sifive/asan/bin/circt-opt+0x1d63617)\r\n    #1 0x32bc1c0 in llvm::ilist_alloc_traits<circt::hw::InstanceRecord>::deleteNode(circt::hw::InstanceRecord*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:42:39\r\n    #2 0x32bc1c0 in llvm::iplist_impl<llvm::simple_ilist<circt::hw::InstanceRecord>, llvm::ilist_traits<circt::hw::InstanceRecord> >::erase(llvm::ilist_iterator<llvm::ilist_detail::node_options<circt::hw::InstanceRecord, true, false, void>, false, false>) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:269:5\r\n    #3 0x32bc1c0 in llvm::iplist_impl<llvm::simple_ilist<circt::hw::InstanceRecord>, llvm::ilist_traits<circt::hw::InstanceRecord> >::erase(circt::hw::InstanceRecord*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/ilist.h:273:39\r\n    #4 0x32b774f in circt::hw::InstanceRecord::erase() /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:24:26\r\n    #5 0x377130e in inlineInputOnly(circt::hw::HWModuleOp, circt::hw::InstanceGraph&, llvm::DenseMap<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> >, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, llvm::SmallDenseMap<mlir::Attribute, circt::sv::BindOp, 4u, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, circt::sv::BindOp> > > >&) /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:431:10\r\n    #6 0x377130e in (anonymous namespace)::SVExtractTestCodeImplPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:639:9\r\n    #7 0x54bd7e9 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:469:11\r\n    #8 0x54bea35 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:533:16\r\n    #9 0x54c34e9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:836:10\r\n    #10 0x54c3242 in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:816:60\r\n    #11 0x40f6862 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17\r\n    #12 0x40f5fd1 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12\r\n    #13 0x40f5fd1 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12\r\n    #14 0x40f5fd1 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #15 0x414e1f6 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #16 0x414df42 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16\r\n    #17 0x414d67b in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1872:5\r\n    #18 0x414d67b in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1890:3\r\n    #19 0x414d67b in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3\r\n    #20 0x40f3e4f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10\r\n    #21 0x40f4123 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:205:10\r\n    #22 0x40f4972 in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:298:14\r\n    #23 0x1d660b5 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:64:23\r\n    #24 0x7f28279fb236 in __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29236) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)\r\n    #25 0x7fffed23a110  ([stack]+0x20110)\r\n    #26 0x73612f6576696668  (<unknown module>)\r\n\r\npreviously allocated by thread T0 here:\r\n    #0 0x1d62c47 in operator new(unsigned long) (/build/sifive/asan/bin/circt-opt+0x1d62c47)\r\n    #1 0x32b7803 in circt::hw::InstanceGraphNode::addInstance(circt::hw::HWInstanceLike, circt::hw::InstanceGraphNode*) /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:29:26\r\n    #2 0x32bb2d3 in circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)::operator()(circt::hw::HWInstanceLike) const /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:63:20\r\n    #3 0x32bb2d3 in std::enable_if<(!(llvm::is_one_of<circt::hw::HWInstanceLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), circt::hw::HWInstanceLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&)::'lambda'(mlir::Operation*)::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:195:7\r\n    #4 0x32bb2d3 in void llvm::function_ref<void (mlir::Operation*)>::callback_fn<std::enable_if<(!(llvm::is_one_of<circt::hw::HWInstanceLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), circt::hw::HWInstanceLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&)::'lambda'(mlir::Operation*)>(long, mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #5 0x3b4d0a2 in llvm::function_ref<void (mlir::Operation*)>::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #6 0x3b4d0a2 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:70:5\r\n    #7 0x3b4d008 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:65:9\r\n    #8 0x32baf26 in std::enable_if<(!(llvm::is_one_of<circt::hw::HWInstanceLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), circt::hw::HWInstanceLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:197:10\r\n    #9 0x32baf26 in std::enable_if<(llvm::function_traits<std::decay<circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)>::type>::num_args) == (1), void>::type mlir::Operation::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), void>(circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:575:12\r\n    #10 0x32baf26 in std::enable_if<(llvm::function_traits<std::decay<circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)>::type>::num_args) == (1), void>::type mlir::OpState::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike), void>(circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const::'lambda'(circt::hw::HWInstanceLike)&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/OpDefinition.h:153:19\r\n    #11 0x32baf26 in circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0::operator()(circt::hw::HWModuleLike) const /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:60:12\r\n    #12 0x32baf26 in std::enable_if<(!(llvm::is_one_of<circt::hw::HWModuleLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, circt::hw::HWModuleLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&)::'lambda'(mlir::Operation*)::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:195:7\r\n    #13 0x32baf26 in void llvm::function_ref<void (mlir::Operation*)>::callback_fn<std::enable_if<(!(llvm::is_one_of<circt::hw::HWModuleLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, circt::hw::HWModuleLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&)::'lambda'(mlir::Operation*)>(long, mlir::Operation*) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #14 0x3b4d0a2 in llvm::function_ref<void (mlir::Operation*)>::operator()(mlir::Operation*) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #15 0x3b4d0a2 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:70:5\r\n    #16 0x3b4d008 in mlir::detail::walk(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, mlir::WalkOrder) /home/will/src/sifive/circt/llvm/mlir/lib/IR/Visitors.cpp:65:9\r\n    #17 0x32b7e8f in std::enable_if<(!(llvm::is_one_of<circt::hw::HWModuleLike, mlir::Operation*, mlir::Region*, mlir::Block*>::value)) && (std::is_same<void, void>::value), void>::type mlir::detail::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, circt::hw::HWModuleLike, void>(mlir::Operation*, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Visitors.h:197:10\r\n    #18 0x32b7e8f in std::enable_if<(llvm::function_traits<std::decay<circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0>::type>::num_args) == (1), void>::type mlir::Operation::walk<(mlir::WalkOrder)1, circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0, void>(circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*)::$_0&&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/IR/Operation.h:575:12\r\n    #19 0x32b7e8f in circt::hw::InstanceGraphBase::InstanceGraphBase(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/HW/InstanceGraphBase.cpp:54:11\r\n    #20 0x32053db in circt::hw::InstanceGraph::InstanceGraph(mlir::Operation*) /home/will/src/sifive/circt/lib/Dialect/HW/HWInstanceGraph.cpp:15:7\r\n    #21 0x1f843c9 in mlir::detail::AnalysisModel<circt::hw::InstanceGraph>::AnalysisModel<mlir::ModuleOp&>(mlir::ModuleOp&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:119:9\r\n    #22 0x1f843c9 in std::_MakeUniq<mlir::detail::AnalysisModel<circt::hw::InstanceGraph> >::__single_object std::make_unique<mlir::detail::AnalysisModel<circt::hw::InstanceGraph>, mlir::ModuleOp&>(mlir::ModuleOp&) /nix/store/kiwdwd6zw4svi9jlr95yg1p5pgpjxn1v-gcc-11.3.0/include/c++/11.3.0/bits/unique_ptr.h:962:34\r\n    #23 0x1f843c9 in auto mlir::detail::AnalysisMap::constructAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp, (void*)0>(mlir::AnalysisManager&, mlir::ModuleOp) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:232:12\r\n    #24 0x1f843c9 in circt::hw::InstanceGraph& mlir::detail::AnalysisMap::getAnalysisImpl<circt::hw::InstanceGraph, mlir::ModuleOp>(mlir::PassInstrumentor*, mlir::ModuleOp, mlir::AnalysisManager&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:210:32\r\n    #25 0x1f84103 in std::enable_if<(std::is_constructible<circt::hw::InstanceGraph, mlir::ModuleOp>::value) || (std::is_constructible<circt::hw::InstanceGraph, mlir::ModuleOp, mlir::AnalysisManager&>::value), circt::hw::InstanceGraph&>::type mlir::detail::AnalysisMap::getAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp>(mlir::PassInstrumentor*, mlir::AnalysisManager&) /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:166:12\r\n    #26 0x1f84096 in circt::hw::InstanceGraph& mlir::AnalysisManager::getAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp>() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/AnalysisManager.h:325:27\r\n    #27 0x1f83fdd in circt::hw::InstanceGraph& mlir::Pass::getAnalysis<circt::hw::InstanceGraph, mlir::ModuleOp>() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/Pass.h:224:33\r\n    #28 0x376fdb0 in circt::hw::InstanceGraph& mlir::OperationPass<mlir::ModuleOp>::getAnalysis<circt::hw::InstanceGraph>() /home/will/src/sifive/circt/llvm/llvm/../mlir/include/mlir/Pass/Pass.h:372:18\r\n    #29 0x376fdb0 in (anonymous namespace)::SVExtractTestCodeImplPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/SV/Transforms/SVExtractTestCode.cpp:610:25\r\n    #30 0x54bd7e9 in mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:469:11\r\n    #31 0x54bea35 in mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:533:16\r\n    #32 0x54c34e9 in mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:836:10\r\n    #33 0x54c3242 in mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:816:60\r\n    #34 0x40f6862 in performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:91:17\r\n    #35 0x40f5fd1 in processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:139:12\r\n    #36 0x40f5fd1 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:181:12\r\n    #37 0x40f5fd1 in mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool)::$_0>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:12\r\n    #38 0x414e1f6 in llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n    #39 0x414df42 in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0::operator()(llvm::StringRef) const /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:88:16\r\n    #40 0x414d67b in void llvm::interleave<llvm::StringRef const*, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&)::'lambda'(), void>(llvm::SmallVector<llvm::StringRef, 8u>, llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1872:5\r\n    #41 0x414d67b in void llvm::interleave<llvm::SmallVector<llvm::StringRef, 8u>, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::raw_ostream, llvm::StringRef>(llvm::SmallVector<llvm::StringRef, 8u> const&, llvm::raw_ostream&, mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool)::$_0, llvm::StringRef const&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/STLExtras.h:1890:3\r\n    #42 0x414d67b in mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:91:3\r\n    #43 0x40f3e4f in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:186:10\r\n    #44 0x40f4123 in mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool, bool, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:205:10\r\n    #45 0x40f4972 in mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/will/src/sifive/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:298:14\r\n    #46 0x1d660b5 in main /home/will/src/sifive/circt/tools/circt-opt/circt-opt.cpp:64:23\r\n    #47 0x7f28279fb236 in __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29236) (BuildId: a2992d10a724db0447439e4793420b5bb5f9c041)\r\n    #48 0x7fffed23a110  ([stack]+0x20110)\r\n\r\nSUMMARY: AddressSanitizer: heap-use-after-free /home/will/src/sifive/circt/include/circt/Dialect/HW/InstanceGraphBase.h:126:26 in circt::hw::InstanceGraphNode::UseIterator::operator++()\r\nShadow bytes around the buggy address:\r\n  0x0c0c7fffa190: fa fa fa fa 00 00 00 00 00 00 00 00 fa fa fa fa\r\n  0x0c0c7fffa1a0: 00 00 00 00 00 00 00 00 fa fa fa fa 00 00 00 00\r\n  0x0c0c7fffa1b0: 00 00 00 00 fa fa fa fa 00 00 00 00 00 00 00 fa\r\n  0x0c0c7fffa1c0: fa fa fa fa 00 00 00 00 00 00 00 fa fa fa fa fa\r\n  0x0c0c7fffa1d0: 00 00 00 00 00 00 00 fa fa fa fa fa fd fd fd fd\r\n=>0x0c0c7fffa1e0: fd fd[fd]fd fa fa fa fa 00 00 00 00 00 00 00 00\r\n  0x0c0c7fffa1f0: fa fa fa fa 00 00 00 00 00 00 00 00 fa fa fa fa\r\n  0x0c0c7fffa200: 00 00 00 00 00 00 00 00 fa fa fa fa 00 00 00 00\r\n  0x0c0c7fffa210: 00 00 00 00 fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c0c7fffa220: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c0c7fffa230: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07 \r\n  Heap left redzone:       fa\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n  Left alloca redzone:     ca\r\n  Right alloca redzone:    cb\r\n==1579121==ABORTING"}, {"number": 3970, "title": "[Handshake] Parsing external function with no SSA values crashes.", "created_at": "2022-09-22T08:13:24Z", "state": "closed", "labels": "bug, Handshake", "body": "The following is an external `handshake.func` that causes the parser to crash.\r\n\r\n```\r\n  handshake.func private @foo(i32, i32, none, ...) -> (i32, none) attributes {argNames = [], resNames = []}\r\n```\r\n\r\nIt seems that this falls apart when modifying SSA value names.\r\n\r\nFurthermore, the parser would try to parse a region, even when it isn't present.", "code_snippet_01": "handshake.func private @foo(i32, i32, none, ...) -> (i32, none) attributes {argNames = [], resNames = []}"}, {"number": 3968, "title": "[FIRRTL] LowerTypes can Violate New Port Uniqueness Checks", "created_at": "2022-09-22T03:11:30Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Consider the following circuit:\r\n\r\n```scala\r\ncircuit Bar:\r\n  module Bar:\r\n    input a: UInt<1>[1]\r\n    output a_0: UInt<1>\r\n\r\n    a_0 <= a[0]\r\n```\r\n\r\nWhen compile with `firtool`, this will currently crash due to changes added in https://github.com/llvm/circt/pull/3891:\r\n```\r\n# firtool Bar.fir\r\nBar.fir:2:10: error: 'firrtl.module' op port names should be unique\r\n  module Bar:\r\n         ^\r\nBar.fir:2:10: note: see current operation: \r\n\"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.uint<1>, %arg1: !firrtl.uint<1>):\r\n  \"firrtl.strictconnect\"(%arg1, %arg0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n}) {annotations = [], portAnnotations = [[], []], portDirections = -2 : i2, portNames = [\"a_0\", \"a_0\"], portSyms = [], portTypes = [!firrtl.uint<1>, !firrtl.uint<1>], sym_name = \"Bar\"} : () -> ()\r\n```\r\n\r\nPreviously, `firtool` would produce some not-so-great names:\r\n\r\n```verilog\r\nmodule Bar(\r\n  input  a_0,\r\n  output a_0_0);\r\n\r\n  assign a_0_0 = a_0;\r\nendmodule\r\n```\r\n\r\nThe SFC produces subjectively better names:\r\n\r\n```verilog\r\nmodule Bar(\r\n  input   a__0,\r\n  output  a_0\r\n);\r\n  assign a_0 = a__0;\r\nendmodule\r\n```\r\n\r\nThe SFC is approximating (though not exactly in my understanding) the definition of _prefix uniqueness_ in the FIRRTL spec. It is not necessary that we implement this, just: (1) that this doesn't crash and (2) that we produce some decent names here.", "code_snippet_01": "circuit Bar:\r\n  module Bar:\r\n    input a: UInt<1>[1]\r\n    output a_0: UInt<1>\r\n\r\n    a_0 <= a[0]", "code_snippet_02": "# firtool Bar.fir\r\nBar.fir:2:10: error: 'firrtl.module' op port names should be unique\r\n  module Bar:\r\n         ^\r\nBar.fir:2:10: note: see current operation: \r\n\"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.uint<1>, %arg1: !firrtl.uint<1>):\r\n  \"firrtl.strictconnect\"(%arg1, %arg0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n}) {annotations = [], portAnnotations = [[], []], portDirections = -2 : i2, portNames = [\"a_0\", \"a_0\"], portSyms = [], portTypes = [!firrtl.uint<1>, !firrtl.uint<1>], sym_name = \"Bar\"} : () -> ()", "code_snippet_03": "module Bar(\r\n  input  a_0,\r\n  output a_0_0);\r\n\r\n  assign a_0_0 = a_0;\r\nendmodule", "code_snippet_04": "module Bar(\r\n  input   a__0,\r\n  output  a_0\r\n);\r\n  assign a_0 = a__0;\r\nendmodule"}, {"number": 3818, "title": "[StandardToHandshake] Loop task pipelining drops threads", "created_at": "2022-09-03T09:27:11Z", "state": "closed", "labels": "bug, Handshake", "body": "While writing additional tests for the `std-to-handshake` pass, I uncovered an issue related to loop task pipelining. \r\nThe test defined [here](https://github.com/llvm/circt/tree/dinistro/more-task-pipeline-tests/integration_test/Dialect/Handshake/multiple_loops) breaks down as it does not emit all results. \r\nIndependent of the input sequence, the 6th thread is always dropped. Note that his only happens for the buffer strategies `all` and `allFIFO`.\r\n\r\nEither this is caused by a faulty test driver or there is indeed a deeper issue in the loop protection strategy. \r\n\r\nCC @mortbopet "}, {"number": 3810, "title": "[SystemC] SCModuleOp::getPortsOfDirection(direction) only returns first occurence", "created_at": "2022-09-02T14:36:30Z", "state": "open", "labels": "bug, SystemC", "body": "Above mentioned member function seems to only return the first port of the given direction for some reason.\r\nThere is no regression test with more than one output port, thus at least one should be added.\r\nObserved in the `hw.output` lowering in HWToSystemC at 9384dccab8692086c21a4166c5e5181623695d91"}, {"number": 3784, "title": "WireDFT: Crashes on DFT enable outside of DUT", "created_at": "2022-08-26T14:53:56Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Test case:\r\n```\r\ncircuit DFT: %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.DFTTestModeEnableAnnotation\",\r\n    \"target\":\"DFT.DFT.psd_test_clock_enable\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"DFT.DUT\"\r\n  }\r\n]]\r\n\r\n  extmodule EICG_wrapper :\r\n    input in : Clock\r\n    input test_en : UInt<1>\r\n    input en : UInt<1>\r\n    output out : Clock\r\n    defname = EICG_wrapper\r\n\r\n  module DUT:\r\n    inst eicg of EICG_wrapper\r\n    eicg.in is invalid\r\n    eicg.test_en is invalid\r\n    eicg.en is invalid\r\n\r\n  module DFT:\r\n    input psd_test_clock_enable : UInt<1>\r\n    inst d of DUT\r\n```\r\n\r\nCrash:\r\n\r\n```\r\nfirtool: /home/will/src/sifive/circt/include/circt/Dialect/HW/InstanceGraphBase.h:121: circt::hw::InstanceGraphNode::UseIterator &circt::hw::InstanceGraphNode::UseIterator::operator++(): Assertion `current && \"incrementing past end\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool /home/will/cur/debug/firrtl/test.fir\r\n #0 0x00000000005ed7e6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:569:13\r\n #1 0x00000000005ebc75 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:104:18\r\n #2 0x00000000005edb7f SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007fe646c950e0 __restore_rt (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x3d0e0)\r\n #4 0x00007fe646cdfc1f __pthread_kill_implementation (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x87c1f)\r\n #5 0x00007fe646c95042 gsignal (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x3d042)\r\n #6 0x00007fe646c8049c abort (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x2849c)\r\n #7 0x00007fe646c803d5 _nl_load_domain.cold.0 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x283d5)\r\n #8 0x00007fe646c8e062 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x36062)\r\n #9 0x00000000007acaaa llvm::SmallVectorTemplateCommon<lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement, void>::back() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:298:5\r\n#10 0x00000000007acaaa lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement& llvm::SmallVectorTemplateBase<lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement, true>::growAndEmplaceBack<circt::hw::InstanceGraphNode*>(circt::hw::InstanceGraphNode*&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:545:18\r\n#11 0x00000000007acaaa lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement& llvm::SmallVectorImpl<lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement>::emplace_back<circt::hw::InstanceGraphNode*>(circt::hw::InstanceGraphNode*&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:927:20\r\n#12 0x00000000007acaaa lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/WireDFT.cpp:89:11\r\n#13 0x00000000007acaaa (anonymous namespace)::WireDFTPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/WireDFT.cpp:205:15\r\n#14 0x0000000000c79020 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11\r\n#15 0x0000000000c79677 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35\r\n#16 0x0000000000c79677 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#17 0x0000000000c79677 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#18 0x0000000000c79677 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#19 0x0000000000c7acfd std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/kiwdwd6zw4svi9jlr95yg1p5pgpjxn1v-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1046:25\r\n#20 0x0000000000c7acfd mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5\r\n#21 0x0000000000c7acfd mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18\r\n#22 0x0000000000c7acfd mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#23 0x0000000000c7acfd mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14\r\n#24 0x0000000000c7905e mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5\r\n#25 0x0000000000c7905e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14\r\n#26 0x0000000000c7b881 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35\r\n#27 0x0000000000c7b881 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#28 0x0000000000c7b881 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#29 0x0000000000c7b881 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#30 0x0000000000c7b881 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:837:10\r\n#31 0x0000000000c7b881 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:817:60\r\n#32 0x00000000005371d8 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35\r\n#33 0x00000000005371d8 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#34 0x00000000005371d8 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#35 0x00000000005371d8 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:696:7\r\n#36 0x0000000000535708 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:794:12\r\n#37 0x00000000005352ea processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:810:12\r\n#38 0x00000000005352ea executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:892:14\r\n#39 0x0000000000534f05 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35\r\n#40 0x0000000000534f05 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#41 0x0000000000534f05 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#42 0x0000000000534f05 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:8\r\n#43 0x00007fe646c81237 __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29237)\r\n#44 0x00007fe646c812f5 __libc_start_main@GLIBC_2.2.5 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x292f5)\r\n#45 0x0000000000534d41 _start /build/glibc-2.34/csu/../sysdeps/x86_64/start.S:118:0\r\n```\r\n", "code_snippet_01": "circuit DFT: %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.DFTTestModeEnableAnnotation\",\r\n    \"target\":\"DFT.DFT.psd_test_clock_enable\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"DFT.DUT\"\r\n  }\r\n]]\r\n\r\n  extmodule EICG_wrapper :\r\n    input in : Clock\r\n    input test_en : UInt<1>\r\n    input en : UInt<1>\r\n    output out : Clock\r\n    defname = EICG_wrapper\r\n\r\n  module DUT:\r\n    inst eicg of EICG_wrapper\r\n    eicg.in is invalid\r\n    eicg.test_en is invalid\r\n    eicg.en is invalid\r\n\r\n  module DFT:\r\n    input psd_test_clock_enable : UInt<1>\r\n    inst d of DUT", "code_snippet_02": "firtool: /home/will/src/sifive/circt/include/circt/Dialect/HW/InstanceGraphBase.h:121: circt::hw::InstanceGraphNode::UseIterator &circt::hw::InstanceGraphNode::UseIterator::operator++(): Assertion `current && \"incrementing past end\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool /home/will/cur/debug/firrtl/test.fir\r\n #0 0x00000000005ed7e6 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:569:13\r\n #1 0x00000000005ebc75 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:104:18\r\n #2 0x00000000005edb7f SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007fe646c950e0 __restore_rt (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x3d0e0)\r\n #4 0x00007fe646cdfc1f __pthread_kill_implementation (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x87c1f)\r\n #5 0x00007fe646c95042 gsignal (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x3d042)\r\n #6 0x00007fe646c8049c abort (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x2849c)\r\n #7 0x00007fe646c803d5 _nl_load_domain.cold.0 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x283d5)\r\n #8 0x00007fe646c8e062 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x36062)\r\n #9 0x00000000007acaaa llvm::SmallVectorTemplateCommon<lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement, void>::back() /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:298:5\r\n#10 0x00000000007acaaa lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement& llvm::SmallVectorTemplateBase<lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement, true>::growAndEmplaceBack<circt::hw::InstanceGraphNode*>(circt::hw::InstanceGraphNode*&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:545:18\r\n#11 0x00000000007acaaa lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement& llvm::SmallVectorImpl<lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>)::StackElement>::emplace_back<circt::hw::InstanceGraphNode*>(circt::hw::InstanceGraphNode*&&) /home/will/src/sifive/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:927:20\r\n#12 0x00000000007acaaa lowestCommonAncestor(circt::hw::InstanceGraphNode*, llvm::function_ref<bool (circt::hw::InstanceRecord*)>) /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/WireDFT.cpp:89:11\r\n#13 0x00000000007acaaa (anonymous namespace)::WireDFTPass::runOnOperation() /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/WireDFT.cpp:205:15\r\n#14 0x0000000000c79020 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11\r\n#15 0x0000000000c79677 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35\r\n#16 0x0000000000c79677 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#17 0x0000000000c79677 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#18 0x0000000000c79677 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#19 0x0000000000c7acfd std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/kiwdwd6zw4svi9jlr95yg1p5pgpjxn1v-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1046:25\r\n#20 0x0000000000c7acfd mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5\r\n#21 0x0000000000c7acfd mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18\r\n#22 0x0000000000c7acfd mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_12&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#23 0x0000000000c7acfd mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14\r\n#24 0x0000000000c7905e mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5\r\n#25 0x0000000000c7905e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14\r\n#26 0x0000000000c7b881 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35\r\n#27 0x0000000000c7b881 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#28 0x0000000000c7b881 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#29 0x0000000000c7b881 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#30 0x0000000000c7b881 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:837:10\r\n#31 0x0000000000c7b881 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:817:60\r\n#32 0x00000000005371d8 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35\r\n#33 0x00000000005371d8 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#34 0x00000000005371d8 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#35 0x00000000005371d8 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:696:7\r\n#36 0x0000000000535708 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:794:12\r\n#37 0x00000000005352ea processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:810:12\r\n#38 0x00000000005352ea executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:892:14\r\n#39 0x0000000000534f05 mlir::LogicalResult::succeeded() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:41:35\r\n#40 0x0000000000534f05 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#41 0x0000000000534f05 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#42 0x0000000000534f05 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:8\r\n#43 0x00007fe646c81237 __libc_start_call_main (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x29237)\r\n#44 0x00007fe646c812f5 __libc_start_main@GLIBC_2.2.5 (/nix/store/mhhlymrg2m70r8h94cwhv2d7a0c8l7g6-glibc-2.34-210/lib/libc.so.6+0x292f5)\r\n#45 0x0000000000534d41 _start /build/glibc-2.34/csu/../sysdeps/x86_64/start.S:118:0"}, {"number": 3768, "title": "[HW] Enum aliasing in SV output", "created_at": "2022-08-24T09:25:15Z", "state": "open", "labels": "bug, HW", "body": "Currently, different enums with identical field names:\r\n```mlir\r\n  hw.type_scope @fsm_enum_typedecls {\r\n    hw.typedecl @M2_state_t : !hw.enum<A, B>\r\n    hw.typedecl @M1_state_t : !hw.enum<A, B>\r\n  }\r\n```\r\n\r\nWill export as:\r\n```sv\r\ntypedef enum {A, B} M2_state_t;\r\ntypedef enum {A, B} M1_state_t;\r\n```\r\nwherein enum values alias.\r\n\r\nEnum values should be emitted with additional pre/suffixing of the enum type name to avoid this, e.g.:\r\n```sv\r\ntypedef enum {M2_state_A, M2_state_B} M2_state_t;\r\ntypedef enum {M1_state_A, M1_state_B} M1_state_t;\r\n```", "code_snippet_01": "hw.type_scope @fsm_enum_typedecls {\r\n    hw.typedecl @M2_state_t : !hw.enum<A, B>\r\n    hw.typedecl @M1_state_t : !hw.enum<A, B>\r\n  }", "code_snippet_02": "typedef enum {A, B} M2_state_t;\r\ntypedef enum {A, B} M1_state_t;", "code_snippet_03": "typedef enum {M2_state_A, M2_state_B} M2_state_t;\r\ntypedef enum {M1_state_A, M1_state_B} M1_state_t;"}, {"number": 3651, "title": "[HWArith] ChainedCast canonicalization pattern is too permissive ", "created_at": "2022-08-03T13:11:04Z", "state": "closed", "labels": "bug, HWArith", "body": "The `ChainedCast` pattern, introduced in https://github.com/llvm/circt/pull/3647, can produce wrong and illegal results, i.e.:\r\n```mlir\r\n    %0 = hwarith.cast %a : (ui8) -> (si8)\r\n    %1 = hwarith.cast %0 : (si8) -> (si10) // Sign-extension\r\n```\r\nis not equivalent with:\r\n```mlir\r\n    %0 = hwarith.cast %a : (ui8) -> (si10) // Zero-extension\r\n```\r\n\r\nalso\r\n```mlir\r\n    %0 = hwarith.cast %a : (i8) -> (si8)\r\n    %1 = hwarith.cast %0 : (si8) -> (si10) // Sign-extension\r\n```\r\ncan not be combined to:\r\n```mlir\r\n    %0 = hwarith.cast %a : (i8) -> (si10)\r\n```", "code_snippet_01": "%0 = hwarith.cast %a : (ui8) -> (si8)\r\n    %1 = hwarith.cast %0 : (si8) -> (si10) // Sign-extension", "code_snippet_02": "%0 = hwarith.cast %a : (ui8) -> (si10) // Zero-extension", "code_snippet_03": "%0 = hwarith.cast %a : (i8) -> (si8)\r\n    %1 = hwarith.cast %0 : (si8) -> (si10) // Sign-extension", "code_snippet_04": "%0 = hwarith.cast %a : (i8) -> (si10)"}, {"number": 3607, "title": "[ExportVerilog] `hw.verilogName` collision on declaration ops", "created_at": "2022-07-26T13:41:36Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```mlir\r\nhw.module @CollectNamesOrder(%in: i1) -> (out:i1) {\r\n  %0 = sv.wire : !hw.inout<i1>\r\n  %foo = sv.wire {hw.verilogName = \"_GEN\"} : !hw.inout<i1>\r\n  %1 = sv.read_inout %foo: !hw.inout<i1>\r\n  hw.output %1: i1\r\n}\r\n```\r\nThe current output is:\r\n```verilog\r\nmodule CollectNamesOrder(       // bar.mlir:2:1\r\n  input  in,\r\n  output out);\r\n\r\n  wire _GEN;    // bar.mlir:3:8\r\n  wire _GEN_0;  // bar.mlir:4:10\r\n\r\n  assign out = _GEN_0;  // bar.mlir:5:8, :6:3\r\nendmodule\r\n\r\nmodule {\r\n  hw.module @CollectNamesOrder(%in: i1) -> (out: i1) {\r\n    %0 = sv.wire  {hw.verilogName = \"_GEN\"} : !hw.inout<i1>\r\n    %foo = sv.wire  {hw.verilogName = \"_GEN\"} : !hw.inout<i1>\r\n    %1 = sv.read_inout %foo : !hw.inout<i1>\r\n    hw.output %1 : i1\r\n  }\r\n}\r\n```\r\n`hw.verilogName` on `%foo` is ignored because the name `_GEN` is given to `%0`. \r\nWe fixed the issue for the cases when temporary wires are introduced at ExportVerilog (https://github.com/llvm/circt/pull/3342) but it seems it is necessary to consider cases like above.", "code_snippet_01": "hw.module @CollectNamesOrder(%in: i1) -> (out:i1) {\r\n  %0 = sv.wire : !hw.inout<i1>\r\n  %foo = sv.wire {hw.verilogName = \"_GEN\"} : !hw.inout<i1>\r\n  %1 = sv.read_inout %foo: !hw.inout<i1>\r\n  hw.output %1: i1\r\n}", "code_snippet_02": "module CollectNamesOrder(       // bar.mlir:2:1\r\n  input  in,\r\n  output out);\r\n\r\n  wire _GEN;    // bar.mlir:3:8\r\n  wire _GEN_0;  // bar.mlir:4:10\r\n\r\n  assign out = _GEN_0;  // bar.mlir:5:8, :6:3\r\nendmodule\r\n\r\nmodule {\r\n  hw.module @CollectNamesOrder(%in: i1) -> (out: i1) {\r\n    %0 = sv.wire  {hw.verilogName = \"_GEN\"} : !hw.inout<i1>\r\n    %foo = sv.wire  {hw.verilogName = \"_GEN\"} : !hw.inout<i1>\r\n    %1 = sv.read_inout %foo : !hw.inout<i1>\r\n    hw.output %1 : i1\r\n  }\r\n}"}, {"number": 3606, "title": "[PrepareForEmission] `reuseExistingInOut` should check ifdef", "created_at": "2022-07-26T12:57:55Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```mlir\r\nhw.module @ReuseExistingInOut(%clock: i1, %a: i1) -> (out1: i1) {\r\n    %0 = comb.or %a, %a : i1\r\n    %mywire = sv.wire  : !hw.inout<i1>\r\n    sv.ifdef  \"FOO\" {\r\n      sv.assign %mywire, %0 : i1\r\n    }\r\n    hw.output %0 : i1\r\n  }\r\n```\r\n\r\nThe current output of `circt-opt -export-verilog` is:\r\n```verilog\r\nmodule ReuseExistingInOut(      // bar.mlir:4:1\r\n  input  clock,\r\n         a,\r\n  output out1);\r\n\r\n  wire mywire;  // bar.mlir:6:13\r\n\r\n  `ifdef FOO    // bar.mlir:8:3\r\n    assign mywire = a | a;      // bar.mlir:5:12, :9:5\r\n  `endif\r\n  assign out1 = mywire; // bar.mlir:6:13, :18:3\r\nendmodule\r\n```\r\nIt is incorrect to replace `%0` with `mywire` because assign to `mywire` is gated by ifdef. ", "code_snippet_01": "hw.module @ReuseExistingInOut(%clock: i1, %a: i1) -> (out1: i1) {\r\n    %0 = comb.or %a, %a : i1\r\n    %mywire = sv.wire  : !hw.inout<i1>\r\n    sv.ifdef  \"FOO\" {\r\n      sv.assign %mywire, %0 : i1\r\n    }\r\n    hw.output %0 : i1\r\n  }", "code_snippet_02": "module ReuseExistingInOut(      // bar.mlir:4:1\r\n  input  clock,\r\n         a,\r\n  output out1);\r\n\r\n  wire mywire;  // bar.mlir:6:13\r\n\r\n  `ifdef FOO    // bar.mlir:8:3\r\n    assign mywire = a | a;      // bar.mlir:5:12, :9:5\r\n  `endif\r\n  assign out1 = mywire; // bar.mlir:6:13, :18:3\r\nendmodule"}, {"number": 3603, "title": "[ExportVerilog] `isExpressionEmittedInlineIntoProceduralDeclaration`  incorrectly inlines assignments", "created_at": "2022-07-26T10:17:43Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```mlir\r\nhw.module @isEmittedBroken(%a:i4, %b:i1, %c:i1) {\r\n  %0 = sv.reg : !hw.inout<i4>\r\n  %1 = sv.reg : !hw.inout<i4>\r\n  %2 = sv.reg : !hw.inout<i2>\r\n  sv.always posedge %b {\r\n   sv.bpassign %0, %a: i4\r\n   sv.bpassign %1, %a: i4\r\n   %3 = sv.read_inout %0: !hw.inout<i4>\r\n   %4 = sv.read_inout %1: !hw.inout<i4>\r\n   %add =comb.add %3, %4:i4\r\n   %extract = comb.extract %add from 1 : (i4) -> i2\r\n   sv.bpassign %2, %extract: i2\r\n  }\r\n}\r\n```\r\nCurrent output:\r\n```verilog\r\nmodule isEmittedBroken( // bar.mlir:1:1\r\n  input [3:0] a,\r\n  input       b,\r\n              c);\r\n\r\n  reg [3:0] _GEN;       // bar.mlir:2:8\r\n  reg [3:0] _GEN_0;     // bar.mlir:3:8\r\n  reg [1:0] _GEN_1;     // bar.mlir:4:8\r\n\r\n  always @(posedge b) begin     // bar.mlir:5:3\r\n    automatic logic [3:0] _GEN_2 = _GEN + _GEN_0;       // bar.mlir:8:9, :9:9, :10:10\r\n\r\n    _GEN = a;   // bar.mlir:6:4\r\n    _GEN_0 = a; // bar.mlir:7:4\r\n    _GEN_1 = _GEN_2[2:1];       // bar.mlir:11:15, :12:4\r\n  end // always @(posedge)\r\nendmodule\r\n```\r\n\r\n`_GEN_2` is declared as \"automatic logic\" variable and initialized at the same time. This is because `isExpressionEmittedInlineIntoProceduralDeclaration` identifies inlining `_GEN + _GEN_0` to be safe but it is actually incorrect. ", "code_snippet_01": "hw.module @isEmittedBroken(%a:i4, %b:i1, %c:i1) {\r\n  %0 = sv.reg : !hw.inout<i4>\r\n  %1 = sv.reg : !hw.inout<i4>\r\n  %2 = sv.reg : !hw.inout<i2>\r\n  sv.always posedge %b {\r\n   sv.bpassign %0, %a: i4\r\n   sv.bpassign %1, %a: i4\r\n   %3 = sv.read_inout %0: !hw.inout<i4>\r\n   %4 = sv.read_inout %1: !hw.inout<i4>\r\n   %add =comb.add %3, %4:i4\r\n   %extract = comb.extract %add from 1 : (i4) -> i2\r\n   sv.bpassign %2, %extract: i2\r\n  }\r\n}", "code_snippet_02": "module isEmittedBroken( // bar.mlir:1:1\r\n  input [3:0] a,\r\n  input       b,\r\n              c);\r\n\r\n  reg [3:0] _GEN;       // bar.mlir:2:8\r\n  reg [3:0] _GEN_0;     // bar.mlir:3:8\r\n  reg [1:0] _GEN_1;     // bar.mlir:4:8\r\n\r\n  always @(posedge b) begin     // bar.mlir:5:3\r\n    automatic logic [3:0] _GEN_2 = _GEN + _GEN_0;       // bar.mlir:8:9, :9:9, :10:10\r\n\r\n    _GEN = a;   // bar.mlir:6:4\r\n    _GEN_0 = a; // bar.mlir:7:4\r\n    _GEN_1 = _GEN_2[2:1];       // bar.mlir:11:15, :12:4\r\n  end // always @(posedge)\r\nendmodule"}, {"number": 3547, "title": "[PrepareForEmission] `shouldSpillWire` creates wires in procedural regions", "created_at": "2022-07-17T21:08:30Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```mlir\r\nmodule attributes {circt.loweringOptions = \"maximumNumberOfTermsPerExpression=4\"} {\r\n  hw.module @Foo(%z: i10) -> () {\r\n    %0 = sv.reg : !hw.inout<i1>\r\n    %re = sv.reg : !hw.inout<i10>\r\n    sv.initial {\r\n      %x = sv.read_inout %re: !hw.inout<i10>\r\n      sv.ifdef.procedural \"bar\" {\r\n        %2 = comb.add %x, %x, %x, %x, %x : i10\r\n        %3 = comb.icmp eq %2, %z: i10\r\n        sv.passign %0, %3: i1\r\n      }\r\n    }\r\n  \r\n    hw.output\r\n  }\r\n}\r\n```\r\nWith `circt-opt -export-verilog` we get the following error.\r\n```\r\nfoo.mlir:9:12: error: sv.wire should be in a non-procedural region\r\n      %2 = comb.add %x, %x, %x, %x, %x : i10\r\n```\r\n\r\n`%2` is spilled to a temporary wire because it violates `maximumNumberOfTermsPerExpression` but it is spilled to a procedural region in the initial block. \r\n \r\n", "code_snippet_01": "module attributes {circt.loweringOptions = \"maximumNumberOfTermsPerExpression=4\"} {\r\n  hw.module @Foo(%z: i10) -> () {\r\n    %0 = sv.reg : !hw.inout<i1>\r\n    %re = sv.reg : !hw.inout<i10>\r\n    sv.initial {\r\n      %x = sv.read_inout %re: !hw.inout<i10>\r\n      sv.ifdef.procedural \"bar\" {\r\n        %2 = comb.add %x, %x, %x, %x, %x : i10\r\n        %3 = comb.icmp eq %2, %z: i10\r\n        sv.passign %0, %3: i1\r\n      }\r\n    }\r\n  \r\n    hw.output\r\n  }\r\n}", "code_snippet_02": "foo.mlir:9:12: error: sv.wire should be in a non-procedural region\r\n      %2 = comb.add %x, %x, %x, %x, %x : i10"}, {"number": 3515, "title": "[firtool] -verbose-pass-executions prints wrong options for drop-names", "created_at": "2022-07-12T17:59:54Z", "state": "closed", "labels": "bug", "body": "Specifying various `-preserve-values=` options (default is 'none' presently) does change the option but not as expected:\r\n\r\n```\r\n$ ./bin/firtool ./test.fir -verbose-pass-executions -preserve-values=none |& grep -o \"drop-names{preserve-values=[^}]\\+}\"\r\ndrop-names{preserve-values=named}\r\ndrop-names{preserve-values=named}\r\ndrop-names{preserve-values=named}\r\ndrop-names{preserve-values=named}\r\n```\r\n\r\nnone is default, and is reported as 'named' (shown above).  Here's what's printed for each of the supported values:\r\n\r\n\r\n\"none\" \u2192 \"named\"\r\n\"named\" \u2192 \"none\"\r\n\"all\" \u2192 \"none\"\r\n\r\nAFAICT the options are working properly, just printed/reported incorrectly.", "code_snippet_01": "$ ./bin/firtool ./test.fir -verbose-pass-executions -preserve-values=none |& grep -o \"drop-names{preserve-values=[^}]\\+}\"\r\ndrop-names{preserve-values=named}\r\ndrop-names{preserve-values=named}\r\ndrop-names{preserve-values=named}\r\ndrop-names{preserve-values=named}"}, {"number": 3495, "title": "[FIRRTL] GCT Taps and Dedup", "created_at": "2022-07-08T23:22:37Z", "state": "closed", "labels": "bug, FIRRTL", "body": "This is the Grand Central (GCT) Taps variant of #3494. GCT Taps does not work on a deduplicated design. We need to fix this with a better representation for XMRs that works with dedup. Dedup and annotations do not work if the annotations describe XMRs.\r\n\r\nConsider:\r\n\r\n```scala\r\ncircuit Top :\r\n  module Bar :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  extmodule DataTap_1 :\r\n    output _0 : UInt<1>\r\n    defname = DataTap_1\r\n\r\n  module Foo :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    wire w : UInt<1>\r\n    inst DataTap_1 of DataTap_1\r\n    DataTap_1._0 is invalid\r\n    w <= DataTap_1._0\r\n\r\n  module Bar_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  extmodule DataTap_1_0 :\r\n    output _0 : UInt<1>\r\n    defname = DataTap_1\r\n\r\n  module Foo_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar_1\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    wire w : UInt<1>\r\n    inst DataTap_1 of DataTap_1_0\r\n    DataTap_1._0 is invalid\r\n    w <= DataTap_1._0\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n\r\n    inst foo1 of Foo\r\n    foo1.clock <= clock\r\n    foo1.reset <= reset\r\n    inst foo2 of Foo_1\r\n    foo2.clock <= clock\r\n    foo2.reset <= reset\r\n```\r\n\r\n```json\r\n[\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\":\"~Top|DataTap_1\",\r\n    \"keys\":[\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/foo1:Foo/bar:Bar>w\",\r\n        \"portName\":\"~Top|DataTap_1>_0\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\":\"~Top|DataTap_1_0\",\r\n    \"keys\":[\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/foo2:Foo_1/bar:Bar_1>w\",\r\n        \"portName\":\"~Top|DataTap_1_0>_0\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"builds/gct-tests/DedupTap/firrtl/gct\",\r\n    \"filename\":\"builds/gct-tests/DedupTap/firrtl/bindings.sv\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.TestBenchDirAnnotation\",\r\n    \"dirname\":\"builds/gct-tests/DedupTap/firrtl/verilog/testbench\"\r\n  }\r\n]\r\n```\r\n\r\nCurrently this will crash after GCT Taps (`firtool Foo.fir -annotation-file Foo.anno.json -dedup -firrtl-grand-central`):\r\n\r\n```\r\nfirrtl/Top.fir:36:10: error: 'firrtl.hierpath' op instance path is incorrect. Expected module: \"DataTap_1_impl_1\" instead found: \"DataTap_1\"\r\n  module Foo_1 :\r\n         ^\r\nfirrtl/Top.fir:36:10: note: see current operation: \"firrtl.hierpath\"() {namepath = [#hw.innerNameRef<@Top::@foo2>, #hw.innerNameRef<@Foo::@DataTap_1>, @DataTap_1], sym_name = \"nla_4\"} : () -> ()\r\nfirrtl/Top.fir:13:10: error: 'firrtl.hierpath' op instance path is incorrect. Expected module: \"DataTap_1_impl_1\" instead found: \"DataTap_1\"\r\n  module Foo :\r\n         ^\r\nfirrtl/Top.fir:13:10: note: see current operation: \"firrtl.hierpath\"() {namepath = [#hw.innerNameRef<@Top::@foo1>, #hw.innerNameRef<@Foo::@DataTap_1>, @DataTap_1], sym_name = \"nla_3\"} : () -> ()\r\n```", "code_snippet_01": "circuit Top :\r\n  module Bar :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  extmodule DataTap_1 :\r\n    output _0 : UInt<1>\r\n    defname = DataTap_1\r\n\r\n  module Foo :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    wire w : UInt<1>\r\n    inst DataTap_1 of DataTap_1\r\n    DataTap_1._0 is invalid\r\n    w <= DataTap_1._0\r\n\r\n  module Bar_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  extmodule DataTap_1_0 :\r\n    output _0 : UInt<1>\r\n    defname = DataTap_1\r\n\r\n  module Foo_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar_1\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    wire w : UInt<1>\r\n    inst DataTap_1 of DataTap_1_0\r\n    DataTap_1._0 is invalid\r\n    w <= DataTap_1._0\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n\r\n    inst foo1 of Foo\r\n    foo1.clock <= clock\r\n    foo1.reset <= reset\r\n    inst foo2 of Foo_1\r\n    foo2.clock <= clock\r\n    foo2.reset <= reset", "code_snippet_02": "[\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\":\"~Top|DataTap_1\",\r\n    \"keys\":[\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/foo1:Foo/bar:Bar>w\",\r\n        \"portName\":\"~Top|DataTap_1>_0\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\":\"~Top|DataTap_1_0\",\r\n    \"keys\":[\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/foo2:Foo_1/bar:Bar_1>w\",\r\n        \"portName\":\"~Top|DataTap_1_0>_0\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"builds/gct-tests/DedupTap/firrtl/gct\",\r\n    \"filename\":\"builds/gct-tests/DedupTap/firrtl/bindings.sv\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.TestBenchDirAnnotation\",\r\n    \"dirname\":\"builds/gct-tests/DedupTap/firrtl/verilog/testbench\"\r\n  }\r\n]", "code_snippet_03": "firrtl/Top.fir:36:10: error: 'firrtl.hierpath' op instance path is incorrect. Expected module: \"DataTap_1_impl_1\" instead found: \"DataTap_1\"\r\n  module Foo_1 :\r\n         ^\r\nfirrtl/Top.fir:36:10: note: see current operation: \"firrtl.hierpath\"() {namepath = [#hw.innerNameRef<@Top::@foo2>, #hw.innerNameRef<@Foo::@DataTap_1>, @DataTap_1], sym_name = \"nla_4\"} : () -> ()\r\nfirrtl/Top.fir:13:10: error: 'firrtl.hierpath' op instance path is incorrect. Expected module: \"DataTap_1_impl_1\" instead found: \"DataTap_1\"\r\n  module Foo :\r\n         ^\r\nfirrtl/Top.fir:13:10: note: see current operation: \"firrtl.hierpath\"() {namepath = [#hw.innerNameRef<@Top::@foo1>, #hw.innerNameRef<@Foo::@DataTap_1>, @DataTap_1], sym_name = \"nla_3\"} : () -> ()"}, {"number": 3494, "title": "[FIRRTL] GCT Views and Dedup", "created_at": "2022-07-08T23:19:29Z", "state": "open", "labels": "bug, FIRRTL", "body": "Grand Central (GCT) Views do not currently work when combined with FIRRTL's deduplication pass. Consider the following circuit and annotation file. `Top` instantiates `Foo` and `Foo_1`. Each of those, respectively, instantiate `Bar` and `Bar_1`. Each `Foo*` has a view of something inside each `Bar*`:\r\n\r\n```scala\r\ncircuit Top :\r\n  module Bar :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  module MyView_companion :\r\n\r\n    skip\r\n\r\n  module Foo :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    inst MyView_companion of MyView_companion\r\n\r\n  module Bar_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  module MyView_companion_0 :\r\n\r\n    skip\r\n\r\n  module Foo_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar_1\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    inst MyView_companion_0 of MyView_companion_0\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n\r\n    inst foo1 of Foo\r\n    foo1.clock <= clock\r\n    foo1.reset <= reset\r\n    inst foo2 of Foo_1\r\n    foo2.clock <= clock\r\n    foo2.reset <= reset\r\n```\r\n\r\n```json\r\n[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~Top|MyView_companion\",\r\n    \"parent\": \"~Top|Foo\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"w\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"Top\",\r\n              \"module\": \"Top\",\r\n              \"path\": [\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"foo1\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Foo\"\r\n                  }\r\n                },\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"bar\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Bar\"\r\n                  }\r\n                }\r\n              ],\r\n              \"ref\": \"w\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~Top|MyView_companion_0\",\r\n    \"parent\": \"~Top|Foo_1\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"w\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"Top\",\r\n              \"module\": \"Top\",\r\n              \"path\": [\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"foo2\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Foo_1\"\r\n                  }\r\n                },\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"bar\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Bar_1\"\r\n                  }\r\n                }\r\n              ],\r\n              \"ref\": \"w\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  }\r\n]\r\n```\r\n\r\nIf you run this with `firtool Foo.fir -annotation-file Foo.anno.json -dedup -firrtl-grand-central` you get an expected error. The GCT Views pass is asserting that the `NoDedupAnnotation` behavior exists:\r\n\r\n```\r\nfirrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once\r\n  module Foo :\r\n         ^\r\nfirrtl/Top.fir:13:10: note: see current operation: \"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):\r\n  %0:2 = \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@bar\">, moduleName = @Bar, name = \"bar\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"]} : () -> (!firrtl.clock, !firrtl.uint<1>)\r\n  \"firrtl.strictconnect\"(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()\r\n  \"firrtl.strictconnect\"(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@MyView_companion\">, moduleName = @MyView_companion, name = \"MyView_companion\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()\r\n}) {annotations = [{circt.nonlocal = @nla_3, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 2 : i64, name = \"MyView\", type = \"parent\"}, {circt.nonlocal = @nla_4, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 0 : i64, name = \"MyView\", type = \"parent\"}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"], portSyms = [\"\", \"\"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\nfirrtl/Top.fir:49:5: note: parent is instantiated here\r\n    inst foo2 of Foo_1\r\n    ^\r\nfirrtl/Top.fir:46:5: note: parent is instantiated here\r\n    inst foo1 of Foo\r\n    ^\r\nfirrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once\r\n  module Foo :\r\n         ^\r\nfirrtl/Top.fir:13:10: note: see current operation: \"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):\r\n  %0:2 = \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@bar\">, moduleName = @Bar, name = \"bar\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"]} : () -> (!firrtl.clock, !firrtl.uint<1>)\r\n  \"firrtl.strictconnect\"(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()\r\n  \"firrtl.strictconnect\"(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@MyView_companion\">, moduleName = @MyView_companion, name = \"MyView_companion\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()\r\n}) {annotations = [{circt.nonlocal = @nla_3, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 2 : i64, name = \"MyView\", type = \"parent\"}, {circt.nonlocal = @nla_4, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 0 : i64, name = \"MyView\", type = \"parent\"}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"], portSyms = [\"\", \"\"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\nfirrtl/Top.fir:49:5: note: parent is instantiated here\r\n    inst foo2 of Foo_1\r\n    ^\r\nfirrtl/Top.fir:46:5: note: parent is instantiated here\r\n    inst foo1 of Foo\r\n    ^\r\nfirrtl/Top.fir:1:1: error: 'firrtl.circuit' op contains a 'companion' with id '2', but does not contain a GrandCentral 'parent' with the same id\r\ncircuit Top :\r\n^\r\n```\r\n\r\nIf you run this without dedup (or with a `NoDedupAnnotation`) everything expectedly works. The fundamental problem is that GCT Views are encoding an XMR using annotations. After Dedup runs, it rightly keeps both of these annotations around. However, now you have a multiply instantiated parent module that is supposed to describe _two_ XMRs. However, these XMRs \"deduplicate\" to a single XMR.\r\n\r\nThere are multiple approaches to fix this:\r\n\r\n1. Modify the GCT Views pass to recognize this pattern and generate a \"minimal\" XMR that combines all the deduplicated XMRs.\r\n2. Special case certain annotations in dedup to also deduplicate.\r\n3. Change `LowerAnnotations` to represent XMRs as \"fake ports\" in the design rooted at the lowest-common ancestor necessary to make the connection. Then dedup works correctly.\r\n\r\n(1) is janky, but expedient. (2) is extremely janky. (3) is the only reasonable solution here.", "code_snippet_01": "circuit Top :\r\n  module Bar :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  module MyView_companion :\r\n\r\n    skip\r\n\r\n  module Foo :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    inst MyView_companion of MyView_companion\r\n\r\n  module Bar_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  module MyView_companion_0 :\r\n\r\n    skip\r\n\r\n  module Foo_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar_1\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    inst MyView_companion_0 of MyView_companion_0\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n\r\n    inst foo1 of Foo\r\n    foo1.clock <= clock\r\n    foo1.reset <= reset\r\n    inst foo2 of Foo_1\r\n    foo2.clock <= clock\r\n    foo2.reset <= reset", "code_snippet_02": "[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~Top|MyView_companion\",\r\n    \"parent\": \"~Top|Foo\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"w\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"Top\",\r\n              \"module\": \"Top\",\r\n              \"path\": [\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"foo1\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Foo\"\r\n                  }\r\n                },\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"bar\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Bar\"\r\n                  }\r\n                }\r\n              ],\r\n              \"ref\": \"w\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~Top|MyView_companion_0\",\r\n    \"parent\": \"~Top|Foo_1\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"w\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"Top\",\r\n              \"module\": \"Top\",\r\n              \"path\": [\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"foo2\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Foo_1\"\r\n                  }\r\n                },\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"bar\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Bar_1\"\r\n                  }\r\n                }\r\n              ],\r\n              \"ref\": \"w\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  }\r\n]", "code_snippet_03": "firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once\r\n  module Foo :\r\n         ^\r\nfirrtl/Top.fir:13:10: note: see current operation: \"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):\r\n  %0:2 = \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@bar\">, moduleName = @Bar, name = \"bar\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"]} : () -> (!firrtl.clock, !firrtl.uint<1>)\r\n  \"firrtl.strictconnect\"(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()\r\n  \"firrtl.strictconnect\"(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@MyView_companion\">, moduleName = @MyView_companion, name = \"MyView_companion\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()\r\n}) {annotations = [{circt.nonlocal = @nla_3, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 2 : i64, name = \"MyView\", type = \"parent\"}, {circt.nonlocal = @nla_4, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 0 : i64, name = \"MyView\", type = \"parent\"}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"], portSyms = [\"\", \"\"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\nfirrtl/Top.fir:49:5: note: parent is instantiated here\r\n    inst foo2 of Foo_1\r\n    ^\r\nfirrtl/Top.fir:46:5: note: parent is instantiated here\r\n    inst foo1 of Foo\r\n    ^\r\nfirrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once\r\n  module Foo :\r\n         ^\r\nfirrtl/Top.fir:13:10: note: see current operation: \"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):\r\n  %0:2 = \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@bar\">, moduleName = @Bar, name = \"bar\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"]} : () -> (!firrtl.clock, !firrtl.uint<1>)\r\n  \"firrtl.strictconnect\"(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()\r\n  \"firrtl.strictconnect\"(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@MyView_companion\">, moduleName = @MyView_companion, name = \"MyView_companion\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()\r\n}) {annotations = [{circt.nonlocal = @nla_3, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 2 : i64, name = \"MyView\", type = \"parent\"}, {circt.nonlocal = @nla_4, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 0 : i64, name = \"MyView\", type = \"parent\"}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"], portSyms = [\"\", \"\"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\nfirrtl/Top.fir:49:5: note: parent is instantiated here\r\n    inst foo2 of Foo_1\r\n    ^\r\nfirrtl/Top.fir:46:5: note: parent is instantiated here\r\n    inst foo1 of Foo\r\n    ^\r\nfirrtl/Top.fir:1:1: error: 'firrtl.circuit' op contains a 'companion' with id '2', but does not contain a GrandCentral 'parent' with the same id\r\ncircuit Top :\r\n^"}, {"number": 3460, "title": "[FIRRTL] Grand Central Views Zero Width Bug", "created_at": "2022-07-01T05:46:19Z", "state": "closed", "labels": "bug, good first issue, FIRRTL", "body": "GCT Views with zero width components is also busted similarly to #3458.\r\n\r\nConsider:\r\n\r\n```scala\r\ncircuit ZeroWidth : %[[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~ZeroWidth|MyView_companion\",\r\n    \"parent\": \"~ZeroWidth|ZeroWidth\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"ground\",\r\n          \"description\": \"a ground type port\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"refBetter\": \"~ZeroWidth|ZeroWidth>w\",\r\n            \"ref\": {\r\n              \"circuit\": \"ZeroWidth\",\r\n              \"module\": \"ZeroWidth\",\r\n              \"path\": [],\r\n              \"ref\": \"w\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  }\r\n]]\r\n  module MyView_companion :\r\n\r\n  module ZeroWidth :\r\n\r\n    wire w : UInt<0>\r\n    w is invalid\r\n    inst MyView_companion of MyView_companion\r\n```\r\n\r\nRunning this through Grand Central will currently not do the right thing. This should not emit an XMR and do something with the zero-width port. Currently ExportVerilog will generate a 1-bit logic with an inline comment. (This should probably be changed, but is different from this issue as we still don't want the XMR.)", "code_snippet_01": "circuit ZeroWidth : %[[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~ZeroWidth|MyView_companion\",\r\n    \"parent\": \"~ZeroWidth|ZeroWidth\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"ground\",\r\n          \"description\": \"a ground type port\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"refBetter\": \"~ZeroWidth|ZeroWidth>w\",\r\n            \"ref\": {\r\n              \"circuit\": \"ZeroWidth\",\r\n              \"module\": \"ZeroWidth\",\r\n              \"path\": [],\r\n              \"ref\": \"w\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  }\r\n]]\r\n  module MyView_companion :\r\n\r\n  module ZeroWidth :\r\n\r\n    wire w : UInt<0>\r\n    w is invalid\r\n    inst MyView_companion of MyView_companion"}, {"number": 3458, "title": "[FIRRTL] Zero Width GCT Taps Crashes in LowerToHW", "created_at": "2022-06-30T23:02:33Z", "state": "closed", "labels": "bug, good first issue, FIRRTL", "body": "The following can produce a crash:\r\n\r\n```scala\r\ncircuit Top : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\":\"~Top|DataTap\",\r\n    \"keys\":[\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top>w\",\r\n        \"portName\":\"~Top|DataTap>_0\"\r\n      }\r\n    ]\r\n  }\r\n]]\r\n  extmodule DataTap:\r\n    output _0: UInt<0>\r\n\r\n  module Top:\r\n    wire w: UInt<0>\r\n    w is invalid\r\n    inst tap of DataTap\r\n```\r\n\r\n`firtool Foo.fir -firrtl-grand-central`:\r\n```\r\nAssertion failed: ((srcWidth != 0) && \"Lowering produced value for zero width source\"), function setLowering, file LowerToHW.cpp, line 2043.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x000000010ebea18d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x000000010ebea70b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x000000010ebe83f6 llvm::sys::RunSignalHandlers() + 134\r\n3  firtool                  0x000000010ebec35f SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff81a838dfd _sigtramp + 29\r\n5  libsystem_platform.dylib 0x0000000000000001 _sigtramp + 18446603370136105505\r\n6  libsystem_c.dylib        0x00007ff81a76ed24 abort + 123\r\n7  libsystem_c.dylib        0x00007ff81a76e0cb err + 0\r\n8  firtool                  0x000000010ed22f8b (anonymous namespace)::FIRRTLLowering::setLowering(mlir::Value, mlir::Value) + 379\r\n9  firtool                  0x000000010ed2575c (anonymous namespace)::FIRRTLLowering::setPossiblyFoldedLowering(mlir::Value, mlir::Value) + 332\r\n10 firtool                  0x000000010ed4705d mlir::LogicalResult (anonymous namespace)::FIRRTLLowering::setLoweringTo<circt::sv::VerbatimExprOp, mlir::Type, mlir::StringAttr, llvm::SmallVector<mlir::Value, 4u>, mlir::ArrayAttr>(mlir::Operation*, mlir::Type, mlir::StringAttr, llvm::SmallVector<mlir::Value, 4u>, mlir::ArrayAttr) + 157\r\n11 firtool                  0x000000010ed46f0d (anonymous namespace)::FIRRTLLowering::visitExpr(circt::firrtl::VerbatimExprOp) + 733\r\n12 firtool                  0x000000010ed46c1b mlir::LogicalResult circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::VerbatimExprOp>(auto) const + 43\r\n13 firtool                  0x000000010ed46b9a llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::firrtl::VerbatimExprOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&) + 122\r\n14 firtool                  0x000000010ed22add circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*) + 2461\r\n15 firtool                  0x000000010ed21b9d circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchVisitor(mlir::Operation*) + 29\r\n16 firtool                  0x000000010ed1d794 (anonymous namespace)::FIRRTLLowering::run() + 308\r\n17 firtool                  0x000000010ed1a9b2 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleOperations(circt::hw::HWModuleOp, (anonymous namespace)::CircuitLoweringState&) + 98\r\n18 firtool                  0x000000010ed19efb (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) + 2155\r\n19 firtool                  0x000000010ed194eb auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9::operator()<unsigned long>(unsigned long) const + 75\r\n20 firtool                  0x000000010edbb3d9 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()::operator()() const + 169\r\n21 firtool                  0x000000010edbb325 decltype(static_cast<llvm::detail::SafeIntIterator<unsigned long, false>>(fp)()) std::__1::__invoke<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()&>(llvm::detail::SafeIntIterator<unsigned long, false>&&) + 21\r\n22 firtool                  0x000000010edbb2dd void std::__1::__invoke_void_return_wrapper<void, true>::__call<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()&>(mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()&) + 29\r\n23 firtool                  0x000000010edbb2ad std::__1::__function::__alloc_func<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()>, void ()>::operator()() + 29\r\n24 firtool                  0x000000010edba2f9 std::__1::__function::__func<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()>, void ()>::operator()() + 25\r\n25 firtool                  0x000000010fb6c852 std::__1::__function::__value_func<void ()>::operator()() const + 50\r\n26 firtool                  0x000000010fb6c815 std::__1::function<void ()>::operator()() const + 21\r\n27 firtool                  0x000000010fb6c7dd llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()::operator()() const + 29\r\n28 firtool                  0x000000010fb6c7a5 decltype(static_cast<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(fp)()) std::__1::__invoke<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 21\r\n29 firtool                  0x000000010fb6c75d void std::__1::__invoke_void_return_wrapper<void, true>::__call<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 29\r\n30 firtool                  0x000000010fb6c72d std::__1::__function::__alloc_func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 29\r\n31 firtool                  0x000000010fb6b519 std::__1::__function::__func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 25\r\n32 firtool                  0x000000010fb6c852 std::__1::__function::__value_func<void ()>::operator()() const + 50\r\n33 firtool                  0x000000010fb6c815 std::__1::function<void ()>::operator()() const + 21\r\n34 firtool                  0x000000010eb22c42 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) + 546\r\n35 firtool                  0x000000010eb261d3 llvm::ThreadPool::grow(int)::$_0::operator()() const + 51\r\n36 firtool                  0x000000010eb26165 void llvm::thread::Apply<llvm::ThreadPool::grow(int)::$_0>(std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::__1::integer_sequence<unsigned long>) + 37\r\n37 firtool                  0x000000010eb26123 void llvm::thread::GenericThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 51\r\n38 firtool                  0x000000010eb25e55 void* llvm::thread::ThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 21\r\n39 libsystem_pthread.dylib  0x00007ff81a8234e1 _pthread_start + 125\r\n40 libsystem_pthread.dylib  0x00007ff81a81ef6b thread_start + 15\r\nzsh: abort      firtool firrtl/Top.fir -firrtl-grand-central\r\n```", "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\":\"~Top|DataTap\",\r\n    \"keys\":[\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top>w\",\r\n        \"portName\":\"~Top|DataTap>_0\"\r\n      }\r\n    ]\r\n  }\r\n]]\r\n  extmodule DataTap:\r\n    output _0: UInt<0>\r\n\r\n  module Top:\r\n    wire w: UInt<0>\r\n    w is invalid\r\n    inst tap of DataTap", "code_snippet_02": "Assertion failed: ((srcWidth != 0) && \"Lowering produced value for zero width source\"), function setLowering, file LowerToHW.cpp, line 2043.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x000000010ebea18d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x000000010ebea70b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x000000010ebe83f6 llvm::sys::RunSignalHandlers() + 134\r\n3  firtool                  0x000000010ebec35f SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff81a838dfd _sigtramp + 29\r\n5  libsystem_platform.dylib 0x0000000000000001 _sigtramp + 18446603370136105505\r\n6  libsystem_c.dylib        0x00007ff81a76ed24 abort + 123\r\n7  libsystem_c.dylib        0x00007ff81a76e0cb err + 0\r\n8  firtool                  0x000000010ed22f8b (anonymous namespace)::FIRRTLLowering::setLowering(mlir::Value, mlir::Value) + 379\r\n9  firtool                  0x000000010ed2575c (anonymous namespace)::FIRRTLLowering::setPossiblyFoldedLowering(mlir::Value, mlir::Value) + 332\r\n10 firtool                  0x000000010ed4705d mlir::LogicalResult (anonymous namespace)::FIRRTLLowering::setLoweringTo<circt::sv::VerbatimExprOp, mlir::Type, mlir::StringAttr, llvm::SmallVector<mlir::Value, 4u>, mlir::ArrayAttr>(mlir::Operation*, mlir::Type, mlir::StringAttr, llvm::SmallVector<mlir::Value, 4u>, mlir::ArrayAttr) + 157\r\n11 firtool                  0x000000010ed46f0d (anonymous namespace)::FIRRTLLowering::visitExpr(circt::firrtl::VerbatimExprOp) + 733\r\n12 firtool                  0x000000010ed46c1b mlir::LogicalResult circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::VerbatimExprOp>(auto) const + 43\r\n13 firtool                  0x000000010ed46b9a llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::firrtl::VerbatimExprOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&) + 122\r\n14 firtool                  0x000000010ed22add circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchExprVisitor(mlir::Operation*) + 2461\r\n15 firtool                  0x000000010ed21b9d circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult>::dispatchVisitor(mlir::Operation*) + 29\r\n16 firtool                  0x000000010ed1d794 (anonymous namespace)::FIRRTLLowering::run() + 308\r\n17 firtool                  0x000000010ed1a9b2 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleOperations(circt::hw::HWModuleOp, (anonymous namespace)::CircuitLoweringState&) + 98\r\n18 firtool                  0x000000010ed19efb (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) + 2155\r\n19 firtool                  0x000000010ed194eb auto (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9::operator()<unsigned long>(unsigned long) const + 75\r\n20 firtool                  0x000000010edbb3d9 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()::operator()() const + 169\r\n21 firtool                  0x000000010edbb325 decltype(static_cast<llvm::detail::SafeIntIterator<unsigned long, false>>(fp)()) std::__1::__invoke<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()&>(llvm::detail::SafeIntIterator<unsigned long, false>&&) + 21\r\n22 firtool                  0x000000010edbb2dd void std::__1::__invoke_void_return_wrapper<void, true>::__call<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()&>(mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()&) + 29\r\n23 firtool                  0x000000010edbb2ad std::__1::__function::__alloc_func<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()>, void ()>::operator()() + 29\r\n24 firtool                  0x000000010edba2f9 std::__1::__function::__func<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'(), std::__1::allocator<mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::$_9&&)::'lambda'()>, void ()>::operator()() + 25\r\n25 firtool                  0x000000010fb6c852 std::__1::__function::__value_func<void ()>::operator()() const + 50\r\n26 firtool                  0x000000010fb6c815 std::__1::function<void ()>::operator()() const + 21\r\n27 firtool                  0x000000010fb6c7dd llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()::operator()() const + 29\r\n28 firtool                  0x000000010fb6c7a5 decltype(static_cast<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(fp)()) std::__1::__invoke<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 21\r\n29 firtool                  0x000000010fb6c75d void std::__1::__invoke_void_return_wrapper<void, true>::__call<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&>(llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()&) + 29\r\n30 firtool                  0x000000010fb6c72d std::__1::__function::__alloc_func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 29\r\n31 firtool                  0x000000010fb6b519 std::__1::__function::__func<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'(), std::__1::allocator<llvm::ThreadPool::createTaskAndFuture(std::__1::function<void ()>)::'lambda'()>, void ()>::operator()() + 25\r\n32 firtool                  0x000000010fb6c852 std::__1::__function::__value_func<void ()>::operator()() const + 50\r\n33 firtool                  0x000000010fb6c815 std::__1::function<void ()>::operator()() const + 21\r\n34 firtool                  0x000000010eb22c42 llvm::ThreadPool::processTasks(llvm::ThreadPoolTaskGroup*) + 546\r\n35 firtool                  0x000000010eb261d3 llvm::ThreadPool::grow(int)::$_0::operator()() const + 51\r\n36 firtool                  0x000000010eb26165 void llvm::thread::Apply<llvm::ThreadPool::grow(int)::$_0>(std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>&, std::__1::integer_sequence<unsigned long>) + 37\r\n37 firtool                  0x000000010eb26123 void llvm::thread::GenericThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 51\r\n38 firtool                  0x000000010eb25e55 void* llvm::thread::ThreadProxy<std::__1::tuple<llvm::ThreadPool::grow(int)::$_0>>(void*) + 21\r\n39 libsystem_pthread.dylib  0x00007ff81a8234e1 _pthread_start + 125\r\n40 libsystem_pthread.dylib  0x00007ff81a81ef6b thread_start + 15\r\nzsh: abort      firtool firrtl/Top.fir -firrtl-grand-central"}, {"number": 3454, "title": "[ExportVerilog] Initial statement needs begin/end for single declaration", "created_at": "2022-06-30T11:00:07Z", "state": "open", "labels": "bug, ExportVerilog", "body": "Input:\r\n```mlir\r\nhw.module private @Foo() -> (){\r\n    sv.initial {\r\n      %param_x = sv.localparam : i42 { value = 11: i42 }\r\n    }\r\n}\r\n```\r\n`$ circt-opt -export-verilog` produces:\r\n```verilog\r\nmodule Foo();\r\n  initial     \r\n    localparam [41:0] param_x = 42'd11; \r\n\r\nendmodule\r\n```\r\n\r\nAt least Verilator and Yosys produce a syntax error. When I added \"begin\" and \"end\" around initial statement, it parses.  \r\n```verilog\r\n  initial begin \r\n    localparam [41:0] param_x = 42'd11;\r\n  end\r\n```", "code_snippet_01": "hw.module private @Foo() -> (){\r\n    sv.initial {\r\n      %param_x = sv.localparam : i42 { value = 11: i42 }\r\n    }\r\n}", "code_snippet_02": "module Foo();\r\n  initial     \r\n    localparam [41:0] param_x = 42'd11; \r\n\r\nendmodule", "code_snippet_03": "initial begin \r\n    localparam [41:0] param_x = 42'd11;\r\n  end"}, {"number": 3419, "title": "[FIRRTL] LowerTypes is Dropping Some `circt.fieldID` Annotations", "created_at": "2022-06-26T19:53:26Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Annotations targeting fields from the LowerAnnotations `circt.fieldID` member are getting dropped during `LowerTypes` whereas annotations that use the older `#firrtl.subAnno` generated by the parser work fine.\r\n\r\nConsider the following:\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\"  {\r\n  firrtl.module @Foo() {\r\n    %a = firrtl.wire interesting_name  {annotations = [\r\n      #firrtl.subAnno<fieldID = 2, {class = \"circt.test2\"}>, \r\n      {circt.fieldID = 2 : i32, class = \"circt.test\"}]\r\n    } : !firrtl.bundle<b: uint<1>, c: vector<uint<1>, 1>>\r\n  }\r\n}\r\n```\r\n\r\nAfter `LowerTypes` (`circt-opt -firrtl-lower-types`) this looks like:\r\n```mlir\r\nfirrtl.circuit \"Foo\"  {\r\n  firrtl.module @Foo() {\r\n    %a_b = firrtl.wire interesting_name  : !firrtl.uint<1>\r\n    %a_c_0 = firrtl.wire interesting_name  {annotations = [{class = \"circt.test2\"}]} : !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nThis bug is likely unreachable/not concerning due to a combination of limited use of `LowerAnnotations` right now (this is only used for GCT View and Taps, those generate annotations on aggregates, and any downstream consumer of Views/Taps will error if these get deleted). However, this should be fixed as we migrate more annotations over. E.g., I noticed this because GCT signal driving _does_ want to target aggregates and I noticed the annotations getting deleted as I migrated them on my branch.", "code_snippet_01": "firrtl.circuit \"Foo\"  {\r\n  firrtl.module @Foo() {\r\n    %a = firrtl.wire interesting_name  {annotations = [\r\n      #firrtl.subAnno<fieldID = 2, {class = \"circt.test2\"}>, \r\n      {circt.fieldID = 2 : i32, class = \"circt.test\"}]\r\n    } : !firrtl.bundle<b: uint<1>, c: vector<uint<1>, 1>>\r\n  }\r\n}", "code_snippet_02": "firrtl.circuit \"Foo\"  {\r\n  firrtl.module @Foo() {\r\n    %a_b = firrtl.wire interesting_name  : !firrtl.uint<1>\r\n    %a_c_0 = firrtl.wire interesting_name  {annotations = [{class = \"circt.test2\"}]} : !firrtl.uint<1>\r\n  }\r\n}"}, {"number": 3417, "title": "[FIRRTL] Unused 0-bit firrtl.invalidvalue remains after LowerToHW", "created_at": "2022-06-24T12:29:18Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Input:\r\n```mlir\r\nfirrtl.circuit \"Foo\"  {\r\n  firrtl.module @Foo() {\r\n    %invalid_ui0 = firrtl.invalidvalue : !firrtl.uint<0>\r\n  }\r\n}\r\n```\r\nOutput of `circt-opt -lower-firrtl-to-hw` contains `firrtl.invalidvalue` for some reason.\r\n```\r\n  hw.module @Foo() {\r\n    %invalid_ui0 = firrtl.invalidvalue : !firrtl.uint<0>\r\n    hw.output\r\n  }\r\n```", "code_snippet_01": "firrtl.circuit \"Foo\"  {\r\n  firrtl.module @Foo() {\r\n    %invalid_ui0 = firrtl.invalidvalue : !firrtl.uint<0>\r\n  }\r\n}", "code_snippet_02": "hw.module @Foo() {\r\n    %invalid_ui0 = firrtl.invalidvalue : !firrtl.uint<0>\r\n    hw.output\r\n  }"}, {"number": 3388, "title": "[ExportVerilog] Weird wire/assign statement indent", "created_at": "2022-06-21T12:22:06Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "I haven't reduced yet but I have often seen indent around wire/assign broken.  For example, in  `DivSqrtRecF64_mulAddZ31` module in [FPU.fir](https://github.com/circt/perf/blob/trunk/regress/FPU.fir) compiled with `firtool -drop-names`, there is code like this:\r\n```verilog\r\n      wire _T_275 = valid_PA & valid_leaving_PA;        // DivSqrtRecF64_mulAddZ31.scala:233:55, :283:28\r\n  assign _T_278 = ~valid_PA | valid_leaving_PA; // DivSqrtRecF64_mulAddZ31.scala:233:55, :235:36, :284:28\r\n      wire _T_298 = specialCodeB_PB[2:1] != 2'h3;       // DivSqrtRecF64_mulAddZ31.scala:97:30, :212:46, :293:24, :298:25, :311:{41,48}\r\n```\r\n", "code_snippet_01": "wire _T_275 = valid_PA & valid_leaving_PA;        // DivSqrtRecF64_mulAddZ31.scala:233:55, :283:28\r\n  assign _T_278 = ~valid_PA | valid_leaving_PA; // DivSqrtRecF64_mulAddZ31.scala:233:55, :235:36, :284:28\r\n      wire _T_298 = specialCodeB_PB[2:1] != 2'h3;       // DivSqrtRecF64_mulAddZ31.scala:97:30, :212:46, :293:24, :298:25, :311:{41,48}"}, {"number": 3334, "title": "[FIRRTL] New NLA Support in ModuleInliner ", "created_at": "2022-06-12T20:19:37Z", "state": "closed", "labels": "bug, FIRRTL", "body": "FIRRTL's Module Inliner definitely does not work with the new-style NLA paths. The problem is that [the NLA is marked dead if it ends in a module](https://github.com/llvm/circt/blob/c266174ef9410ff345a31a2af289f1d70d5d6147/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp#L325). Instead, the NLA is still alive so long as it has uses within the module.\r\n\r\nConsider:\r\n\r\n```mlir\r\nfirrtl.circuit \"Top\" {\r\n  firrtl.hierpath @path_component_old [@Top::@foo, @Foo::@bar1, @Bar::@b]\r\n  firrtl.hierpath @path_component_new [@Top::@foo, @Foo::@bar1, @Bar]\r\n  firrtl.module private @Bar() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n    %b = firrtl.wire sym @b {annotations = [\r\n      {circt.nonlocal = @path_component_old, \"path_component_old\"},\r\n      {circt.nonlocal = @path_component_new, \"path_component_new\"}\r\n    ]} : !firrtl.uint<1>\r\n  }\r\n  firrtl.module private @Foo() {\r\n    firrtl.instance bar1 sym @bar1 @Bar()\r\n    firrtl.instance bar2 sym @bar2 @Bar()\r\n  }\r\n  firrtl.module @Top() {\r\n    firrtl.instance foo sym @foo @Foo()\r\n  }\r\n}\r\n```\r\n\r\nThis currently drops `@path_component_new` because it gets marked dead when `@Bar` is inlined:\r\n\r\n```\r\n# circt-opt Bar.mlir -firrtl-inliner -debug-only=firrtl-inliner\r\n===- Running Module Inliner Pass --------------------------------------------===\r\nNLA modifications:\r\n  - orig:           firrtl.hierpath @path_component_old [@Top::@foo, @Foo::@bar1, @Bar::@b]\r\n    new:            firrtl.nla @path_component_old [#hw.innerNameRef<@Top::@foo>, #hw.innerNameRef<@Foo::@b>]\r\n    dead:           0\r\n    isDead:         0\r\n    isLocal:        0\r\n    inlinedSymbols: [3]\r\n    flattenPoint:   -1\r\n    renames:\r\n  - orig:           firrtl.hierpath @path_component_new [@Top::@foo, @Foo::@bar1, @Bar]\r\n    new:            \r\n    dead:           1\r\n    isDead:         1\r\n    isLocal:        0\r\n    inlinedSymbols: [3]\r\n    flattenPoint:   -1\r\n    renames:\r\n===--------------------------------------------------------------------------===\r\nmodule {\r\n  firrtl.circuit \"Top\"  {\r\n    firrtl.hierpath @path_component_old [@Top::@foo, @Foo::@b]\r\n    firrtl.module private @Foo() {\r\n      %bar1_b = firrtl.wire sym @b   {annotations = [{circt.nonlocal = @path_component_old, path_component_old}]} : !firrtl.uint<1>\r\n      %bar2_b = firrtl.wire sym @b_0   : !firrtl.uint<1>\r\n    }\r\n    firrtl.module @Top() {\r\n      firrtl.instance foo sym @foo  @Foo()\r\n    }\r\n  }\r\n}\r\n```", "code_snippet_01": "firrtl.circuit \"Top\" {\r\n  firrtl.hierpath @path_component_old [@Top::@foo, @Foo::@bar1, @Bar::@b]\r\n  firrtl.hierpath @path_component_new [@Top::@foo, @Foo::@bar1, @Bar]\r\n  firrtl.module private @Bar() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n    %b = firrtl.wire sym @b {annotations = [\r\n      {circt.nonlocal = @path_component_old, \"path_component_old\"},\r\n      {circt.nonlocal = @path_component_new, \"path_component_new\"}\r\n    ]} : !firrtl.uint<1>\r\n  }\r\n  firrtl.module private @Foo() {\r\n    firrtl.instance bar1 sym @bar1 @Bar()\r\n    firrtl.instance bar2 sym @bar2 @Bar()\r\n  }\r\n  firrtl.module @Top() {\r\n    firrtl.instance foo sym @foo @Foo()\r\n  }\r\n}", "code_snippet_02": "# circt-opt Bar.mlir -firrtl-inliner -debug-only=firrtl-inliner\r\n===- Running Module Inliner Pass --------------------------------------------===\r\nNLA modifications:\r\n  - orig:           firrtl.hierpath @path_component_old [@Top::@foo, @Foo::@bar1, @Bar::@b]\r\n    new:            firrtl.nla @path_component_old [#hw.innerNameRef<@Top::@foo>, #hw.innerNameRef<@Foo::@b>]\r\n    dead:           0\r\n    isDead:         0\r\n    isLocal:        0\r\n    inlinedSymbols: [3]\r\n    flattenPoint:   -1\r\n    renames:\r\n  - orig:           firrtl.hierpath @path_component_new [@Top::@foo, @Foo::@bar1, @Bar]\r\n    new:            \r\n    dead:           1\r\n    isDead:         1\r\n    isLocal:        0\r\n    inlinedSymbols: [3]\r\n    flattenPoint:   -1\r\n    renames:\r\n===--------------------------------------------------------------------------===\r\nmodule {\r\n  firrtl.circuit \"Top\"  {\r\n    firrtl.hierpath @path_component_old [@Top::@foo, @Foo::@b]\r\n    firrtl.module private @Foo() {\r\n      %bar1_b = firrtl.wire sym @b   {annotations = [{circt.nonlocal = @path_component_old, path_component_old}]} : !firrtl.uint<1>\r\n      %bar2_b = firrtl.wire sym @b_0   : !firrtl.uint<1>\r\n    }\r\n    firrtl.module @Top() {\r\n      firrtl.instance foo sym @foo  @Foo()\r\n    }\r\n  }\r\n}"}, {"number": 3307, "title": "ModuleInliner: Finish removing reliance on breadcrumbs, currently broken in some situations", "created_at": "2022-06-09T00:20:34Z", "state": "closed", "labels": "bug, FIRRTL", "body": "## Summary\r\n\r\nCurrently, the inliner can do the wrong thing in various scenarios due to expecting/relying on the presence of breadcrumbs.\r\nThis is not good, because we haven't created those breadcrumbs since before 1.0 .\r\n\r\nExamples below involve HierPath's that use symbols that conflict after inlining.\r\n\r\n## Example 1\r\n\r\nFor example, this input file causes an error:\r\n\r\n```scala\r\ncircuit Inline : %[[\r\n  {\r\n    \"class\": \"firrtl.passes.InlineAnnotation\",\r\n    \"target\": \"~Inline|Foo\"\r\n  },\r\n  {\r\n    \"class\":\"testing\",\r\n    \"target\":\"~Inline|Inline/foo:Foo/bar:Bar>i\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Inline|Inline>bar\"\r\n  }\r\n]]\r\n  module Inline:\r\n    input i: UInt<1>\r\n    output o: UInt<1>\r\n\r\n    inst foo of Foo\r\n    wire bar: UInt<1>\r\n\r\n    foo.i <- bar\r\n    bar <- i\r\n    o <- foo.o\r\n\r\n\r\n  module Bar:\r\n    input i: UInt\r\n    output o: UInt\r\n\r\n    o <- i\r\n\r\n  module Foo:\r\n    input i: UInt\r\n    output o: UInt\r\n\r\n    inst bar of Bar\r\n\r\n    bar.i <- i\r\n    o <- bar.o\r\n```\r\n\r\nWhich produces the following error when running `firtool` on it (verifier after the inliner runs):\r\n\r\n```console\r\n<unknown>:0: error: 'firrtl.hierpath' op  module: \"Inline\" does not contain any instance with symbol: \"bar\"\r\n<unknown>:0: note: see current operation: \"firrtl.hierpath\"() {namepath = [#hw.innerNameRef<@Inline::@bar>, #hw.innerNameRef<@Bar::@i>], sym_name = \"nla_1\"} : () -> ()\r\n```\r\n\r\n## Example 2\r\n\r\nAs a variant of the above example, it's possible to cause the inliner to do the wrong thing but not have an error-- causing the annotation to have the wrong path:\r\n\r\n```scala\r\ncircuit Inline : %[[\r\n  {\r\n    \"class\": \"firrtl.passes.InlineAnnotation\",\r\n    \"target\": \"~Inline|Foo\"\r\n  },\r\n  {\r\n    \"class\":\"test_1\",\r\n    \"target\":\"~Inline|Inline/foo:Foo/bar:Bar>i\"\r\n  },\r\n  {\r\n    \"class\":\"test_2\",\r\n    \"target\":\"~Inline|Inline/bar:Bar>i\"\r\n  }\r\n]]\r\n  module Inline:\r\n    input i: UInt<1>\r\n    output o: UInt<1>\r\n\r\n    inst foo of Foo\r\n    inst bar of Bar\r\n\r\n    foo.i <- bar.i\r\n    bar.i <- i\r\n    o <- foo.o\r\n\r\n\r\n  module Bar:\r\n    input i: UInt\r\n    output o: UInt\r\n\r\n    o <- i\r\n\r\n  module Foo:\r\n    input i: UInt\r\n    output o: UInt\r\n\r\n    inst bar of Bar\r\n\r\n    bar.i <- i\r\n    o <- bar.o\r\n```\r\n\r\nHere's the MLIR before/after Inliner runs:\r\n\r\n**Before**:\r\n```mlir\r\nfirrtl.circuit \"Inline\"  {\r\n  firrtl.hierpath @nla_2 [@Inline::@bar, @Bar::@i]\r\n  firrtl.hierpath @nla_1 [@Inline::@foo, @Foo::@bar, @Bar::@i]\r\n  firrtl.module @Inline(in %i: !firrtl.uint<1>, out %o: !firrtl.uint<1>) {\r\n    %foo_i, %foo_o = firrtl.instance foo sym @foo  @Foo(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)\r\n    %bar_i, %bar_o = firrtl.instance bar sym @bar  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)\r\n    firrtl.strictconnect %foo_i, %bar_i : !firrtl.uint<1>\r\n    firrtl.strictconnect %bar_i, %i : !firrtl.uint<1>\r\n    firrtl.strictconnect %o, %foo_o : !firrtl.uint<1>\r\n  }\r\n  firrtl.module private @Bar(in %i: !firrtl.uint<1> sym @i [{circt.nonlocal = @nla_1, class = \"test_1\"}, {circt.nonlocal = @nla_2, class = \"test_2\"}], out %o: !firrtl.uint<1>) {\r\n    firrtl.strictconnect %o, %i : !firrtl.uint<1>\r\n  }\r\n  firrtl.module private @Foo(in %i: !firrtl.uint<1>, out %o: !firrtl.uint<1>) attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n    %bar_i, %bar_o = firrtl.instance bar sym @bar  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)\r\n    firrtl.strictconnect %bar_i, %i : !firrtl.uint<1>\r\n    firrtl.strictconnect %o, %bar_o : !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\n**After**:\r\n```mlir\r\nfirrtl.circuit \"Inline\"  {\r\n  firrtl.hierpath @nla_2 [@Inline::@bar, @Bar::@i]\r\n  firrtl.hierpath @nla_1 [@Inline::@bar, @Bar::@i]\r\n  firrtl.module @Inline(in %i: !firrtl.uint<1>, out %o: !firrtl.uint<1>) {\r\n    %foo_i = firrtl.wire  : !firrtl.uint<1>\r\n    %foo_o = firrtl.wire  : !firrtl.uint<1>\r\n    %foo_bar_i, %foo_bar_o = firrtl.instance foo_bar sym @bar_0  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)\r\n    firrtl.strictconnect %foo_bar_i, %foo_i : !firrtl.uint<1>\r\n    firrtl.strictconnect %foo_o, %foo_bar_o : !firrtl.uint<1>\r\n    %bar_i, %bar_o = firrtl.instance bar sym @bar  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)\r\n    firrtl.strictconnect %foo_i, %bar_i : !firrtl.uint<1>\r\n    firrtl.strictconnect %bar_i, %i : !firrtl.uint<1>\r\n    firrtl.strictconnect %o, %foo_o : !firrtl.uint<1>\r\n  }\r\n  firrtl.module private @Bar(in %i: !firrtl.uint<1> sym @i [{circt.nonlocal = @nla_1, class = \"test_1\"}, {circt.nonlocal = @nla_2, class = \"test_2\"}], out %o: !firrtl.uint<1>) {\r\n    firrtl.strictconnect %o, %i : !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nNotice how after inlining, `nla_1` and `nla_2` are the same path, instead of `nla_1` going via `bar_0`.\r\n\r\n## Notes\r\n\r\nThis issue can be observed after updating the inliner test to not have the breadcrumbs (1771b1eb687a6a3ed255d3a34b724ff02791b98c for example, although that test will still fail after fixing this in the FileCheck portion because I haven't finished updating it to also not /look/ for updated breadcrumbs).  Finishing removing breadcrumbs from the tests is probably a good idea (to root out this sort of issue elsewhere), but the Inliner test seems to have most of the breadcrumbs-in-test-code presently.\r\n\r\nWhen fixing this, check for other things that might be wrong (hopefully nothing not covered by above examples(!) and tests, but for example dropping NLA's that seem unused or mishandling local/non-local).\r\n\r\nUpdating the Inliner for the new+improved HierPath style for NLA's may be blocked by this (at least being confident the result works).", "code_snippet_01": "circuit Inline : %[[\r\n  {\r\n    \"class\": \"firrtl.passes.InlineAnnotation\",\r\n    \"target\": \"~Inline|Foo\"\r\n  },\r\n  {\r\n    \"class\":\"testing\",\r\n    \"target\":\"~Inline|Inline/foo:Foo/bar:Bar>i\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Inline|Inline>bar\"\r\n  }\r\n]]\r\n  module Inline:\r\n    input i: UInt<1>\r\n    output o: UInt<1>\r\n\r\n    inst foo of Foo\r\n    wire bar: UInt<1>\r\n\r\n    foo.i <- bar\r\n    bar <- i\r\n    o <- foo.o\r\n\r\n\r\n  module Bar:\r\n    input i: UInt\r\n    output o: UInt\r\n\r\n    o <- i\r\n\r\n  module Foo:\r\n    input i: UInt\r\n    output o: UInt\r\n\r\n    inst bar of Bar\r\n\r\n    bar.i <- i\r\n    o <- bar.o", "code_snippet_02": "<unknown>:0: error: 'firrtl.hierpath' op  module: \"Inline\" does not contain any instance with symbol: \"bar\"\r\n<unknown>:0: note: see current operation: \"firrtl.hierpath\"() {namepath = [#hw.innerNameRef<@Inline::@bar>, #hw.innerNameRef<@Bar::@i>], sym_name = \"nla_1\"} : () -> ()", "code_snippet_03": "circuit Inline : %[[\r\n  {\r\n    \"class\": \"firrtl.passes.InlineAnnotation\",\r\n    \"target\": \"~Inline|Foo\"\r\n  },\r\n  {\r\n    \"class\":\"test_1\",\r\n    \"target\":\"~Inline|Inline/foo:Foo/bar:Bar>i\"\r\n  },\r\n  {\r\n    \"class\":\"test_2\",\r\n    \"target\":\"~Inline|Inline/bar:Bar>i\"\r\n  }\r\n]]\r\n  module Inline:\r\n    input i: UInt<1>\r\n    output o: UInt<1>\r\n\r\n    inst foo of Foo\r\n    inst bar of Bar\r\n\r\n    foo.i <- bar.i\r\n    bar.i <- i\r\n    o <- foo.o\r\n\r\n\r\n  module Bar:\r\n    input i: UInt\r\n    output o: UInt\r\n\r\n    o <- i\r\n\r\n  module Foo:\r\n    input i: UInt\r\n    output o: UInt\r\n\r\n    inst bar of Bar\r\n\r\n    bar.i <- i\r\n    o <- bar.o", "code_snippet_04": "firrtl.circuit \"Inline\"  {\r\n  firrtl.hierpath @nla_2 [@Inline::@bar, @Bar::@i]\r\n  firrtl.hierpath @nla_1 [@Inline::@foo, @Foo::@bar, @Bar::@i]\r\n  firrtl.module @Inline(in %i: !firrtl.uint<1>, out %o: !firrtl.uint<1>) {\r\n    %foo_i, %foo_o = firrtl.instance foo sym @foo  @Foo(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)\r\n    %bar_i, %bar_o = firrtl.instance bar sym @bar  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)\r\n    firrtl.strictconnect %foo_i, %bar_i : !firrtl.uint<1>\r\n    firrtl.strictconnect %bar_i, %i : !firrtl.uint<1>\r\n    firrtl.strictconnect %o, %foo_o : !firrtl.uint<1>\r\n  }\r\n  firrtl.module private @Bar(in %i: !firrtl.uint<1> sym @i [{circt.nonlocal = @nla_1, class = \"test_1\"}, {circt.nonlocal = @nla_2, class = \"test_2\"}], out %o: !firrtl.uint<1>) {\r\n    firrtl.strictconnect %o, %i : !firrtl.uint<1>\r\n  }\r\n  firrtl.module private @Foo(in %i: !firrtl.uint<1>, out %o: !firrtl.uint<1>) attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n    %bar_i, %bar_o = firrtl.instance bar sym @bar  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)\r\n    firrtl.strictconnect %bar_i, %i : !firrtl.uint<1>\r\n    firrtl.strictconnect %o, %bar_o : !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_05": "firrtl.circuit \"Inline\"  {\r\n  firrtl.hierpath @nla_2 [@Inline::@bar, @Bar::@i]\r\n  firrtl.hierpath @nla_1 [@Inline::@bar, @Bar::@i]\r\n  firrtl.module @Inline(in %i: !firrtl.uint<1>, out %o: !firrtl.uint<1>) {\r\n    %foo_i = firrtl.wire  : !firrtl.uint<1>\r\n    %foo_o = firrtl.wire  : !firrtl.uint<1>\r\n    %foo_bar_i, %foo_bar_o = firrtl.instance foo_bar sym @bar_0  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)\r\n    firrtl.strictconnect %foo_bar_i, %foo_i : !firrtl.uint<1>\r\n    firrtl.strictconnect %foo_o, %foo_bar_o : !firrtl.uint<1>\r\n    %bar_i, %bar_o = firrtl.instance bar sym @bar  @Bar(in i: !firrtl.uint<1>, out o: !firrtl.uint<1>)\r\n    firrtl.strictconnect %foo_i, %bar_i : !firrtl.uint<1>\r\n    firrtl.strictconnect %bar_i, %i : !firrtl.uint<1>\r\n    firrtl.strictconnect %o, %foo_o : !firrtl.uint<1>\r\n  }\r\n  firrtl.module private @Bar(in %i: !firrtl.uint<1> sym @i [{circt.nonlocal = @nla_1, class = \"test_1\"}, {circt.nonlocal = @nla_2, class = \"test_2\"}], out %o: !firrtl.uint<1>) {\r\n    firrtl.strictconnect %o, %i : !firrtl.uint<1>\r\n  }\r\n}"}, {"number": 3268, "title": "[StandardToHandshake] Passing `memref` to a function will still use `memref.alloc` ", "created_at": "2022-06-03T11:12:50Z", "state": "open", "labels": "bug, Handshake", "body": "Passing the following code to `--lower-std-to-handshake` produces a weird output.\r\n\r\n```mlir\r\nfunc.func @external_mem(%mem : memref<4xi32>) {\r\n  return\r\n}\r\n\r\nfunc.func @normal_mem() {\r\n  %mem = memref.alloc() : memref<4xi32>\r\n  func.call @external_mem(%mem) : (memref<4xi32>) -> ()\r\n  return\r\n}\r\n```\r\n\r\nOutput:\r\n\r\n```mlir\r\nhandshake.func @external_mem(%arg0: memref<4xi32>, %arg1: none, ...) -> none attributes {argNames = [\"in0\", \"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n  extmemory[ld = 0, st = 0] (%arg0 : memref<4xi32>) () {id = 0 : i32} : () -> ()\r\n  return %arg1 : none\r\n }\r\nhandshake.func @normal_mem(%arg0: none, ...) -> none attributes {argNames = [\"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n  %0:2 = fork [2] %arg0 : none\r\n  %1 = memref.alloc() : memref<4xi32>\r\n  %2 = instance @external_mem(%1, %0#0) : (memref<4xi32>, none) -> none\r\n  sink %2 : none\r\n  return %0#1 : none\r\n}\r\n```\r\n\r\nAs you can see, a `memref.alloc()` remains, which is not expected and thus breaks further transformations. \r\n\r\nI would expect that a correct lowering would construct a `MemoryOp` in the `@normal_mem` function. How this exactly interacts with the external memory op is not clear to me, as this will cause cross function dependencies depending on the amount of memory operations in `@external_mem`.", "code_snippet_01": "func.func @external_mem(%mem : memref<4xi32>) {\r\n  return\r\n}\r\n\r\nfunc.func @normal_mem() {\r\n  %mem = memref.alloc() : memref<4xi32>\r\n  func.call @external_mem(%mem) : (memref<4xi32>) -> ()\r\n  return\r\n}", "code_snippet_02": "handshake.func @external_mem(%arg0: memref<4xi32>, %arg1: none, ...) -> none attributes {argNames = [\"in0\", \"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n  extmemory[ld = 0, st = 0] (%arg0 : memref<4xi32>) () {id = 0 : i32} : () -> ()\r\n  return %arg1 : none\r\n }\r\nhandshake.func @normal_mem(%arg0: none, ...) -> none attributes {argNames = [\"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n  %0:2 = fork [2] %arg0 : none\r\n  %1 = memref.alloc() : memref<4xi32>\r\n  %2 = instance @external_mem(%1, %0#0) : (memref<4xi32>, none) -> none\r\n  sink %2 : none\r\n  return %0#1 : none\r\n}"}, {"number": 3261, "title": "[FIRRTL] Lower Types Not Lowering Annotation-less Symbols", "created_at": "2022-06-02T20:14:26Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Consider:\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.hierpath @nla_a [@Foo::@bar, @Bar::@a]\r\n  firrtl.module @Bar() {\r\n    %a = firrtl.wire sym @a : !firrtl.bundle<a: uint<1>>\r\n  }\r\n  firrtl.module @Foo() {\r\n    firrtl.instance bar sym @bar @Bar()\r\n  }\r\n}\r\n```\r\n\r\nThis is currently being lowered, by `LowerTypes`, to:\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.hierpath @nla_a [@Foo::@bar, @Bar::@a]\r\n  firrtl.module @Bar() {\r\n    %a_a = firrtl.wire sym @a_a : !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Foo() {\r\n    firrtl.instance bar sym @bar @Bar()\r\n  }\r\n}\r\n```\r\n\r\nThis then trips hierarchical path verification because the `@a` symbol was not updated to `@a_a`. The logic inside `LowerTypes` is only lowering symbols that participate in an annotation which isn't correct.", "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.hierpath @nla_a [@Foo::@bar, @Bar::@a]\r\n  firrtl.module @Bar() {\r\n    %a = firrtl.wire sym @a : !firrtl.bundle<a: uint<1>>\r\n  }\r\n  firrtl.module @Foo() {\r\n    firrtl.instance bar sym @bar @Bar()\r\n  }\r\n}", "code_snippet_02": "firrtl.circuit \"Foo\" {\r\n  firrtl.hierpath @nla_a [@Foo::@bar, @Bar::@a]\r\n  firrtl.module @Bar() {\r\n    %a_a = firrtl.wire sym @a_a : !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Foo() {\r\n    firrtl.instance bar sym @bar @Bar()\r\n  }\r\n}"}, {"number": 3257, "title": "[StandardToHandshake] External memory lowering produces code with multiple uses. ", "created_at": "2022-06-02T12:30:25Z", "state": "closed", "labels": "bug, Handshake", "body": "Lowering the following IR with `--lowert-std-to-handshake` produces invalid code.\r\n\r\n```mlir\r\nfunc.func @sub(%mem : memref<1xi32>) {\r\n  %i = arith.constant 0 : index\r\n  %val = memref.load %mem[%i] : memref<1xi32>\r\n  return\r\n}\r\n```\r\n\r\nOutput:\r\n\r\n```mlir\r\n  handshake.func @foo(%arg0: memref<1xi32>, %arg1: none, ...) -> none attributes {argNames = [\"in0\", \"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n    %0:2 = extmemory[ld = 1, st = 0] (%arg0 : memref<1xi32>) (%addressResults) {id = 0 : i32} : (index) -> (i32, none)\r\n    sink %arg0 : memref<1xi32>\r\n    %1:2 = fork [2] %arg1 : none\r\n    %2:2 = fork [2] %1#1 : none\r\n    %3 = join %2#1, %0#1 : none\r\n    %4 = constant %2#0 {value = 0 : index} : index\r\n    %dataResult, %addressResults = load [%4] %0#0, %1#0 : index, i32\r\n    sink %dataResult : i32\r\n    return %3 : none\r\n  }\r\n```\r\n\r\nAs you can see, the memref argument `%arg0` has multiple uses which is not allowed in handshake. \r\n\r\nFurthermore, the documentation mentions that an interface for all loads and stores should be added, which is not the case:\r\n\r\n> An ExternalMemoryOp represents a wrapper around a memref input to a handshake function. The semantics of the load/store operands are identical to what is decribed for MemoryOp. The only difference is that the first operand to this operand is a memref value. Upon lowering to FIRRTL, a handshake interface will be created in the top-level component for each load- and store which connected to this memory.\r\n\r\nWas this just no implemented fully? \r\n\r\nPartially related to #3256 ", "code_snippet_01": "func.func @sub(%mem : memref<1xi32>) {\r\n  %i = arith.constant 0 : index\r\n  %val = memref.load %mem[%i] : memref<1xi32>\r\n  return\r\n}", "code_snippet_02": "handshake.func @foo(%arg0: memref<1xi32>, %arg1: none, ...) -> none attributes {argNames = [\"in0\", \"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n    %0:2 = extmemory[ld = 1, st = 0] (%arg0 : memref<1xi32>) (%addressResults) {id = 0 : i32} : (index) -> (i32, none)\r\n    sink %arg0 : memref<1xi32>\r\n    %1:2 = fork [2] %arg1 : none\r\n    %2:2 = fork [2] %1#1 : none\r\n    %3 = join %2#1, %0#1 : none\r\n    %4 = constant %2#0 {value = 0 : index} : index\r\n    %dataResult, %addressResults = load [%4] %0#0, %1#0 : index, i32\r\n    sink %dataResult : i32\r\n    return %3 : none\r\n  }"}, {"number": 3256, "title": "[StandardToHandshake] Handing unused external memory. ", "created_at": "2022-06-02T11:54:04Z", "state": "closed", "labels": "bug, Handshake", "body": "The following IR causes the `--convert-std-to-handshake` pass to produce a segfault.\r\n\r\n```mlir\r\nmodule {\r\n  func.func @foo(%mem : memref<1xi32>) {\r\n    return\r\n  }\r\n}\r\n```\r\n\r\nThe cause is `https://github.com/llvm/circt/blob/main/lib/Conversion/StandardToHandshake/StandardToHandshake.cpp#L1457` because there is no such thing as a \"defining op\".\r\n\r\nThis can obviously be circumvented by checking if it's a `BlockArgument` and then continuing the loop. While the fix stops the pass from crashing and thus produces the following, the conversion to FIRRTL crashes afterwards.\r\n\r\n```mlir\r\nhandshake.func @foo(%arg0: memref<1xi32>, %arg1: none, ...) -> none attributes {argNames = [\"in0\", \"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n  sink %arg0 : memref<1xi32>\r\n  return %arg1 : none\r\n}\r\n\r\n```\r\n\r\n`HandshakeToFIRRTL` assumes that each memref which is passed to a function is feed into a `extmemory` operation, which is not the case here. \r\nHow should I fix that? By introducing an extra check that will ignore this case when then `memref` is directly pushed into a sink?", "code_snippet_01": "module {\r\n  func.func @foo(%mem : memref<1xi32>) {\r\n    return\r\n  }\r\n}", "code_snippet_02": "handshake.func @foo(%arg0: memref<1xi32>, %arg1: none, ...) -> none attributes {argNames = [\"in0\", \"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n  sink %arg0 : memref<1xi32>\r\n  return %arg1 : none\r\n}"}, {"number": 3240, "title": "[FIRRTL] Grand Central Views/Taps Should Not Block Deduplication", "created_at": "2022-05-29T05:27:10Z", "state": "open", "labels": "bug, FIRRTL", "body": "The dead wire taps added to GCT Views and Data Taps are causing problems with deduplication. Specifically, the dead wire taps can block deduplication because they are IR operations. A GCT view or tap should not block deduplication.\r\n\r\n## Example\r\n\r\nConsider the following circuit.  In this, there are two submodules and _only one_ is tapped via a Grand Central View on wire `_w`:\r\n\r\n```scala\r\ncircuit Top :\r\n  module Submodule :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    wire _w : UInt<1> \r\n    _w <= in \r\n    out <= _w \r\n\r\n  module Submodule_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    wire _w : UInt<1> \r\n    _w <= in \r\n    out <= _w \r\n\r\n  module MyView_companion :\r\n\r\n    wire _WIRE : UInt<1>\r\n    _WIRE <= UInt<1>(\"h0\")\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    inst sub1 of Submodule \r\n    sub1.clock <= clock\r\n    sub1.reset <= reset\r\n    inst sub2 of Submodule_1 \r\n    sub2.clock <= clock\r\n    sub2.reset <= reset\r\n    sub1.in <= in \r\n    sub2.in <= in \r\n    node _out_T = xor(sub1.out, sub2.out) \r\n    out <= _out_T \r\n    inst MyView_companion of MyView_companion \r\n```\r\n\r\nThe corresponding annotation file is:\r\n```json\r\n[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|MyView_companion>_WIRE\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\":\"MyView\",\r\n    \"companion\":\"~Top|MyView_companion\",\r\n    \"parent\":\"~Top|Top\",\r\n    \"view\":\"{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedBundleType\\\",\\\"defName\\\":\\\"MyInterface\\\",\\\"elements\\\":[{\\\"name\\\":\\\"tap1\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\",\\\"ref\\\":{\\\"circuit\\\":\\\"Top\\\",\\\"module\\\":\\\"Top\\\",\\\"path\\\":[{\\\"_1\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$Instance\\\",\\\"value\\\":\\\"sub1\\\"},\\\"_2\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$OfModule\\\",\\\"value\\\":\\\"Submodule\\\"}}],\\\"ref\\\":\\\"_w\\\",\\\"component\\\":[]},\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\\\"}}}]}\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\":\"~Top|MyView_companion\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"builds/gct-tests/DedupOneTap/firrtl/gct\",\r\n    \"filename\":\"builds/gct-tests/DedupOneTap/firrtl/bindings.sv\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation\",\r\n    \"filename\":\"builds/gct-tests/DedupOneTap/firrtl/gct/gct.yaml\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.stage.RunFirrtlTransformAnnotation\",\r\n    \"transform\":\"sifive.enterprise.grandcentral.GrandCentralTransform\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.stage.RunFirrtlTransformAnnotation\",\r\n    \"transform\":\"sifive.enterprise.firrtl.ExtractTestCodeTransform\"\r\n  }\r\n]\r\n```\r\n\r\nWhen compiled, this currently produces two copies of the submodule due to the `_gctTap` which causes them to differ.\r\n\r\nThe output Verilog currently is:\r\n\r\n```verilog\r\nmodule Submodule(\r\n  input  in,\r\n  output out);\r\n\r\n  wire _gctTap;\r\n\r\n  assign _gctTap = in;\r\n  assign out = in;\r\nendmodule\r\n\r\nmodule Submodule_1(\r\n  input  in,\r\n  output out);\r\n\r\n  assign out = in;\r\nendmodule\r\n\r\nmodule Top(\r\n  input  clock,\r\n         reset,\r\n         in,\r\n  output out);\r\n\r\n  wire _sub2_out;\r\n  wire _sub1_out;\r\n\r\n  // This interface is elsewhere emitted as a bind statement.\r\n  // MyInterface MyView();\r\n  Submodule sub1 (\r\n    .in  (in),\r\n    .out (_sub1_out)\r\n  );\r\n  Submodule_1 sub2 (\r\n    .in  (in),\r\n    .out (_sub2_out)\r\n  );\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    MyView_companion MyView_companion ();\r\n  */\r\n  assign out = _sub1_out ^ _sub2_out;\r\nendmodule\r\n```", "code_snippet_01": "circuit Top :\r\n  module Submodule :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    wire _w : UInt<1> \r\n    _w <= in \r\n    out <= _w \r\n\r\n  module Submodule_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    wire _w : UInt<1> \r\n    _w <= in \r\n    out <= _w \r\n\r\n  module MyView_companion :\r\n\r\n    wire _WIRE : UInt<1>\r\n    _WIRE <= UInt<1>(\"h0\")\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    inst sub1 of Submodule \r\n    sub1.clock <= clock\r\n    sub1.reset <= reset\r\n    inst sub2 of Submodule_1 \r\n    sub2.clock <= clock\r\n    sub2.reset <= reset\r\n    sub1.in <= in \r\n    sub2.in <= in \r\n    node _out_T = xor(sub1.out, sub2.out) \r\n    out <= _out_T \r\n    inst MyView_companion of MyView_companion", "code_snippet_02": "[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|MyView_companion>_WIRE\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\":\"MyView\",\r\n    \"companion\":\"~Top|MyView_companion\",\r\n    \"parent\":\"~Top|Top\",\r\n    \"view\":\"{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedBundleType\\\",\\\"defName\\\":\\\"MyInterface\\\",\\\"elements\\\":[{\\\"name\\\":\\\"tap1\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\",\\\"ref\\\":{\\\"circuit\\\":\\\"Top\\\",\\\"module\\\":\\\"Top\\\",\\\"path\\\":[{\\\"_1\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$Instance\\\",\\\"value\\\":\\\"sub1\\\"},\\\"_2\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$OfModule\\\",\\\"value\\\":\\\"Submodule\\\"}}],\\\"ref\\\":\\\"_w\\\",\\\"component\\\":[]},\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\\\"}}}]}\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\":\"~Top|MyView_companion\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"builds/gct-tests/DedupOneTap/firrtl/gct\",\r\n    \"filename\":\"builds/gct-tests/DedupOneTap/firrtl/bindings.sv\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation\",\r\n    \"filename\":\"builds/gct-tests/DedupOneTap/firrtl/gct/gct.yaml\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.stage.RunFirrtlTransformAnnotation\",\r\n    \"transform\":\"sifive.enterprise.grandcentral.GrandCentralTransform\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.stage.RunFirrtlTransformAnnotation\",\r\n    \"transform\":\"sifive.enterprise.firrtl.ExtractTestCodeTransform\"\r\n  }\r\n]", "code_snippet_03": "module Submodule(\r\n  input  in,\r\n  output out);\r\n\r\n  wire _gctTap;\r\n\r\n  assign _gctTap = in;\r\n  assign out = in;\r\nendmodule\r\n\r\nmodule Submodule_1(\r\n  input  in,\r\n  output out);\r\n\r\n  assign out = in;\r\nendmodule\r\n\r\nmodule Top(\r\n  input  clock,\r\n         reset,\r\n         in,\r\n  output out);\r\n\r\n  wire _sub2_out;\r\n  wire _sub1_out;\r\n\r\n  // This interface is elsewhere emitted as a bind statement.\r\n  // MyInterface MyView();\r\n  Submodule sub1 (\r\n    .in  (in),\r\n    .out (_sub1_out)\r\n  );\r\n  Submodule_1 sub2 (\r\n    .in  (in),\r\n    .out (_sub2_out)\r\n  );\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    MyView_companion MyView_companion ();\r\n  */\r\n  assign out = _sub1_out ^ _sub2_out;\r\nendmodule"}, {"number": 3112, "title": "[StaticLogicToCalyx] Unused group in execution schedule.", "created_at": "2022-05-12T05:18:32Z", "state": "closed", "labels": "bug, Calyx", "body": "```mlir\r\n// test.mlir\r\nfunc.func @func(%A: memref<4xi32>, %B: memref<4xi32>, %R: memref<4xi32>) {\r\n  affine.for %i = 0 to 4 {\r\n    %5 = affine.load %A[%i] : memref<4xi32>\r\n    %6 = affine.load %B[%i] : memref<4xi32>\r\n    %7 = arith.muli %5, %6 : i32\r\n    affine.store %7, %R[%i] : memref<4xi32>\r\n  }\r\n  return\r\n}\r\n```\r\n\r\n```\r\n ./build/bin/circt-opt -convert-affine-to-staticlogic test.mlir | ./build/bin/circt-opt --lower-scf-to-calyx\r\n```\r\n\r\n```mlir\r\nmodule {\r\n  func.func @func(%arg0: memref<4xi32>, %arg1: memref<4xi32>, %arg2: memref<4xi32>) {\r\n    %c0 = arith.constant 0 : index\r\n    %c4 = arith.constant 4 : index\r\n    %c1 = arith.constant 1 : index\r\n    staticlogic.pipeline.while II =  1 trip_count =  4 iter_args(%arg3 = %c0) : (index) -> () {\r\n      %0 = arith.cmpi ult, %arg3, %c4 : index\r\n      staticlogic.pipeline.register %0 : i1\r\n    } do {\r\n      %0:3 = staticlogic.pipeline.stage start = 0 {\r\n        %2 = memref.load %arg0[%arg3] : memref<4xi32>\r\n        %3 = memref.load %arg1[%arg3] : memref<4xi32>\r\n        %4 = arith.addi %arg3, %c1 : index\r\n        staticlogic.pipeline.register %2, %3, %4 : i32, i32, index\r\n      } : i32, i32, index\r\n      %1 = staticlogic.pipeline.stage start = 1 {\r\n        %2 = arith.muli %0#0, %0#1 : i32\r\n        staticlogic.pipeline.register %2 : i32\r\n      } : i32\r\n      staticlogic.pipeline.stage start = 4 {\r\n        memref.store %1, %arg2[%arg3] : memref<4xi32>\r\n        staticlogic.pipeline.register \r\n      }\r\n      staticlogic.pipeline.terminator iter_args(%0#2), results() : (index) -> ()\r\n    }\r\n    return\r\n  }\r\n}\r\n```\r\n\r\n```mlir\r\n\"builtin.module\"() ({\r\n  \"calyx.program\"() ({\r\n    \"calyx.component\"() ({\r\n    ^bb0(%arg0: i32, %arg1: i1, %arg2: i32, %arg3: i1, %arg4: i32, %arg5: i1, %arg6: i1, %arg7: i1, %arg8: i1, %arg9: i32, %arg10: i2, %arg11: i1, %arg12: i32, %arg13: i2, %arg14: i1, %arg15: i32, %arg16: i2, %arg17: i1, %arg18: i1):\r\n      %0 = \"hw.constant\"() {value = 1 : i32} : () -> i32\r\n      %1 = \"hw.constant\"() {value = 4 : i32} : () -> i32\r\n      %2 = \"hw.constant\"() {value = 0 : i32} : () -> i32\r\n      %3 = \"hw.constant\"() {value = true} : () -> i1\r\n      %4:2 = \"calyx.std_slice\"() {sym_name = \"std_slice_2\"} : () -> (i32, i2)\r\n      %5:2 = \"calyx.std_slice\"() {sym_name = \"std_slice_1\"} : () -> (i32, i2)\r\n      %6:2 = \"calyx.std_slice\"() {sym_name = \"std_slice_0\"} : () -> (i32, i2)\r\n      %7:7 = \"calyx.std_mult_pipe\"() {sym_name = \"std_mult_pipe_0\"} : () -> (i1, i1, i1, i32, i32, i32, i1)\r\n      %8:3 = \"calyx.std_add\"() {sym_name = \"std_add_0\"} : () -> (i32, i32, i32)\r\n      %9:3 = \"calyx.std_lt\"() {sym_name = \"std_lt_0\"} : () -> (i32, i32, i1)\r\n      %10:6 = \"calyx.register\"() {sym_name = \"stage_1_register_0_reg\"} : () -> (i32, i1, i1, i1, i32, i1)\r\n      %11:6 = \"calyx.register\"() {sym_name = \"stage_0_register_1_reg\"} : () -> (i32, i1, i1, i1, i32, i1)\r\n      %12:6 = \"calyx.register\"() {sym_name = \"stage_0_register_0_reg\"} : () -> (i32, i1, i1, i1, i32, i1)\r\n      %13:6 = \"calyx.register\"() {sym_name = \"while_0_arg0_reg\"} : () -> (i32, i1, i1, i1, i32, i1)\r\n      \"calyx.wires\"() ({\r\n        \"calyx.group\"() ({\r\n          \"calyx.assign\"(%13#0, %2) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%13#1, %3) : (i1, i1) -> ()\r\n          \"calyx.group_done\"(%13#5) : (i1) -> ()\r\n        }) {sym_name = \"assign_while_0_init_0\"} : () -> ()\r\n        \"calyx.comb_group\"() ({\r\n          \"calyx.assign\"(%9#0, %13#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%9#1, %1) : (i32, i32) -> ()\r\n        }) {sym_name = \"bb0_0\"} : () -> ()\r\n        \"calyx.group\"() ({\r\n          \"calyx.assign\"(%4#0, %13#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%arg10, %4#1) : (i2, i2) -> ()\r\n          \"calyx.assign\"(%12#0, %arg0) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%12#1, %3) : (i1, i1) -> ()\r\n          \"calyx.group_done\"(%12#5) : (i1) -> ()\r\n        }) {sym_name = \"bb0_1\"} : () -> ()\r\n        \"calyx.group\"() ({\r\n          \"calyx.assign\"(%5#0, %13#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%arg13, %5#1) : (i2, i2) -> ()\r\n          \"calyx.assign\"(%11#0, %arg2) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%11#1, %3) : (i1, i1) -> ()\r\n          \"calyx.group_done\"(%11#5) : (i1) -> ()\r\n        }) {sym_name = \"bb0_2\"} : () -> ()\r\n        \"calyx.group\"() ({\r\n          \"calyx.assign\"(%8#0, %13#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%8#1, %0) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%13#0, %8#2) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%13#1, %3) : (i1, i1) -> ()\r\n          \"calyx.group_done\"(%13#5) : (i1) -> ()\r\n        }) {sym_name = \"bb0_3\"} : () -> ()\r\n        \"calyx.group\"() ({\r\n          \"calyx.assign\"(%7#3, %12#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%7#4, %11#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%10#0, %7#5) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%10#1, %7#6) : (i1, i1) -> ()\r\n          \"calyx.assign\"(%7#2, %3) : (i1, i1) -> ()\r\n          \"calyx.group_done\"(%10#5) : (i1) -> ()\r\n        }) {sym_name = \"bb0_4\"} : () -> ()\r\n        \"calyx.group\"() ({\r\n          \"calyx.assign\"(%6#0, %13#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%arg16, %6#1) : (i2, i2) -> ()\r\n          \"calyx.assign\"(%arg15, %10#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%arg17, %3) : (i1, i1) -> ()\r\n          \"calyx.group_done\"(%arg5) : (i1) -> ()\r\n        }) {sym_name = \"bb0_5\"} : () -> ()\r\n      }) : () -> ()\r\n      \"calyx.control\"() ({\r\n        \"calyx.seq\"() ({\r\n          \"calyx.par\"() ({./bin/circt-opt --lower-scf-to-calyx\r\n            \"calyx.enable\"() {groupName = @assign_while_0_init_0} : () -> ()\r\n          }) : () -> ()\r\n          \"calyx.par\"() ({\r\n            \"calyx.enable\"() {groupName = @bb0_1} : () -> ()\r\n            \"calyx.enable\"() {groupName = @bb0_2} : () -> ()\r\n            \"calyx.enable\"() {groupName = @bb0_3} : () -> ()\r\n          }) : () -> ()\r\n          \"calyx.par\"() ({\r\n            \"calyx.enable\"() {groupName = @bb0_1} : () -> ()\r\n            \"calyx.enable\"() {groupName = @bb0_2} : () -> ()\r\n            \"calyx.enable\"() {groupName = @bb0_3} : () -> ()\r\n            \"calyx.enable\"() {groupName = @bb0_4} : () -> ()\r\n          }) : () -> ()\r\n          \"calyx.while\"(%9#2) ({\r\n            \"calyx.par\"() ({\r\n              \"calyx.enable\"() {groupName = @bb0_1} : () -> ()\r\n              \"calyx.enable\"() {groupName = @bb0_2} : () -> ()\r\n              \"calyx.enable\"() {groupName = @bb0_3} : () -> ()\r\n              \"calyx.enable\"() {groupName = @bb0_4} : () -> ()\r\n            }) : () -> ()\r\n          }) {bound = 2 : i64, groupName = @bb0_0} : (i1) -> ()\r\n          \"calyx.par\"() ({\r\n            \"calyx.enable\"() {groupName = @bb0_4} : () -> ()\r\n          }) : () -> ()\r\n        }) : () -> ()\r\n      }) : () -> ()\r\n    }) {function_type = (i32, i1, i32, i1, i32, i1, i1, i1, i1, i32, i2, i1, i32, i2, i1, i32, i2, i1, i1) -> (), portAttributes = [{mem = {id = 0 : i32, tag = \"read_data\"}}, {mem = {id = 0 : i32, tag = \"done\"}}, {mem = {id = 1 : i32, tag = \"read_data\"}}, {mem = {id = 1 : i32, tag = \"done\"}}, {mem = {id = 2 : i32, tag = \"read_data\"}}, {mem = {id = 2 : i32, tag = \"done\"}}, {clk}, {reset}, {go}, {mem = {id = 0 : i32, tag = \"write_data\"}}, {mem = {addr_idx = 0 : i32, id = 0 : i32, tag = \"addr\"}}, {mem = {id = 0 : i32, tag = \"write_en\"}}, {mem = {id = 1 : i32, tag = \"write_data\"}}, {mem = {addr_idx = 0 : i32, id = 1 : i32, tag = \"addr\"}}, {mem = {id = 1 : i32, tag = \"write_en\"}}, {mem = {id = 2 : i32, tag = \"write_data\"}}, {mem = {addr_idx = 0 : i32, id = 2 : i32, tag = \"addr\"}}, {mem = {id = 2 : i32, tag = \"write_en\"}}, {done}], portDirections = -512 : i19, portNames = [\"ext_mem0_read_data\", \"ext_mem0_done\", \"ext_mem1_read_data\", \"ext_mem1_done\", \"ext_mem2_read_data\", \"ext_mem2_done\", \"clk\", \"reset\", \"go\", \"ext_mem0_write_data\", \"ext_mem0_addr0\", \"ext_mem0_write_en\", \"ext_mem1_write_data\", \"ext_mem1_addr0\", \"ext_mem1_write_en\", \"ext_mem2_write_data\", \"ext_mem2_addr0\", \"ext_mem2_write_en\", \"done\"], sym_name = \"func\", toplevel} : () -> ()\r\n  }) {entryPointName = \"func\"} : () -> ()\r\n}) : () -> ()\r\n```\r\n\r\n```\r\n<stdin>:21:9: error: 'calyx.group' op with name: \"bb0_5\" is unused in the control execution schedule\r\n        memref.store %1, %arg2[%arg3] : memref<4xi32>\r\n```", "code_snippet_01": "// test.mlir\r\nfunc.func @func(%A: memref<4xi32>, %B: memref<4xi32>, %R: memref<4xi32>) {\r\n  affine.for %i = 0 to 4 {\r\n    %5 = affine.load %A[%i] : memref<4xi32>\r\n    %6 = affine.load %B[%i] : memref<4xi32>\r\n    %7 = arith.muli %5, %6 : i32\r\n    affine.store %7, %R[%i] : memref<4xi32>\r\n  }\r\n  return\r\n}", "code_snippet_02": "./build/bin/circt-opt -convert-affine-to-staticlogic test.mlir | ./build/bin/circt-opt --lower-scf-to-calyx", "code_snippet_03": "module {\r\n  func.func @func(%arg0: memref<4xi32>, %arg1: memref<4xi32>, %arg2: memref<4xi32>) {\r\n    %c0 = arith.constant 0 : index\r\n    %c4 = arith.constant 4 : index\r\n    %c1 = arith.constant 1 : index\r\n    staticlogic.pipeline.while II =  1 trip_count =  4 iter_args(%arg3 = %c0) : (index) -> () {\r\n      %0 = arith.cmpi ult, %arg3, %c4 : index\r\n      staticlogic.pipeline.register %0 : i1\r\n    } do {\r\n      %0:3 = staticlogic.pipeline.stage start = 0 {\r\n        %2 = memref.load %arg0[%arg3] : memref<4xi32>\r\n        %3 = memref.load %arg1[%arg3] : memref<4xi32>\r\n        %4 = arith.addi %arg3, %c1 : index\r\n        staticlogic.pipeline.register %2, %3, %4 : i32, i32, index\r\n      } : i32, i32, index\r\n      %1 = staticlogic.pipeline.stage start = 1 {\r\n        %2 = arith.muli %0#0, %0#1 : i32\r\n        staticlogic.pipeline.register %2 : i32\r\n      } : i32\r\n      staticlogic.pipeline.stage start = 4 {\r\n        memref.store %1, %arg2[%arg3] : memref<4xi32>\r\n        staticlogic.pipeline.register \r\n      }\r\n      staticlogic.pipeline.terminator iter_args(%0#2), results() : (index) -> ()\r\n    }\r\n    return\r\n  }\r\n}", "code_snippet_04": "\"builtin.module\"() ({\r\n  \"calyx.program\"() ({\r\n    \"calyx.component\"() ({\r\n    ^bb0(%arg0: i32, %arg1: i1, %arg2: i32, %arg3: i1, %arg4: i32, %arg5: i1, %arg6: i1, %arg7: i1, %arg8: i1, %arg9: i32, %arg10: i2, %arg11: i1, %arg12: i32, %arg13: i2, %arg14: i1, %arg15: i32, %arg16: i2, %arg17: i1, %arg18: i1):\r\n      %0 = \"hw.constant\"() {value = 1 : i32} : () -> i32\r\n      %1 = \"hw.constant\"() {value = 4 : i32} : () -> i32\r\n      %2 = \"hw.constant\"() {value = 0 : i32} : () -> i32\r\n      %3 = \"hw.constant\"() {value = true} : () -> i1\r\n      %4:2 = \"calyx.std_slice\"() {sym_name = \"std_slice_2\"} : () -> (i32, i2)\r\n      %5:2 = \"calyx.std_slice\"() {sym_name = \"std_slice_1\"} : () -> (i32, i2)\r\n      %6:2 = \"calyx.std_slice\"() {sym_name = \"std_slice_0\"} : () -> (i32, i2)\r\n      %7:7 = \"calyx.std_mult_pipe\"() {sym_name = \"std_mult_pipe_0\"} : () -> (i1, i1, i1, i32, i32, i32, i1)\r\n      %8:3 = \"calyx.std_add\"() {sym_name = \"std_add_0\"} : () -> (i32, i32, i32)\r\n      %9:3 = \"calyx.std_lt\"() {sym_name = \"std_lt_0\"} : () -> (i32, i32, i1)\r\n      %10:6 = \"calyx.register\"() {sym_name = \"stage_1_register_0_reg\"} : () -> (i32, i1, i1, i1, i32, i1)\r\n      %11:6 = \"calyx.register\"() {sym_name = \"stage_0_register_1_reg\"} : () -> (i32, i1, i1, i1, i32, i1)\r\n      %12:6 = \"calyx.register\"() {sym_name = \"stage_0_register_0_reg\"} : () -> (i32, i1, i1, i1, i32, i1)\r\n      %13:6 = \"calyx.register\"() {sym_name = \"while_0_arg0_reg\"} : () -> (i32, i1, i1, i1, i32, i1)\r\n      \"calyx.wires\"() ({\r\n        \"calyx.group\"() ({\r\n          \"calyx.assign\"(%13#0, %2) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%13#1, %3) : (i1, i1) -> ()\r\n          \"calyx.group_done\"(%13#5) : (i1) -> ()\r\n        }) {sym_name = \"assign_while_0_init_0\"} : () -> ()\r\n        \"calyx.comb_group\"() ({\r\n          \"calyx.assign\"(%9#0, %13#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%9#1, %1) : (i32, i32) -> ()\r\n        }) {sym_name = \"bb0_0\"} : () -> ()\r\n        \"calyx.group\"() ({\r\n          \"calyx.assign\"(%4#0, %13#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%arg10, %4#1) : (i2, i2) -> ()\r\n          \"calyx.assign\"(%12#0, %arg0) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%12#1, %3) : (i1, i1) -> ()\r\n          \"calyx.group_done\"(%12#5) : (i1) -> ()\r\n        }) {sym_name = \"bb0_1\"} : () -> ()\r\n        \"calyx.group\"() ({\r\n          \"calyx.assign\"(%5#0, %13#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%arg13, %5#1) : (i2, i2) -> ()\r\n          \"calyx.assign\"(%11#0, %arg2) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%11#1, %3) : (i1, i1) -> ()\r\n          \"calyx.group_done\"(%11#5) : (i1) -> ()\r\n        }) {sym_name = \"bb0_2\"} : () -> ()\r\n        \"calyx.group\"() ({\r\n          \"calyx.assign\"(%8#0, %13#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%8#1, %0) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%13#0, %8#2) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%13#1, %3) : (i1, i1) -> ()\r\n          \"calyx.group_done\"(%13#5) : (i1) -> ()\r\n        }) {sym_name = \"bb0_3\"} : () -> ()\r\n        \"calyx.group\"() ({\r\n          \"calyx.assign\"(%7#3, %12#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%7#4, %11#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%10#0, %7#5) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%10#1, %7#6) : (i1, i1) -> ()\r\n          \"calyx.assign\"(%7#2, %3) : (i1, i1) -> ()\r\n          \"calyx.group_done\"(%10#5) : (i1) -> ()\r\n        }) {sym_name = \"bb0_4\"} : () -> ()\r\n        \"calyx.group\"() ({\r\n          \"calyx.assign\"(%6#0, %13#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%arg16, %6#1) : (i2, i2) -> ()\r\n          \"calyx.assign\"(%arg15, %10#4) : (i32, i32) -> ()\r\n          \"calyx.assign\"(%arg17, %3) : (i1, i1) -> ()\r\n          \"calyx.group_done\"(%arg5) : (i1) -> ()\r\n        }) {sym_name = \"bb0_5\"} : () -> ()\r\n      }) : () -> ()\r\n      \"calyx.control\"() ({\r\n        \"calyx.seq\"() ({\r\n          \"calyx.par\"() ({./bin/circt-opt --lower-scf-to-calyx\r\n            \"calyx.enable\"() {groupName = @assign_while_0_init_0} : () -> ()\r\n          }) : () -> ()\r\n          \"calyx.par\"() ({\r\n            \"calyx.enable\"() {groupName = @bb0_1} : () -> ()\r\n            \"calyx.enable\"() {groupName = @bb0_2} : () -> ()\r\n            \"calyx.enable\"() {groupName = @bb0_3} : () -> ()\r\n          }) : () -> ()\r\n          \"calyx.par\"() ({\r\n            \"calyx.enable\"() {groupName = @bb0_1} : () -> ()\r\n            \"calyx.enable\"() {groupName = @bb0_2} : () -> ()\r\n            \"calyx.enable\"() {groupName = @bb0_3} : () -> ()\r\n            \"calyx.enable\"() {groupName = @bb0_4} : () -> ()\r\n          }) : () -> ()\r\n          \"calyx.while\"(%9#2) ({\r\n            \"calyx.par\"() ({\r\n              \"calyx.enable\"() {groupName = @bb0_1} : () -> ()\r\n              \"calyx.enable\"() {groupName = @bb0_2} : () -> ()\r\n              \"calyx.enable\"() {groupName = @bb0_3} : () -> ()\r\n              \"calyx.enable\"() {groupName = @bb0_4} : () -> ()\r\n            }) : () -> ()\r\n          }) {bound = 2 : i64, groupName = @bb0_0} : (i1) -> ()\r\n          \"calyx.par\"() ({\r\n            \"calyx.enable\"() {groupName = @bb0_4} : () -> ()\r\n          }) : () -> ()\r\n        }) : () -> ()\r\n      }) : () -> ()\r\n    }) {function_type = (i32, i1, i32, i1, i32, i1, i1, i1, i1, i32, i2, i1, i32, i2, i1, i32, i2, i1, i1) -> (), portAttributes = [{mem = {id = 0 : i32, tag = \"read_data\"}}, {mem = {id = 0 : i32, tag = \"done\"}}, {mem = {id = 1 : i32, tag = \"read_data\"}}, {mem = {id = 1 : i32, tag = \"done\"}}, {mem = {id = 2 : i32, tag = \"read_data\"}}, {mem = {id = 2 : i32, tag = \"done\"}}, {clk}, {reset}, {go}, {mem = {id = 0 : i32, tag = \"write_data\"}}, {mem = {addr_idx = 0 : i32, id = 0 : i32, tag = \"addr\"}}, {mem = {id = 0 : i32, tag = \"write_en\"}}, {mem = {id = 1 : i32, tag = \"write_data\"}}, {mem = {addr_idx = 0 : i32, id = 1 : i32, tag = \"addr\"}}, {mem = {id = 1 : i32, tag = \"write_en\"}}, {mem = {id = 2 : i32, tag = \"write_data\"}}, {mem = {addr_idx = 0 : i32, id = 2 : i32, tag = \"addr\"}}, {mem = {id = 2 : i32, tag = \"write_en\"}}, {done}], portDirections = -512 : i19, portNames = [\"ext_mem0_read_data\", \"ext_mem0_done\", \"ext_mem1_read_data\", \"ext_mem1_done\", \"ext_mem2_read_data\", \"ext_mem2_done\", \"clk\", \"reset\", \"go\", \"ext_mem0_write_data\", \"ext_mem0_addr0\", \"ext_mem0_write_en\", \"ext_mem1_write_data\", \"ext_mem1_addr0\", \"ext_mem1_write_en\", \"ext_mem2_write_data\", \"ext_mem2_addr0\", \"ext_mem2_write_en\", \"done\"], sym_name = \"func\", toplevel} : () -> ()\r\n  }) {entryPointName = \"func\"} : () -> ()\r\n}) : () -> ()", "code_snippet_05": "<stdin>:21:9: error: 'calyx.group' op with name: \"bb0_5\" is unused in the control execution schedule\r\n        memref.store %1, %arg2[%arg3] : memref<4xi32>"}, {"number": 3111, "title": " lower-scf-to-calyx => valueGroupAssigns.end() && \"No group evaluating value!\"' failed", "created_at": "2022-05-12T02:21:20Z", "state": "closed", "labels": "bug, Calyx", "body": "When lowering lower-scf-to-calyx I'm getting:\r\n\r\ncirct-opt --allow-unregistered-dialect --lower-scf-to-calyx  -o=test_memory_3_calyx.mlir  test_memory_3_staticlogic.mlir\r\n\r\ncirct-opt: /mnt/scratch/tools/github/circt/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp:331: TGroupOp circt::ComponentLoweringState::getEvaluatingGroup(mlir::Value) [with TGroupOp = circt::calyx::GroupInterface]: Assertion `it != valueGroupAssigns.end() && \"No group evaluating value!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: /mnt/scratch/tools/github/circt/build/bin/circt-opt --allow-unregistered-dialect --lower-scf-to-calyx -o=polygeist_circt_calyx/test_memory_3_calyx.mlir polygeist_circt_calyx/test_memory_3_staticlogic.mlir\r\n #0 0x00007fa78919b405 PrintStackTraceSignalHandler(void*) Signals.cpp:0:0\r\n #1 0x00007fa789198a84 SignalHandler(int) Signals.cpp:0:0\r\n #2 0x00007fa788a07520 (/lib/x86_64-linux-gnu/libc.so.6+0x42520)\r\n #3 0x00007fa788a5ba7c __pthread_kill_implementation ./nptl/./nptl/pthread_kill.c:44:76\r\n #4 0x00007fa788a5ba7c __pthread_kill_internal ./nptl/./nptl/pthread_kill.c:78:10\r\n #5 0x00007fa788a5ba7c pthread_kill ./nptl/./nptl/pthread_kill.c:89:10\r\n #6 0x00007fa788a07476 gsignal ./signal/../sysdeps/posix/raise.c:27:6\r\n #7 0x00007fa7889ed7f3 abort ./stdlib/./stdlib/abort.c:81:7\r\n #8 0x00007fa7889ed71b _nl_load_domain ./intl/./intl/loadmsgcat.c:1177:9\r\n #9 0x00007fa7889fee96 (/lib/x86_64-linux-gnu/libc.so.6+0x39e96)\r\n#10 0x00005652a5a0561f circt::BuildPipelineGroups::buildStageGroups(circt::staticlogic::PipelineWhileOp, circt::staticlogic::PipelineStageOp, mlir::Patte\r\n[test_memory_3.zip](https://github.com/llvm/circt/files/8674539/test_memory_3.zip)\r\nrnRewriter&) const (/mnt/scratch/tools/github/circt/build/bin/circt-opt+0x5d461f)\r\n#11 0x00005652a5a05de5 circt::BuildPipelineGroups::PartiallyLowerFuncToComp(mlir::func::FuncOp, mlir::PatternRewriter&) const (/mnt/scratch/tools/github/circt/build/bin/circt-opt+0x5d4de5)\r\n#12 0x00005652a59e845e circt::PartialLoweringPattern<mlir::func::FuncOp, mlir::OpRewritePattern>::matchAndRewrite(mlir::func::FuncOp, mlir::PatternRewriter&) const (/mnt/scratch/tools/github/circt/build/bin/circt-opt+0x5b745e)\r\n#13 0x00007fa78949df6d mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIRRewrite.so.15git+0x4ff6d)\r\n#14 0x00007fa7895086a1 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) (.constprop.0) GreedyPatternRewriteDriver.cpp:0:0\r\n#15 0x00007fa78950a7b3 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIRTransformUtils.so.15git+0x607b3)\r\n#16 0x00005652a59eb151 circt::SCFToCalyxPass::runOnOperation() (/mnt/scratch/tools/github/circt/build/bin/circt-opt+0x5ba151)\r\n#17 0x00007fa78942b19a mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIRPass.so.15git+0x2c19a)\r\n#18 0x00007fa78942b8c0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIRPass.so.15git+0x2c8c0)\r\n#19 0x00007fa78942cbe4 mlir::PassManager::run(mlir::Operation*) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIRPass.so.15git+0x2dbe4)\r\n#20 0x00007fa78a23215d performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>) (.constprop.0) MlirOptMain.cpp:0:0\r\n#21 0x00007fa78a2324c1 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, llvm::ThreadPool*) MlirOptMain.cpp:0:0\r\n#22 0x00007fa78a232970 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (mlir::PassManager&)>, mlir::DialectRegistry&, bool, bool, bool, bool, bool) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIROptLib.so.15git+0x7970)\r\n#23 0x00007fa78a234742 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) (/mnt/scratch/tools/github/circt/llvm/build/./lib/libMLIROptLib.so.15git+0x9742)\r\n#24 0x00005652a547ca3c main (/mnt/scratch/tools/github/circt/build/bin/circt-opt+0x4ba3c)\r\n#25 0x00007fa7889eed90 __libc_start_call_main ./csu/../sysdeps/nptl/libc_start_call_main.h:58:16\r\n#26 0x00007fa7889eee40 call_init ./csu/../csu/libc-start.c:128:20\r\n#27 0x00007fa7889eee40 __libc_start_main ./csu/../csu/libc-start.c:379:5\r\n#28 0x00005652a547cd75 _start (/mnt/scratch/tools/github/circt/build/bin/circt-opt+0x4bd75)\r\n"}, {"number": 3105, "title": "[FIRRTL] ExtractInstances wrapper module name is not prefixed", "created_at": "2022-05-11T14:49:40Z", "state": "open", "labels": "bug, FIRRTL", "body": "The optional wrapper modules that `ExtractInstances` can generate (e.g. through the `group` field in `ExtractSeqMemsFileAnnotation`) do not get prefixed by `PrefixModules`. See `test/Dialect/FIRRTL/SFCTests/ExtractSeqMems/Compose.fir` for an example.\r\n\r\nDoing the prefixing is not that simple, since ideally we would want prefixing to run before extraction. But extraction creates `sv.verbatim` ops with symbol references to modules which prefixing will invalidate. Alternatively one could go the route of GrandCentral views which also runs after prefixing, but where prefixing updates the annotations relevant for GCT views to contain the prefix. This is challenging for extraction though, since instances to be extracted are not all explicitly annotated, and whether or not a prefix has to be added to the wrapper module also depends on whether the location of the wrapper module is inside the area of effect of a prefix annotation.\r\n\r\nIdeally we would make `PrefixInstances` update symbols appropriately (#3104) and make `sv.verbatim` robust under hierarchy modification. That would disentangle the ordering requirements of the passes and we could run extraction before prefixing."}, {"number": 3104, "title": "[FIRRTL] PrefixModules does not update symbols in sv.verbatim ops", "created_at": "2022-05-11T14:42:23Z", "state": "open", "labels": "bug, FIRRTL", "body": "The `PrefixModules` pass does not update uses of the old module symbol names to the renamed version. Occurs if a pass runs before prefixing that already generates verbatim nodes refering to modules through symbol placeholders (as we commonly do in metadata emission).\r\n\r\nGetting this right might actually be harder than it looks at first glance, especially if modules have to be duplicated to account for instance-specific prefixing."}, {"number": 3097, "title": "[FIRRTL][CreateSiFiveMetadata] Should use symbol references in exported metadata", "created_at": "2022-05-11T03:41:17Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The ForceNames annotation changes the name of modules after the creation of the verbatim ops, so we should be using symbol references to get the correct module names.\r\n\r\n(this is just a tracking issue for a PR that is already open)"}, {"number": 3093, "title": "[FIRRTL] Extract memory instances", "created_at": "2022-05-10T18:03:25Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Extend the `ExtractInstances` pass such that it marks instances of the new `FMemModuleOp` as to be extracted. This then allows the pass to cover the functionality of the original `ExtractSeqMems` pass on the Scala side of things.\r\n\r\nFixes #3092."}, {"number": 3091, "title": "[FIRRTL] Uniquify extracted instance symbols", "created_at": "2022-05-10T16:48:45Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Fix an issue in the `ExtractInstances` pass where certain diamond-shaped instantiation arrangements can lead to instances with identical symbol after extraction.\r\n\r\nWith this change, the pass uses `ModuleNamespace::newName` to ensure the instance symbol is unique within the module it is being extracted to. Fixing this also requires fixing an issue where a black box in a multiply instantiated parent would not properly filter its non-local annotations to only contain the ones that go through the parent instance it was pulled out of.\r\n\r\nFixes #3089."}, {"number": 3090, "title": "[FIRRTL] ExtractInstances duplicates NLAs without assigning new names", "created_at": "2022-05-10T14:52:23Z", "state": "open", "labels": "bug, FIRRTL", "body": "The following caveat is a problem: https://github.com/llvm/circt/blob/a9bdc67cf5bd9493b402c1ee18dca1f6c9766e28/lib/Dialect/FIRRTL/Transforms/ExtractInstances.cpp#L601-L620\r\n\r\nIn a nutshell: There are cases where `ExtractInstances` has to create multiple copies of an NLA during extraction, and currently it does not pick new names for those NLAs. Doing so is a bit cumbersome since the pass has to visit all instances along the NLA path and insert trackers for the newly-created NLAs there as well.\r\n\r\nThe case where this happens requires:\r\n- An instance to be extracted that is nested somewhere within a multiply-instantiated module\r\n- An NLA on that instance that is rooted at the multiply-instantiated module"}, {"number": 3089, "title": "[FIRRTL] Conflicting extracted instance symbols in diamond-shaped instance graph", "created_at": "2022-05-10T14:48:22Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The `ExtractInstances` pass can create situations where the top-level module ends up having multiple instances with the same symbol if the following conditions are met:\r\n- Extracted instances are within a multiply-instantiated module\r\n- Instances had a `inner_sym` already before extraction (e.g., because they were part of an NLA)\r\n\r\nThe pass should make sure that extracted instance symbols are uniquified, potentially updating the relevant NLAs."}, {"number": 3033, "title": "[FIRRTL] Dedup Should Work in Circuit Order", "created_at": "2022-05-03T22:37:08Z", "state": "open", "labels": "bug, FIRRTL", "body": "CIRCT deviates from the SFC because it is doing deduplication based on the instantiation order).  Instead, deduplication should use circuit order (declaration order).\r\n\r\nConsider the following:\r\n\r\n```scala\r\ncircuit Bar:\r\n  module X:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    b <= not(a)\r\n  module Y:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    b <= not(a)\r\n  module Bar:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    inst y of Y\r\n    inst x of X\r\n\r\n    x.a <= a\r\n    y.a <= a\r\n    b <= xor(x.b, y.b)\r\n```\r\n\r\nThis circuit, `Bar`, instantiates two modules that will deduplicate, `X` and `Y`. Module `Y` is instantiated before module `X`. However, `Y` should deduplicate into `X` because `X` is declared first.\r\n\r\nCurrently CIRCT produces (`firtool Bar.fir -dedup -strip-debug-info`):\r\n\r\n```verilog\r\nmodule Y(\r\n  input  a,\r\n  output b);\r\n\r\n  assign b = ~a;\r\nendmodule\r\n\r\nmodule Bar(\r\n  input  a,\r\n  output b);\r\n\r\n  wire _x_b;\r\n  wire _y_b;\r\n\r\n  Y y (\r\n    .a (a),\r\n    .b (_y_b)\r\n  );\r\n  Y x (\r\n    .a (a),\r\n    .b (_x_b)\r\n  );\r\n  assign b = _x_b ^ _y_b;\r\nendmodule\r\n```\r\n\r\nSFC produces (`firrtl -i Bar.fir`):\r\n\r\n```verilog\r\nmodule X(\r\n  input   a,\r\n  output  b\r\n);\r\n  assign b = ~a;\r\nendmodule\r\nmodule Bar(\r\n  input   a,\r\n  output  b\r\n);\r\n  wire  y_a;\r\n  wire  y_b;\r\n  wire  x_a;\r\n  wire  x_b;\r\n  X y (\r\n    .a(y_a),\r\n    .b(y_b)\r\n  );\r\n  X x (\r\n    .a(x_a),\r\n    .b(x_b)\r\n  );\r\n  assign b = x_b ^ y_b;\r\n  assign y_a = a;\r\n  assign x_a = a;\r\nendmodule\r\n```", "code_snippet_01": "circuit Bar:\r\n  module X:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    b <= not(a)\r\n  module Y:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    b <= not(a)\r\n  module Bar:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    inst y of Y\r\n    inst x of X\r\n\r\n    x.a <= a\r\n    y.a <= a\r\n    b <= xor(x.b, y.b)", "code_snippet_02": "module Y(\r\n  input  a,\r\n  output b);\r\n\r\n  assign b = ~a;\r\nendmodule\r\n\r\nmodule Bar(\r\n  input  a,\r\n  output b);\r\n\r\n  wire _x_b;\r\n  wire _y_b;\r\n\r\n  Y y (\r\n    .a (a),\r\n    .b (_y_b)\r\n  );\r\n  Y x (\r\n    .a (a),\r\n    .b (_x_b)\r\n  );\r\n  assign b = _x_b ^ _y_b;\r\nendmodule", "code_snippet_03": "module X(\r\n  input   a,\r\n  output  b\r\n);\r\n  assign b = ~a;\r\nendmodule\r\nmodule Bar(\r\n  input   a,\r\n  output  b\r\n);\r\n  wire  y_a;\r\n  wire  y_b;\r\n  wire  x_a;\r\n  wire  x_b;\r\n  X y (\r\n    .a(y_a),\r\n    .b(y_b)\r\n  );\r\n  X x (\r\n    .a(x_a),\r\n    .b(x_b)\r\n  );\r\n  assign b = x_b ^ y_b;\r\n  assign y_a = a;\r\n  assign x_a = a;\r\nendmodule"}, {"number": 2888, "title": "[FIRRTL] Don't Dedup Modules with Different NestedPrefixModulesAnnotation", "created_at": "2022-04-13T04:49:07Z", "state": "open", "labels": "bug", "body": "`NestedPrefixModulesAnnotation` with different prefixes should not deduplicate. This can be interpreted one of two ways, either of which should have the same effect:\r\n\r\n1. `NestedPrefixModulesAnnotation` should block deduplication.\r\n2. The `PrefixModules` pass should duplicate modules which have different prefixes.\r\n\r\nSiFive's extensions to the SFC are implementing this using strategy (2).\r\n\r\nAn end-to-end test case that should work is the following:\r\n\r\n```scala\r\ncircuit Foo: %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"prefix\":\"prefix1_\",\r\n    \"inclusive\":true,\r\n    \"target\":\"~Foo|Bar\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"prefix\":\"prefix2_\",\r\n    \"inclusive\":true,\r\n    \"target\":\"~Foo|Baz\"\r\n  }\r\n]]\r\n  module Bar:\r\n  module Baz:\r\n  module Foo:\r\n    inst bar of Bar\r\n    inst baz of Baz\r\n```\r\n\r\nCurrently, this produces (`firtool -dedup -strip-debug-info`):\r\n\r\n```verilog\r\nmodule prefix2_Bar();\r\nendmodule\r\n\r\nmodule Foo();\r\n  prefix2_Bar bar ();\r\n  prefix2_Bar baz ();\r\nendmodule\r\n```\r\n\r\nThis should produce:\r\n```verilog\r\nmodule prefix1_Bar();\r\nendmodule\r\n\r\nmodule prefix2_Baz();\r\nendmodule\r\n\r\nmodule Foo();\r\n  prefix1_Bar bar ();\r\n  prefix2_Baz baz ();\r\nendmodule\r\n```\r\n\r\nThere may also be an interaction here with memories where memories should not deduplicate if they have different prefixes.  This may be a little funky because it has interactions with the memory generator schema which may not respect prefixing.", "code_snippet_01": "circuit Foo: %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"prefix\":\"prefix1_\",\r\n    \"inclusive\":true,\r\n    \"target\":\"~Foo|Bar\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"prefix\":\"prefix2_\",\r\n    \"inclusive\":true,\r\n    \"target\":\"~Foo|Baz\"\r\n  }\r\n]]\r\n  module Bar:\r\n  module Baz:\r\n  module Foo:\r\n    inst bar of Bar\r\n    inst baz of Baz", "code_snippet_02": "module prefix2_Bar();\r\nendmodule\r\n\r\nmodule Foo();\r\n  prefix2_Bar bar ();\r\n  prefix2_Bar baz ();\r\nendmodule", "code_snippet_03": "module prefix1_Bar();\r\nendmodule\r\n\r\nmodule prefix2_Baz();\r\nendmodule\r\n\r\nmodule Foo();\r\n  prefix1_Bar bar ();\r\n  prefix2_Baz baz ();\r\nendmodule"}, {"number": 2859, "title": "[HWMemSimImpl] Fix randomization of wide memories", "created_at": "2022-04-07T08:56:54Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The `HWMemSimImpl` pass currently generates SystemVerilog that some tools cannot parse properly in cases where the memory data width is not a multiple of the random value bit width (32). In those cases the randomization produces:\r\n\r\n    reg [33:0] _RANDOM;\r\n    _RANDOM = {{`RANDOM}[1:0], {`RANDOM}};\r\n\r\nSome tools do not recognize ``` {`RANDOM}[1:0] ``` as a primary expression and mistake it for being part of the concatenation, only to then complain that this isn't proper concatenation syntax.\r\n\r\nThis commit changes the randomization code to put the part-select after the overall concatenation, in the hope that most tools will have an easier time identifying `{...}[1:0]` as a primary expression if it appears as the right-hand side of an assignment. This now produces:\r\n\r\n    reg [33:0] _RANDOM;\r\n    _RANDOM = {{`RANDOM}, {`RANDOM}}[33:0];", "code_snippet_01": "{`RANDOM}[1:0]"}, {"number": 2858, "title": "[InferResets] Fix inference for zero-length vectors", "created_at": "2022-04-07T06:06:57Z", "state": "closed", "labels": "bug, FIRRTL", "body": "When tracing resets through the design, the `InferResets` pass always uses the ID of the first vector element if it encounters a vector type. This is done to ensure that connections to an element of a vector affects the type inference of all the other elements too, since the pass can only pick a single reset type for the entire vector instead of individual types for each vector element.\r\n\r\nThis is problematic since it assumes that all vectors have at least one element, which may not be the case in practice. If such a vector is encountered, the field IDs get out of sync in weird ways if the vector is embedded in a bundle: when the bundle is asked to resolve a field ID to one of its fields, it treats the zero-length vector as actually having zero elements, such that forcibly asking for the first, non-existent element of that vector spills over into the next bundle field.\r\n\r\nThis commit changes the handling of vectors by always using the vector's self-referential field ID (i.e., the ID 0) to capture connections during reset tracing. Later in type updating, vectors correspondingly assume that a field ID 0 means that the vector element type is to be updated. This is not generally how field refs are supposed to work, but since the ID abuse is limited to this file we should be fine.\r\n\r\nFixes #2857."}, {"number": 2807, "title": "[FIRRTL] Infer type of mux with aggregate operands", "created_at": "2022-03-25T15:24:00Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Extend the type inference for the `MuxPrimOp` to also support operands with aggregate types. The multiplexer is expected to return a widthless type when the two operands are of an integer type but with unknown widths, and the larger of the two otherwise (e.g., `UInt` for `UInt, UInt<42>`). This inference only occurred for ground types and did not recurse into vectors and bundles. This commit changes the type inference to perform a pairwise inference on the leaves of arbitrarily nested aggregates.\r\n\r\nFixes #2806."}, {"number": 2806, "title": "[FIRRTL] Mux Result Type Inference Asserting Out", "created_at": "2022-03-25T06:15:46Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Consider the following circuit:\r\n```scala\r\ncircuit Foo :\r\n  module Foo :\r\n    input a: UInt<1>[1]\r\n    input b: UInt<32>[1]\r\n    input sel: UInt<1>\r\n    output c: UInt[1]\r\n\r\n    c <= mux(sel, a, b)\r\n```\r\n\r\nThis will currently cause MFC to error out with (`firtool Foo.fir`):\r\n```\r\n# firtool Foo.fir --verbose-pass-executions\r\nFoo.fir:8:10: error: unknown types to mux\r\n    c <= mux(sel, a, b)\r\n         ^\r\n```\r\n\r\nThe SFC will, however, compile this to:\r\n```verilog\r\nmodule Foo(\r\n  input         a_0,\r\n  input  [31:0] b_0,\r\n  input         sel,\r\n  output [31:0] c_0\r\n);\r\n  assign c_0 = sel ? {{31'd0}, a_0} : b_0;\r\nendmodule\r\n```\r\n\r\nI'm currently seeing a failure for an internal design where this error is produced after `InferResets` when using a specific annotation file.  However, I expect that a solution to the circuit above will fix the problem for the internal design.", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input a: UInt<1>[1]\r\n    input b: UInt<32>[1]\r\n    input sel: UInt<1>\r\n    output c: UInt[1]\r\n\r\n    c <= mux(sel, a, b)", "code_snippet_02": "# firtool Foo.fir --verbose-pass-executions\r\nFoo.fir:8:10: error: unknown types to mux\r\n    c <= mux(sel, a, b)\r\n         ^", "code_snippet_03": "module Foo(\r\n  input         a_0,\r\n  input  [31:0] b_0,\r\n  input         sel,\r\n  output [31:0] c_0\r\n);\r\n  assign c_0 = sel ? {{31'd0}, a_0} : b_0;\r\nendmodule"}, {"number": 2779, "title": "[FIRRTL] IMCP Issue with Register Reset", "created_at": "2022-03-17T03:24:47Z", "state": "closed", "labels": "bug, FIRRTL", "body": "IMCP is choosing to optimize a register with an invalidated reset to the reset value. This is causing a divergence with the Scala FIRRTL Compiler (SFC).\r\n\r\nConsider:\r\n\r\n```scala\r\ncircuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    output b: UInt<1>\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    bar.a is invalid\r\n    b <= bar.b\r\n    \r\n  module Bar :\r\n    input clock : Clock\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    reg r : UInt<1>, clock with: (reset => (a, UInt<1>(1)))\r\n    r is invalid\r\n\r\n    b <= r\r\n```\r\n\r\nCIRCT produces:\r\n\r\n```verilog\r\nmodule Foo(\t// Foo.fir:2:10\r\n  input  clock,\r\n  output b);\r\n\r\n  Bar bar ();\t// Foo.fir:6:5\r\n  assign b = 1'h1;\t// Foo.fir:2:10, :6:5\r\nendmodule\r\n```\r\n\r\nSFC produces:\r\n```verilog\r\nmodule Foo(\r\n  input   clock,\r\n  output  b\r\n);\r\n  assign b = 1'h0;\r\nendmodule\r\n```", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    output b: UInt<1>\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    bar.a is invalid\r\n    b <= bar.b\r\n    \r\n  module Bar :\r\n    input clock : Clock\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    reg r : UInt<1>, clock with: (reset => (a, UInt<1>(1)))\r\n    r is invalid\r\n\r\n    b <= r", "code_snippet_02": "module Foo(\t// Foo.fir:2:10\r\n  input  clock,\r\n  output b);\r\n\r\n  Bar bar ();\t// Foo.fir:6:5\r\n  assign b = 1'h1;\t// Foo.fir:2:10, :6:5\r\nendmodule", "code_snippet_03": "module Foo(\r\n  input   clock,\r\n  output  b\r\n);\r\n  assign b = 1'h0;\r\nendmodule"}, {"number": 2767, "title": "[FIRRTL] GCT Mem Taps + Dedup Producing Invalid XMRs", "created_at": "2022-03-15T02:07:20Z", "state": "closed", "labels": "bug, FIRRTL", "body": "There is a bug in FIRRTL Dialect's Grand Central Taps transform where memory taps of deduplicated modules can produce invalid XMRs.\r\n\r\nConsider the following:\r\n\r\n```scala\r\ncircuit Top : %[[\r\n  {\r\n    \"class\":\"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\":\"~Top|MemTap_1\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\":\"~Top|MemTap_2\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.MemTapAnnotation\",\r\n    \"taps\":[\r\n      \"Top.MemTap_1.mem[0]\"\r\n    ],\r\n    \"source\":\"~Top|Submodule_1>bar\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.MemTapAnnotation\",\r\n    \"taps\":[\r\n      \"Top.MemTap_2.mem[0]\"\r\n    ],\r\n    \"source\":\"~Top|Submodule_2>bar\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"builds/gct-taps/Simple/firrtl/gct\",\r\n    \"filename\":\"builds/gct-taps/Simple/firrtl/bindings.sv\"\r\n  }\r\n]]\r\n  module Submodule_1 :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output out: UInt<1>\r\n\r\n    cmem bar : UInt<1>[1]\r\n    infer mport out_MPORT = bar[UInt<1>(\"h0\")], clock\r\n    out <= out_MPORT\r\n\r\n  module Submodule_2 :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    cmem bar : UInt<1>[1]\r\n    infer mport out_MPORT = bar[UInt<1>(\"h0\")], clock\r\n    out <= out_MPORT\r\n\r\n  extmodule MemTap_1 :\r\n    output mem : UInt<1>[1]\r\n    defname = MemTap\r\n\r\n  extmodule MemTap_2 :\r\n    output mem : UInt<1>[1]\r\n    defname = MemTap\r\n\r\n  module DUT :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    inst submodule_1 of Submodule_1\r\n    submodule_1.clock <= clock\r\n    submodule_1.reset <= reset\r\n\r\n    inst submodule_2 of Submodule_2\r\n    submodule_2.clock <= clock\r\n    submodule_2.reset <= reset\r\n\r\n    out <= or(submodule_1.out, submodule_2.out)\r\n\r\n    inst mem_tap_MemTap_1 of MemTap_1\r\n    mem_tap_MemTap_1.mem is invalid\r\n\r\n    inst mem_tap_MemTap_2 of MemTap_2\r\n    mem_tap_MemTap_2.mem is invalid\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    inst dut of DUT\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    out <= dut.out\r\n```\r\n\r\nYou can compile this with into an output directory `gct-memtap`:\r\n\r\n```\r\nfirtool gct-taps/Simple/firrtl/Top.fir --firrtl-grand-central --split-verilog -o gct-memtap\r\n```\r\n\r\nThis can then be checked with Verilator using:\r\n\r\n```\r\nverilator -lint-only -f gct-memtap/filelist.f -Igct-memtap\r\n```\r\n\r\nWith dedup enabled, the XMRs for the memory taps are incorrect:\r\n\r\n```\r\n%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_2_impl_0.sv:4:22: Can't find definition of 'submodule_2' in dotted scope/variable: 'Top.submodule_2'\r\n    4 |   assign mem_0 = Top.submodule_2.bar.Memory[0];  \r\n      |                      ^~~~~~~~~~~\r\n        ... Known scopes under 'Top': dut\r\n%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_2_impl_0.sv:4:34: Can't find definition of 'bar' in dotted scope/variable: 'Top.bar'\r\n    4 |   assign mem_0 = Top.submodule_2.bar.Memory[0];  \r\n      |                                  ^~~\r\n        ... Known scopes under 'Top': dut\r\n%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_1_impl_0.sv:4:22: Can't find definition of 'submodule_1' in dotted scope/variable: 'Top.submodule_1'\r\n    4 |   assign mem_0 = Top.submodule_1.bar.Memory[0];  \r\n      |                      ^~~~~~~~~~~\r\n        ... Known scopes under 'Top': dut\r\n%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_1_impl_0.sv:4:34: Can't find definition of 'bar' in dotted scope/variable: 'Top.bar'\r\n    4 |   assign mem_0 = Top.submodule_1.bar.Memory[0];  \r\n      |                                  ^~~\r\n        ... Known scopes under 'Top': dut\r\n%Error: Exiting due to 4 error(s)\r\n```\r\n\r\nSpecifically, an invalid XMR is:\r\n\r\n```verilog\r\nassign mem_0 = Top.submodule_1.bar.Memory[0];\r\n```\r\n\r\nThe XMR should be:\r\n\r\n```verilog\r\nassign mem_0 = DUT.submodule_1.bar.Memory[0];\r\n```", "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\":\"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\":\"~Top|MemTap_1\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\":\"~Top|MemTap_2\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.MemTapAnnotation\",\r\n    \"taps\":[\r\n      \"Top.MemTap_1.mem[0]\"\r\n    ],\r\n    \"source\":\"~Top|Submodule_1>bar\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.MemTapAnnotation\",\r\n    \"taps\":[\r\n      \"Top.MemTap_2.mem[0]\"\r\n    ],\r\n    \"source\":\"~Top|Submodule_2>bar\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"builds/gct-taps/Simple/firrtl/gct\",\r\n    \"filename\":\"builds/gct-taps/Simple/firrtl/bindings.sv\"\r\n  }\r\n]]\r\n  module Submodule_1 :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output out: UInt<1>\r\n\r\n    cmem bar : UInt<1>[1]\r\n    infer mport out_MPORT = bar[UInt<1>(\"h0\")], clock\r\n    out <= out_MPORT\r\n\r\n  module Submodule_2 :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    cmem bar : UInt<1>[1]\r\n    infer mport out_MPORT = bar[UInt<1>(\"h0\")], clock\r\n    out <= out_MPORT\r\n\r\n  extmodule MemTap_1 :\r\n    output mem : UInt<1>[1]\r\n    defname = MemTap\r\n\r\n  extmodule MemTap_2 :\r\n    output mem : UInt<1>[1]\r\n    defname = MemTap\r\n\r\n  module DUT :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    inst submodule_1 of Submodule_1\r\n    submodule_1.clock <= clock\r\n    submodule_1.reset <= reset\r\n\r\n    inst submodule_2 of Submodule_2\r\n    submodule_2.clock <= clock\r\n    submodule_2.reset <= reset\r\n\r\n    out <= or(submodule_1.out, submodule_2.out)\r\n\r\n    inst mem_tap_MemTap_1 of MemTap_1\r\n    mem_tap_MemTap_1.mem is invalid\r\n\r\n    inst mem_tap_MemTap_2 of MemTap_2\r\n    mem_tap_MemTap_2.mem is invalid\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    inst dut of DUT\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    out <= dut.out", "code_snippet_02": "firtool gct-taps/Simple/firrtl/Top.fir --firrtl-grand-central --split-verilog -o gct-memtap", "code_snippet_03": "verilator -lint-only -f gct-memtap/filelist.f -Igct-memtap", "code_snippet_04": "%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_2_impl_0.sv:4:22: Can't find definition of 'submodule_2' in dotted scope/variable: 'Top.submodule_2'\r\n    4 |   assign mem_0 = Top.submodule_2.bar.Memory[0];  \r\n      |                      ^~~~~~~~~~~\r\n        ... Known scopes under 'Top': dut\r\n%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_2_impl_0.sv:4:34: Can't find definition of 'bar' in dotted scope/variable: 'Top.bar'\r\n    4 |   assign mem_0 = Top.submodule_2.bar.Memory[0];  \r\n      |                                  ^~~\r\n        ... Known scopes under 'Top': dut\r\n%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_1_impl_0.sv:4:22: Can't find definition of 'submodule_1' in dotted scope/variable: 'Top.submodule_1'\r\n    4 |   assign mem_0 = Top.submodule_1.bar.Memory[0];  \r\n      |                      ^~~~~~~~~~~\r\n        ... Known scopes under 'Top': dut\r\n%Error: gct-memtap/builds/gct-taps/Simple/firrtl/gct/MemTap_1_impl_0.sv:4:34: Can't find definition of 'bar' in dotted scope/variable: 'Top.bar'\r\n    4 |   assign mem_0 = Top.submodule_1.bar.Memory[0];  \r\n      |                                  ^~~\r\n        ... Known scopes under 'Top': dut\r\n%Error: Exiting due to 4 error(s)", "code_snippet_05": "assign mem_0 = Top.submodule_1.bar.Memory[0];", "code_snippet_06": "assign mem_0 = DUT.submodule_1.bar.Memory[0];"}, {"number": 2763, "title": "[FIRRTL][LowerTypes] Lower Types is Broken for Implicit Truncation", "created_at": "2022-03-14T15:44:18Z", "state": "closed", "labels": "bug, FIRRTL", "body": "CIRCT is currently incorrectly erroring out during `LowerTypes` for circuits that have bulk connects with implicit truncations.\r\n\r\nConsider the following:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    input a: {a: UInt<10>}\r\n    output b: {a: UInt<9>}\r\n\r\n    b <= a\r\n```\r\n\r\nThis current produces:\r\n```\r\n# firtool Foo.fir\r\nFoo.fir:6:7: error: destination width 9 is not greater than or equal to source width 10\r\n    b <= a\r\n      ^\r\nFoo.fir:6:7: note: see current operation: \"firrtl.connect\"(%arg1, %arg0) : (!firrtl.uint<9>, !firrtl.uint<10>) -> ()\r\n```\r\n\r\nWith the SFC, this happily accepts it:\r\n```\r\n# firrtl -i Foo.fir && cat Foo.v\r\nmodule Foo(\r\n  input  [9:0] a_a,\r\n  output [8:0] b_a\r\n);\r\n  assign b_a = a_a[8:0];\r\nendmodule\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input a: {a: UInt<10>}\r\n    output b: {a: UInt<9>}\r\n\r\n    b <= a", "code_snippet_02": "# firtool Foo.fir\r\nFoo.fir:6:7: error: destination width 9 is not greater than or equal to source width 10\r\n    b <= a\r\n      ^\r\nFoo.fir:6:7: note: see current operation: \"firrtl.connect\"(%arg1, %arg0) : (!firrtl.uint<9>, !firrtl.uint<10>) -> ()", "code_snippet_03": "# firrtl -i Foo.fir && cat Foo.v\r\nmodule Foo(\r\n  input  [9:0] a_a,\r\n  output [8:0] b_a\r\n);\r\n  assign b_a = a_a[8:0];\r\nendmodule"}, {"number": 2719, "title": "[FIRRTL] Dedup accesses bundle type out-of-bounds element", "created_at": "2022-03-03T14:29:18Z", "state": "closed", "labels": "bug, FIRRTL", "body": "I stumbled across the following bug today when I tried to reduce a test case for a different problem. Basically, when running the `module-externalizer` reduction, which tries to replace as many `firrtl.module` with `firrtl.extmodule` ops as possible, the dedup pass would start to trigger an assertion in `BundleType::getElementType`. I suspect this is somehow related to handling of extmodules, since regular modules didn't trigger the crash.\r\n\r\nHere's the reduced test case:\r\n```mlir\r\nfirrtl.circuit \"Foo\"  {\r\n  firrtl.extmodule @Bar(\r\n    in clock: !firrtl.clock, out io: !firrtl.bundle<a: clock>)\r\n  firrtl.extmodule @Baz(\r\n    in clock: !firrtl.clock, out io: !firrtl.bundle<a flip: uint<1>, b flip: uint<16>, c: uint<1>>)\r\n  firrtl.module @Foo() {\r\n    %invalid_ui16 = firrtl.invalidvalue : !firrtl.uint<16>\r\n    %bar_clock, %bar_io = firrtl.instance bar @Bar(\r\n      in clock: !firrtl.clock, out io: !firrtl.bundle<a: clock>)\r\n    %baz_clock, %baz_io = firrtl.instance baz @Baz(\r\n      in clock: !firrtl.clock, out io: !firrtl.bundle<a flip: uint<1>, b flip: uint<16>, c: uint<1>>)\r\n    %0 = firrtl.subfield %baz_io(1)\r\n      : (!firrtl.bundle<a flip: uint<1>, b flip: uint<16>, c: uint<1>>) -> !firrtl.uint<16>\r\n    firrtl.strictconnect %0, %invalid_ui16 : !firrtl.uint<16>\r\n  }\r\n}\r\n```\r\nRunning this through dedup produces the following on my machine:\r\n```\r\n# circt-opt --firrtl-dedup\r\ncirct-opt: FIRRTLTypes.cpp:843: circt::firrtl::FIRRTLType circt::firrtl::BundleType::getElementType(size_t):\r\nAssertion `index < getNumElements() && \"index must be less than number of fields in bundle\"' failed.\r\n[...]\r\nDeduper::fixupReferences(mlir::Value, mlir::Type) Dedup.cpp:387:59\r\nDeduper::fixupReferences(circt::firrtl::FModuleLike, mlir::Operation*) Dedup.cpp:449:25\r\nDeduper::dedup(circt::firrtl::FModuleLike, circt::firrtl::FModuleLike) Dedup.cpp:233:3\r\n```", "code_snippet_01": "firrtl.circuit \"Foo\"  {\r\n  firrtl.extmodule @Bar(\r\n    in clock: !firrtl.clock, out io: !firrtl.bundle<a: clock>)\r\n  firrtl.extmodule @Baz(\r\n    in clock: !firrtl.clock, out io: !firrtl.bundle<a flip: uint<1>, b flip: uint<16>, c: uint<1>>)\r\n  firrtl.module @Foo() {\r\n    %invalid_ui16 = firrtl.invalidvalue : !firrtl.uint<16>\r\n    %bar_clock, %bar_io = firrtl.instance bar @Bar(\r\n      in clock: !firrtl.clock, out io: !firrtl.bundle<a: clock>)\r\n    %baz_clock, %baz_io = firrtl.instance baz @Baz(\r\n      in clock: !firrtl.clock, out io: !firrtl.bundle<a flip: uint<1>, b flip: uint<16>, c: uint<1>>)\r\n    %0 = firrtl.subfield %baz_io(1)\r\n      : (!firrtl.bundle<a flip: uint<1>, b flip: uint<16>, c: uint<1>>) -> !firrtl.uint<16>\r\n    firrtl.strictconnect %0, %invalid_ui16 : !firrtl.uint<16>\r\n  }\r\n}", "code_snippet_02": "# circt-opt --firrtl-dedup\r\ncirct-opt: FIRRTLTypes.cpp:843: circt::firrtl::FIRRTLType circt::firrtl::BundleType::getElementType(size_t):\r\nAssertion `index < getNumElements() && \"index must be less than number of fields in bundle\"' failed.\r\n[...]\r\nDeduper::fixupReferences(mlir::Value, mlir::Type) Dedup.cpp:387:59\r\nDeduper::fixupReferences(circt::firrtl::FModuleLike, mlir::Operation*) Dedup.cpp:449:25\r\nDeduper::dedup(circt::firrtl::FModuleLike, circt::firrtl::FModuleLike) Dedup.cpp:233:3"}, {"number": 2718, "title": "[firtool] Preserve Val Names Broken for Analog", "created_at": "2022-03-02T23:42:19Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Chisel `val` name preservation, introduced in https://github.com/llvm/circt/pull/2676, has a bug where this will cause verification failures if there are analog types inside aggregates. \r\n\r\nConsider:\r\n```scala\r\ncircuit Foo :\r\n  module Foo :\r\n    input a: {flip a: UInt<1>, b: Analog<1>}\r\n    output b: {flip a: UInt<1>, b: Analog<1>}\r\n\r\n    wire w: {flip a: UInt<1>, b: Analog<1>}\r\n    w.a <= a.a\r\n\r\n    b.a <= w.a\r\n    attach(a.b, w.b, b.b)\r\n```\r\n\r\nWith `firtool Foo.fir` the verifier errors out:\r\n```\r\n# firtool Foo.fir\r\n./test.fir:6:5: error: analog types may not be connected\r\n    wire w: {flip a: UInt<1>, b: Analog<1>}\r\n    ^\r\n./test.fir:6:5: note: see current operation: \"firrtl.connect\"(%7, %4) : (!firrtl.bundle<a: uint<1>, b: analog<1>>, !firrtl.bundle<a flip: uint<1>, b: analog<1>>) -> ()\r\n```\r\n\r\nIf the wire's type is not passive (it has flips), then it needs to be a wire and then it will try to bulk connect the wire, and you can't connect analog. The parser should be modified to use `attach` for leaves that are analog.", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input a: {flip a: UInt<1>, b: Analog<1>}\r\n    output b: {flip a: UInt<1>, b: Analog<1>}\r\n\r\n    wire w: {flip a: UInt<1>, b: Analog<1>}\r\n    w.a <= a.a\r\n\r\n    b.a <= w.a\r\n    attach(a.b, w.b, b.b)", "code_snippet_02": "# firtool Foo.fir\r\n./test.fir:6:5: error: analog types may not be connected\r\n    wire w: {flip a: UInt<1>, b: Analog<1>}\r\n    ^\r\n./test.fir:6:5: note: see current operation: \"firrtl.connect\"(%7, %4) : (!firrtl.bundle<a: uint<1>, b: analog<1>>, !firrtl.bundle<a flip: uint<1>, b: analog<1>>) -> ()"}, {"number": 2713, "title": "[FIRRTL] Dedup makes port NLAs point at the module", "created_at": "2022-03-02T16:27:00Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Under certain circumstances, the deduplication pass changes NLAs pointing to a module port and makes them point at the surrounding module instead. After some `circt-reduce` and manual cleanup:\r\n```mlir\r\nfirrtl.circuit \"Foo\"  {\r\n  firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b1>, #hw.innerNameRef<@Bar_43::@out>]\r\n  firrtl.extmodule @Bar_42(out out: !firrtl.clock)\r\n  firrtl.extmodule @Bar_43(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_1}])\r\n  firrtl.module @Foo() {\r\n    %b0_out = firrtl.instance b0 @Bar_42(out out: !firrtl.clock)\r\n    %b1_out = firrtl.instance b1 sym @b1 \r\n      {annotations = [{circt.nonlocal = @nla_1, class = \"circt.nonlocal\"}]} @Bar_43(out out: !firrtl.clock)\r\n  }\r\n  // NLAs after `circt-opt --firrtl-dedup`:\r\n  // firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b1>, @Bar_42]\r\n}\r\n```\r\nNote how the last path segment of `@nla_1` changes from `#hw.innerNameRef<@Bar_43::@out>` to `@Bar_43`.\r\n\r\nThe behaviour seems to be limited to NLAs on modules that were dropped in favor of another, identical module. The following just defines three redundant modules with NLAs, and all but the first see this behaviour:\r\n```mlir\r\nfirrtl.circuit \"Foo\"  {\r\n  firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b0>, #hw.innerNameRef<@Bar_42::@out>]\r\n  firrtl.nla @nla_2 [#hw.innerNameRef<@Foo::@b1>, #hw.innerNameRef<@Bar_43::@out>]\r\n  firrtl.nla @nla_3 [#hw.innerNameRef<@Foo::@b2>, #hw.innerNameRef<@Bar_44::@out>]\r\n  firrtl.extmodule @Bar_42(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_1}])\r\n  firrtl.extmodule @Bar_43(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_2}])\r\n  firrtl.extmodule @Bar_44(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_3}])\r\n  firrtl.module @Foo() {\r\n    %b0_out = firrtl.instance b0 sym @b0\r\n      {annotations = [{circt.nonlocal = @nla_1, class = \"circt.nonlocal\"}]} @Bar_42(out out: !firrtl.clock)\r\n    %b1_out = firrtl.instance b1 sym @b1\r\n      {annotations = [{circt.nonlocal = @nla_2, class = \"circt.nonlocal\"}]} @Bar_43(out out: !firrtl.clock)\r\n    %b2_out = firrtl.instance b2 sym @b2\r\n      {annotations = [{circt.nonlocal = @nla_3, class = \"circt.nonlocal\"}]} @Bar_44(out out: !firrtl.clock)\r\n  }\r\n  // NLAs after `circt-opt --firrtl-dedup`:\r\n  // firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b0>, #hw.innerNameRef<@Bar_42::@out>]\r\n  // firrtl.nla @nla_2 [#hw.innerNameRef<@Foo::@b1>, @Bar_42]\r\n  // firrtl.nla @nla_3 [#hw.innerNameRef<@Foo::@b2>, @Bar_42]\r\n}\r\n```", "code_snippet_01": "firrtl.circuit \"Foo\"  {\r\n  firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b1>, #hw.innerNameRef<@Bar_43::@out>]\r\n  firrtl.extmodule @Bar_42(out out: !firrtl.clock)\r\n  firrtl.extmodule @Bar_43(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_1}])\r\n  firrtl.module @Foo() {\r\n    %b0_out = firrtl.instance b0 @Bar_42(out out: !firrtl.clock)\r\n    %b1_out = firrtl.instance b1 sym @b1 \r\n      {annotations = [{circt.nonlocal = @nla_1, class = \"circt.nonlocal\"}]} @Bar_43(out out: !firrtl.clock)\r\n  }\r\n  // NLAs after `circt-opt --firrtl-dedup`:\r\n  // firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b1>, @Bar_42]\r\n}", "code_snippet_02": "firrtl.circuit \"Foo\"  {\r\n  firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b0>, #hw.innerNameRef<@Bar_42::@out>]\r\n  firrtl.nla @nla_2 [#hw.innerNameRef<@Foo::@b1>, #hw.innerNameRef<@Bar_43::@out>]\r\n  firrtl.nla @nla_3 [#hw.innerNameRef<@Foo::@b2>, #hw.innerNameRef<@Bar_44::@out>]\r\n  firrtl.extmodule @Bar_42(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_1}])\r\n  firrtl.extmodule @Bar_43(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_2}])\r\n  firrtl.extmodule @Bar_44(out out: !firrtl.clock sym @out [{circt.nonlocal = @nla_3}])\r\n  firrtl.module @Foo() {\r\n    %b0_out = firrtl.instance b0 sym @b0\r\n      {annotations = [{circt.nonlocal = @nla_1, class = \"circt.nonlocal\"}]} @Bar_42(out out: !firrtl.clock)\r\n    %b1_out = firrtl.instance b1 sym @b1\r\n      {annotations = [{circt.nonlocal = @nla_2, class = \"circt.nonlocal\"}]} @Bar_43(out out: !firrtl.clock)\r\n    %b2_out = firrtl.instance b2 sym @b2\r\n      {annotations = [{circt.nonlocal = @nla_3, class = \"circt.nonlocal\"}]} @Bar_44(out out: !firrtl.clock)\r\n  }\r\n  // NLAs after `circt-opt --firrtl-dedup`:\r\n  // firrtl.nla @nla_1 [#hw.innerNameRef<@Foo::@b0>, #hw.innerNameRef<@Bar_42::@out>]\r\n  // firrtl.nla @nla_2 [#hw.innerNameRef<@Foo::@b1>, @Bar_42]\r\n  // firrtl.nla @nla_3 [#hw.innerNameRef<@Foo::@b2>, @Bar_42]\r\n}"}, {"number": 2693, "title": "[FIRRTLToHW] Consider strictconnect for elimination", "created_at": "2022-02-25T16:18:07Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The `LowerToHW` conversion uses the `tryEliminatingConnectsToValue` function to try and eliminate unnecessary connects to a value and replace all value uses with the connected value instead. This is used to avoid unnecessary `*.output` temporary wires when generating the `hw.output` lowering. That function only considers `ConnectOp` though, and any `StrictConnectOp` are left untouched. This commit extends the elimination to also consider `StrictConnectOp`, such that the lowered HW design contains fewer temporary wires."}, {"number": 2692, "title": "[FIRRTL] Honor NLAs in GCT data tap paths", "created_at": "2022-02-25T09:20:58Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The Grand Central data/mem taps pass used guess which concrete instance of a wire or port a data/mem tap referred to, because the taps were local annotations (i.e., they did not mention a concrete instance that they applied to). Since we now *do* have support for non-local annotations, and passes like deduplication make ample use of them, the GCT pass should consider the additional path information provided by NLAs when generating the data tap wiring. This commit makes GCT leverage the path information in NLAs.\r\n\r\nA concrete example would be a design with two instances:\r\n```\r\nmodule Top:\r\n  inst foo of Foo\r\n  inst bar of Foo\r\n```\r\nIf the instance port `foo.a` is targeted as a reference data tap, the GCT pass would up until now consider `Top.foo.a` and `Top.bar.a` as possible paths to that port, essentially ignoring the concrete instance path provided by the NLA `foo.a` and instead finding all possible prefixes for `Foo.a` (note the reference to Foo the module, not foo the instance.) The pass would then pick among all possible prefixes the shortest one (or in case of a tie, the last shortest one), which in this case could lead to the data tap targeting `Top.bar.a`, instead of the specified `Top.foo.a`.\r\n\r\nThe solution is to actually consider the concrete NLA instance path if one is given, and use that to perform the tapping. Arguably, *all* GCT data taps should be local annotations, which would also allow us to get rid of a lot of hacky logic in the GCT pass. That requires upstream changes in Chisel first, though.\r\n\r\nFixes #2691.", "code_snippet_01": "module Top:\r\n  inst foo of Foo\r\n  inst bar of Foo"}, {"number": 2688, "title": "[FIRRTL] HW Attributes not Loaded?", "created_at": "2022-02-25T02:38:03Z", "state": "closed", "labels": "bug, FIRRTL", "body": "When running `circt-opt` with a lone pass that creates a `hw::InnerRefAttr` I can get MLIR to crash because the HW attributes aren't loaded.  (This is the same circuit as #2687, but with the bug in #2687 worked around by renaming `%0` to `%a`)\r\n\r\n```mlir\r\nfirrtl.circuit \"Top\"  {\r\n  firrtl.module @Top() {\r\n    %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n    %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)\r\n  }\r\n  firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n    %a = firrtl.wire  {annotations = [{class = \"hello\"}]} : !firrtl.uint<1>\r\n    %b = firrtl.node sym @b %a  : !firrtl.uint<1>\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %x, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n  firrtl.module @A_(out %x: !firrtl.uint<1>) {\r\n    %a = firrtl.wire  : !firrtl.uint<1>\r\n    %b = firrtl.node sym @b %a  : !firrtl.uint<1>\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %x, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nThis then crashes when running `circt-opt --pass-pipeline='firrtl.circuit(firrtl-dedup)' dedup.mlir` with:\r\n\r\n```\r\nLLVM ERROR: can't create Attribute 'circt::hw::InnerRefAttr' because storage uniquer isn't initialized: the dialect was likely not loaded, or the attribute wasn't added with addAttributes<...>() in the Dialect::initialize() method.\r\n```", "code_snippet_01": "firrtl.circuit \"Top\"  {\r\n  firrtl.module @Top() {\r\n    %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n    %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)\r\n  }\r\n  firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n    %a = firrtl.wire  {annotations = [{class = \"hello\"}]} : !firrtl.uint<1>\r\n    %b = firrtl.node sym @b %a  : !firrtl.uint<1>\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %x, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n  firrtl.module @A_(out %x: !firrtl.uint<1>) {\r\n    %a = firrtl.wire  : !firrtl.uint<1>\r\n    %b = firrtl.node sym @b %a  : !firrtl.uint<1>\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %x, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_02": "LLVM ERROR: can't create Attribute 'circt::hw::InnerRefAttr' because storage uniquer isn't initialized: the dialect was likely not loaded, or the attribute wasn't added with addAttributes<...>() in the Dialect::initialize() method."}, {"number": 2687, "title": "[FIRRTL] Dedup Creating Empty Symbols?", "created_at": "2022-02-25T02:34:39Z", "state": "closed", "labels": "bug, FIRRTL", "body": "I think FIRRTL's dedup can inadvertently create empty symbols (which then crash during printing).  Consider the following circuit where `%0` in `@A` and `@A_` are going to be deduped.  This results in an NLA that gets generated with, I think, the symbol `@\"\"` which will be empty:\r\n\r\n```mlir\r\nfirrtl.circuit \"Top\"  {\r\n  firrtl.module @Top() {\r\n    %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n    %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)\r\n  }\r\n  firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n    %0 = firrtl.wire  {annotations = [{class = \"hello\"}]} : !firrtl.uint<1>\r\n    %b = firrtl.node sym @b %0  : !firrtl.uint<1>\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %0, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %x, %0 : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n  firrtl.module @A_(out %x: !firrtl.uint<1>) {\r\n    %0 = firrtl.wire  : !firrtl.uint<1>\r\n    %b = firrtl.node sym @b %0  : !firrtl.uint<1>\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %0, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %x, %0 : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nThe crash I'm seeing is:\r\n```\r\n# firtool dedup.mlir -ir-fir -dedup=1\r\nmodule {\r\n  firrtl.circuit \"Top\"  {\r\n    firrtl.nla @nla [#hw.innerNameRef<@Top::@a1>, Assertion failed: (!symbolRef.empty() && \"expected valid symbol reference\"), function printSymbolReference, file AsmPrinter.cpp, line 1626.\r\n```", "code_snippet_01": "firrtl.circuit \"Top\"  {\r\n  firrtl.module @Top() {\r\n    %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n    %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)\r\n  }\r\n  firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n    %0 = firrtl.wire  {annotations = [{class = \"hello\"}]} : !firrtl.uint<1>\r\n    %b = firrtl.node sym @b %0  : !firrtl.uint<1>\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %0, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %x, %0 : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n  firrtl.module @A_(out %x: !firrtl.uint<1>) {\r\n    %0 = firrtl.wire  : !firrtl.uint<1>\r\n    %b = firrtl.node sym @b %0  : !firrtl.uint<1>\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %0, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %x, %0 : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_02": "# firtool dedup.mlir -ir-fir -dedup=1\r\nmodule {\r\n  firrtl.circuit \"Top\"  {\r\n    firrtl.nla @nla [#hw.innerNameRef<@Top::@a1>, Assertion failed: (!symbolRef.empty() && \"expected valid symbol reference\"), function printSymbolReference, file AsmPrinter.cpp, line 1626."}, {"number": 2665, "title": "[FIRParser] Flip assert predicate before applying modifiers", "created_at": "2022-02-21T15:38:40Z", "state": "closed", "labels": "bug, FIRRTL", "body": "When parsing printf-encoded assertions, the condition of the surrounding `when` has to be inverted in order to go from the fail-when-true polarity of the printf to the fail-when-false polarity of the assert. Predicate modifiers (currently just `trueOrIsX`) are formulated with respect to the assertion predicate, i.e., on the fail-when-false polarity. So a `trueOrIsX` modifier is supposed to add an additional pass case to the assertion if the condition is `X`. The parser currently applies predicate modifiers on the fail-when-true polarity, which is wrong. Move the predicate inversion upwards so it occurs before modifiers are applied.\r\n\r\nFixes #2653."}, {"number": 2588, "title": "[ExportVerilog] [PrepareForEmission] Invalid wire creation with disallowLocalVariables option", "created_at": "2022-02-06T06:55:48Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```mlir\r\n// circt-opt -export-verilog %s\r\nmodule attributes {circt.loweringOptions = \"disallowLocalVariables,verifLabels,emittedLineLength=240\"} {\r\nhw.module @Foo(%r: i1, %f: i1) -> (foo: i1) {\r\n  %false = hw.constant false\r\n  %reg = sv.reg sym @__reg__  : !hw.inout<i1>\r\n  sv.initial {\r\n    %3 = sv.read_inout %1 : !hw.inout<i1>\r\n    %6 = comb.or %f, %3 : i1\r\n    sv.if %3 {\r\n      sv.passign %reg, %r : i1\r\n    }\r\n  }\r\n  %0 = sv.read_inout %reg : !hw.inout<i1>\r\n  %.io_writeVec.wire = sv.wire  : !hw.inout<array<1xi1>>\r\n  %1 = sv.array_index_inout %.io_writeVec.wire[%false] : !hw.inout<array<1xi1>>, i1\r\n  hw.output %0 : i1\r\n}\r\n}\r\n```\r\n\r\n```\r\n<unknown>:0: error: invalid element for hw.inout type '!hw.inout<i1>'\r\ncirct-opt: ../llvm/llvm/../mlir/include/mlir/IR/StorageUniquerSupport.h:140: static ConcreteT mlir::detail::StorageUserBase<circt::hw::InOutType, mlir::Type, circt::hw::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get(mlir::MLIRContext *, Args...) [ConcreteT = circt::hw::InOutType, BaseT = mlir::Type, StorageT = circt::hw::detail::InOutTypeStorage, UniquerT = mlir::detail::TypeUniquer, Traits = <>, Args = <mlir::Type>]: Assertion `succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ./bin/circt-opt -export-verilog ex.mlir\r\n #0 0x00000000005b2193 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/uenoku/dev/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:13\r\n #1 0x00000000005b02d0 llvm::sys::RunSignalHandlers() /home/uenoku/dev/circt/llvm/llvm/lib/Support/Signals.cpp:97:18\r\n #2 0x00000000005b27ca SignalHandler(int) /home/uenoku/dev/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #3 0x00007f4efc0901f0 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x141f0)\r\n #4 0x00007f4efbaeffbb raise ./signal/../sysdeps/unix/sysv/linux/raise.c:50:1\r\n #5 0x00007f4efbad5864 abort ./stdlib/abort.c:81:7\r\n #6 0x00007f4efbad5749 get_sysdep_segment_value ./intl/loadmsgcat.c:509:8\r\n #7 0x00007f4efbad5749 _nl_load_domain ./intl/loadmsgcat.c:970:34\r\n #8 0x00007f4efbae73d6 (/lib/x86_64-linux-gnu/libc.so.6+0x383d6)\r\n #9 0x00000000009bda70 mlir::detail::StorageUserBase<circt::hw::InOutType, mlir::Type, circt::hw::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::getImpl() const /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/StorageUniquerSupport.h:184:68\r\n#10 0x00000000009bda70 circt::hw::InOutType::getElementType() const /home/uenoku/dev/circt/build/tools/circt/include/circt/Dialect/HW/HWTypes.cpp.inc:172:10\r\n#11 0x0000000000a5a6c8 circt::sv::WireOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Type, mlir::StringAttr, mlir::StringAttr) /home/uenoku/dev/circt/lib/Dialect/SV/SVOps.cpp:1010:21\r\n#12 0x00000000006bd41a circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type>(mlir::Location, mlir::Type&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Builders.h:431:16\r\n#13 0x00000000006bbce7 lowerUsersToTemporaryWire(mlir::Operation&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/PrepareForEmission.cpp:229:28\r\n#14 0x00000000006bbce7 circt::ExportVerilog::prepareHWModule(mlir::Block&, circt::LoweringOptions const&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/PrepareForEmission.cpp:541:7\r\n#15 0x00000000006941ed mlir::LogicalResult mlir::failableParallelForEach<circt::hw::HWModuleOp*, void mlir::parallelForEach<circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71>(mlir::MLIRContext*, circt::hw::HWModuleOp*, circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&)::'lambda'(circt::hw::HWModuleOp*&&)>(mlir::MLIRContext*, circt::hw::HWModuleOp*, circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Threading.h:48:26\r\n#16 0x00000000006941ed void mlir::parallelForEach<circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71>(mlir::MLIRContext*, circt::hw::HWModuleOp*, circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Threading.h:124:9\r\n#17 0x00000000006941ed void mlir::parallelForEach<llvm::SmallVector<circt::hw::HWModuleOp, 6u>&, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71>(mlir::MLIRContext*, llvm::SmallVector<circt::hw::HWModuleOp, 6u>&, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Threading.h:136:3\r\n#18 0x00000000006941ed prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:4370:3\r\n```\r\n\r\nSeems prepareForEmission tries to create temporary wires for inout operations with out-of-order uses.", "code_snippet_01": "// circt-opt -export-verilog %s\r\nmodule attributes {circt.loweringOptions = \"disallowLocalVariables,verifLabels,emittedLineLength=240\"} {\r\nhw.module @Foo(%r: i1, %f: i1) -> (foo: i1) {\r\n  %false = hw.constant false\r\n  %reg = sv.reg sym @__reg__  : !hw.inout<i1>\r\n  sv.initial {\r\n    %3 = sv.read_inout %1 : !hw.inout<i1>\r\n    %6 = comb.or %f, %3 : i1\r\n    sv.if %3 {\r\n      sv.passign %reg, %r : i1\r\n    }\r\n  }\r\n  %0 = sv.read_inout %reg : !hw.inout<i1>\r\n  %.io_writeVec.wire = sv.wire  : !hw.inout<array<1xi1>>\r\n  %1 = sv.array_index_inout %.io_writeVec.wire[%false] : !hw.inout<array<1xi1>>, i1\r\n  hw.output %0 : i1\r\n}\r\n}", "code_snippet_02": "<unknown>:0: error: invalid element for hw.inout type '!hw.inout<i1>'\r\ncirct-opt: ../llvm/llvm/../mlir/include/mlir/IR/StorageUniquerSupport.h:140: static ConcreteT mlir::detail::StorageUserBase<circt::hw::InOutType, mlir::Type, circt::hw::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get(mlir::MLIRContext *, Args...) [ConcreteT = circt::hw::InOutType, BaseT = mlir::Type, StorageT = circt::hw::detail::InOutTypeStorage, UniquerT = mlir::detail::TypeUniquer, Traits = <>, Args = <mlir::Type>]: Assertion `succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ./bin/circt-opt -export-verilog ex.mlir\r\n #0 0x00000000005b2193 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/uenoku/dev/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:13\r\n #1 0x00000000005b02d0 llvm::sys::RunSignalHandlers() /home/uenoku/dev/circt/llvm/llvm/lib/Support/Signals.cpp:97:18\r\n #2 0x00000000005b27ca SignalHandler(int) /home/uenoku/dev/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #3 0x00007f4efc0901f0 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x141f0)\r\n #4 0x00007f4efbaeffbb raise ./signal/../sysdeps/unix/sysv/linux/raise.c:50:1\r\n #5 0x00007f4efbad5864 abort ./stdlib/abort.c:81:7\r\n #6 0x00007f4efbad5749 get_sysdep_segment_value ./intl/loadmsgcat.c:509:8\r\n #7 0x00007f4efbad5749 _nl_load_domain ./intl/loadmsgcat.c:970:34\r\n #8 0x00007f4efbae73d6 (/lib/x86_64-linux-gnu/libc.so.6+0x383d6)\r\n #9 0x00000000009bda70 mlir::detail::StorageUserBase<circt::hw::InOutType, mlir::Type, circt::hw::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::getImpl() const /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/StorageUniquerSupport.h:184:68\r\n#10 0x00000000009bda70 circt::hw::InOutType::getElementType() const /home/uenoku/dev/circt/build/tools/circt/include/circt/Dialect/HW/HWTypes.cpp.inc:172:10\r\n#11 0x0000000000a5a6c8 circt::sv::WireOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Type, mlir::StringAttr, mlir::StringAttr) /home/uenoku/dev/circt/lib/Dialect/SV/SVOps.cpp:1010:21\r\n#12 0x00000000006bd41a circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type>(mlir::Location, mlir::Type&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Builders.h:431:16\r\n#13 0x00000000006bbce7 lowerUsersToTemporaryWire(mlir::Operation&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/PrepareForEmission.cpp:229:28\r\n#14 0x00000000006bbce7 circt::ExportVerilog::prepareHWModule(mlir::Block&, circt::LoweringOptions const&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/PrepareForEmission.cpp:541:7\r\n#15 0x00000000006941ed mlir::LogicalResult mlir::failableParallelForEach<circt::hw::HWModuleOp*, void mlir::parallelForEach<circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71>(mlir::MLIRContext*, circt::hw::HWModuleOp*, circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&)::'lambda'(circt::hw::HWModuleOp*&&)>(mlir::MLIRContext*, circt::hw::HWModuleOp*, circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Threading.h:48:26\r\n#16 0x00000000006941ed void mlir::parallelForEach<circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71>(mlir::MLIRContext*, circt::hw::HWModuleOp*, circt::hw::HWModuleOp*, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Threading.h:124:9\r\n#17 0x00000000006941ed void mlir::parallelForEach<llvm::SmallVector<circt::hw::HWModuleOp, 6u>&, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71>(mlir::MLIRContext*, llvm::SmallVector<circt::hw::HWModuleOp, 6u>&, prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&)::$_71&&) /home/uenoku/dev/circt/build/../llvm/llvm/../mlir/include/mlir/IR/Threading.h:136:3\r\n#18 0x00000000006941ed prepareForEmission(mlir::ModuleOp, circt::LoweringOptions const&) /home/uenoku/dev/circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:4370:3"}, {"number": 2572, "title": "[FIRRTL] names get underscores in output", "created_at": "2022-02-02T19:10:36Z", "state": "closed", "labels": "bug", "body": "underscores prevent vcs from tracing things.  We shouldn't be adding underscores to user-specified names."}, {"number": 2570, "title": "[FIRRTL] Remove unused NLAs from OMIR", "created_at": "2022-02-02T17:41:51Z", "state": "closed", "labels": "bug", "body": "`EmitOMIR.cpp` was removing `circt.nonlocal` annotations but not deleting the `NonLocalAnchor` operations.\r\nThis commit adds the removed NLA reference to the list of NLAs that need to be removed.\r\nThe assumption here is that NLAs are not reused, that is there is only one client for each NLA.\r\nNot adding any lit test to check for this, since the NLA verifier should error out if we miss to remove the op."}, {"number": 2561, "title": "[Handshake] Integration tests broken recently.", "created_at": "2022-02-01T18:02:06Z", "state": "closed", "labels": "bug, Handshake", "body": "@mortbopet we don't test these in CI (requires a commercial simulator), but the Handshake integration tests are currently broken, probably by 5fc6ef49b78883890efa1798693d42546294bea4. The failure I'm seeing is:\r\n\r\n```\r\nerror: 'handshake.buffer' op result 0 has multiple uses.\r\n```\r\n\r\nBoth tests fail in this way. Let me know if you can see offhand why this fails, or else I'll take a look at it.", "code_snippet_01": "error: 'handshake.buffer' op result 0 has multiple uses."}, {"number": 2546, "title": "[FIRRTL] Missed Combinational Loop Detection", "created_at": "2022-02-01T01:13:04Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following circuit should trip combinational loop checking, but does not:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    output b: UInt<1>\r\n\r\n    b <= not(b)\r\n```\r\n\r\nThis gets into HW dialect and crashes on malformed IR of a unary `xor`. \ud83d\udc40 \r\n\r\n```\r\n%0 = comb.xor %0 : i1\r\n```\r\n\r\n```\r\nAssertion failed: (size > 1 && \"expected 2 or more operands\"), function canonicalize, file CombFolds.cpp, line 1228.\r\nProcess 65409 stopped\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = hit program assert\r\n    frame #4: 0x0000000100be2fe6 firtool`circt::comb::XorOp::canonicalize(op=XorOp @ 0x00007ff7bfefd388, rewriter=0x00007ff7bfefdcc0) at CombFolds.cpp:1228:3\r\n   1225\tLogicalResult XorOp::canonicalize(XorOp op, PatternRewriter &rewriter) {\r\n   1226\t  auto inputs = op.inputs();\r\n   1227\t  auto size = inputs.size();\r\n-> 1228\t  assert(size > 1 && \"expected 2 or more operands\");\r\n   1229\t\r\n   1230\t  // xor(..., x, x) -> xor (...) -- idempotent\r\n   1231\t  if (inputs[size - 1] == inputs[size - 2]) {\r\n```\r\n\r\nI expect the problem is the read of an output port is not being checked for combinational loops.", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    output b: UInt<1>\r\n\r\n    b <= not(b)", "code_snippet_02": "%0 = comb.xor %0 : i1", "code_snippet_03": "Assertion failed: (size > 1 && \"expected 2 or more operands\"), function canonicalize, file CombFolds.cpp, line 1228.\r\nProcess 65409 stopped\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = hit program assert\r\n    frame #4: 0x0000000100be2fe6 firtool`circt::comb::XorOp::canonicalize(op=XorOp @ 0x00007ff7bfefd388, rewriter=0x00007ff7bfefdcc0) at CombFolds.cpp:1228:3\r\n   1225\tLogicalResult XorOp::canonicalize(XorOp op, PatternRewriter &rewriter) {\r\n   1226\t  auto inputs = op.inputs();\r\n   1227\t  auto size = inputs.size();\r\n-> 1228\t  assert(size > 1 && \"expected 2 or more operands\");\r\n   1229\t\r\n   1230\t  // xor(..., x, x) -> xor (...) -- idempotent\r\n   1231\t  if (inputs[size - 1] == inputs[size - 2]) {"}, {"number": 2531, "title": "[FIRRTL] DontTouchAnnotation as Symbol and Deduplication", "created_at": "2022-01-27T21:03:37Z", "state": "open", "labels": "bug, FIRRTL", "body": "The modeling of `DontTouchAnnotation` as a symbol destroys some information that may be necessary for an SFC-exact implementation of deduplication.\r\n\r\nConsider the following circuit. Modules `A` and `A_` are structurally equivalent and should deduplicate. `A` has a `DontTouchAnnotation` on a wire inside it. This is not supposed to block deduplication.\r\n\r\n```scala\r\ncircuit Top : %[[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"Top.A.b\"\r\n  }\r\n]]\r\n  module Top :\r\n    inst a1 of A\r\n    inst a2 of A_\r\n  module A :\r\n    output x: UInt<1>\r\n    wire b: UInt<1>\r\n    b is invalid\r\n    x <= b\r\n  module A_ :\r\n    output x: UInt<1>\r\n    wire b: UInt<1>\r\n    b is invalid\r\n    x <= b\r\n```\r\n\r\nWhen we parse this in, this specific annotations becomes a symbol `@b`:\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Top\"   {\r\n    firrtl.module @Top() {\r\n      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n      %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)\r\n    }\r\n    firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n      %b = firrtl.wire sym @b  : !firrtl.uint<1>\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n    firrtl.module @A_(out %x: !firrtl.uint<1>) {\r\n      %b = firrtl.wire  : !firrtl.uint<1>\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAfter deduplication, the circuit looks like with `@b` applied to the deduplicated wire. The effect of the annotation now applies to both wires:\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Top\"   {\r\n    firrtl.module @Top() {\r\n      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n      %a2_x = firrtl.instance a2  @A(out x: !firrtl.uint<1>)\r\n    }\r\n    firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      %b = firrtl.wire sym @b  : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nIn contrast, the SFC produces a non-local annotation targeting the original instance's wire:\r\n```scala\r\ncircuit Top :\r\n  module A :\r\n    output x : UInt<1>\r\n\r\n    wire b : UInt<1> @[dont-touch.scala 33:15]\r\n    b is invalid @[dont-touch.scala 34:5]\r\n    x <= b @[dont-touch.scala 36:5]\r\n\r\n  module Top :\r\n\r\n    inst a1 of A @[dont-touch.scala 47:18]\r\n    inst a2 of A @[dont-touch.scala 48:18]\r\n```\r\n```json\r\n[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top/a1:A>b\"\r\n  }\r\n]\r\n```\r\n\r\nI don't have an opinion or evidence that this is problematic, yet. This is just reporting an SFC deviation.", "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"Top.A.b\"\r\n  }\r\n]]\r\n  module Top :\r\n    inst a1 of A\r\n    inst a2 of A_\r\n  module A :\r\n    output x: UInt<1>\r\n    wire b: UInt<1>\r\n    b is invalid\r\n    x <= b\r\n  module A_ :\r\n    output x: UInt<1>\r\n    wire b: UInt<1>\r\n    b is invalid\r\n    x <= b", "code_snippet_02": "module  {\r\n  firrtl.circuit \"Top\"   {\r\n    firrtl.module @Top() {\r\n      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n      %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)\r\n    }\r\n    firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n      %b = firrtl.wire sym @b  : !firrtl.uint<1>\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n    firrtl.module @A_(out %x: !firrtl.uint<1>) {\r\n      %b = firrtl.wire  : !firrtl.uint<1>\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_03": "module  {\r\n  firrtl.circuit \"Top\"   {\r\n    firrtl.module @Top() {\r\n      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n      %a2_x = firrtl.instance a2  @A(out x: !firrtl.uint<1>)\r\n    }\r\n    firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      %b = firrtl.wire sym @b  : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_04": "circuit Top :\r\n  module A :\r\n    output x : UInt<1>\r\n\r\n    wire b : UInt<1> @[dont-touch.scala 33:15]\r\n    b is invalid @[dont-touch.scala 34:5]\r\n    x <= b @[dont-touch.scala 36:5]\r\n\r\n  module Top :\r\n\r\n    inst a1 of A @[dont-touch.scala 47:18]\r\n    inst a2 of A @[dont-touch.scala 48:18]", "code_snippet_05": "[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top/a1:A>b\"\r\n  }\r\n]"}, {"number": 2516, "title": "[FIRRTL] (mem) mismatch", "created_at": "2022-01-25T05:27:32Z", "state": "open", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 6243\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock0: Clock\r\n    input raddr: UInt<10>\r\n    input waddr: UInt<10>\r\n    input wdata: UInt<20>\r\n    output tmp54: UInt<20>\r\n    mem tmp53:\r\n      data-type => UInt<20>\r\n      depth => 10\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp53.r0.clk <= clock0\r\n    tmp53.r0.en <= UInt(0)\r\n    tmp53.r0.addr <= waddr\r\n    tmp53.w0.clk <= clock0\r\n    tmp53.w0.en <= UInt(1)\r\n    tmp53.w0.addr <= raddr\r\n    tmp53.w0.data <= wdata\r\n    tmp53.w0.mask <= UInt(1)\r\n    tmp54 <= tmp53.r0.data\r\n```\r\n\r\nCompiled with firtool --lower-to-hw --infer-widths --imconstprop --lowering-options=disallowPackedArrays,emittedLineLength=8192 --mlir-timing --verilog -o=$VFILE2 produces this Verilog:\r\n\r\n```verilog\r\nmodule tmp53_ext(\t// a_top_mod.fir:9:5\r\n  input  [3:0]  R0_addr,\r\n  input         R0_en, R0_clk,\r\n  input  [3:0]  W0_addr,\r\n  input         W0_en, W0_clk,\r\n  input  [19:0] W0_data,\r\n  input         W0_mask,\r\n  output [19:0] R0_data);\r\n\r\n  reg [19:0] Memory[0:9];\r\n\r\n  wire _T = W0_en & W0_mask;\r\n  always @(posedge W0_clk) begin\r\n    if (_T)\r\n      Memory[W0_addr] <= W0_data;\r\n  end // always @(posedge)\r\n  assign R0_data = R0_en ? Memory[R0_addr] : 20'bx;\t// a_top_mod.fir:9:5\r\nendmodule\r\n\r\nmodule top_mod(\t// a_top_mod.fir:3:10\r\n  input         clock0,\r\n  input  [9:0]  raddr, waddr,\r\n  input  [19:0] wdata,\r\n  output [19:0] tmp54);\r\n\r\n  tmp53_ext tmp53 (\t// a_top_mod.fir:9:5\r\n    .R0_addr (waddr[3:0]),\t// a_top_mod.fir:19:19\r\n    .R0_en   (1'h0),\t// a_top_mod.fir:18:20\r\n    .R0_clk  (clock0),\r\n    .W0_addr (raddr[3:0]),\t// a_top_mod.fir:22:19\r\n    .W0_en   (1'h1),\t// a_top_mod.fir:21:20\r\n    .W0_clk  (clock0),\r\n    .W0_data (wdata),\r\n    .W0_mask (1'h1),\t// a_top_mod.fir:21:20\r\n    .R0_data (tmp54)\r\n  );\r\nendmodule\r\n```\r\n\r\nCompiled with firrtl-1.5-SNAPSHOT produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input         clock0,\r\n  input  [9:0]  raddr,\r\n  input  [9:0]  waddr,\r\n  input  [19:0] wdata,\r\n  output [19:0] tmp54\r\n);\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n  reg [31:0] _RAND_1;\r\n`endif // RANDOMIZE_GARBAGE_ASSIGN\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  reg [31:0] _RAND_0;\r\n`endif // RANDOMIZE_MEM_INIT\r\n  reg [19:0] tmp53 [0:9];\r\n  wire  tmp53_r0_en;\r\n  wire [3:0] tmp53_r0_addr;\r\n  wire [19:0] tmp53_r0_data;\r\n  wire [19:0] tmp53_w0_data;\r\n  wire [3:0] tmp53_w0_addr;\r\n  wire  tmp53_w0_mask;\r\n  wire  tmp53_w0_en;\r\n  assign tmp53_r0_en = 1'h0;\r\n  assign tmp53_r0_addr = waddr[3:0];\r\n  `ifndef RANDOMIZE_GARBAGE_ASSIGN\r\n  assign tmp53_r0_data = tmp53[tmp53_r0_addr];\r\n  `else\r\n  assign tmp53_r0_data = tmp53_r0_addr >= 4'ha ? _RAND_1[19:0] : tmp53[tmp53_r0_addr];\r\n  `endif // RANDOMIZE_GARBAGE_ASSIGN\r\n  assign tmp53_w0_data = wdata;\r\n  assign tmp53_w0_addr = raddr[3:0];\r\n  assign tmp53_w0_mask = 1'h1;\r\n  assign tmp53_w0_en = 1'h1;\r\n  assign tmp54 = tmp53_r0_data;\r\n  always @(posedge clock0) begin\r\n    if (tmp53_w0_en & tmp53_w0_mask) begin\r\n      tmp53[tmp53_w0_addr] <= tmp53_w0_data;\r\n    end\r\n  end\r\n// Register and memory initialization\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_INVALID_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_REG_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifndef RANDOM\r\n`define RANDOM $random\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  integer initvar;\r\n`endif\r\n`ifndef SYNTHESIS\r\n`ifdef FIRRTL_BEFORE_INITIAL\r\n`FIRRTL_BEFORE_INITIAL\r\n`endif\r\ninitial begin\r\n  `ifdef RANDOMIZE\r\n    `ifdef INIT_RANDOM\r\n      `INIT_RANDOM\r\n    `endif\r\n    `ifndef VERILATOR\r\n      `ifdef RANDOMIZE_DELAY\r\n        #`RANDOMIZE_DELAY begin end\r\n      `else\r\n        #0.002 begin end\r\n      `endif\r\n    `endif\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n  _RAND_1 = {1{`RANDOM}};\r\n`endif // RANDOMIZE_GARBAGE_ASSIGN\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  _RAND_0 = {1{`RANDOM}};\r\n  for (initvar = 0; initvar < 10; initvar = initvar+1)\r\n    tmp53[initvar] = _RAND_0[19:0];\r\n`endif // RANDOMIZE_MEM_INIT\r\n  `endif // RANDOMIZE\r\nend // initial\r\n`ifdef FIRRTL_AFTER_INITIAL\r\n`FIRRTL_AFTER_INITIAL\r\n`endif\r\n`endif // SYNTHESIS\r\nendmodule\r\n```\r\n`Yosys 0.13+15 (git sha1 bc027b2ca, clang 13.0.0 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nERROR: Found 20 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "; seed: 6243\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock0: Clock\r\n    input raddr: UInt<10>\r\n    input waddr: UInt<10>\r\n    input wdata: UInt<20>\r\n    output tmp54: UInt<20>\r\n    mem tmp53:\r\n      data-type => UInt<20>\r\n      depth => 10\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp53.r0.clk <= clock0\r\n    tmp53.r0.en <= UInt(0)\r\n    tmp53.r0.addr <= waddr\r\n    tmp53.w0.clk <= clock0\r\n    tmp53.w0.en <= UInt(1)\r\n    tmp53.w0.addr <= raddr\r\n    tmp53.w0.data <= wdata\r\n    tmp53.w0.mask <= UInt(1)\r\n    tmp54 <= tmp53.r0.data", "code_snippet_02": "module tmp53_ext(\t// a_top_mod.fir:9:5\r\n  input  [3:0]  R0_addr,\r\n  input         R0_en, R0_clk,\r\n  input  [3:0]  W0_addr,\r\n  input         W0_en, W0_clk,\r\n  input  [19:0] W0_data,\r\n  input         W0_mask,\r\n  output [19:0] R0_data);\r\n\r\n  reg [19:0] Memory[0:9];\r\n\r\n  wire _T = W0_en & W0_mask;\r\n  always @(posedge W0_clk) begin\r\n    if (_T)\r\n      Memory[W0_addr] <= W0_data;\r\n  end // always @(posedge)\r\n  assign R0_data = R0_en ? Memory[R0_addr] : 20'bx;\t// a_top_mod.fir:9:5\r\nendmodule\r\n\r\nmodule top_mod(\t// a_top_mod.fir:3:10\r\n  input         clock0,\r\n  input  [9:0]  raddr, waddr,\r\n  input  [19:0] wdata,\r\n  output [19:0] tmp54);\r\n\r\n  tmp53_ext tmp53 (\t// a_top_mod.fir:9:5\r\n    .R0_addr (waddr[3:0]),\t// a_top_mod.fir:19:19\r\n    .R0_en   (1'h0),\t// a_top_mod.fir:18:20\r\n    .R0_clk  (clock0),\r\n    .W0_addr (raddr[3:0]),\t// a_top_mod.fir:22:19\r\n    .W0_en   (1'h1),\t// a_top_mod.fir:21:20\r\n    .W0_clk  (clock0),\r\n    .W0_data (wdata),\r\n    .W0_mask (1'h1),\t// a_top_mod.fir:21:20\r\n    .R0_data (tmp54)\r\n  );\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input         clock0,\r\n  input  [9:0]  raddr,\r\n  input  [9:0]  waddr,\r\n  input  [19:0] wdata,\r\n  output [19:0] tmp54\r\n);\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n  reg [31:0] _RAND_1;\r\n`endif // RANDOMIZE_GARBAGE_ASSIGN\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  reg [31:0] _RAND_0;\r\n`endif // RANDOMIZE_MEM_INIT\r\n  reg [19:0] tmp53 [0:9];\r\n  wire  tmp53_r0_en;\r\n  wire [3:0] tmp53_r0_addr;\r\n  wire [19:0] tmp53_r0_data;\r\n  wire [19:0] tmp53_w0_data;\r\n  wire [3:0] tmp53_w0_addr;\r\n  wire  tmp53_w0_mask;\r\n  wire  tmp53_w0_en;\r\n  assign tmp53_r0_en = 1'h0;\r\n  assign tmp53_r0_addr = waddr[3:0];\r\n  `ifndef RANDOMIZE_GARBAGE_ASSIGN\r\n  assign tmp53_r0_data = tmp53[tmp53_r0_addr];\r\n  `else\r\n  assign tmp53_r0_data = tmp53_r0_addr >= 4'ha ? _RAND_1[19:0] : tmp53[tmp53_r0_addr];\r\n  `endif // RANDOMIZE_GARBAGE_ASSIGN\r\n  assign tmp53_w0_data = wdata;\r\n  assign tmp53_w0_addr = raddr[3:0];\r\n  assign tmp53_w0_mask = 1'h1;\r\n  assign tmp53_w0_en = 1'h1;\r\n  assign tmp54 = tmp53_r0_data;\r\n  always @(posedge clock0) begin\r\n    if (tmp53_w0_en & tmp53_w0_mask) begin\r\n      tmp53[tmp53_w0_addr] <= tmp53_w0_data;\r\n    end\r\n  end\r\n// Register and memory initialization\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_INVALID_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_REG_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifndef RANDOM\r\n`define RANDOM $random\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  integer initvar;\r\n`endif\r\n`ifndef SYNTHESIS\r\n`ifdef FIRRTL_BEFORE_INITIAL\r\n`FIRRTL_BEFORE_INITIAL\r\n`endif\r\ninitial begin\r\n  `ifdef RANDOMIZE\r\n    `ifdef INIT_RANDOM\r\n      `INIT_RANDOM\r\n    `endif\r\n    `ifndef VERILATOR\r\n      `ifdef RANDOMIZE_DELAY\r\n        #`RANDOMIZE_DELAY begin end\r\n      `else\r\n        #0.002 begin end\r\n      `endif\r\n    `endif\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n  _RAND_1 = {1{`RANDOM}};\r\n`endif // RANDOMIZE_GARBAGE_ASSIGN\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  _RAND_0 = {1{`RANDOM}};\r\n  for (initvar = 0; initvar < 10; initvar = initvar+1)\r\n    tmp53[initvar] = _RAND_0[19:0];\r\n`endif // RANDOMIZE_MEM_INIT\r\n  `endif // RANDOMIZE\r\nend // initial\r\n`ifdef FIRRTL_AFTER_INITIAL\r\n`FIRRTL_AFTER_INITIAL\r\n`endif\r\n`endif // SYNTHESIS\r\nendmodule", "code_snippet_04": "ERROR: Found 20 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 2514, "title": "[FIRRTL] (core dump) leq,SInt<0>", "created_at": "2022-01-24T23:38:13Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Running following fir file\r\n\r\n```python\r\n; seed: 3339\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock1: Clock\r\n    input inp_a: {inp_c: SInt<0>, inp_f: {inp_g: {inp_j: SInt<0>}}, inp_h: {inp_k: UInt<15>}}\r\n    reg tmp23: UInt, clock1\r\n    tmp23 <= head(UInt<1>(\"b1\"), 0)\r\n    node _tmp26 = leq(inp_a.inp_f.inp_g.inp_j, asSInt(tmp23))\r\n```\r\n\r\nwith:\r\n\r\n`firtool a_top_mod.fir --lowering-options=disallowPackedArrays,noAlwaysComb,disallowLocalVariables --verilog -o=a_top_mod.fir.mfc.v` \r\n\r\nI am getting this error:\r\n```\r\nfirtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:284: int llvm::APInt::compareSigned(const llvm::APInt&) const: Assertion `BitWidth == RHS.BitWidth && \"Bit widths must be same for comparison\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --verilog --lowering-options=disallowPackedArrays,noAlwaysComb,disallowLocalVariables -o=a_top_mod.fir.mfc.v\r\n #0 0x000000000045c441 PrintStackTraceSignalHandler(void*) Signals.cpp:0:0\r\n #1 0x0000000000459d0e SignalHandler(int) Signals.cpp:0:0\r\n #2 0x00007f3fc26d1420 __restore_rt (/lib64/libc.so.6+0x56420)\r\n #3 0x00007f3fc272124c __pthread_kill_implementation (/lib64/libc.so.6+0xa624c)\r\n #4 0x00007f3fc26d1356 gsignal (/lib64/libc.so.6+0x56356)\r\n #5 0x00007f3fc26ba7d3 abort (/lib64/libc.so.6+0x3f7d3)\r\n #6 0x00007f3fc26ba6eb _nl_load_domain.cold (/lib64/libc.so.6+0x3f6eb)\r\n #7 0x00007f3fc26c9946 (/lib64/libc.so.6+0x4e946)\r\n #8 0x000000000046733f llvm::APInt::compareSigned(llvm::APInt const&) const (../../llvm/circt/build/bin/firtool+0x46733f)\r\n #9 0x000000000075dc59 circt::firrtl::LEQPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) (../../llvm/circt/build/bin/firtool+0x75dc59)\r\n#10 0x000000000073d2d3 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&>::CallImpl<std::enable_if<(llvm::disjunction<std::is_same<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp>, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::ZeroSuccessor<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::NOperands<2u>::Impl<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, circt::firrtl::SameOperandsIntTypeKind<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::InferTypeOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::MemoryEffectOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > > >::value) && (llvm::detail::detector<void, mlir::Op<circt::firrtl::LEQPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, circt::firrtl::SameOperandsIntTypeKind, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::has_single_result_fold, mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >::value_t::value), llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const> >::type mlir::Op<circt::firrtl::LEQPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, circt::firrtl::SameOperandsIntTypeKind, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::getFoldHookFnImpl<circt::firrtl::LEQPrimOp>()::'lambda'(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>(void*, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) (../../llvm/circt/build/bin/firtool+0x73d2d3)\r\n#11 0x00000000006ec4ba mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) (../../llvm/circt/build/bin/firtool+0x6ec4ba)\r\n#12 0x000000000086a519 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) (../../llvm/circt/build/bin/firtool+0x86a519)\r\n#13 0x000000000086b8a3 mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) (../../llvm/circt/build/bin/firtool+0x86b8a3)\r\n#14 0x00000000008562b9 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) (.constprop.0) GreedyPatternRewriteDriver.cpp:0:0\r\n#15 0x000000000085842a mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) (../../llvm/circt/build/bin/firtool+0x85842a)\r\n#16 0x0000000000908846 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x908846)\r\n#17 0x0000000000908dd8 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x908dd8)\r\n#18 0x00000000009072ce mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x9072ce)\r\n#19 0x00000000009088cf mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x9088cf)\r\n#20 0x0000000000908dd8 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x908dd8)\r\n#21 0x00000000009072ce mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x9072ce)\r\n#22 0x00000000009088cf mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x9088cf)\r\n#23 0x0000000000908dd8 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x908dd8)\r\n#24 0x000000000090a42b mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x90a42b)\r\n#25 0x000000000040d8e1 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) firtool.cpp:0:0\r\n#26 0x000000000040e874 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) firtool.cpp:0:0\r\n#27 0x0000000000409aa1 main (../../llvm/circt/build/bin/firtool+0x409aa1)\r\n#28 0x00007f3fc26bb5c0 __libc_start_call_main (/lib64/libc.so.6+0x405c0)\r\n#29 0x00007f3fc26bb67c __libc_start_main@GLIBC_2.2.5 (/lib64/libc.so.6+0x4067c)\r\n#30 0x0000000000409e25 _start /home/abuild/rpmbuild/BUILD/glibc-2.34/csu/../sysdeps/x86_64/start.S:118:0\r\n```\r\n", "code_snippet_01": "; seed: 3339\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock1: Clock\r\n    input inp_a: {inp_c: SInt<0>, inp_f: {inp_g: {inp_j: SInt<0>}}, inp_h: {inp_k: UInt<15>}}\r\n    reg tmp23: UInt, clock1\r\n    tmp23 <= head(UInt<1>(\"b1\"), 0)\r\n    node _tmp26 = leq(inp_a.inp_f.inp_g.inp_j, asSInt(tmp23))", "code_snippet_02": "firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:284: int llvm::APInt::compareSigned(const llvm::APInt&) const: Assertion `BitWidth == RHS.BitWidth && \"Bit widths must be same for comparison\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --verilog --lowering-options=disallowPackedArrays,noAlwaysComb,disallowLocalVariables -o=a_top_mod.fir.mfc.v\r\n #0 0x000000000045c441 PrintStackTraceSignalHandler(void*) Signals.cpp:0:0\r\n #1 0x0000000000459d0e SignalHandler(int) Signals.cpp:0:0\r\n #2 0x00007f3fc26d1420 __restore_rt (/lib64/libc.so.6+0x56420)\r\n #3 0x00007f3fc272124c __pthread_kill_implementation (/lib64/libc.so.6+0xa624c)\r\n #4 0x00007f3fc26d1356 gsignal (/lib64/libc.so.6+0x56356)\r\n #5 0x00007f3fc26ba7d3 abort (/lib64/libc.so.6+0x3f7d3)\r\n #6 0x00007f3fc26ba6eb _nl_load_domain.cold (/lib64/libc.so.6+0x3f6eb)\r\n #7 0x00007f3fc26c9946 (/lib64/libc.so.6+0x4e946)\r\n #8 0x000000000046733f llvm::APInt::compareSigned(llvm::APInt const&) const (../../llvm/circt/build/bin/firtool+0x46733f)\r\n #9 0x000000000075dc59 circt::firrtl::LEQPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) (../../llvm/circt/build/bin/firtool+0x75dc59)\r\n#10 0x000000000073d2d3 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&>::CallImpl<std::enable_if<(llvm::disjunction<std::is_same<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp>, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::ZeroSuccessor<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::OpTrait::NOperands<2u>::Impl<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, circt::firrtl::SameOperandsIntTypeKind<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::InferTypeOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > >, circt::firrtl::LEQPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >, mlir::MemoryEffectOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> > > >::value) && (llvm::detail::detector<void, mlir::Op<circt::firrtl::LEQPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, circt::firrtl::SameOperandsIntTypeKind, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::has_single_result_fold, mlir::OpTrait::OneResult<circt::firrtl::LEQPrimOp> >::value_t::value), llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const> >::type mlir::Op<circt::firrtl::LEQPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, circt::firrtl::SameOperandsIntTypeKind, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::getFoldHookFnImpl<circt::firrtl::LEQPrimOp>()::'lambda'(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>(void*, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) (../../llvm/circt/build/bin/firtool+0x73d2d3)\r\n#11 0x00000000006ec4ba mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) (../../llvm/circt/build/bin/firtool+0x6ec4ba)\r\n#12 0x000000000086a519 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) (../../llvm/circt/build/bin/firtool+0x86a519)\r\n#13 0x000000000086b8a3 mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) (../../llvm/circt/build/bin/firtool+0x86b8a3)\r\n#14 0x00000000008562b9 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>) (.constprop.0) GreedyPatternRewriteDriver.cpp:0:0\r\n#15 0x000000000085842a mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) (../../llvm/circt/build/bin/firtool+0x85842a)\r\n#16 0x0000000000908846 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x908846)\r\n#17 0x0000000000908dd8 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x908dd8)\r\n#18 0x00000000009072ce mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x9072ce)\r\n#19 0x00000000009088cf mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x9088cf)\r\n#20 0x0000000000908dd8 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x908dd8)\r\n#21 0x00000000009072ce mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x9072ce)\r\n#22 0x00000000009088cf mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x9088cf)\r\n#23 0x0000000000908dd8 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x908dd8)\r\n#24 0x000000000090a42b mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x90a42b)\r\n#25 0x000000000040d8e1 processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) firtool.cpp:0:0\r\n#26 0x000000000040e874 processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::Optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) firtool.cpp:0:0\r\n#27 0x0000000000409aa1 main (../../llvm/circt/build/bin/firtool+0x409aa1)\r\n#28 0x00007f3fc26bb5c0 __libc_start_call_main (/lib64/libc.so.6+0x405c0)\r\n#29 0x00007f3fc26bb67c __libc_start_main@GLIBC_2.2.5 (/lib64/libc.so.6+0x4067c)\r\n#30 0x0000000000409e25 _start /home/abuild/rpmbuild/BUILD/glibc-2.34/csu/../sysdeps/x86_64/start.S:118:0"}, {"number": 2504, "title": "[ExportVerilog] Incorrect verilog output for bitcast + zero width aggregate types", "created_at": "2022-01-23T22:10:34Z", "state": "open", "labels": "bug, ExportVerilog", "body": "We are emitting zero bit width array/struct as one bit element. This is problem when we use bitcast for them.\r\n\r\n```mlir\r\nhw.module @top(%source: i1) -> (b: !hw.struct<zero: !hw.array<1xi0>, c: i1>) {\r\n    %cast = hw.bitcast %source: (i1) -> !hw.struct<zero: !hw.array<1xi0>, c: i1>\r\n    hw.output %cast : !hw.struct<zero: !hw.array<1xi0>, c: i1>\r\n }\r\n```\r\n\r\n```sv\r\nmodule top(\t// out.mlir:2:3\r\n  input                                                            source,\r\n  output struct packed {logic [0:0]/*Zero Width*/ zero; logic c; } b);\r\n \r\n  assign b = source;\t// out.mlir:3:12, :4:5\r\nendmodule\r\n```\r\n", "code_snippet_01": "hw.module @top(%source: i1) -> (b: !hw.struct<zero: !hw.array<1xi0>, c: i1>) {\r\n    %cast = hw.bitcast %source: (i1) -> !hw.struct<zero: !hw.array<1xi0>, c: i1>\r\n    hw.output %cast : !hw.struct<zero: !hw.array<1xi0>, c: i1>\r\n }", "code_snippet_02": "module top(\t// out.mlir:2:3\r\n  input                                                            source,\r\n  output struct packed {logic [0:0]/*Zero Width*/ zero; logic c; } b);\r\n \r\n  assign b = source;\t// out.mlir:3:12, :4:5\r\nendmodule"}, {"number": 2491, "title": "[SCFToCalyx] Crash with external memories", "created_at": "2022-01-21T23:13:50Z", "state": "closed", "labels": "bug, Calyx", "body": "I'm trying to run the following program through SCFToCalyx:\r\n\r\n```mlir\r\n func @main(%arg0 : memref<64xi32>, %arg1 : memref<64xi32>) -> i32 {\r\n    %c0_i32 = arith.constant 0 : i32\r\n    %c0 = arith.constant 0 : index\r\n    %c64 = arith.constant 64 : index\r\n    %c1 = arith.constant 1 : index\r\n    %0:2 = scf.while (%arg2 = %c0, %arg3 = %c0_i32) : (index, i32) -> (index, i32) {\r\n      %1 = arith.cmpi slt, %arg2, %c64 : index\r\n      scf.condition(%1) %arg2, %arg3 : index, i32\r\n    } do {\r\n    ^bb0(%arg2: index, %arg3: i32):  // no predecessors\r\n      %1 = arith.addi %arg2, %c1 : index\r\n      %2 = memref.load %arg0[%arg2] : memref<64xi32>\r\n      %3 = memref.load %arg1[%arg2] : memref<64xi32>\r\n      %4 = arith.muli %2, %3 : i32\r\n      %5 = arith.addi %arg3, %4 : i32\r\n      scf.yield %1, %5 : index, i32\r\n    }\r\n    return %0#1 : i32\r\n  }\r\n```\r\n\r\nUnfortunately, this seems to crash the pass, and worse, it silently just exits with a return code of 1. This appears to be related to the external memories; if I move the parameters to internal allocations, the pass succeeds:\r\n\r\n```mlir\r\n  func @main() -> i32 {\r\n    %arg0 = memref.alloc() : memref<64xi32>\r\n    %arg1 = memref.alloc() : memref<64xi32>\r\n```\r\n\r\nI haven't begun looking into this yet, but will mention here if I do.", "code_snippet_01": "func @main(%arg0 : memref<64xi32>, %arg1 : memref<64xi32>) -> i32 {\r\n    %c0_i32 = arith.constant 0 : i32\r\n    %c0 = arith.constant 0 : index\r\n    %c64 = arith.constant 64 : index\r\n    %c1 = arith.constant 1 : index\r\n    %0:2 = scf.while (%arg2 = %c0, %arg3 = %c0_i32) : (index, i32) -> (index, i32) {\r\n      %1 = arith.cmpi slt, %arg2, %c64 : index\r\n      scf.condition(%1) %arg2, %arg3 : index, i32\r\n    } do {\r\n    ^bb0(%arg2: index, %arg3: i32):  // no predecessors\r\n      %1 = arith.addi %arg2, %c1 : index\r\n      %2 = memref.load %arg0[%arg2] : memref<64xi32>\r\n      %3 = memref.load %arg1[%arg2] : memref<64xi32>\r\n      %4 = arith.muli %2, %3 : i32\r\n      %5 = arith.addi %arg3, %4 : i32\r\n      scf.yield %1, %5 : index, i32\r\n    }\r\n    return %0#1 : i32\r\n  }", "code_snippet_02": "func @main() -> i32 {\r\n    %arg0 = memref.alloc() : memref<64xi32>\r\n    %arg1 = memref.alloc() : memref<64xi32>"}, {"number": 2464, "title": "[FIRRTL] FlattenAnnotation should be removed by ModuleInliner Pass", "created_at": "2022-01-15T06:47:32Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The `ModuleInliner` pas isn't removing `FlattenAnnotation`s on flattened modules.  This isn't a problem, per se, as flattening is an idempotent operation.  However, it's good practice for passes to remove annotations that they consume."}, {"number": 2451, "title": "[FIRRTL] Module Inliner Needs to Unique Colliding Symbols", "created_at": "2022-01-13T05:52:23Z", "state": "closed", "labels": "bug, FIRRTL", "body": "FIRRTL Dialect's `ModuleInliner` pass can result in inner sym collisions.  Consider the following:\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Bar() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n    %b = firrtl.wire sym @hello : !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Foo() {\r\n    firrtl.instance foo @Bar()\r\n    %a = firrtl.wire sym @hello : !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nAfter running `circt-opt -pass-pipeline='firrtl.circuit(firrtl-inliner)' Bar.mlir`:\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\"   {\r\n  firrtl.module @Foo() {\r\n    %foo_b = firrtl.wire sym @hello  : !firrtl.uint<1>\r\n    %a = firrtl.wire sym @hello  : !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nThe `@hello` symbol should be renamed using a `firrtl::ModuleNamespace` (and any NLAs using it should be updated).\r\n\r\nNote: I'm working on fixing NLAs generally in the `ModuleInliner` and I'd like to land that before fixing this.\r\n\r\nNote: I'm in favor of keeping the symbol name unmodified if it doesn't collide as opposed to updating the symbol to reflect the inlining, e.g., `@foo_hello`.  (Doing this would _still_ require uniquing the symbol in the namespace even though it lowers the probability of a collision.)", "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Bar() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n    %b = firrtl.wire sym @hello : !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Foo() {\r\n    firrtl.instance foo @Bar()\r\n    %a = firrtl.wire sym @hello : !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_02": "firrtl.circuit \"Foo\"   {\r\n  firrtl.module @Foo() {\r\n    %foo_b = firrtl.wire sym @hello  : !firrtl.uint<1>\r\n    %a = firrtl.wire sym @hello  : !firrtl.uint<1>\r\n  }\r\n}"}, {"number": 2404, "title": "[ExportVerilog] Crash with disallowLocalVariables option", "created_at": "2021-12-28T17:27:11Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "input:\r\n```mlir\r\nhw.module @Foo(%clock: i1) {\r\n    %false = hw.constant false\r\n    %c0_i16 = hw.constant 0 : i16\r\n    %status_regs = sv.reg : !hw.inout<array<1xi32>>\r\n    %0 = sv.array_index_inout %status_regs[%false] : !hw.inout<array<1xi32>>, i1\r\n    %1 = sv.read_inout %0 : !hw.inout<i32>\r\n    %2 = comb.extract %1 from 0 : (i32) -> i16\r\n    %3 = comb.concat %c0_i16, %2 : i16, i16\r\n    sv.always posedge %clock  {\r\n       sv.passign %0, %3 : i32\r\n    }\r\n    hw.output\r\n  }\r\n```\r\n```\r\n./bin/firtool --lowering-options=disallowLocalVariables foo.mlir\r\n```\r\ncauses the assertion failure:\r\n```\r\n./lib/Conversion/ExportVerilog/ExportVerilog.cpp:355: llvm::StringRef getVerilogDeclWord(mlir::Operation *, const circt::LoweringOptions &): Assertion `!options.disallowLocalVariables && \"automatic variables not allowed\"' failed\r\n```\r\n\r\n(This is reduced by circt-reduce. Thank you @fabianschuiki for creating circt-reduce!)", "code_snippet_01": "hw.module @Foo(%clock: i1) {\r\n    %false = hw.constant false\r\n    %c0_i16 = hw.constant 0 : i16\r\n    %status_regs = sv.reg : !hw.inout<array<1xi32>>\r\n    %0 = sv.array_index_inout %status_regs[%false] : !hw.inout<array<1xi32>>, i1\r\n    %1 = sv.read_inout %0 : !hw.inout<i32>\r\n    %2 = comb.extract %1 from 0 : (i32) -> i16\r\n    %3 = comb.concat %c0_i16, %2 : i16, i16\r\n    sv.always posedge %clock  {\r\n       sv.passign %0, %3 : i32\r\n    }\r\n    hw.output\r\n  }", "code_snippet_02": "./bin/firtool --lowering-options=disallowLocalVariables foo.mlir", "code_snippet_03": "./lib/Conversion/ExportVerilog/ExportVerilog.cpp:355: llvm::StringRef getVerilogDeclWord(mlir::Operation *, const circt::LoweringOptions &): Assertion `!options.disallowLocalVariables && \"automatic variables not allowed\"' failed"}, {"number": 2357, "title": "[FIRRTL] Fix use-after-free of ops erased during assert parsing", "created_at": "2021-12-16T13:33:10Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Fix an issue where the `foldWhenEncodedVerifOp` function would erase operations while the `LazyLocationListener` of the parser still has a pointer to them. This causes `endStatement` to try and assign locations to those operations, which for the erased operations is a use after free. This adjusts the `foldWhenEncodedVerifOp` function to only remove the operation but not immediately destroy it. This allows the listener to do its updates and properly clean up the removed operations once it's done.\r\n\r\nFixes #2355."}, {"number": 2346, "title": "[FIRRTL] Fix OMIR port widths not being hex values", "created_at": "2021-12-15T16:16:07Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Fix an issue in the `EmitOMIR` pass, where the addition of port information would introduce additional `OMBigInt` values which were not properly formatted as hexadecimal values, but just as decimal ones. This updates the emission to make them hexadecimal as expected by other parts of the FIRRTL ecosystem."}, {"number": 2343, "title": "[LowerToHW] Invalid lowering of register assignments through subindex/subfield", "created_at": "2021-12-15T14:37:45Z", "state": "closed", "labels": "bug", "body": "```mlir\r\n; firtool -verilog -lower-types=false\r\nfirrtl.module @AggregateRegAssign(in %clock: !firrtl.clock, in %value: !firrtl.uint<1>) {\r\n      %reg = firrtl.reg %clock  : !firrtl.vector<uint<1>, 1>\r\n      %0 = firrtl.subindex %reg[0] : !firrtl.vector<uint<1>, 1>\r\n      firrtl.connect %0, %value : !firrtl.uint<1>, !firrtl.uint<1>\r\n}\r\n```\r\ncurrently generates something like this: \r\n```sv\r\nmodule AggregateRegAssign(      // foo.mlir:2:1\r\n  input clock, value);\r\n\r\n  reg [0:0] reg_0;      // foo.mlir:3:14\r\n  assign reg_0[1'h0] = value;   // foo.mlir:3:14, :4:12, :5:7\r\nendmodule\r\n```\r\nWe have to put assignment into always statement. This is a bug of `FIRRTLLowering::visitStmt(ConnectOp)`.", "code_snippet_01": "; firtool -verilog -lower-types=false\r\nfirrtl.module @AggregateRegAssign(in %clock: !firrtl.clock, in %value: !firrtl.uint<1>) {\r\n      %reg = firrtl.reg %clock  : !firrtl.vector<uint<1>, 1>\r\n      %0 = firrtl.subindex %reg[0] : !firrtl.vector<uint<1>, 1>\r\n      firrtl.connect %0, %value : !firrtl.uint<1>, !firrtl.uint<1>\r\n}", "code_snippet_02": "module AggregateRegAssign(      // foo.mlir:2:1\r\n  input clock, value);\r\n\r\n  reg [0:0] reg_0;      // foo.mlir:3:14\r\n  assign reg_0[1'h0] = value;   // foo.mlir:3:14, :4:12, :5:7\r\nendmodule"}, {"number": 2342, "title": "[ExportVerilog] Invalid emission of mux of aggregates + extract", "created_at": "2021-12-14T22:04:55Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```mlir\r\n// circt-opt %s -export-verilog\r\nhw.module @muxAggregate(%cond: i1, %a: !hw.struct<c: i1>, %b: !hw.struct<c: i1>) -> (out: i1) {\r\n    %0 = comb.mux %cond, %a, %b : !hw.struct<c: i1>\r\n    %1 = hw.struct_extract %0[\"c\"] : !hw.struct<c: i1>\r\n    hw.output %1 : i1\r\n}\r\n```\r\nwill become\r\n```sv\r\nmodule muxAggregate(      // foo.mlir:2:3\r\n  input                            cond,\r\n  input  struct packed {logic c; } a, b,\r\n  output                           out);\r\n\r\n  assign out = (cond ? a : b).c;        // foo.mlir:3:12, :4:12, :5:5\r\nendmodule\r\n```\r\n`(cond?a:b).c` causes a syntax error so we need to spill mux into a temporary wire. ", "code_snippet_01": "// circt-opt %s -export-verilog\r\nhw.module @muxAggregate(%cond: i1, %a: !hw.struct<c: i1>, %b: !hw.struct<c: i1>) -> (out: i1) {\r\n    %0 = comb.mux %cond, %a, %b : !hw.struct<c: i1>\r\n    %1 = hw.struct_extract %0[\"c\"] : !hw.struct<c: i1>\r\n    hw.output %1 : i1\r\n}", "code_snippet_02": "module muxAggregate(      // foo.mlir:2:3\r\n  input                            cond,\r\n  input  struct packed {logic c; } a, b,\r\n  output                           out);\r\n\r\n  assign out = (cond ? a : b).c;        // foo.mlir:3:12, :4:12, :5:5\r\nendmodule"}, {"number": 2335, "title": "[ExportVerilog] Invalid automatic variable emission of struct type", "created_at": "2021-12-13T15:41:37Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```mlir\r\n; circt-opt %s -export-verilog\r\nhw.module @AggregateTemporay(%clock: i1, %foo: i1) {\r\n  %temp = sv.reg  : !hw.inout<!hw.struct<b: i1>>\r\n  sv.always posedge %clock  {\r\n    %0 = hw.bitcast %foo : (i1) -> !hw.struct<b: i1>\r\n    sv.passign %temp, %0 : !hw.struct<b: i1>\r\n    sv.passign %temp, %0 : !hw.struct<b: i1>\r\n  }\r\n}\r\n```\r\nwill generate something like this:\r\n```sv\r\nmodule AggregateTemporay(       // foo.mlir:1:1\r\n  input clock, foo);\r\n\r\n  struct packed {logic b; } temp;       // foo.mlir:2:11\r\n\r\n  always @(posedge clock) begin // foo.mlir:5:3\r\n    automatic logic struct packed {logic b; } _T = foo;       // foo.mlir:6:10\r\n\r\n    temp <= _T; // foo.mlir:7:5\r\n    temp <= _T; // foo.mlir:8:5\r\n  end // always @(posedge)\r\nendmodule\r\n```\r\n`automatic logic struct packed {logic b; } _T = foo;` is syntactically incorrect. \r\nWe have to emit `automatic struct packed {logic b; } _T = foo; `. ", "code_snippet_01": "; circt-opt %s -export-verilog\r\nhw.module @AggregateTemporay(%clock: i1, %foo: i1) {\r\n  %temp = sv.reg  : !hw.inout<!hw.struct<b: i1>>\r\n  sv.always posedge %clock  {\r\n    %0 = hw.bitcast %foo : (i1) -> !hw.struct<b: i1>\r\n    sv.passign %temp, %0 : !hw.struct<b: i1>\r\n    sv.passign %temp, %0 : !hw.struct<b: i1>\r\n  }\r\n}", "code_snippet_02": "module AggregateTemporay(       // foo.mlir:1:1\r\n  input clock, foo);\r\n\r\n  struct packed {logic b; } temp;       // foo.mlir:2:11\r\n\r\n  always @(posedge clock) begin // foo.mlir:5:3\r\n    automatic logic struct packed {logic b; } _T = foo;       // foo.mlir:6:10\r\n\r\n    temp <= _T; // foo.mlir:7:5\r\n    temp <= _T; // foo.mlir:8:5\r\n  end // always @(posedge)\r\nendmodule"}, {"number": 2327, "title": "[ExportVerilog] Verilog empty struct emission", "created_at": "2021-12-12T20:54:34Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```mlir\r\nhw.module @EmptyStruct(%empty: !hw.struct<>) {\r\n}\r\n```\r\nwill generate\r\n```verilog\r\nmodule EmptyStruct(     // foo.mlir:1:1\r\n  input struct packed {} empty);\r\n\r\nendmodule\r\n```\r\nAn empty `{}` causes syntax errors so we need to emit `/*Zero Width*/` instead. ", "code_snippet_01": "hw.module @EmptyStruct(%empty: !hw.struct<>) {\r\n}", "code_snippet_02": "module EmptyStruct(     // foo.mlir:1:1\r\n  input struct packed {} empty);\r\n\r\nendmodule"}, {"number": 2326, "title": "[ExportVerilog] Verilog reserved keywords in Struct Type field names", "created_at": "2021-12-12T20:45:06Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```mlir\r\n; circt-opt -export-verilog %s\r\nhw.module @ReservedKeyword(%rep: !hw.struct<repeat: i1>) {\r\n}\r\n```\r\nwill generate\r\n```verilog\r\nmodule ReservedKeyword( // foo.mlir:1:1\r\n  input struct packed {logic repeat; } rep);\r\n\r\nendmodule\r\n```\r\nThis causes a syntax error because `repeat` is verilog keyword. We have to check field names are verilog keyward as well as variable names. ", "code_snippet_01": "; circt-opt -export-verilog %s\r\nhw.module @ReservedKeyword(%rep: !hw.struct<repeat: i1>) {\r\n}", "code_snippet_02": "module ReservedKeyword( // foo.mlir:1:1\r\n  input struct packed {logic repeat; } rep);\r\n\r\nendmodule"}, {"number": 2316, "title": "[FIRRTL] Fix index overflows during subaccess lowering", "created_at": "2021-12-09T10:34:09Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Fix an issue in `LowerTypes` around `SubaccessOp`s, where narrow index expressions could cause constant overflows. If the subaccess index had fewer bits than necessary to address all elements of the vector, the comparisons between that index and a constant generated for every element would see the constant overflow for all the elements beyond reach.\r\n\r\nFor example, using a 2-bit index `x` to access a 5-element vector `y` would generate comparisons as follows:\r\n\r\n- `x == 0 : i2`\r\n- `x == 1 : i2`\r\n- `x == 2 : i2`\r\n- `x == 3 : i2`\r\n- `x == 0 : i2` (4 overflows in the 2-bit constant)\r\n\r\nThis fixes the issue by choosing the width of the constants according to `ceil(log2(vectorLength))`, which is guaranteed to always have enough bits to represent all vector indices. This makes the generated equality checks compare numbers of potentially different bit widths, which is fine in FIRRTL.\r\n\r\nFixes #2315."}, {"number": 2315, "title": "[FIRRTL] Subaccess into vector may overflow index expression", "created_at": "2021-12-09T10:10:09Z", "state": "closed", "labels": "bug, FIRRTL", "body": "A subaccess into a vector longer than what the index can address will cause constants to overflow during `LowerTypes`:\r\n```\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(\r\n    in %x: !firrtl.vector<uint<10>, 5>,\r\n    in %source: !firrtl.uint<2>,\r\n    out %z: !firrtl.uint<10>\r\n  ) {\r\n    %0 = firrtl.subaccess %x[%source] : !firrtl.vector<uint<10>, 5>, !firrtl.uint<2>\r\n    firrtl.connect %z, %0 : !firrtl.uint<10>, !firrtl.uint<10>\r\n  }\r\n}\r\n```\r\nwill lower to\r\n```\r\nfirrtl.circuit \"Foo\"   {\r\n  firrtl.module @Foo(\r\n    in %x_0: !firrtl.uint<10>,\r\n    in %x_1: !firrtl.uint<10>,\r\n    in %x_2: !firrtl.uint<10>,\r\n    in %x_3: !firrtl.uint<10>,\r\n    in %x_4: !firrtl.uint<10>,\r\n    in %source: !firrtl.uint<2>,\r\n    out %z: !firrtl.uint<10>\r\n  ) {\r\n    %c1_ui2 = firrtl.constant 1 : !firrtl.uint<2>\r\n    %c2_ui2 = firrtl.constant 2 : !firrtl.uint<2>\r\n    %c3_ui2 = firrtl.constant 3 : !firrtl.uint<2>\r\n    %c0_ui2 = firrtl.constant 0 : !firrtl.uint<2>  // <-- 4 being squeezed into the 2-bit index\r\n    %0 = firrtl.eq %source, %c1_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>\r\n    %1 = firrtl.mux(%0, %x_1, %x_0) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>\r\n    %2 = firrtl.eq %source, %c2_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>\r\n    %3 = firrtl.mux(%2, %x_2, %1) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>\r\n    %4 = firrtl.eq %source, %c3_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>\r\n    %5 = firrtl.mux(%4, %x_3, %3) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>\r\n    %6 = firrtl.eq %source, %c0_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>\r\n    %7 = firrtl.mux(%6, %x_4, %5) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>\r\n    firrtl.connect %z, %7 : !firrtl.uint<10>, !firrtl.uint<10>\r\n  }\r\n}\r\n```\r\nThis causes fun things during Verilog emission, like indexing an array `{x0, ..., x5}` with a 2-bit index expression `y` being lowered to `{x4, x5, x2, x3}[y]` (where the overflowing indices 4 and 5 get wrapped around and override the other values). Working on a fix.", "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(\r\n    in %x: !firrtl.vector<uint<10>, 5>,\r\n    in %source: !firrtl.uint<2>,\r\n    out %z: !firrtl.uint<10>\r\n  ) {\r\n    %0 = firrtl.subaccess %x[%source] : !firrtl.vector<uint<10>, 5>, !firrtl.uint<2>\r\n    firrtl.connect %z, %0 : !firrtl.uint<10>, !firrtl.uint<10>\r\n  }\r\n}", "code_snippet_02": "firrtl.circuit \"Foo\"   {\r\n  firrtl.module @Foo(\r\n    in %x_0: !firrtl.uint<10>,\r\n    in %x_1: !firrtl.uint<10>,\r\n    in %x_2: !firrtl.uint<10>,\r\n    in %x_3: !firrtl.uint<10>,\r\n    in %x_4: !firrtl.uint<10>,\r\n    in %source: !firrtl.uint<2>,\r\n    out %z: !firrtl.uint<10>\r\n  ) {\r\n    %c1_ui2 = firrtl.constant 1 : !firrtl.uint<2>\r\n    %c2_ui2 = firrtl.constant 2 : !firrtl.uint<2>\r\n    %c3_ui2 = firrtl.constant 3 : !firrtl.uint<2>\r\n    %c0_ui2 = firrtl.constant 0 : !firrtl.uint<2>  // <-- 4 being squeezed into the 2-bit index\r\n    %0 = firrtl.eq %source, %c1_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>\r\n    %1 = firrtl.mux(%0, %x_1, %x_0) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>\r\n    %2 = firrtl.eq %source, %c2_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>\r\n    %3 = firrtl.mux(%2, %x_2, %1) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>\r\n    %4 = firrtl.eq %source, %c3_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>\r\n    %5 = firrtl.mux(%4, %x_3, %3) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>\r\n    %6 = firrtl.eq %source, %c0_ui2 : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>\r\n    %7 = firrtl.mux(%6, %x_4, %5) : (!firrtl.uint<1>, !firrtl.uint<10>, !firrtl.uint<10>) -> !firrtl.uint<10>\r\n    firrtl.connect %z, %7 : !firrtl.uint<10>, !firrtl.uint<10>\r\n  }\r\n}"}, {"number": 2299, "title": "[FIRRTL] Parsing a `-1` Parameter Results in Too Few Bits", "created_at": "2021-12-06T21:07:20Z", "state": "closed", "labels": "bug, FIRRTL", "body": "When parsing external module parameters from FIRRTL text, negative numbers need to be expanded to a 32-bit value.  (Likely, all integer parameters should just be parsed as 32-bit values regardless of whether or not they can fit in a smaller-sized APSInt.)\r\n\r\nAs an example, the following input FIRRTL text:\r\n\r\n```scala\r\ncircuit Foo:\r\n  extmodule Bar:\r\n    output a: UInt<1>\r\n    parameter x = -1\r\n  module Foo:\r\n    output a: UInt<1>\r\n\r\n    inst bar of Bar\r\n    a <= bar.a\r\n```\r\n\r\nIs parsed into:\r\n```mlir\r\nfirrtl.circuit \"Foo\"   {\r\n  firrtl.extmodule @Bar(out a: !firrtl.uint<1>) attributes {parameters = {x = -1 : i4}}\r\n  firrtl.module @Foo(out %a: !firrtl.uint<1>) {\r\n    %bar_a = firrtl.instance bar  @Bar(out a: !firrtl.uint<1>)\r\n    firrtl.connect %a, %bar_a : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nThis results in the following Verilog:\r\n```verilog\r\n// external module Bar\r\n\r\nmodule Foo(     // Foo.fir:5:10\r\n  output a);\r\n\r\n  Bar #(\r\n    .x(15)\r\n  ) bar (       // Foo.fir:8:5\r\n    .a (a)\r\n  );\r\nendmodule\r\n```\r\n\r\nThe SFC produces:\r\n```verilog\r\nmodule Foo(\r\n  output  a\r\n);\r\n  wire  bar_a;\r\n  Bar #(.x(-1)) bar (\r\n    .a(bar_a)\r\n  );\r\n  assign a = bar_a;\r\nendmodule\r\n```", "code_snippet_01": "circuit Foo:\r\n  extmodule Bar:\r\n    output a: UInt<1>\r\n    parameter x = -1\r\n  module Foo:\r\n    output a: UInt<1>\r\n\r\n    inst bar of Bar\r\n    a <= bar.a", "code_snippet_02": "firrtl.circuit \"Foo\"   {\r\n  firrtl.extmodule @Bar(out a: !firrtl.uint<1>) attributes {parameters = {x = -1 : i4}}\r\n  firrtl.module @Foo(out %a: !firrtl.uint<1>) {\r\n    %bar_a = firrtl.instance bar  @Bar(out a: !firrtl.uint<1>)\r\n    firrtl.connect %a, %bar_a : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_03": "// external module Bar\r\n\r\nmodule Foo(     // Foo.fir:5:10\r\n  output a);\r\n\r\n  Bar #(\r\n    .x(15)\r\n  ) bar (       // Foo.fir:8:5\r\n    .a (a)\r\n  );\r\nendmodule", "code_snippet_04": "module Foo(\r\n  output  a\r\n);\r\n  wire  bar_a;\r\n  Bar #(.x(-1)) bar (\r\n    .a(bar_a)\r\n  );\r\n  assign a = bar_a;\r\nendmodule"}, {"number": 2298, "title": "[LowerToHW] Define Behavior for Multiple Circuits", "created_at": "2021-12-06T19:11:08Z", "state": "open", "labels": "bug, FIRRTL, HW", "body": "Currently, if you compile multiple FIRRTL circuits, only one of them gets lowered. We need to define a behavior here for how this should work and what the resulting HW representation is. Consider the following:\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n  firrtl.circuit \"Bar\"   {\r\n    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis produces, after `LowerToHW`:\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Bar\"   {\r\n    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n  hw.module @Foo(%a: i1) -> (b: i1) {\r\n    hw.output %a : i1\r\n  }\r\n}\r\n```\r\n\r\nIf allowed to continue after this, eventually `ExportVerilog` will print an error because it doesn't know how to handle a `firrtl.circuit`.\r\n\r\nI can think of two behaviors here:\r\n\r\n1. This should produce a flat list of modules.\r\n2. (Likely what we need) This should lower each to two lists of modules in a `hw.namespace`-guarded region.", "code_snippet_01": "module  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n  firrtl.circuit \"Bar\"   {\r\n    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_02": "module  {\r\n  firrtl.circuit \"Bar\"   {\r\n    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n  hw.module @Foo(%a: i1) -> (b: i1) {\r\n    hw.output %a : i1\r\n  }\r\n}"}, {"number": 2289, "title": "[FIRRTL] Sub Folder Can't Use AsUInt Before Pad", "created_at": "2021-12-05T07:10:40Z", "state": "closed", "labels": "bug, FIRRTL", "body": "There's a bug in the sub folder added in #2251.  This inserts an `asUInt` before `canonicalizePrimOp` adds a `pad`.  The end result is that we wind up with zero-extension instead of sign-extension.\r\n\r\nConsider:\r\n\r\n```scala\r\ncircuit Bar :\r\n  module Bar :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output out : UInt<5>\r\n\r\n    reg r: UInt<1>, clock\r\n    r <= r\r\n    out <= sub(UInt<4>(0), dshl(UInt<1>(1), r))\r\n```\r\n\r\nAfter canonicalization, this is:\r\n\r\n```mlir\r\nfirrtl.module @Bar(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, out %out: !firrtl.uint<5>) {\r\n  %r = firrtl.reg %clock  : !firrtl.uint<2>\r\n  firrtl.connect %r, %r : !firrtl.uint<2>, !firrtl.uint<2>\r\n  %0 = firrtl.neg %r : (!firrtl.uint<2>) -> !firrtl.sint<3>\r\n  %1 = firrtl.asUInt %0 : (!firrtl.sint<3>) -> !firrtl.uint<3>\r\n  %2 = firrtl.pad %1, 5 : (!firrtl.uint<3>) -> !firrtl.uint<5>\r\n  firrtl.connect %out, %2 : !firrtl.uint<5>, !firrtl.uint<5>\r\n}\r\n```\r\n\r\nIMCP then collapses all this (as the register is invalid/zero) to produce the following Verilog:\r\n\r\n```verilog\r\nmodule Bar(output [4:0] out);\r\n  assign out = 5'h7;\r\nendmodule\r\n```\r\n\r\nThis should be `5'h1f`.\r\n\r\nThe output produced by the SFC is the following which I think is `5'h1f` after the context determined widths happen, but I'm not sure...:\r\n```verilog\r\nmodule Bar(\r\n  input        clock,\r\n  input        reset,\r\n  output [4:0] out\r\n);\r\n  assign out = 4'h0 - 4'h1;\r\nendmodule\r\n```", "code_snippet_01": "circuit Bar :\r\n  module Bar :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output out : UInt<5>\r\n\r\n    reg r: UInt<1>, clock\r\n    r <= r\r\n    out <= sub(UInt<4>(0), dshl(UInt<1>(1), r))", "code_snippet_02": "firrtl.module @Bar(in %clock: !firrtl.clock, in %reset: !firrtl.uint<1>, out %out: !firrtl.uint<5>) {\r\n  %r = firrtl.reg %clock  : !firrtl.uint<2>\r\n  firrtl.connect %r, %r : !firrtl.uint<2>, !firrtl.uint<2>\r\n  %0 = firrtl.neg %r : (!firrtl.uint<2>) -> !firrtl.sint<3>\r\n  %1 = firrtl.asUInt %0 : (!firrtl.sint<3>) -> !firrtl.uint<3>\r\n  %2 = firrtl.pad %1, 5 : (!firrtl.uint<3>) -> !firrtl.uint<5>\r\n  firrtl.connect %out, %2 : !firrtl.uint<5>, !firrtl.uint<5>\r\n}", "code_snippet_03": "module Bar(output [4:0] out);\r\n  assign out = 5'h7;\r\nendmodule", "code_snippet_04": "module Bar(\r\n  input        clock,\r\n  input        reset,\r\n  output [4:0] out\r\n);\r\n  assign out = 4'h0 - 4'h1;\r\nendmodule"}, {"number": 2269, "title": "[LowerToHW] LowerToHW Can't Handle 0-width Constants", "created_at": "2021-12-01T17:47:35Z", "state": "closed", "labels": "bug", "body": "The following is crashing on an old assertion inside LowerToHW:\r\n\r\n```mlir\r\nfirrtl.circuit \"top_mod\"   {\r\n  firrtl.module @top_mod(out %a: !firrtl.uint<0>) {\r\n    %c0_ui0 = firrtl.constant 0 : !firrtl.uint<0>\r\n    firrtl.connect %a, %c0_ui0 : !firrtl.uint<0>, !firrtl.uint<0>\r\n  }\r\n}\r\n```\r\n\r\nWith the change in https://github.com/llvm/circt/pull/2268, this type of code can now be generated and we need to lower it.  Specifically, the above is reduced from the nightly performance regression `test1.fir` with #2268 applied.  The above code will then fail on `main` without #2268.", "code_snippet_01": "firrtl.circuit \"top_mod\"   {\r\n  firrtl.module @top_mod(out %a: !firrtl.uint<0>) {\r\n    %c0_ui0 = firrtl.constant 0 : !firrtl.uint<0>\r\n    firrtl.connect %a, %c0_ui0 : !firrtl.uint<0>, !firrtl.uint<0>\r\n  }\r\n}"}, {"number": 2256, "title": "[ExportVerilog] Remove parallel assert, XFAIL, add comment", "created_at": "2021-11-30T09:22:00Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Remove the `isInParallelMode` flag and the corresponding assertion, which are no longer needed since the emission phase of `ExportVerilog` treats the IR as immutable, which allows for pretty straightforward parallelization. All mutation is limited to the preparation phase which lives in the separate `PrepareForEmission.cpp` file.\r\n\r\nAlso remove the XFAIL on one of the FIRRTL Grand Central integration tests, which used to trigger this assertion.\r\n\r\nAdd comments to the `ExportVerilog.cpp` and `PrepareForEmission.cpp` files explaining the separation into an IR-mutating preparation and IR-immutable emission phase."}, {"number": 2250, "title": "[CombFolds] Fix issue in icmp ult/ugt extract fold", "created_at": "2021-11-29T08:42:16Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Fix an issue introduced in 3664712 where ult comparisons against a constant of the shape `0b111..111000..000` would be converted to an extract operation. The fold is based on the observation that in an icmp `x < cst`, where `cst` has this shape of a bunch of leading ones followed by all zeros, all values for `x` for which the comparison would return a 0 are the values that have all the upper bits set (those that are a one in the constant). Therefore the comparison is equivalent to checking if those upper bits are not all ones. The implementation in 3664712 erroneously checked the lower bits of the number."}, {"number": 2238, "title": "[ExportVerilog] Fix bind emission, split into parallel/sequential phase", "created_at": "2021-11-25T07:43:54Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Emission of `sv.bind` requires to occur in a sequential piece of code. This is currently handled well in `emitOps` if parallelize is `true`, which is the case for single-file Verilog emission. But in split Verilog emission, `emitOps` itself is called in a parallel block, which breaks an implicit assumption in the code.\r\n\r\nThis change extends the split into parallel and sequential phases of emission, and makes them explicit at the unified/split Verilog emitter level by separating the `emitOps` function into an `emitOpsParallel` and a `emitOpsSequential`. These correspond to the first and second half of the original `emitOps`:\r\n\r\n- `emitOpsParallel` performs opportunistic emission of operations. It tries to emit operations in parallel, if possible directly to the   output stream, or into a string buffer otherwise. It may leave operations unemitted.\r\n- `emitOpsSequential` performs the final emission of operations. This includes emitting any string buffers produced by the parallel portion, and actually emitting any ops that were left over.\r\n\r\nThe split Verilog emitter now keeps a list of `SplitOutputFile`s in a vector, which is used to carry the necessary information from the parallel to the sequential emission phase. The emitter then performs emission in two phases: first calling the `emitParallel` function in a parallel block, and then calling the `emitSequential` function in a sequential block.\r\n\r\nThis fixes an assertion that triggers when trying to emit any design containing bind statements through the split Verilog emitter."}, {"number": 2207, "title": "[FIRRTL] Fix InferResets failing on zero-width registers", "created_at": "2021-11-18T17:32:12Z", "state": "closed", "labels": "bug, FIRRTL", "body": "In practice we have come across registers of width zero. The `InferResets` pass then tries to add an asynchronous reset to these, for which it has to come up with a zero value of that type. However, the `firrtl.constant` op cannot generate a value of width 0. This adds a workaround that keeps `ConstantOp` unchanged, but uses the `TailPrimOp` to chop off the only bit from a single-bit value."}, {"number": 2203, "title": "[FIRRTL] Cast Folders for Invalid", "created_at": "2021-11-18T00:04:16Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Similar to #2197, there are other folds/canonicalizations that are missing that may result in registers hanging around.\r\n\r\nConsider the following.  This is the same as #2197, but just with `asUInt` as opposed to `pad`:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    input clock: Clock\r\n    output a: UInt<1>\r\n\r\n    wire x: SInt<1>\r\n    x is invalid\r\n\r\n    reg b: UInt<1>, clock\r\n    b <= asUInt(x)\r\n    a <= b\r\n```\r\n\r\nMFC produces a register:\r\n\r\n```verilog\r\n  always @(posedge clock)\t// Foo.fir:10:7\r\n    b <= 1'h0;\t// Foo.fir:7:7, :10:7\r\n  assign a = b;\t// Foo.fir:2:10\r\n```\r\n\r\nSFC produces a constant output:\r\n\r\n```verilog\r\n  assign a = 1'h0;\r\n```\r\n\r\nHowever, this is just the tip of the iceberg.  I generated lots of tests of this same form and committed passing and failing test cases in https://github.com/llvm/circt/commit/4e21aebe0b26a4182ad95ef453ea4753618cf605.  When people look at fixing this, they should be able to move tests from the failing file to the passing file.", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input clock: Clock\r\n    output a: UInt<1>\r\n\r\n    wire x: SInt<1>\r\n    x is invalid\r\n\r\n    reg b: UInt<1>, clock\r\n    b <= asUInt(x)\r\n    a <= b", "code_snippet_02": "always @(posedge clock)\t// Foo.fir:10:7\r\n    b <= 1'h0;\t// Foo.fir:7:7, :10:7\r\n  assign a = b;\t// Foo.fir:2:10", "code_snippet_03": "assign a = 1'h0;"}, {"number": 2154, "title": "[ExportVerilog] Query global state to get the updated names", "created_at": "2021-11-11T21:34:00Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The commit https://github.com/llvm/circt/commit/fc7d917466db453d3e7a322194977519c4cb5a19, updated the name legalization to properly rename \r\nall declaration ops `(<WireOp, RegOp, LocalParamOp, InstanceOp>)`, and \r\nmaintain them in the rename map in the global state. \r\nThis means, the ops no longer have the updated names in the IR.\r\n\r\nThis commit fixes the `ExportVerilog` to query the global symbol table,\r\n for getting the name of any Declaration op.\r\nThis fixes an issue with the `bind` op printing the incorrect old names.\r\n\r\n\r\n"}, {"number": 2132, "title": "[FIRRTL] InferReset crash with Subaccess Index", "created_at": "2021-11-10T16:17:03Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following IR crashes with `circt-opt --pass-pipeline='firrtl.circuit(firrtl-infer-resets)'`\r\n\r\n```mlir\r\nfirrtl.circuit \"Top\" {\r\n  firrtl.module @Top(in %clock: !firrtl.clock, in %reset: !firrtl.asyncreset, in %init: !firrtl.uint<1>, in %in: !firrtl.uint<8>, in %extraReset: !firrtl.asyncreset ) attributes {\r\n    portAnnotations = [[],[],[],[],[{class = \"firrtl.transforms.DontTouchAnnotation\"}, {class = \"sifive.enterprise.firrtl.FullAsyncResetAnnotation\"}]]} {\r\n    %c1_ui8 = firrtl.constant 1 : !firrtl.uint<2>\r\n    %arr = firrtl.wire : !firrtl.vector<uint<8>, 1>\r\n    %reg6 = firrtl.regreset %clock, %init, %c1_ui8 : !firrtl.uint<1>, !firrtl.uint<2>, !firrtl.uint<2>\r\n    %2 = firrtl.subaccess %arr[%reg6] : !firrtl.vector<uint<8>, 1>, !firrtl.uint<2>\r\n    firrtl.connect %2, %in : !firrtl.uint<8>, !firrtl.uint<8>\r\n                                                                                                                                                                                                                                              }\r\n}\r\n```\r\n\r\n```\r\nt1.mlir:6:13: error: subaccess requires vector operand, not '!firrtl.uint<2>' \r\n%reg6 = firrtl.regreset %clock, %init, %c1_ui8 : !firrtl.uint<1>, !firrtl.uint<2>, !firrtl.uint<2>\r\n^  \r\nLLVM ERROR: Failed to infer result type(s).           \r\n```\r\nSeems like `insertResetMux()` in `InferResets` doesn't handle the case when `resetValue` is not the input but `index` into `SubaccessOp` . ", "code_snippet_01": "firrtl.circuit \"Top\" {\r\n  firrtl.module @Top(in %clock: !firrtl.clock, in %reset: !firrtl.asyncreset, in %init: !firrtl.uint<1>, in %in: !firrtl.uint<8>, in %extraReset: !firrtl.asyncreset ) attributes {\r\n    portAnnotations = [[],[],[],[],[{class = \"firrtl.transforms.DontTouchAnnotation\"}, {class = \"sifive.enterprise.firrtl.FullAsyncResetAnnotation\"}]]} {\r\n    %c1_ui8 = firrtl.constant 1 : !firrtl.uint<2>\r\n    %arr = firrtl.wire : !firrtl.vector<uint<8>, 1>\r\n    %reg6 = firrtl.regreset %clock, %init, %c1_ui8 : !firrtl.uint<1>, !firrtl.uint<2>, !firrtl.uint<2>\r\n    %2 = firrtl.subaccess %arr[%reg6] : !firrtl.vector<uint<8>, 1>, !firrtl.uint<2>\r\n    firrtl.connect %2, %in : !firrtl.uint<8>, !firrtl.uint<8>\r\n                                                                                                                                                                                                                                              }\r\n}", "code_snippet_02": "t1.mlir:6:13: error: subaccess requires vector operand, not '!firrtl.uint<2>' \r\n%reg6 = firrtl.regreset %clock, %init, %c1_ui8 : !firrtl.uint<1>, !firrtl.uint<2>, !firrtl.uint<2>\r\n^  \r\nLLVM ERROR: Failed to infer result type(s)."}, {"number": 2126, "title": "[ExportVerilog] Parametric Verilog Widths Printing `w-1` as `w+MaxValue`", "created_at": "2021-11-10T04:28:49Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The following circuit:\r\n\r\n```mlir\r\nhw.module @Bar<w: i32 = 8>\r\n  (%a: !hw.int<#hw.param.decl.ref<\"w\">>) -> (b: !hw.int<#hw.param.decl.ref<\"w\">>)  {\r\n  hw.output %a : !hw.int<#hw.param.decl.ref<\"w\">>\r\n}\r\n```\r\n\r\nIs printing out as `w + 0xFFFFFFFF`:\r\n\r\n```verilog\r\nmodule Bar\r\n  #(parameter w = 8) (\r\n  input  [w + 4294967295:0] a,\r\n  output [w + 4294967295:0] b);\r\n\r\n  assign b = a;\t\r\nendmodule\r\n```\r\n\r\nThis likes like a simple problem of `-1` not showing up as intended.", "code_snippet_01": "hw.module @Bar<w: i32 = 8>\r\n  (%a: !hw.int<#hw.param.decl.ref<\"w\">>) -> (b: !hw.int<#hw.param.decl.ref<\"w\">>)  {\r\n  hw.output %a : !hw.int<#hw.param.decl.ref<\"w\">>\r\n}", "code_snippet_02": "module Bar\r\n  #(parameter w = 8) (\r\n  input  [w + 4294967295:0] a,\r\n  output [w + 4294967295:0] b);\r\n\r\n  assign b = a;\t\r\nendmodule"}, {"number": 2116, "title": "[ExportVerilog] Get legalized bind port names", "created_at": "2021-11-09T16:55:37Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The `emitBind` was using incorrect port names during `ExportVerilog`. \r\nUse `getPortVerilogName` to get the updated name. \r\nFixes https://github.com/llvm/circt/issues/2084"}, {"number": 2115, "title": "[ExportVerilog] Fix output port symbols not interpolating properly", "created_at": "2021-11-09T16:26:53Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Fix an issue in `ExportVerilog` where `hw.exportPort` symbols on output ports of a module would not be properly interpolated into `sv.verbatim` operations. This commit fixes the issue by adding the output ports to the symbol cache, and changing the interpolation of port symbols to rely on the `getPortVerilogName()` function of the `GlobalNameTable`. This has the benefit of beign consistent with the corresponding module (name collisions are resolved), and that no `BlockArgument` is required to get a hold of the output port name."}, {"number": 2109, "title": "[FIRRTL] Fix local wire/node resets not dominating inferred connections", "created_at": "2021-11-09T07:59:31Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Fix an issue in `InferResets` where using a local wire or node as the async reset for the module could cause dominance issues when the wire was declared *after* some of things it would end up getting connected to. A typical example would be:\r\n\r\n    %reg = firrtl.reg %clock\r\n    %localReset = firrtl.wire /*FullAsyncResetAnnotation*/\r\n\r\nIn this case `InferResets` would decide to hook `%localReset` up to the register `%reg`, creating a dominance problem.\r\n\r\nThis commit changes the behavior of `InferResets` such that it moves the local reset declaration up to before the first thing it gets connected to, possibly converting a `NodeOp` to a `WireOp` if the node's input value blocks the move due to it not dominating the target site.\r\n\r\nThanks to @youngar for finding this issue!"}, {"number": 2108, "title": "[SCFToCalyx] Incorrect assumptions for memory inlining.", "created_at": "2021-11-09T06:16:49Z", "state": "closed", "labels": "bug, Calyx", "body": "Currently, the SCFToCalyx pass assumes that if there is a single load from a given memory, then it can be \"inlined.\"\r\n\r\nThis means a body with a read and write to the same memory will be inlined. This leads to two individual problems:\r\n\r\n1. We probably shouldn't be reading and writing to the same memory within the same group.\r\n2. Address ports are assigned twice; this is illegal."}, {"number": 2092, "title": "[ExportVerilog] Line Breaks in SV Verbatim not Commented", "created_at": "2021-11-07T18:30:09Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The following circuit, when run through Verilog export, results in illegal Verilog:\r\n\r\n```mlir\r\nfirrtl.circuit \"Bar\"   {\r\n  firrtl.module @Foo(in %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: !firrtl.uint<1>, out %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: !firrtl.uint<1>) {\r\n    firrtl.connect %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\r\n    , %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Bar(in %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: !firrtl.uint<1>, out %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: !firrtl.uint<1>) {\r\n    %foo_a, %foo_b = firrtl.instance foo {lowerToBind=true} @Foo(in aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: !firrtl.uint<1>, out bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: !firrtl.uint<1>)\r\n    firrtl.connect %foo_a, %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb, %foo_b : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nThis produces (`firtool Bar.mlir -verilog`):\r\n\r\n```verilog\r\nmodule Foo(\t// Bar.mlir:3:5\r\n  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\r\n  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\r\n\r\n  assign bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb = \r\n                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\t// Bar.mlir:3:5\r\nendmodule\r\n\r\nmodule Bar(\t// Bar.mlir:7:5\r\n  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\r\n  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\r\n\r\n  // This instance is elsewhere emitted as a bind statement.\r\n  // Foo foo (\t// Bar.mlir:8:24\r\n  //   .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (\r\n                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),\r\n  //   .bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)\r\n  // );\r\nendmodule\r\n```\r\n\r\nThe problem appears to have been introduced in: 7d94f232\r\n\r\nPreviously, this would produce:\r\n\r\n```verilog\r\nmodule Foo(\t// Bar.mlir:3:5\r\n  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\r\n  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\r\n\r\n  assign bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\t// Bar.mlir:3:5\r\nendmodule\r\n\r\nmodule Bar(\t// Bar.mlir:7:5\r\n  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\r\n  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\r\n\r\n  // This instance is elsewhere emitted as a bind statement.\r\n  // Foo foo (\t// Bar.mlir:8:24\r\n  //   .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),\r\n  //   .bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)\r\n  // );\r\nendmodule\r\n```", "code_snippet_01": "firrtl.circuit \"Bar\"   {\r\n  firrtl.module @Foo(in %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: !firrtl.uint<1>, out %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: !firrtl.uint<1>) {\r\n    firrtl.connect %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\r\n    , %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Bar(in %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: !firrtl.uint<1>, out %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: !firrtl.uint<1>) {\r\n    %foo_a, %foo_b = firrtl.instance foo {lowerToBind=true} @Foo(in aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa: !firrtl.uint<1>, out bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb: !firrtl.uint<1>)\r\n    firrtl.connect %foo_a, %aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb, %foo_b : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_02": "module Foo(\t// Bar.mlir:3:5\r\n  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\r\n  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\r\n\r\n  assign bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb = \r\n                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\t// Bar.mlir:3:5\r\nendmodule\r\n\r\nmodule Bar(\t// Bar.mlir:7:5\r\n  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\r\n  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\r\n\r\n  // This instance is elsewhere emitted as a bind statement.\r\n  // Foo foo (\t// Bar.mlir:8:24\r\n  //   .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (\r\n                aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),\r\n  //   .bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)\r\n  // );\r\nendmodule", "code_snippet_03": "module Foo(\t// Bar.mlir:3:5\r\n  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\r\n  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\r\n\r\n  assign bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;\t// Bar.mlir:3:5\r\nendmodule\r\n\r\nmodule Bar(\t// Bar.mlir:7:5\r\n  input  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\r\n  output bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\r\n\r\n  // This instance is elsewhere emitted as a bind statement.\r\n  // Foo foo (\t// Bar.mlir:8:24\r\n  //   .aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa),\r\n  //   .bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)\r\n  // );\r\nendmodule"}, {"number": 2089, "title": "[FIRRTL] Free of Unalloc'd Pointer during Assert Parsing", "created_at": "2021-11-06T19:30:27Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following circuit is causing a free of an unallocated pointer crash inside `FIRParserAsserts.cpp`:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input a: UInt<1>\r\n\r\n    when a :\r\n      node b = eq(reset, UInt<1>(\"h0\"))\r\n      when b :\r\n        assert(clock, UInt<1>(\"h1\"), UInt<1>(\"h1\"), \"\") : assert_50\r\n        node c = eq(UInt<1>(\"h1\"), UInt<1>(\"h0\"))\r\n        when c :\r\n          printf(clock, UInt<1>(\"h1\"), \"Assertion failed: [verif-library-assert]<extraction-summary>{\\\"predicateModifier\\\":{\\\"type\\\":\\\"noMod\\\"},\\\"format\\\":{\\\"type\\\":\\\"ifElseFatal\\\"},\\\"labelExts\\\":[\\\"hello\\\"],\\\"baseMsg\\\":\\\"Assertion failed (verification library): hello  @[hello.scala 1337:42]\\\"}</extraction-summary>\\n    at world.scala:42 chisel3.assert(predicate, flag + exStr, msgArgs: _*)(sourceInfo, compileOptions)\\n\") : printf_50\r\n```\r\n\r\nI'm seeing:\r\n```\r\n# lldb firtool -- issues/free-unalloc.fir \r\n(lldb) target create \"firtool\"\r\nCurrent executable set to 'firtool' (x86_64).\r\n(lldb) settings set -- target.run-args  \"issues/free-unalloc.fir\"\r\n(lldb) r\r\nProcess 91940 launched: '/usr/bin/firtool' (x86_64)\r\nfirtool(91940,0x10499fe00) malloc: *** error for object 0x104d15c10: pointer being freed was not allocated\r\nfirtool(91940,0x10499fe00) malloc: *** set a breakpoint in malloc_error_break to debug\r\nProcess 91940 stopped\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGABRT\r\n    frame #0: 0x00007fff204c092e libsystem_kernel.dylib`__pthread_kill + 10\r\nlibsystem_kernel.dylib`__pthread_kill:\r\n->  0x7fff204c092e <+10>: jae    0x7fff204c0938            ; <+20>\r\n    0x7fff204c0930 <+12>: movq   %rax, %rdi\r\n    0x7fff204c0933 <+15>: jmp    0x7fff204baad9            ; cerror_nocancel\r\n    0x7fff204c0938 <+20>: retq   \r\nTarget 0: (firtool) stopped.\r\n(lldb) frame select 7\r\nframe #7: 0x00000001002b5fdf firtool`circt::firrtl::foldWhenEncodedVerifOp(builder=0x00007ffeefbfca60, whenStmt=WhenOp @ 0x00007ffeefbfc058) at FIRParserAsserts.cpp:302:11\r\n   299 \t          });\r\n   300 \t    }\r\n   301 \t    for (auto op : opsToErase)\r\n-> 302 \t      op->erase();\r\n   303 \t  }\r\n   304 \t\r\n   305 \t  builder.setInsertionPointAfter(whenStmt);\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input a: UInt<1>\r\n\r\n    when a :\r\n      node b = eq(reset, UInt<1>(\"h0\"))\r\n      when b :\r\n        assert(clock, UInt<1>(\"h1\"), UInt<1>(\"h1\"), \"\") : assert_50\r\n        node c = eq(UInt<1>(\"h1\"), UInt<1>(\"h0\"))\r\n        when c :\r\n          printf(clock, UInt<1>(\"h1\"), \"Assertion failed: [verif-library-assert]<extraction-summary>{\\\"predicateModifier\\\":{\\\"type\\\":\\\"noMod\\\"},\\\"format\\\":{\\\"type\\\":\\\"ifElseFatal\\\"},\\\"labelExts\\\":[\\\"hello\\\"],\\\"baseMsg\\\":\\\"Assertion failed (verification library): hello  @[hello.scala 1337:42]\\\"}</extraction-summary>\\n    at world.scala:42 chisel3.assert(predicate, flag + exStr, msgArgs: _*)(sourceInfo, compileOptions)\\n\") : printf_50", "code_snippet_02": "# lldb firtool -- issues/free-unalloc.fir \r\n(lldb) target create \"firtool\"\r\nCurrent executable set to 'firtool' (x86_64).\r\n(lldb) settings set -- target.run-args  \"issues/free-unalloc.fir\"\r\n(lldb) r\r\nProcess 91940 launched: '/usr/bin/firtool' (x86_64)\r\nfirtool(91940,0x10499fe00) malloc: *** error for object 0x104d15c10: pointer being freed was not allocated\r\nfirtool(91940,0x10499fe00) malloc: *** set a breakpoint in malloc_error_break to debug\r\nProcess 91940 stopped\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGABRT\r\n    frame #0: 0x00007fff204c092e libsystem_kernel.dylib`__pthread_kill + 10\r\nlibsystem_kernel.dylib`__pthread_kill:\r\n->  0x7fff204c092e <+10>: jae    0x7fff204c0938            ; <+20>\r\n    0x7fff204c0930 <+12>: movq   %rax, %rdi\r\n    0x7fff204c0933 <+15>: jmp    0x7fff204baad9            ; cerror_nocancel\r\n    0x7fff204c0938 <+20>: retq   \r\nTarget 0: (firtool) stopped.\r\n(lldb) frame select 7\r\nframe #7: 0x00000001002b5fdf firtool`circt::firrtl::foldWhenEncodedVerifOp(builder=0x00007ffeefbfca60, whenStmt=WhenOp @ 0x00007ffeefbfc058) at FIRParserAsserts.cpp:302:11\r\n   299 \t          });\r\n   300 \t    }\r\n   301 \t    for (auto op : opsToErase)\r\n-> 302 \t      op->erase();\r\n   303 \t  }\r\n   304 \t\r\n   305 \t  builder.setInsertionPointAfter(whenStmt);"}, {"number": 2069, "title": "[HW] [Windows] Assertion failed: !it->second.hasPort() && \"Module names should never be ports\", file C:\\code\\circt\\include\\circt/Dialect/HW/HWOps.h, line 187", "created_at": "2021-11-02T04:29:43Z", "state": "closed", "labels": "bug, HW", "body": "CIRCT on Windows is currently broken with `Assertion failed: !it->second.hasPort() && \"Module names should never be ports\", file C:\\code\\circt\\include\\circt/Dialect/HW/HWOps.h, line 187`. For instance:\r\n\r\n```\r\nFAIL: CIRCT :: Dialect/SV/prettify-verilog.mlir (121 of 300)\r\n******************** TEST 'CIRCT :: Dialect/SV/prettify-verilog.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 1';   c:\\code\\circt_build\\bin\\circt-opt.exe -prettify-verilog C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir | c:\\code\\circt_build\\bin\\filecheck.exe C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir\r\n: 'RUN: at line 2';   c:\\code\\circt_build\\bin\\circt-opt.exe -prettify-verilog C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir | c:\\code\\circt_build\\bin\\circt-opt.exe --export-verilog | c:\\code\\circt_build\\bin\\filecheck.exe C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir --check-prefix=VERILOG\r\n--\r\nExit Code: 2\r\n\r\nCommand Output (stdout):\r\n--\r\n$ \":\" \"RUN: at line 1\"\r\n$ \"c:\\code\\circt_build\\bin\\circt-opt.exe\" \"-prettify-verilog\" \"C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir\"\r\n$ \"c:\\code\\circt_build\\bin\\filecheck.exe\" \"C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir\"\r\n$ \":\" \"RUN: at line 2\"\r\n$ \"c:\\code\\circt_build\\bin\\circt-opt.exe\" \"-prettify-verilog\" \"C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir\"\r\n$ \"c:\\code\\circt_build\\bin\\circt-opt.exe\" \"--export-verilog\"\r\n# command stderr:\r\nAssertion failed: !it->second.hasPort() && \"Module names should never be ports\", file C:\\code\\circt\\include\\circt/Dialect/HW/HWOps.h, line 187\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\n #0 0x00007ff6331998cc HandleAbort C:\\code\\circt\\llvm\\llvm\\lib\\Support\\Windows\\Signals.inc:408:0\r\n #1 0x00007ffbbcf9bc31 (C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll+0x6bc31)\r\n #2 0x00007ffbbcf9d889 (C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll+0x6d889)\r\n #3 0x00007ffbbcfa30bf (C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll+0x730bf)\r\n #4 0x00007ffbbcfa1091 (C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll+0x71091)\r\n #5 0x00007ffbbcfa3a1f (C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll+0x73a1f)\r\n #6 0x00007ff63359db34 circt::hw::SymbolCache::getDefinition(class llvm::StringRef) const C:\\code\\circt\\include\\circt\\Dialect\\HW\\HWOps.h:187:0\r\n #7 0x00007ff63359d9f0 circt::hw::SymbolCache::getDefinition(class mlir::FlatSymbolRefAttr) const C:\\code\\circt\\include\\circt\\Dialect\\HW\\HWOps.h:197:0\r\n #8 0x00007ff633db9a99 circt::hw::InstanceOp::getReferencedModule(class circt::hw::SymbolCache const *) C:\\code\\circt\\lib\\Dialect\\HW\\HWOps.cpp:832:0\r\n #9 0x00007ff6335319ea `anonymous namespace'::StmtEmitter::visitStmt C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:3016:0\r\n#10 0x00007ff6335508fd <lambda_67ecaea1f18c3f2c5781c752e8551e9e>::operator()<circt::hw::InstanceOp> C:\\code\\circt\\include\\circt\\Dialect\\HW\\HWVisitors.h:84:0\r\n#11 0x00007ff63355a605 llvm::TypeSwitch<mlir::Operation *,mlir::LogicalResult>::Case<circt::hw::InstanceOp,<lambda_67ecaea1f18c3f2c5781c752e8551e9e> &> C:\\code\\circt\\llvm\\llvm\\include\\llvm\\ADT\\TypeSwitch.h:121:0\r\n#12 0x00007ff63355c83c llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation *,mlir::LogicalResult>,mlir::Operation *>::Case<circt::hw::OutputOp,circt::hw::InstanceOp,<lambda_67ecaea1f18c3f2c5781c752e8551e9e> > C:\\code\\circt\\llvm\\llvm\\include\\llvm\\ADT\\TypeSwitch.h:47:0\r\n#13 0x00007ff63352e7cb circt::hw::StmtVisitor<`anonymous namespace'::StmtEmitter,mlir::LogicalResult>::dispatchStmtVisitor C:\\code\\circt\\include\\circt\\Dialect\\HW\\HWVisitors.h:82:0\r\n#14 0x00007ff63352ef03 `anonymous namespace'::StmtEmitter::emitStatement C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:3228:0\r\n#15 0x00007ff63352f15e `anonymous namespace'::StmtEmitter::emitStatementBlock C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:3429:0\r\n#16 0x00007ff633522d73 `anonymous namespace'::ModuleEmitter::emitHWModule C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:3775:0\r\n#17 0x00007ff63354ffcc <lambda_5180d4edfd1d3e51638c180167ed63ea>::operator()<circt::hw::HWModuleOp> C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:4105:0\r\n#18 0x00007ff633558f85 llvm::TypeSwitch<mlir::Operation *,void>::Case<circt::hw::HWModuleOp,<lambda_5180d4edfd1d3e51638c180167ed63ea> > C:\\code\\circt\\llvm\\llvm\\include\\llvm\\ADT\\TypeSwitch.h:170:0\r\n#19 0x00007ff63353d386 emitOperation C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:4104:0\r\n#20 0x00007ff63353d812 <lambda_a9ede889d1b3f22089910ed89a310f8b>::operator() C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:4171:0\r\n#21 0x00007ff63354d1cf <lambda_7050d41f794d1e46a912ba0add2fdfba>::operator()<`anonymous namespace'::StringOrOpToEmit &> C:\\code\\circt\\llvm\\mlir\\include\\mlir\\IR\\Threading.h:125:0\r\n#22 0x00007ff633540f5f <lambda_61ef71485879529b202dab933c69d60c>::operator() C:\\code\\circt\\llvm\\mlir\\include\\mlir\\IR\\Threading.h:65:0\r\n#23 0x00007ff633577e74 std::invoke<<lambda_61ef71485879529b202dab933c69d60c> &> C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits:1586:0\r\n#24 0x00007ff633562a74 std::_Invoker_ret<void,1>::_Call<<lambda_61ef71485879529b202dab933c69d60c> &> C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\functional:745:0\r\n#25 0x00007ff6335413cb std::_Func_impl_no_alloc<<lambda_61ef71485879529b202dab933c69d60c>,void>::_Do_call C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\functional:921:0\r\n#26 0x00007ff6337bfb3f std::_Func_class<void>::operator()(void) const C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\functional:969:0\r\n#27 0x00007ff635317fd4 std::_Packaged_state<(void)>::_Call_immediate(void) C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\future:604:0\r\n#28 0x00007ff635317b50 std::packaged_task<(void)>::operator()(void) C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\future:1399:0\r\n#29 0x00007ff635314cda <lambda_363bb815a5743b94ed5a743b9a07bcb7>::operator() C:\\code\\circt\\llvm\\llvm\\lib\\Support\\ThreadPool.cpp:56:0\r\n#30 0x00007ff635315718 llvm::thread::Apply<<lambda_363bb815a5743b94ed5a743b9a07bcb7> > C:\\code\\circt\\llvm\\llvm\\include\\llvm\\Support\\thread.h:43:0\r\n#31 0x00007ff635315787 llvm::thread::GenericThreadProxy<std::tuple<<lambda_363bb815a5743b94ed5a743b9a07bcb7> > > C:\\code\\circt\\llvm\\llvm\\include\\llvm\\Support\\thread.h:51:0\r\n#32 0x00007ff6353157e4 llvm::thread::ThreadProxy<std::tuple<<lambda_363bb815a5743b94ed5a743b9a07bcb7> > > C:\\code\\circt\\llvm\\llvm\\include\\llvm\\Support\\thread.h:71:0\r\n#33 0x00007ffbbcfa4c7c (C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll+0x74c7c)\r\n#34 0x00007ffc2d1d54e0 (C:\\WINDOWS\\System32\\KERNEL32.DLL+0x154e0)\r\n#35 0x00007ffc2dce485b (C:\\WINDOWS\\SYSTEM32\\ntdll.dll+0x485b)\r\n\r\nerror: command failed with exit status: 2147483651\r\n$ \"c:\\code\\circt_build\\bin\\filecheck.exe\" \"C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir\" \"--check-prefix=VERILOG\"\r\n# command stderr:\r\nFileCheck error: '<stdin>' is empty.\r\nFileCheck command line:  c:\\code\\circt_build\\bin\\filecheck.exe C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir --check-prefix=VERILOG\r\n\r\nerror: command failed with exit status: 2\r\n\r\n--\r\n```\r\n\r\n@darthscsi Since you touched this line 6 days ago, I'm assigning this to you. ", "code_snippet_01": "FAIL: CIRCT :: Dialect/SV/prettify-verilog.mlir (121 of 300)\r\n******************** TEST 'CIRCT :: Dialect/SV/prettify-verilog.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 1';   c:\\code\\circt_build\\bin\\circt-opt.exe -prettify-verilog C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir | c:\\code\\circt_build\\bin\\filecheck.exe C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir\r\n: 'RUN: at line 2';   c:\\code\\circt_build\\bin\\circt-opt.exe -prettify-verilog C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir | c:\\code\\circt_build\\bin\\circt-opt.exe --export-verilog | c:\\code\\circt_build\\bin\\filecheck.exe C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir --check-prefix=VERILOG\r\n--\r\nExit Code: 2\r\n\r\nCommand Output (stdout):\r\n--\r\n$ \":\" \"RUN: at line 1\"\r\n$ \"c:\\code\\circt_build\\bin\\circt-opt.exe\" \"-prettify-verilog\" \"C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir\"\r\n$ \"c:\\code\\circt_build\\bin\\filecheck.exe\" \"C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir\"\r\n$ \":\" \"RUN: at line 2\"\r\n$ \"c:\\code\\circt_build\\bin\\circt-opt.exe\" \"-prettify-verilog\" \"C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir\"\r\n$ \"c:\\code\\circt_build\\bin\\circt-opt.exe\" \"--export-verilog\"\r\n# command stderr:\r\nAssertion failed: !it->second.hasPort() && \"Module names should never be ports\", file C:\\code\\circt\\include\\circt/Dialect/HW/HWOps.h, line 187\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\n #0 0x00007ff6331998cc HandleAbort C:\\code\\circt\\llvm\\llvm\\lib\\Support\\Windows\\Signals.inc:408:0\r\n #1 0x00007ffbbcf9bc31 (C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll+0x6bc31)\r\n #2 0x00007ffbbcf9d889 (C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll+0x6d889)\r\n #3 0x00007ffbbcfa30bf (C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll+0x730bf)\r\n #4 0x00007ffbbcfa1091 (C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll+0x71091)\r\n #5 0x00007ffbbcfa3a1f (C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll+0x73a1f)\r\n #6 0x00007ff63359db34 circt::hw::SymbolCache::getDefinition(class llvm::StringRef) const C:\\code\\circt\\include\\circt\\Dialect\\HW\\HWOps.h:187:0\r\n #7 0x00007ff63359d9f0 circt::hw::SymbolCache::getDefinition(class mlir::FlatSymbolRefAttr) const C:\\code\\circt\\include\\circt\\Dialect\\HW\\HWOps.h:197:0\r\n #8 0x00007ff633db9a99 circt::hw::InstanceOp::getReferencedModule(class circt::hw::SymbolCache const *) C:\\code\\circt\\lib\\Dialect\\HW\\HWOps.cpp:832:0\r\n #9 0x00007ff6335319ea `anonymous namespace'::StmtEmitter::visitStmt C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:3016:0\r\n#10 0x00007ff6335508fd <lambda_67ecaea1f18c3f2c5781c752e8551e9e>::operator()<circt::hw::InstanceOp> C:\\code\\circt\\include\\circt\\Dialect\\HW\\HWVisitors.h:84:0\r\n#11 0x00007ff63355a605 llvm::TypeSwitch<mlir::Operation *,mlir::LogicalResult>::Case<circt::hw::InstanceOp,<lambda_67ecaea1f18c3f2c5781c752e8551e9e> &> C:\\code\\circt\\llvm\\llvm\\include\\llvm\\ADT\\TypeSwitch.h:121:0\r\n#12 0x00007ff63355c83c llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation *,mlir::LogicalResult>,mlir::Operation *>::Case<circt::hw::OutputOp,circt::hw::InstanceOp,<lambda_67ecaea1f18c3f2c5781c752e8551e9e> > C:\\code\\circt\\llvm\\llvm\\include\\llvm\\ADT\\TypeSwitch.h:47:0\r\n#13 0x00007ff63352e7cb circt::hw::StmtVisitor<`anonymous namespace'::StmtEmitter,mlir::LogicalResult>::dispatchStmtVisitor C:\\code\\circt\\include\\circt\\Dialect\\HW\\HWVisitors.h:82:0\r\n#14 0x00007ff63352ef03 `anonymous namespace'::StmtEmitter::emitStatement C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:3228:0\r\n#15 0x00007ff63352f15e `anonymous namespace'::StmtEmitter::emitStatementBlock C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:3429:0\r\n#16 0x00007ff633522d73 `anonymous namespace'::ModuleEmitter::emitHWModule C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:3775:0\r\n#17 0x00007ff63354ffcc <lambda_5180d4edfd1d3e51638c180167ed63ea>::operator()<circt::hw::HWModuleOp> C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:4105:0\r\n#18 0x00007ff633558f85 llvm::TypeSwitch<mlir::Operation *,void>::Case<circt::hw::HWModuleOp,<lambda_5180d4edfd1d3e51638c180167ed63ea> > C:\\code\\circt\\llvm\\llvm\\include\\llvm\\ADT\\TypeSwitch.h:170:0\r\n#19 0x00007ff63353d386 emitOperation C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:4104:0\r\n#20 0x00007ff63353d812 <lambda_a9ede889d1b3f22089910ed89a310f8b>::operator() C:\\code\\circt\\lib\\Conversion\\ExportVerilog\\ExportVerilog.cpp:4171:0\r\n#21 0x00007ff63354d1cf <lambda_7050d41f794d1e46a912ba0add2fdfba>::operator()<`anonymous namespace'::StringOrOpToEmit &> C:\\code\\circt\\llvm\\mlir\\include\\mlir\\IR\\Threading.h:125:0\r\n#22 0x00007ff633540f5f <lambda_61ef71485879529b202dab933c69d60c>::operator() C:\\code\\circt\\llvm\\mlir\\include\\mlir\\IR\\Threading.h:65:0\r\n#23 0x00007ff633577e74 std::invoke<<lambda_61ef71485879529b202dab933c69d60c> &> C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\type_traits:1586:0\r\n#24 0x00007ff633562a74 std::_Invoker_ret<void,1>::_Call<<lambda_61ef71485879529b202dab933c69d60c> &> C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\functional:745:0\r\n#25 0x00007ff6335413cb std::_Func_impl_no_alloc<<lambda_61ef71485879529b202dab933c69d60c>,void>::_Do_call C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\functional:921:0\r\n#26 0x00007ff6337bfb3f std::_Func_class<void>::operator()(void) const C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\functional:969:0\r\n#27 0x00007ff635317fd4 std::_Packaged_state<(void)>::_Call_immediate(void) C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\future:604:0\r\n#28 0x00007ff635317b50 std::packaged_task<(void)>::operator()(void) C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Tools\\MSVC\\14.29.30133\\include\\future:1399:0\r\n#29 0x00007ff635314cda <lambda_363bb815a5743b94ed5a743b9a07bcb7>::operator() C:\\code\\circt\\llvm\\llvm\\lib\\Support\\ThreadPool.cpp:56:0\r\n#30 0x00007ff635315718 llvm::thread::Apply<<lambda_363bb815a5743b94ed5a743b9a07bcb7> > C:\\code\\circt\\llvm\\llvm\\include\\llvm\\Support\\thread.h:43:0\r\n#31 0x00007ff635315787 llvm::thread::GenericThreadProxy<std::tuple<<lambda_363bb815a5743b94ed5a743b9a07bcb7> > > C:\\code\\circt\\llvm\\llvm\\include\\llvm\\Support\\thread.h:51:0\r\n#32 0x00007ff6353157e4 llvm::thread::ThreadProxy<std::tuple<<lambda_363bb815a5743b94ed5a743b9a07bcb7> > > C:\\code\\circt\\llvm\\llvm\\include\\llvm\\Support\\thread.h:71:0\r\n#33 0x00007ffbbcfa4c7c (C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll+0x74c7c)\r\n#34 0x00007ffc2d1d54e0 (C:\\WINDOWS\\System32\\KERNEL32.DLL+0x154e0)\r\n#35 0x00007ffc2dce485b (C:\\WINDOWS\\SYSTEM32\\ntdll.dll+0x485b)\r\n\r\nerror: command failed with exit status: 2147483651\r\n$ \"c:\\code\\circt_build\\bin\\filecheck.exe\" \"C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir\" \"--check-prefix=VERILOG\"\r\n# command stderr:\r\nFileCheck error: '<stdin>' is empty.\r\nFileCheck command line:  c:\\code\\circt_build\\bin\\filecheck.exe C:\\code\\circt\\test\\Dialect\\SV\\prettify-verilog.mlir --check-prefix=VERILOG\r\n\r\nerror: command failed with exit status: 2\r\n\r\n--"}, {"number": 2047, "title": "[FIRRTL] Make GCT data tap hierarchical names start at module", "created_at": "2021-10-28T08:02:09Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Change how GCT data/memory taps are generated by always starting the hierarchical names with a module. This removes ambiguities where a local declaration `bar` could shadow an instance `bar` in a parent module, rendering the XMR `bar.x` invalid. Also, if a signal is tapped in the same module where the data taps module is instantiated, the resulting hierarchical name would just be `x`, which in SV is not a hierarchical name and causes no resolution against the `x` in the parent module we're interested in. Always inserting a module name prefix removes any such ambiguity, generates a hierarchical name in any case, and causes SV to properly look upwards in the instance graph until that parent module is found."}, {"number": 2041, "title": "[FIRRTL] Extend when-encoded assert pattern detection in parser", "created_at": "2021-10-27T09:08:09Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Extend the FIR file parser's ability to detect when-encoded assertions. In recent Chisel versions, these have slightly changed to now be of the form:\r\n\r\n    assert(clock, cond, enable, \"msg\")\r\n    node T = eq(cond, UInt<1>(0))\r\n    when T:\r\n      printf(clock, enable, \"Assertion failed: msg\")\r\n\r\nThe previous implementation of the FIR parser only detects the following pattern:\r\n\r\n    when not_cond:\r\n      printf(clock, enable, \"Assertion failed: msg\")\r\n      stop(clock, enable, 1)\r\n\r\nThis fixes issues SiFive has seen on FIRRTL emitted from never versions of Chisel. Originally found by @Ramlakshmi3733."}, {"number": 2039, "title": "[FIRRTL] Fix SRAM instance paths in OMIR", "created_at": "2021-10-26T14:57:19Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Fix an issue in `EmitOMIR` where the instance paths of SRAMs would be incorrectly rendered as `OMMemberReferenceTarget` instead of the correct `OMMemberInstanceTarget`. This also includes figuring out the module name that the final SRAM is going to have, which in the case of a `firrtl.mem` is a bit tricky/fragile: the actual module name for the memory is only generated after lowering to the HW dialect, at which point the OMIR has long been emitted. This change \"predicts\" the name that the memory is going to have by querying `getFirMemoryName()`, which looks like it's going to be accurate in most cases we currently care about.\r\n\r\nIn the long run, we'll want better ways to encode this formulation of an instance path and ideally dealy it until `ExportVerilog` time."}, {"number": 2036, "title": "Analysis/scheduling-analysis.mlir failing on release builds", "created_at": "2021-10-25T23:48:19Z", "state": "closed", "labels": "bug", "body": "Analysis/scheduling-analysis.mlir is failing for me on release, but not debug builds on multiple machines.  This clearly isn't affecting everybody.\r\nI am not seeing:\r\n`arith.addi %arg2, %1 {dependence}`\r\nbut rather\r\n`      %2 = arith.addi %arg2, %1 : i32`\r\nin the output (for example)."}, {"number": 2029, "title": "[FIRRTL] RemoveCHIRRTL Should Lower Unused Memories (or at least repsect DontTouch)", "created_at": "2021-10-22T17:54:24Z", "state": "open", "labels": "bug, FIRRTL", "body": "If you have an unused behavior memory in FIRRTL, the SFC will lower this to a memory that has no ports. This is a candidate for later DCE, but won't be DCE'd if there is a don't touch annotation. \r\n\r\nIn CIRCT, we are deleting behavioral memories which have no users, i.e., DCE'ing unused memories during RemoveCHIRRTL,  and not respecting a dont touch annotation that may exist.\r\n\r\nI expect that this has no effect on \"sane\" designs and is consequently a low priority bug. For more info, I hit this when writing some test cases for Grand Central where I didn't want to hook up my memories. \ud83d\ude05 "}, {"number": 2027, "title": "[FIRRTL] Prefix Grand Central Data/Mem Taps", "created_at": "2021-10-22T05:33:29Z", "state": "closed", "labels": "bug, FIRRTL", "body": "I believe that https://github.com/llvm/circt/pull/2020 needs to be extended to work with Grand Central data and mem tap blackboxes. Likely, this needs the same approach as #2020 where prefix modules is updated to mutate data/mem tap annotations. That should be enough for `GrandCentralTaps` to use the new names without modifications."}, {"number": 2026, "title": "[FIRRTL] BlackBoxMemory Pass Needs to Handle All Annotations", "created_at": "2021-10-22T04:43:51Z", "state": "open", "labels": "bug, FIRRTL", "body": "The `BlackBoxMemory` pass was updated to copy annotations from memories onto the blackboxed instance in f239be4cd23bb21a1a19854f5bdc325ddf953ec1. However, port annotations are currently being dropped.\r\n\r\nUpdate this pass to copy over port annotations with the following strategy:\r\n- An annotation on a memory port should be applied to all flattened ports associated with the original port\r\n- An annotation on a specific field of a memory port should be copied to its respective flattened new port\r\n\r\nAdditionally, it may make more sense to copy annotations onto the external module as opposed to onto the instance (which is how f239be4cd23bb21a1a19854f5bdc325ddf953ec1) does it. One or the other should be entirely equivalent (from the perspective of preserving the information, though copying onto the module may be better)."}, {"number": 1996, "title": "[FIRRTL] Mark extmodules that had black box anno consumed", "created_at": "2021-10-14T17:41:08Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Fix an issue where generating metadata after the blackbox reader pass has run would cause additional blackbox modules to appear in the generated metadata. This happens because the blackbox reader removes the blackbox annotations, which the metadata pass is looking for to blacklist the corresponding extmodules.\r\n\r\nThis change causes the blackbox reader pass to add a `BlackBox` annotation on any extmodule for which it has processed one of the blackbox annotations. The metadata pass then additionally blacklists this annotation. Also add a unit and integration test to ensure this happens.\r\n\r\nFixes an issue in the SiFive flow (@Ramlakshmi3733)."}, {"number": 1988, "title": "[Simulator] UB when using llhd.shr on signal", "created_at": "2021-10-13T10:26:15Z", "state": "open", "labels": "bug, LLHD, Simulator", "body": "The following code leads to UB in the output trace, although, the semantics are clearly defined. This is because of a bug in the `ShrOpConversion` pattern in the `LLHDToLLVM` pass, where there is a slice extract performed only on the `%basesig` value instead of a concatenation of hidden and base.\r\n\r\n```mlir\r\nllhd.entity @root () -> () {\r\n  %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>\r\n\r\n  %hidden = hw.constant 0xff : i8\r\n  %base = hw.constant 0 : i8\r\n  %amnt = hw.constant 4 : i3\r\n\r\n  %resultsig = llhd.sig \"result\" %base : i8\r\n  %basesig = llhd.sig \"base\" %base : i8\r\n  %hiddensig = llhd.sig \"hidden\" %hidden : i8\r\n  %shr = llhd.shr %basesig, %hiddensig, %amnt : (!llhd.sig<i8>, !llhd.sig<i8>, i3) -> !llhd.sig<i8>\r\n  %prbshr = llhd.prb %shr : !llhd.sig<i8>\r\n  llhd.drv %resultsig, %prbshr after %time : !llhd.sig<i8>\r\n}\r\n```\r\n\r\nExpected output:\r\n```\r\n0ps 0d 0e  root/base  0x00\r\n0ps 0d 0e  root/hidden  0xff\r\n0ps 0d 0e  root/result  0x00\r\n1000ps 0d 0e  root/result  0xf0         // UB here (also seen 0x70, 0x10, etc.)\r\nFinished at 2000ps 0d 0e (3 cycles)\r\n```", "code_snippet_01": "llhd.entity @root () -> () {\r\n  %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>\r\n\r\n  %hidden = hw.constant 0xff : i8\r\n  %base = hw.constant 0 : i8\r\n  %amnt = hw.constant 4 : i3\r\n\r\n  %resultsig = llhd.sig \"result\" %base : i8\r\n  %basesig = llhd.sig \"base\" %base : i8\r\n  %hiddensig = llhd.sig \"hidden\" %hidden : i8\r\n  %shr = llhd.shr %basesig, %hiddensig, %amnt : (!llhd.sig<i8>, !llhd.sig<i8>, i3) -> !llhd.sig<i8>\r\n  %prbshr = llhd.prb %shr : !llhd.sig<i8>\r\n  llhd.drv %resultsig, %prbshr after %time : !llhd.sig<i8>\r\n}", "code_snippet_02": "0ps 0d 0e  root/base  0x00\r\n0ps 0d 0e  root/hidden  0xff\r\n0ps 0d 0e  root/result  0x00\r\n1000ps 0d 0e  root/result  0xf0         // UB here (also seen 0x70, 0x10, etc.)\r\nFinished at 2000ps 0d 0e (3 cycles)"}, {"number": 1971, "title": "[FIRRTL] Annotation Parsing Performance Bug", "created_at": "2021-10-11T19:50:49Z", "state": "closed", "labels": "bug, FIRRTL", "body": "As found by @Ramlakshmi3733, large designs seem to exhibit bad scaling performance with the existing FIRRTL Parser's annotation parsing/scattering.  I don't have a minimal example, but a \"large\" design is spending 50% of its total compile in the parser and ~60% of the parser time appears to be dealing with annotations. (This was tested by running with and without an annotation file.)\r\n\r\nWe should figure out what's going on here.  This likely involves moving the annotation scattering/application into the annotation handling pass and removing the old processing logic."}, {"number": 1969, "title": "[FIRRTL] Investigate, Fix Grand Central Slowness", "created_at": "2021-10-11T13:40:55Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The Grand Central (`lib/Dialect/FIRRTL/Transforms/GrandCentral.cpp`), Grand Central Taps (`lib/Dialect/FIRRTL/Transforms/GrandCentralTaps.cpp`), and Grand Central Signal Mappings (`lib/Dialect/FIRRTL/Transforms/GrandCentralSignalMappings.cpp`) have been reported as running slow on large designs (with duplicated modules). Investigate what's going on here and fix it.\r\n\r\nSome ideas:\r\n\r\n1. (@fabianschuiki states) that this may just be stemming from the lack of deduplication, so this is the expected scaling we get.\r\n2. (@Ramlakshmi3733 suggests) exploring parallelizing these passes. There may be some issues here as the passes are mostly just a two-phase process of collecting information during a global walk, then adding IR constructs. The collect information phase could be parallelized (with workers competing to write to a global data store?).\r\n3. Combine all these passes.\r\n4. Promote Grand Central information collection to an analysis then remove Grand Central annotations during `LowerToHW`.\r\n5. (@fabianschuiki suggests) leaving breadcrumbs on the FIRRTL modules during scattering indicating that they have no GCT-related information. This would speed up the walk by avoiding modules that will not contribute to a GCT construct. (EmitSignalMappings already works this way.)\r\n"}, {"number": 1902, "title": "[FIRRTL] Fix use of invalidated iterators in InferResets", "created_at": "2021-09-29T14:01:50Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Fix two issues in InferResets:\r\n\r\n1.  References into a dense map that may get invalidated while being live by inserts being done into the map through subsequent accesses.\r\n2.  Vectors being `std::move`d out of potentially multiple times. This is problematic because the move may leave an invalid vector behind which is no longer safe to access again. The fix properly uses a `std::swap` to move data out of the vector and leave an empty one behind."}, {"number": 1851, "title": "[FIRRTL] (mem) sv.alwaysff should be in a non-procedural region", "created_at": "2021-09-22T21:19:31Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 51\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input inp_k: SInt<0>\r\n    input inp_cb: UInt<0>\r\n    mem tmp153:\r\n      data-type => SInt<4>\r\n      depth => 9\r\n      read-latency => 1\r\n      write-latency => 2\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n      writer => w1\r\n      writer => w2\r\n    tmp153.r0.clk <= clock\r\n    tmp153.r0.en <= asUInt(inp_k)\r\n    tmp153.r0.addr <= asUInt(SInt<31>(-596888200))\r\n    tmp153.w0.clk <= clock\r\n    tmp153.w0.en <= head(UInt<18>(\"o14004\"), 1)\r\n    tmp153.w0.addr <= inp_cb\r\n    tmp153.w0.data <= inp_k\r\n    tmp153.w0.mask <= asUInt(SInt<26>(\"h1875d5c\"))\r\n    tmp153.w1.clk <= clock\r\n    tmp153.w1.en <= head(asUInt(SInt<4>(0)), 1)\r\n    tmp153.w1.addr <= asUInt(inp_k)\r\n    tmp153.w1.data <= SInt<31>(\"h13a08ea3\")\r\n    tmp153.w1.mask <= asUInt(inp_k)\r\n    tmp153.w2.clk <= clock\r\n    tmp153.w2.en <= head(asUInt(SInt<26>(\"o-45356020\")), 1)\r\n    tmp153.w2.addr <= asUInt(inp_k)\r\n    tmp153.w2.data <= inp_k\r\n    tmp153.w2.mask <= asUInt(inp_k)\r\n    node tmp154 = tmp153.r0.data\r\n```\r\n\r\nCompiled with `firtool  --verilog -o=$VFILE2` produces this Error:\r\n\r\n```mlir\r\n<unknown>:0: error: sv.alwaysff should be in a non-procedural region\r\n<unknown>:0: note: see current operation: \"sv.alwaysff\"(%arg13) ( {\r\n  \"sv.passign\"(%27, %arg14) : (!hw.inout<i1>, i1) -> ()\r\n},  {\r\n}) {clockEdge = 0 : i32, resetStyle = 0 : i32} : (i1) -> ()\r\n```\r\n", "code_snippet_01": "; seed: 51\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input inp_k: SInt<0>\r\n    input inp_cb: UInt<0>\r\n    mem tmp153:\r\n      data-type => SInt<4>\r\n      depth => 9\r\n      read-latency => 1\r\n      write-latency => 2\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n      writer => w1\r\n      writer => w2\r\n    tmp153.r0.clk <= clock\r\n    tmp153.r0.en <= asUInt(inp_k)\r\n    tmp153.r0.addr <= asUInt(SInt<31>(-596888200))\r\n    tmp153.w0.clk <= clock\r\n    tmp153.w0.en <= head(UInt<18>(\"o14004\"), 1)\r\n    tmp153.w0.addr <= inp_cb\r\n    tmp153.w0.data <= inp_k\r\n    tmp153.w0.mask <= asUInt(SInt<26>(\"h1875d5c\"))\r\n    tmp153.w1.clk <= clock\r\n    tmp153.w1.en <= head(asUInt(SInt<4>(0)), 1)\r\n    tmp153.w1.addr <= asUInt(inp_k)\r\n    tmp153.w1.data <= SInt<31>(\"h13a08ea3\")\r\n    tmp153.w1.mask <= asUInt(inp_k)\r\n    tmp153.w2.clk <= clock\r\n    tmp153.w2.en <= head(asUInt(SInt<26>(\"o-45356020\")), 1)\r\n    tmp153.w2.addr <= asUInt(inp_k)\r\n    tmp153.w2.data <= inp_k\r\n    tmp153.w2.mask <= asUInt(inp_k)\r\n    node tmp154 = tmp153.r0.data", "code_snippet_02": "<unknown>:0: error: sv.alwaysff should be in a non-procedural region\r\n<unknown>:0: note: see current operation: \"sv.alwaysff\"(%arg13) ( {\r\n  \"sv.passign\"(%27, %arg14) : (!hw.inout<i1>, i1) -> ()\r\n},  {\r\n}) {clockEdge = 0 : i32, resetStyle = 0 : i32} : (i1) -> ()"}, {"number": 1828, "title": "[FIRRTL] BlackBoxInlineAnno file path", "created_at": "2021-09-21T19:55:07Z", "state": "closed", "labels": "bug", "body": "Annotation:\r\n```json\r\n    \"class\":\"firrtl.transforms.BlackBoxInlineAnno\",\r\n    \"target\":\"CoreIPSubsystemVerifTestHarness.DummyVroom\",\r\n```\r\nNeeds to pay attention to:\r\n```json\r\n    \"class\":\"sifive.enterprise.firrtl.TestBenchDirAnnotation\",\r\n```\r\nto place files in correct directory", "code_snippet_01": "\"class\":\"firrtl.transforms.BlackBoxInlineAnno\",\r\n    \"target\":\"CoreIPSubsystemVerifTestHarness.DummyVroom\",", "code_snippet_02": "\"class\":\"sifive.enterprise.firrtl.TestBenchDirAnnotation\","}, {"number": 1822, "title": "[HW] Empty port names can't be roundtripped", "created_at": "2021-09-21T15:13:45Z", "state": "closed", "labels": "bug", "body": "modules made with empty names for arguments print out like this, which then doesn't parse.\r\n```\r\nhw.module @foo(%arg1: i32) attributes {argNames = [\"\"]} {\r\n}\r\n```", "code_snippet_01": "hw.module @foo(%arg1: i32) attributes {argNames = [\"\"]} {\r\n}"}, {"number": 1802, "title": "[Calyx] Missing emission of 'else' branches", "created_at": "2021-09-16T14:53:23Z", "state": "closed", "labels": "bug, Calyx", "body": "In the following program, the \"else\" branch of the control `if`-statement missing in the emitted native Calyx IR, when running `circt-translate --export-calyx`:\r\n```mlir\r\nmodule  {\r\n  calyx.program  {\r\n    calyx.component @main(%in0: i32, %in1: i32, %clk: i1 {clk}, %reset: i1 {reset}, %go: i1 {go}) -> (%out0: i32, %done: i1 {done}) {\r\n      %true = hw.constant true\r\n      %std_add_2.left, %std_add_2.right, %std_add_2.out = calyx.std_add \"std_add_2\" : i32, i32, i32\r\n      %std_add_1.left, %std_add_1.right, %std_add_1.out = calyx.std_add \"std_add_1\" : i32, i32, i32\r\n      %std_add_0.left, %std_add_0.right, %std_add_0.out = calyx.std_add \"std_add_0\" : i32, i32, i32\r\n      %std_sub_1.left, %std_sub_1.right, %std_sub_1.out = calyx.std_sub \"std_sub_1\" : i32, i32, i32\r\n      %std_sub_0.left, %std_sub_0.right, %std_sub_0.out = calyx.std_sub \"std_sub_0\" : i32, i32, i32\r\n      %std_ge_0.left, %std_ge_0.right, %std_ge_0.out = calyx.std_ge \"std_ge_0\" : i32, i32, i1\r\n      %ret_arg0_reg.in, %ret_arg0_reg.write_en, %ret_arg0_reg.clk, %ret_arg0_reg.reset, %ret_arg0_reg.out, %ret_arg0_reg.done = calyx.register \"ret_arg0_reg\" : i32, i1, i1, i1, i32, i1\r\n      %bb3_arg1_reg.in, %bb3_arg1_reg.write_en, %bb3_arg1_reg.clk, %bb3_arg1_reg.reset, %bb3_arg1_reg.out, %bb3_arg1_reg.done = calyx.register \"bb3_arg1_reg\" : i32, i1, i1, i1, i32, i1\r\n      %bb3_arg0_reg.in, %bb3_arg0_reg.write_en, %bb3_arg0_reg.clk, %bb3_arg0_reg.reset, %bb3_arg0_reg.out, %bb3_arg0_reg.done = calyx.register \"bb3_arg0_reg\" : i32, i1, i1, i1, i32, i1\r\n      %bb2_arg0_reg.in, %bb2_arg0_reg.write_en, %bb2_arg0_reg.clk, %bb2_arg0_reg.reset, %bb2_arg0_reg.out, %bb2_arg0_reg.done = calyx.register \"bb2_arg0_reg\" : i32, i1, i1, i1, i32, i1\r\n      %bb1_arg0_reg.in, %bb1_arg0_reg.write_en, %bb1_arg0_reg.clk, %bb1_arg0_reg.reset, %bb1_arg0_reg.out, %bb1_arg0_reg.done = calyx.register \"bb1_arg0_reg\" : i32, i1, i1, i1, i32, i1\r\n      calyx.wires  {\r\n        calyx.assign %out0 = %ret_arg0_reg.out : i32\r\n        calyx.group @bb0_to_bb1  {\r\n          calyx.assign %bb1_arg0_reg.in = %in0 : i32\r\n          calyx.assign %bb1_arg0_reg.write_en = %true : i1\r\n          calyx.group_done %bb1_arg0_reg.done : i1\r\n        }\r\n        calyx.group @bb0_to_bb2  {\r\n          calyx.assign %bb2_arg0_reg.in = %in1 : i32\r\n          calyx.assign %bb2_arg0_reg.write_en = %true : i1\r\n          calyx.group_done %bb2_arg0_reg.done : i1\r\n        }\r\n        calyx.group @bb1_to_bb3  {\r\n          calyx.assign %bb3_arg0_reg.in = %std_sub_0.out : i32\r\n          calyx.assign %bb3_arg0_reg.write_en = %true : i1\r\n          calyx.assign %bb3_arg1_reg.in = %std_sub_1.out : i32\r\n          calyx.assign %bb3_arg1_reg.write_en = %true : i1\r\n          calyx.assign %std_sub_0.left = %bb1_arg0_reg.out : i32\r\n          calyx.assign %std_sub_0.right = %in1 : i32\r\n          calyx.assign %std_sub_1.left = %bb1_arg0_reg.out : i32\r\n          calyx.assign %std_sub_1.right = %in0 : i32\r\n          %0 = comb.and %bb3_arg0_reg.done, %bb3_arg1_reg.done : i1\r\n          calyx.group_done %true, %0 ? : i1\r\n        }\r\n        calyx.group @bb2_to_bb3  {\r\n          calyx.assign %bb3_arg0_reg.in = %std_add_0.out : i32\r\n          calyx.assign %bb3_arg0_reg.write_en = %true : i1\r\n          calyx.assign %bb3_arg1_reg.in = %std_add_1.out : i32\r\n          calyx.assign %bb3_arg1_reg.write_en = %true : i1\r\n          calyx.assign %std_add_0.left = %bb2_arg0_reg.out : i32\r\n          calyx.assign %std_add_0.right = %in1 : i32\r\n          calyx.assign %std_add_1.left = %bb2_arg0_reg.out : i32\r\n          calyx.assign %std_add_1.right = %in0 : i32\r\n          %0 = comb.and %bb3_arg0_reg.done, %bb3_arg1_reg.done : i1\r\n          calyx.group_done %true, %0 ? : i1\r\n        }\r\n        calyx.group @ret_assign_0  {\r\n          calyx.assign %ret_arg0_reg.in = %std_add_2.out : i32\r\n          calyx.assign %ret_arg0_reg.write_en = %true : i1\r\n          calyx.assign %std_add_2.left = %bb3_arg0_reg.out : i32\r\n          calyx.assign %std_add_2.right = %bb3_arg1_reg.out : i32\r\n          calyx.group_done %ret_arg0_reg.done : i1\r\n        }\r\n        calyx.comb_group @comb_bb0_0  {\r\n          calyx.assign %std_ge_0.left = %in0 : i32\r\n          calyx.assign %std_ge_0.right = %in1 : i32\r\n        }\r\n      }\r\n      calyx.control  {\r\n        calyx.seq  {\r\n          calyx.if %std_ge_0.out with @comb_bb0_0  {\r\n            calyx.seq  {\r\n              calyx.enable @bb0_to_bb1 {compiledGroups = []}\r\n              calyx.enable @bb1_to_bb3 {compiledGroups = []}\r\n            }\r\n          } else  {\r\n            calyx.seq  {\r\n              calyx.enable @bb0_to_bb2 {compiledGroups = []}\r\n              calyx.enable @bb2_to_bb3 {compiledGroups = []}\r\n            }\r\n          }\r\n          calyx.enable @ret_assign_0 {compiledGroups = []}\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nemits to the native calyx IR:\r\n```\r\nimport \"primitives/core.futil\";\r\ncomponent main(in0: 32, in1: 32, @clk clk: 1, @reset reset: 1, @go go: 1) -> (out0: 32, @done done: 1) {\r\n  cells {\r\n    std_add_2 = std_add(32);\r\n    std_add_1 = std_add(32);\r\n    std_add_0 = std_add(32);\r\n    std_sub_1 = std_sub(32);\r\n    std_sub_0 = std_sub(32);\r\n    std_ge_0 = std_ge(32);\r\n    ret_arg0_reg = std_reg(32);\r\n    bb3_arg1_reg = std_reg(32);\r\n    bb3_arg0_reg = std_reg(32);\r\n    bb2_arg0_reg = std_reg(32);\r\n    bb1_arg0_reg = std_reg(32);\r\n  }\r\n  wires {\r\n    out0 = ret_arg0_reg.out;\r\n    group bb0_to_bb1 {\r\n      bb1_arg0_reg.in = in0;\r\n      bb1_arg0_reg.write_en = 1'd1;\r\n      bb0_to_bb1[done] = bb1_arg0_reg.done;\r\n    }\r\n    group bb0_to_bb2 {\r\n      bb2_arg0_reg.in = in1;\r\n      bb2_arg0_reg.write_en = 1'd1;\r\n      bb0_to_bb2[done] = bb2_arg0_reg.done;\r\n    }\r\n    group bb1_to_bb3 {\r\n      bb3_arg0_reg.in = std_sub_0.out;\r\n      bb3_arg0_reg.write_en = 1'd1;\r\n      bb3_arg1_reg.in = std_sub_1.out;\r\n      bb3_arg1_reg.write_en = 1'd1;\r\n      std_sub_0.left = bb1_arg0_reg.out;\r\n      std_sub_0.right = in1;\r\n      std_sub_1.left = bb1_arg0_reg.out;\r\n      std_sub_1.right = in0;\r\n      bb1_to_bb3[done] = (bb3_arg0_reg.done & bb3_arg1_reg.done) ? 1'd1;\r\n    }\r\n    group bb2_to_bb3 {\r\n      bb3_arg0_reg.in = std_add_0.out;\r\n      bb3_arg0_reg.write_en = 1'd1;\r\n      bb3_arg1_reg.in = std_add_1.out;\r\n      bb3_arg1_reg.write_en = 1'd1;\r\n      std_add_0.left = bb2_arg0_reg.out;\r\n      std_add_0.right = in1;\r\n      std_add_1.left = bb2_arg0_reg.out;\r\n      std_add_1.right = in0;\r\n      bb2_to_bb3[done] = (bb3_arg0_reg.done & bb3_arg1_reg.done) ? 1'd1;\r\n    }\r\n    group ret_assign_0 {\r\n      ret_arg0_reg.in = std_add_2.out;\r\n      ret_arg0_reg.write_en = 1'd1;\r\n      std_add_2.left = bb3_arg0_reg.out;\r\n      std_add_2.right = bb3_arg1_reg.out;\r\n      ret_assign_0[done] = ret_arg0_reg.done;\r\n    }\r\n    comb group comb_bb0_0 {\r\n      std_ge_0.left = in0;\r\n      std_ge_0.right = in1;\r\n    }\r\n  }\r\n  control {\r\n    seq {\r\n      if std_ge_0.out with comb_bb0_0 {\r\n        seq {\r\n          bb0_to_bb1;\r\n          bb1_to_bb3;\r\n        }\r\n      }\r\n      ret_assign_0;\r\n    }\r\n  }\r\n}\r\n```", "code_snippet_01": "module  {\r\n  calyx.program  {\r\n    calyx.component @main(%in0: i32, %in1: i32, %clk: i1 {clk}, %reset: i1 {reset}, %go: i1 {go}) -> (%out0: i32, %done: i1 {done}) {\r\n      %true = hw.constant true\r\n      %std_add_2.left, %std_add_2.right, %std_add_2.out = calyx.std_add \"std_add_2\" : i32, i32, i32\r\n      %std_add_1.left, %std_add_1.right, %std_add_1.out = calyx.std_add \"std_add_1\" : i32, i32, i32\r\n      %std_add_0.left, %std_add_0.right, %std_add_0.out = calyx.std_add \"std_add_0\" : i32, i32, i32\r\n      %std_sub_1.left, %std_sub_1.right, %std_sub_1.out = calyx.std_sub \"std_sub_1\" : i32, i32, i32\r\n      %std_sub_0.left, %std_sub_0.right, %std_sub_0.out = calyx.std_sub \"std_sub_0\" : i32, i32, i32\r\n      %std_ge_0.left, %std_ge_0.right, %std_ge_0.out = calyx.std_ge \"std_ge_0\" : i32, i32, i1\r\n      %ret_arg0_reg.in, %ret_arg0_reg.write_en, %ret_arg0_reg.clk, %ret_arg0_reg.reset, %ret_arg0_reg.out, %ret_arg0_reg.done = calyx.register \"ret_arg0_reg\" : i32, i1, i1, i1, i32, i1\r\n      %bb3_arg1_reg.in, %bb3_arg1_reg.write_en, %bb3_arg1_reg.clk, %bb3_arg1_reg.reset, %bb3_arg1_reg.out, %bb3_arg1_reg.done = calyx.register \"bb3_arg1_reg\" : i32, i1, i1, i1, i32, i1\r\n      %bb3_arg0_reg.in, %bb3_arg0_reg.write_en, %bb3_arg0_reg.clk, %bb3_arg0_reg.reset, %bb3_arg0_reg.out, %bb3_arg0_reg.done = calyx.register \"bb3_arg0_reg\" : i32, i1, i1, i1, i32, i1\r\n      %bb2_arg0_reg.in, %bb2_arg0_reg.write_en, %bb2_arg0_reg.clk, %bb2_arg0_reg.reset, %bb2_arg0_reg.out, %bb2_arg0_reg.done = calyx.register \"bb2_arg0_reg\" : i32, i1, i1, i1, i32, i1\r\n      %bb1_arg0_reg.in, %bb1_arg0_reg.write_en, %bb1_arg0_reg.clk, %bb1_arg0_reg.reset, %bb1_arg0_reg.out, %bb1_arg0_reg.done = calyx.register \"bb1_arg0_reg\" : i32, i1, i1, i1, i32, i1\r\n      calyx.wires  {\r\n        calyx.assign %out0 = %ret_arg0_reg.out : i32\r\n        calyx.group @bb0_to_bb1  {\r\n          calyx.assign %bb1_arg0_reg.in = %in0 : i32\r\n          calyx.assign %bb1_arg0_reg.write_en = %true : i1\r\n          calyx.group_done %bb1_arg0_reg.done : i1\r\n        }\r\n        calyx.group @bb0_to_bb2  {\r\n          calyx.assign %bb2_arg0_reg.in = %in1 : i32\r\n          calyx.assign %bb2_arg0_reg.write_en = %true : i1\r\n          calyx.group_done %bb2_arg0_reg.done : i1\r\n        }\r\n        calyx.group @bb1_to_bb3  {\r\n          calyx.assign %bb3_arg0_reg.in = %std_sub_0.out : i32\r\n          calyx.assign %bb3_arg0_reg.write_en = %true : i1\r\n          calyx.assign %bb3_arg1_reg.in = %std_sub_1.out : i32\r\n          calyx.assign %bb3_arg1_reg.write_en = %true : i1\r\n          calyx.assign %std_sub_0.left = %bb1_arg0_reg.out : i32\r\n          calyx.assign %std_sub_0.right = %in1 : i32\r\n          calyx.assign %std_sub_1.left = %bb1_arg0_reg.out : i32\r\n          calyx.assign %std_sub_1.right = %in0 : i32\r\n          %0 = comb.and %bb3_arg0_reg.done, %bb3_arg1_reg.done : i1\r\n          calyx.group_done %true, %0 ? : i1\r\n        }\r\n        calyx.group @bb2_to_bb3  {\r\n          calyx.assign %bb3_arg0_reg.in = %std_add_0.out : i32\r\n          calyx.assign %bb3_arg0_reg.write_en = %true : i1\r\n          calyx.assign %bb3_arg1_reg.in = %std_add_1.out : i32\r\n          calyx.assign %bb3_arg1_reg.write_en = %true : i1\r\n          calyx.assign %std_add_0.left = %bb2_arg0_reg.out : i32\r\n          calyx.assign %std_add_0.right = %in1 : i32\r\n          calyx.assign %std_add_1.left = %bb2_arg0_reg.out : i32\r\n          calyx.assign %std_add_1.right = %in0 : i32\r\n          %0 = comb.and %bb3_arg0_reg.done, %bb3_arg1_reg.done : i1\r\n          calyx.group_done %true, %0 ? : i1\r\n        }\r\n        calyx.group @ret_assign_0  {\r\n          calyx.assign %ret_arg0_reg.in = %std_add_2.out : i32\r\n          calyx.assign %ret_arg0_reg.write_en = %true : i1\r\n          calyx.assign %std_add_2.left = %bb3_arg0_reg.out : i32\r\n          calyx.assign %std_add_2.right = %bb3_arg1_reg.out : i32\r\n          calyx.group_done %ret_arg0_reg.done : i1\r\n        }\r\n        calyx.comb_group @comb_bb0_0  {\r\n          calyx.assign %std_ge_0.left = %in0 : i32\r\n          calyx.assign %std_ge_0.right = %in1 : i32\r\n        }\r\n      }\r\n      calyx.control  {\r\n        calyx.seq  {\r\n          calyx.if %std_ge_0.out with @comb_bb0_0  {\r\n            calyx.seq  {\r\n              calyx.enable @bb0_to_bb1 {compiledGroups = []}\r\n              calyx.enable @bb1_to_bb3 {compiledGroups = []}\r\n            }\r\n          } else  {\r\n            calyx.seq  {\r\n              calyx.enable @bb0_to_bb2 {compiledGroups = []}\r\n              calyx.enable @bb2_to_bb3 {compiledGroups = []}\r\n            }\r\n          }\r\n          calyx.enable @ret_assign_0 {compiledGroups = []}\r\n        }\r\n      }\r\n    }\r\n  }\r\n}", "code_snippet_02": "import \"primitives/core.futil\";\r\ncomponent main(in0: 32, in1: 32, @clk clk: 1, @reset reset: 1, @go go: 1) -> (out0: 32, @done done: 1) {\r\n  cells {\r\n    std_add_2 = std_add(32);\r\n    std_add_1 = std_add(32);\r\n    std_add_0 = std_add(32);\r\n    std_sub_1 = std_sub(32);\r\n    std_sub_0 = std_sub(32);\r\n    std_ge_0 = std_ge(32);\r\n    ret_arg0_reg = std_reg(32);\r\n    bb3_arg1_reg = std_reg(32);\r\n    bb3_arg0_reg = std_reg(32);\r\n    bb2_arg0_reg = std_reg(32);\r\n    bb1_arg0_reg = std_reg(32);\r\n  }\r\n  wires {\r\n    out0 = ret_arg0_reg.out;\r\n    group bb0_to_bb1 {\r\n      bb1_arg0_reg.in = in0;\r\n      bb1_arg0_reg.write_en = 1'd1;\r\n      bb0_to_bb1[done] = bb1_arg0_reg.done;\r\n    }\r\n    group bb0_to_bb2 {\r\n      bb2_arg0_reg.in = in1;\r\n      bb2_arg0_reg.write_en = 1'd1;\r\n      bb0_to_bb2[done] = bb2_arg0_reg.done;\r\n    }\r\n    group bb1_to_bb3 {\r\n      bb3_arg0_reg.in = std_sub_0.out;\r\n      bb3_arg0_reg.write_en = 1'd1;\r\n      bb3_arg1_reg.in = std_sub_1.out;\r\n      bb3_arg1_reg.write_en = 1'd1;\r\n      std_sub_0.left = bb1_arg0_reg.out;\r\n      std_sub_0.right = in1;\r\n      std_sub_1.left = bb1_arg0_reg.out;\r\n      std_sub_1.right = in0;\r\n      bb1_to_bb3[done] = (bb3_arg0_reg.done & bb3_arg1_reg.done) ? 1'd1;\r\n    }\r\n    group bb2_to_bb3 {\r\n      bb3_arg0_reg.in = std_add_0.out;\r\n      bb3_arg0_reg.write_en = 1'd1;\r\n      bb3_arg1_reg.in = std_add_1.out;\r\n      bb3_arg1_reg.write_en = 1'd1;\r\n      std_add_0.left = bb2_arg0_reg.out;\r\n      std_add_0.right = in1;\r\n      std_add_1.left = bb2_arg0_reg.out;\r\n      std_add_1.right = in0;\r\n      bb2_to_bb3[done] = (bb3_arg0_reg.done & bb3_arg1_reg.done) ? 1'd1;\r\n    }\r\n    group ret_assign_0 {\r\n      ret_arg0_reg.in = std_add_2.out;\r\n      ret_arg0_reg.write_en = 1'd1;\r\n      std_add_2.left = bb3_arg0_reg.out;\r\n      std_add_2.right = bb3_arg1_reg.out;\r\n      ret_assign_0[done] = ret_arg0_reg.done;\r\n    }\r\n    comb group comb_bb0_0 {\r\n      std_ge_0.left = in0;\r\n      std_ge_0.right = in1;\r\n    }\r\n  }\r\n  control {\r\n    seq {\r\n      if std_ge_0.out with comb_bb0_0 {\r\n        seq {\r\n          bb0_to_bb1;\r\n          bb1_to_bb3;\r\n        }\r\n      }\r\n      ret_assign_0;\r\n    }\r\n  }\r\n}"}, {"number": 1799, "title": "[FIRRTL] Grand Central Views Needs to Mangle Verilog Keywords in XMRs", "created_at": "2021-09-15T23:57:22Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Currently, if a field in a Grand Central-generated interface conflicts with a Verilog keyword, this will get mangled properly during `HWLegalizeNames`. However, this will not update the XMR that has already been dumped into an `sv.verbatim` op.\r\n\r\nThe simple solution would be to mangle names at the point at which they are created so that the verbatim XMRs will be correct.\r\n\r\nConcretely, I'm seeing this issue for an interface field called `signed` where it is mangled to `signed_0`, but the XMR still points to `foo.bar.signed`."}, {"number": 1795, "title": "[Simulator] Crash when initializing `llhd.sig` with non-constant value", "created_at": "2021-09-15T12:19:24Z", "state": "open", "labels": "bug, LLHD", "body": "When trying to simulate a module such as the following, the simulator crashes without a meaningful error message or assertion (just telling you that a value not defined in this region is used or the reconcile conversion cast pass complaining that some op was already replaced). This is because in `LLHDToLLVM.cpp` the operations creating `%get` are recursively cloned into a init function created indirectly by the simulation engine, but it only considers `hw.array_create`, `hw.struct_create`, and operations without operands (stop condition of recursion).\r\n\r\nIt would be ideal to support any operation not just these three, or at least throw a meaningful error message for the user in `recursiveCloneInit`.\r\nAlso, wouldn't it be better to clone these operations in a separate function and let the LLVM inliner decide whether to inline it or not (because the operation chain might be a lot bigger than just a constant op, leading to a lot of duplicated code)?\r\n\r\n```mlir\r\nllhd.entity @root () -> () {\r\n    %0 = hw.constant 0 : i8\r\n    %index = hw.constant 1 : i1\r\n\r\n    %array = hw.array_create %0, %0 : i8\r\n    %get = hw.array_get %array[%index] : !hw.array<2xi8>\r\n\r\n    %getsig = llhd.sig \"get\" %get : i8  // Using %0 instead of %get works just fine; %get leads to a crash\r\n\r\n    %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>\r\n    llhd.drv %getsig, %get after %time : !llhd.sig<i8>\r\n}\r\n```", "code_snippet_01": "llhd.entity @root () -> () {\r\n    %0 = hw.constant 0 : i8\r\n    %index = hw.constant 1 : i1\r\n\r\n    %array = hw.array_create %0, %0 : i8\r\n    %get = hw.array_get %array[%index] : !hw.array<2xi8>\r\n\r\n    %getsig = llhd.sig \"get\" %get : i8  // Using %0 instead of %get works just fine; %get leads to a crash\r\n\r\n    %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>\r\n    llhd.drv %getsig, %get after %time : !llhd.sig<i8>\r\n}"}, {"number": 1793, "title": "[FIRRTL] IMConstprop doesn't always catch dontTouch output ports", "created_at": "2021-09-14T23:30:32Z", "state": "closed", "labels": "bug", "body": "```\r\nfirrtl.circuit \"bar\" {\r\n\r\nfirrtl.module @foo(out %b: !firrtl.uint<3> {firrtl.annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}]}) {\r\n  %const = firrtl.constant 1 : !firrtl.uint<3>\r\n  firrtl.connect %b, %const : !firrtl.uint<3>, !firrtl.uint<3>\r\n}\r\n\r\nfirrtl.module @bar(out %b : !firrtl.uint<3>, in %c : !firrtl.uint<1>) {\r\n      %const = firrtl.constant 2 : !firrtl.uint<3>\r\n      %int_b = firrtl.instance @foo  {name = \"int\"} : !firrtl.uint<3>\r\n      %m = firrtl.mux(%c, %int_b, %const) : (!firrtl.uint<1>, !firrtl.uint<3>, !firrtl.uint<3>) -> !firrtl.uint<3>\r\n      firrtl.connect %b, %m : !firrtl.uint<3>, !firrtl.uint<3>\r\n}\r\n}\r\n```\r\n\r\nmarkInstanceOp should mark the modulePortVal with dontTouch as overdefined, then the lattice prop skip in visitConnect is correct.", "code_snippet_01": "firrtl.circuit \"bar\" {\r\n\r\nfirrtl.module @foo(out %b: !firrtl.uint<3> {firrtl.annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}]}) {\r\n  %const = firrtl.constant 1 : !firrtl.uint<3>\r\n  firrtl.connect %b, %const : !firrtl.uint<3>, !firrtl.uint<3>\r\n}\r\n\r\nfirrtl.module @bar(out %b : !firrtl.uint<3>, in %c : !firrtl.uint<1>) {\r\n      %const = firrtl.constant 2 : !firrtl.uint<3>\r\n      %int_b = firrtl.instance @foo  {name = \"int\"} : !firrtl.uint<3>\r\n      %m = firrtl.mux(%c, %int_b, %const) : (!firrtl.uint<1>, !firrtl.uint<3>, !firrtl.uint<3>) -> !firrtl.uint<3>\r\n      firrtl.connect %b, %m : !firrtl.uint<3>, !firrtl.uint<3>\r\n}\r\n}"}, {"number": 1788, "title": "[Python] Update InstanceBuilder to populate input/output names for hw.InstanceOp", "created_at": "2021-09-14T20:25:00Z", "state": "closed", "labels": "bug, HW, Python", "body": "After https://github.com/llvm/circt/commit/3d19aa785468d4819961acf296c015d6f7fb318f, `HWInstanceOp` (in C++) has two new attributes to store arrays of input/output port names. Since this changed in ODS, the generated `hw.InstanceOp` (in Python) has two new arguments to the constructor. We need to update this to pass them in accordingly as `post_args`:\r\n\r\nhttps://github.com/llvm/circt/blob/8b08c41e6cc5b6765b34ba1d037667881d69191a/lib/Bindings/Python/circt/dialects/_hw_ops_ext.py#L34\r\n\r\nThis manifests as errors in the Python bindings tests that look like this:\r\n\r\n```\r\nTypeError: __init__() missing 2 required positional arguments: 'parameters' and 'sym_name'\r\n```", "code_snippet_01": "TypeError: __init__() missing 2 required positional arguments: 'parameters' and 'sym_name'"}, {"number": 1771, "title": "[FIRRTL] Lexing Issues With Deeply Nested Expressions?", "created_at": "2021-09-10T23:09:58Z", "state": "open", "labels": "bug, FIRRTL", "body": "Circuits with long lines and/or deeply nested expressions seem to crash the lexer.\r\n\r\nHere's a failing circuit (this is a 1024-deep concatenation):\r\n\r\n```scala\r\ncircuit Bar :\r\n  module Bar :\r\n    input a: UInt<1>\r\n    output b: UInt<1024>\r\n\r\n    b <= cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\r\n```\r\n\r\nThis is erroring out with an `EXC_BAD_ACCESS` occurring in the lexer:\r\n\r\n```\r\n# lldb firtool -- Bar.fir\r\n(lldb) target create \"firtool\"\r\nCurrent executable set to 'firtool' (x86_64).\r\n(lldb) settings set -- target.run-args  \"Bar.fir\"\r\n(lldb) run\r\nProcess 10399 launched: '/Users/schuylere/usr/bin/firtool' (x86_64)\r\nProcess 10399 stopped\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=2, address=0x7ffeef3fffff)\r\n    frame #0: 0x00000001005857e4 firtool`llvm::isAlpha(C=<unavailable>) at StringExtras.h:95\r\n   92  \tinline bool isHexDigit(char C) { return hexDigitValue(C) != ~0U; }\r\n   93  \t\r\n   94  \t/// Checks if character \\p C is a valid letter as classified by \"C\" locale.\r\n-> 95  \tinline bool isAlpha(char C) {\r\n   96  \t  return ('a' <= C && C <= 'z') || ('A' <= C && C <= 'Z');\r\n   97  \t}\r\n   98  \t\r\nTarget 0: (firtool) stopped.\r\n(lldb) frame select 1\r\nframe #1: 0x000000010024a592 firtool`circt::firrtl::FIRLexer::lexIdentifierOrKeyword(this=0x00007ffeefbfdbe8, tokStart=\"cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\"...) at FIRLexer.cpp:386:10\r\n   383 \t///\r\n   384 \tFIRToken FIRLexer::lexIdentifierOrKeyword(const char *tokStart) {\r\n   385 \t  // Match the rest of the identifier regex: [0-9a-zA-Z_$-]*\r\n-> 386 \t  while (llvm::isAlpha(*curPtr) || llvm::isDigit(*curPtr) || *curPtr == '_' ||\r\n   387 \t         *curPtr == '$' || *curPtr == '-')\r\n   388 \t    ++curPtr;\r\n   389\r\n```", "code_snippet_01": "circuit Bar :\r\n  module Bar :\r\n    input a: UInt<1>\r\n    output b: UInt<1024>\r\n\r\n    b <= cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))", "code_snippet_02": "# lldb firtool -- Bar.fir\r\n(lldb) target create \"firtool\"\r\nCurrent executable set to 'firtool' (x86_64).\r\n(lldb) settings set -- target.run-args  \"Bar.fir\"\r\n(lldb) run\r\nProcess 10399 launched: '/Users/schuylere/usr/bin/firtool' (x86_64)\r\nProcess 10399 stopped\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=2, address=0x7ffeef3fffff)\r\n    frame #0: 0x00000001005857e4 firtool`llvm::isAlpha(C=<unavailable>) at StringExtras.h:95\r\n   92  \tinline bool isHexDigit(char C) { return hexDigitValue(C) != ~0U; }\r\n   93  \t\r\n   94  \t/// Checks if character \\p C is a valid letter as classified by \"C\" locale.\r\n-> 95  \tinline bool isAlpha(char C) {\r\n   96  \t  return ('a' <= C && C <= 'z') || ('A' <= C && C <= 'Z');\r\n   97  \t}\r\n   98  \t\r\nTarget 0: (firtool) stopped.\r\n(lldb) frame select 1\r\nframe #1: 0x000000010024a592 firtool`circt::firrtl::FIRLexer::lexIdentifierOrKeyword(this=0x00007ffeefbfdbe8, tokStart=\"cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\"...) at FIRLexer.cpp:386:10\r\n   383 \t///\r\n   384 \tFIRToken FIRLexer::lexIdentifierOrKeyword(const char *tokStart) {\r\n   385 \t  // Match the rest of the identifier regex: [0-9a-zA-Z_$-]*\r\n-> 386 \t  while (llvm::isAlpha(*curPtr) || llvm::isDigit(*curPtr) || *curPtr == '_' ||\r\n   387 \t         *curPtr == '$' || *curPtr == '-')\r\n   388 \t    ++curPtr;\r\n   389"}, {"number": 1757, "title": "[FIRRTL] SFC Memory Lowering: Respect Write Collision Behavior", "created_at": "2021-09-09T18:57:01Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The default lowering for memories in the Scala FIRRTL Compiler (SFC) introduces a write ordering if the memories have the ports have the same clock.  This creates problems when trying to formally verify SFC-generate Verilog with CIRCT-generate Verilog.\r\n\r\nAdd an option that merges ports with the same clock into the same always block where the writes are ordered based on the port order.  This should probably be done as an extension of the existing generator schema that sets an optional ordering of write ports.  During FIRRTL memory lowering, this flag would then set the ordering based on the declared order of FIRRTL memory write ports.\r\n\r\nAs an example, consider the following FIRRTL circuit:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    input clock: Clock\r\n    input r0: {addr: UInt<4>, en: UInt<1>, flip data: UInt<8>}\r\n    input w0: {addr: UInt<4>, en: UInt<1>, data: UInt<8>, mask: UInt<1>}\r\n    input w1: {addr: UInt<4>, en: UInt<1>, data: UInt<8>, mask: UInt<1>}\r\n\r\n    wire _r0: {addr: UInt<4>, en: UInt<1>, clk: Clock, flip data: UInt<8>}\r\n    _r0 <- r0\r\n    _r0.clk <= clock\r\n\r\n    wire _w0: {addr: UInt<4>, en: UInt<1>, clk: Clock, data: UInt<8>, mask: UInt<1>}\r\n    _w0 <- w0\r\n    _w0.clk <= clock\r\n\r\n    wire _w1: {addr: UInt<4>, en: UInt<1>, clk: Clock, data: UInt<8>, mask: UInt<1>}\r\n    _w1 <- w1\r\n    _w1.clk <= clock\r\n\r\n    mem memory:\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      reader => r0\r\n      writer => w0\r\n      writer => w1\r\n      read-latency => 1\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.r0 <= _r0\r\n    memory.w0 <= _w0\r\n    memory.w1 <= _w1\r\n```\r\n\r\nThe SFC will produce the following verilog (`firrtl -i Foo.fir && cat Foo.v | verilator -E -P /dev/stdin`):\r\n\r\n```verilog\r\nmodule Foo(\r\n  input        clock,\r\n  input  [3:0] r0_addr,\r\n  input        r0_en,\r\n  output [7:0] r0_data,\r\n  input  [3:0] w0_addr,\r\n  input        w0_en,\r\n  input  [7:0] w0_data,\r\n  input        w0_mask,\r\n  input  [3:0] w1_addr,\r\n  input        w1_en,\r\n  input  [7:0] w1_data,\r\n  input        w1_mask\r\n);\r\n  reg [7:0] memory [0:15];\r\n  wire  memory_r0_en;\r\n  wire [3:0] memory_r0_addr;\r\n  wire [7:0] memory_r0_data;\r\n  wire [7:0] memory_w0_data;\r\n  wire [3:0] memory_w0_addr;\r\n  wire  memory_w0_mask;\r\n  wire  memory_w0_en;\r\n  wire [7:0] memory_w1_data;\r\n  wire [3:0] memory_w1_addr;\r\n  wire  memory_w1_mask;\r\n  wire  memory_w1_en;\r\n  reg  memory_r0_en_pipe_0;\r\n  reg [3:0] memory_r0_addr_pipe_0;\r\n  assign memory_r0_en = memory_r0_en_pipe_0;\r\n  assign memory_r0_addr = memory_r0_addr_pipe_0;\r\n  assign memory_r0_data = memory[memory_r0_addr];\r\n  assign memory_w0_data = w0_data;\r\n  assign memory_w0_addr = w0_addr;\r\n  assign memory_w0_mask = w0_mask;\r\n  assign memory_w0_en = w0_en;\r\n  assign memory_w1_data = w1_data;\r\n  assign memory_w1_addr = w1_addr;\r\n  assign memory_w1_mask = w1_mask;\r\n  assign memory_w1_en = w1_en;\r\n  assign r0_data = memory_r0_data;\r\n  always @(posedge clock) begin\r\n    if (memory_w0_en & memory_w0_mask) begin\r\n      memory[memory_w0_addr] <= memory_w0_data;\r\n    end\r\n    if (memory_w1_en & memory_w1_mask) begin\r\n      memory[memory_w1_addr] <= memory_w1_data;\r\n    end\r\n    memory_r0_en_pipe_0 <= r0_en;\r\n    if (r0_en) begin\r\n      memory_r0_addr_pipe_0 <= r0_addr;\r\n    end\r\n  end\r\ninitial begin\r\nend  \r\nendmodule\r\n```\r\n\r\nCIRCT produces the following which is not formally equivalent (`firtool Foo.fir -verilog`):\r\n\r\n```verilog\r\nmodule FIRRTLMem_1_2_0_8_16_1_1_0(\t// Foo.fir:25:5\r\n  input        ro_clock_0, ro_en_0,\r\n  input  [3:0] ro_addr_0,\r\n  input        wo_clock_0, wo_en_0,\r\n  input  [3:0] wo_addr_0,\r\n  input        wo_mask_0,\r\n  input  [7:0] wo_data_0,\r\n  input        wo_clock_1, wo_en_1,\r\n  input  [3:0] wo_addr_1,\r\n  input        wo_mask_1,\r\n  input  [7:0] wo_data_1,\r\n  output [7:0] ro_data_0);\r\n\r\n  reg [7:0] Memory[0:15];\r\n  reg       _T;\r\n  reg [3:0] _T_0;\r\n\r\n  always @(posedge ro_clock_0) begin\r\n    _T <= ro_en_0;\r\n    _T_0 <= ro_addr_0;\r\n  end // always @(posedge)\r\n  always @(posedge wo_clock_0) begin\r\n    if (wo_en_0 & wo_mask_0)\r\n      Memory[wo_addr_0] <= wo_data_0;\r\n  end // always @(posedge)\r\n  always @(posedge wo_clock_1) begin\r\n    if (wo_en_1 & wo_mask_1)\r\n      Memory[wo_addr_1] <= wo_data_1;\r\n  end // always @(posedge)\r\n  assign ro_data_0 = _T ? Memory[_T_0] : 8'bx;\t// Foo.fir:25:5\r\nendmodule\r\n\r\nmodule Foo(\t// Foo.fir:2:10\r\n  input        clock,\r\n  input  [3:0] r0_addr,\r\n  input        r0_en,\r\n  input  [3:0] w0_addr,\r\n  input        w0_en,\r\n  input  [7:0] w0_data,\r\n  input        w0_mask,\r\n  input  [3:0] w1_addr,\r\n  input        w1_en,\r\n  input  [7:0] w1_data,\r\n  input        w1_mask,\r\n  output [7:0] r0_data);\r\n\r\n  FIRRTLMem_1_2_0_8_16_1_1_0 memory (\t// Foo.fir:25:5\r\n    .ro_clock_0 (clock),\r\n    .ro_en_0    (r0_en),\r\n    .ro_addr_0  (r0_addr),\r\n    .wo_clock_0 (clock),\r\n    .wo_en_0    (w0_en),\r\n    .wo_addr_0  (w0_addr),\r\n    .wo_mask_0  (w0_mask),\r\n    .wo_data_0  (w0_data),\r\n    .wo_clock_1 (clock),\r\n    .wo_en_1    (w1_en),\r\n    .wo_addr_1  (w1_addr),\r\n    .wo_mask_1  (w1_mask),\r\n    .wo_data_1  (w1_data),\r\n    .ro_data_0  (r0_data)\r\n  );\r\nendmodule\r\n```\r\n\r\nThe specific issue is that the SFC version is enforcing a write ordering where simultaneous writes to the `w0` and `w1` port will result in the `w1` port winning. In the CIRCT version, this is undefined behavior. Abstractly, and without any other information, the CIRCT generation is \"better\" as it leaves it up to the Synthesis tool to choose an ordering.  (E.g., FPGA tools prefer separate always blocks so that they don't have to code in an explicit ordering to align with what the SFC code is behaviorally describing.)\r\n\r\nNote that If the write ports are reordered in the FIRRTL definition so that `w1` comes before `w0`, then you will get `w0` \"winning\" on collision", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input clock: Clock\r\n    input r0: {addr: UInt<4>, en: UInt<1>, flip data: UInt<8>}\r\n    input w0: {addr: UInt<4>, en: UInt<1>, data: UInt<8>, mask: UInt<1>}\r\n    input w1: {addr: UInt<4>, en: UInt<1>, data: UInt<8>, mask: UInt<1>}\r\n\r\n    wire _r0: {addr: UInt<4>, en: UInt<1>, clk: Clock, flip data: UInt<8>}\r\n    _r0 <- r0\r\n    _r0.clk <= clock\r\n\r\n    wire _w0: {addr: UInt<4>, en: UInt<1>, clk: Clock, data: UInt<8>, mask: UInt<1>}\r\n    _w0 <- w0\r\n    _w0.clk <= clock\r\n\r\n    wire _w1: {addr: UInt<4>, en: UInt<1>, clk: Clock, data: UInt<8>, mask: UInt<1>}\r\n    _w1 <- w1\r\n    _w1.clk <= clock\r\n\r\n    mem memory:\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      reader => r0\r\n      writer => w0\r\n      writer => w1\r\n      read-latency => 1\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.r0 <= _r0\r\n    memory.w0 <= _w0\r\n    memory.w1 <= _w1", "code_snippet_02": "module Foo(\r\n  input        clock,\r\n  input  [3:0] r0_addr,\r\n  input        r0_en,\r\n  output [7:0] r0_data,\r\n  input  [3:0] w0_addr,\r\n  input        w0_en,\r\n  input  [7:0] w0_data,\r\n  input        w0_mask,\r\n  input  [3:0] w1_addr,\r\n  input        w1_en,\r\n  input  [7:0] w1_data,\r\n  input        w1_mask\r\n);\r\n  reg [7:0] memory [0:15];\r\n  wire  memory_r0_en;\r\n  wire [3:0] memory_r0_addr;\r\n  wire [7:0] memory_r0_data;\r\n  wire [7:0] memory_w0_data;\r\n  wire [3:0] memory_w0_addr;\r\n  wire  memory_w0_mask;\r\n  wire  memory_w0_en;\r\n  wire [7:0] memory_w1_data;\r\n  wire [3:0] memory_w1_addr;\r\n  wire  memory_w1_mask;\r\n  wire  memory_w1_en;\r\n  reg  memory_r0_en_pipe_0;\r\n  reg [3:0] memory_r0_addr_pipe_0;\r\n  assign memory_r0_en = memory_r0_en_pipe_0;\r\n  assign memory_r0_addr = memory_r0_addr_pipe_0;\r\n  assign memory_r0_data = memory[memory_r0_addr];\r\n  assign memory_w0_data = w0_data;\r\n  assign memory_w0_addr = w0_addr;\r\n  assign memory_w0_mask = w0_mask;\r\n  assign memory_w0_en = w0_en;\r\n  assign memory_w1_data = w1_data;\r\n  assign memory_w1_addr = w1_addr;\r\n  assign memory_w1_mask = w1_mask;\r\n  assign memory_w1_en = w1_en;\r\n  assign r0_data = memory_r0_data;\r\n  always @(posedge clock) begin\r\n    if (memory_w0_en & memory_w0_mask) begin\r\n      memory[memory_w0_addr] <= memory_w0_data;\r\n    end\r\n    if (memory_w1_en & memory_w1_mask) begin\r\n      memory[memory_w1_addr] <= memory_w1_data;\r\n    end\r\n    memory_r0_en_pipe_0 <= r0_en;\r\n    if (r0_en) begin\r\n      memory_r0_addr_pipe_0 <= r0_addr;\r\n    end\r\n  end\r\ninitial begin\r\nend  \r\nendmodule", "code_snippet_03": "module FIRRTLMem_1_2_0_8_16_1_1_0(\t// Foo.fir:25:5\r\n  input        ro_clock_0, ro_en_0,\r\n  input  [3:0] ro_addr_0,\r\n  input        wo_clock_0, wo_en_0,\r\n  input  [3:0] wo_addr_0,\r\n  input        wo_mask_0,\r\n  input  [7:0] wo_data_0,\r\n  input        wo_clock_1, wo_en_1,\r\n  input  [3:0] wo_addr_1,\r\n  input        wo_mask_1,\r\n  input  [7:0] wo_data_1,\r\n  output [7:0] ro_data_0);\r\n\r\n  reg [7:0] Memory[0:15];\r\n  reg       _T;\r\n  reg [3:0] _T_0;\r\n\r\n  always @(posedge ro_clock_0) begin\r\n    _T <= ro_en_0;\r\n    _T_0 <= ro_addr_0;\r\n  end // always @(posedge)\r\n  always @(posedge wo_clock_0) begin\r\n    if (wo_en_0 & wo_mask_0)\r\n      Memory[wo_addr_0] <= wo_data_0;\r\n  end // always @(posedge)\r\n  always @(posedge wo_clock_1) begin\r\n    if (wo_en_1 & wo_mask_1)\r\n      Memory[wo_addr_1] <= wo_data_1;\r\n  end // always @(posedge)\r\n  assign ro_data_0 = _T ? Memory[_T_0] : 8'bx;\t// Foo.fir:25:5\r\nendmodule\r\n\r\nmodule Foo(\t// Foo.fir:2:10\r\n  input        clock,\r\n  input  [3:0] r0_addr,\r\n  input        r0_en,\r\n  input  [3:0] w0_addr,\r\n  input        w0_en,\r\n  input  [7:0] w0_data,\r\n  input        w0_mask,\r\n  input  [3:0] w1_addr,\r\n  input        w1_en,\r\n  input  [7:0] w1_data,\r\n  input        w1_mask,\r\n  output [7:0] r0_data);\r\n\r\n  FIRRTLMem_1_2_0_8_16_1_1_0 memory (\t// Foo.fir:25:5\r\n    .ro_clock_0 (clock),\r\n    .ro_en_0    (r0_en),\r\n    .ro_addr_0  (r0_addr),\r\n    .wo_clock_0 (clock),\r\n    .wo_en_0    (w0_en),\r\n    .wo_addr_0  (w0_addr),\r\n    .wo_mask_0  (w0_mask),\r\n    .wo_data_0  (w0_data),\r\n    .wo_clock_1 (clock),\r\n    .wo_en_1    (w1_en),\r\n    .wo_addr_1  (w1_addr),\r\n    .wo_mask_1  (w1_mask),\r\n    .wo_data_1  (w1_data),\r\n    .ro_data_0  (r0_data)\r\n  );\r\nendmodule"}, {"number": 1734, "title": "[FIRRTL] Add non-local annotation support to GCT Data Taps", "created_at": "2021-09-06T15:13:33Z", "state": "open", "labels": "bug, FIRRTL", "body": "The Grand Central Data/Mem Taps pass currently only works with annotations that refer to entire modules. With the non-local annotations having been merged recently, it should now be expanded to also properly support those. We've seen a few cases internally where this is necessary."}, {"number": 1705, "title": "[FIRRTL] (mem) Procedural assignment to wire ", "created_at": "2021-09-03T01:35:54Z", "state": "closed", "labels": "bug, FIRRTL, ExportVerilog", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 1\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input inp_bb: SInt<24>\r\n    input inp_g: UInt<0>\r\n    mem tmp173:\r\n      data-type => SInt<5>\r\n      depth => 2\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp173.r0.clk <= clock\r\n    tmp173.r0.en <= head(UInt<4>(\"h6\"), 1)\r\n    tmp173.r0.addr <= asUInt(SInt<30>(\"o-744515272\"))\r\n    tmp173.w0.clk <= clock\r\n    tmp173.w0.en <= head(asUInt(inp_bb), 1)\r\n    tmp173.w0.addr <= inp_g\r\n    tmp173.w0.data <= asSInt(inp_g)\r\n    tmp173.w0.mask <= inp_g\r\n```\r\n\r\nCompiled with `firtool   --lower-to-hw --infer-widths --imconstprop --lowering-options=disallowPackedArrays,emittedLineLength=8192 --mlir-timing --verilog -o=$VFILE2` produces this Verilog:\r\n\r\n```verilog\r\nmodule FIRRTLMem_1_1_0_5_2_0_1_0(\t// a_top_mod.fir:7:5\r\n  input        ro_clock_0, ro_en_0, ro_addr_0, wo_clock_0, wo_en_0, wo_addr_0, wo_mask_0,\r\n  input  [4:0] wo_data_0,\r\n  output [4:0] ro_data_0);\r\n\r\n  reg [4:0] Memory[0:1];\r\n\r\n  wire _T = wo_en_0 & wo_mask_0;\r\n  wire [4:0] _T_0 = Memory[wo_addr_0];\r\n  always @(posedge wo_clock_0) begin\r\n    if (_T)\r\n      _T_0 <= wo_data_0;\r\n  end // always @(posedge)\r\n  assign ro_data_0 = ro_en_0 ? Memory[ro_addr_0] : 5'bx;\t// a_top_mod.fir:7:5\r\nendmodule\r\n\r\nmodule top_mod(\t// a_top_mod.fir:3:10\r\n  input        clock,\r\n  input [23:0] inp_bb);\r\n\r\n  wire [4:0] tmp173_ro_data_0;\t// a_top_mod.fir:7:5\r\n\r\n  FIRRTLMem_1_1_0_5_2_0_1_0 tmp173 (\t// a_top_mod.fir:7:5\r\n    .ro_clock_0 (clock),\r\n    .ro_en_0    (1'h0),\t// a_top_mod.fir:16:21\r\n    .ro_addr_0  (1'h0),\t// a_top_mod.fir:16:21\r\n    .wo_clock_0 (clock),\r\n    .wo_en_0    (inp_bb[23]),\t// a_top_mod.fir:19:21\r\n    .wo_addr_0  (1'h0),\t// a_top_mod.fir:16:21\r\n    .wo_mask_0  (1'h0),\t// a_top_mod.fir:16:21\r\n    .wo_data_0  (5'h0),\t// a_top_mod.fir:21:20\r\n    .ro_data_0  (tmp173_ro_data_0)\r\n  );\r\nendmodule\r\n```\r\n\r\n```\r\nVerilator 4.211 devel rev v4.210-70-gc69ddc46\r\n```\r\n\r\nGives the following error:\r\n\r\n```\r\n%Error-PROCASSWIRE: a_top_mod.fir.mfc.v:12:7: Procedural assignment to wire, perhaps intended var (IEEE 1800-2017 6.5): '_T_0'\r\n                                            : ... In instance top_mod.tmp173\r\n   12 |       _T_0 <= wo_data_0;\r\n      |       ^~~~\r\n                    ... For error description see https://verilator.org/warn/PROCASSWIRE?v=4.211\r\n%Error: Exiting due to 1 error(s)\r\n        ... See the manual at https://verilator.org/verilator_doc.html for more assistance.\r\n```\r\n", "code_snippet_01": "; seed: 1\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input inp_bb: SInt<24>\r\n    input inp_g: UInt<0>\r\n    mem tmp173:\r\n      data-type => SInt<5>\r\n      depth => 2\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp173.r0.clk <= clock\r\n    tmp173.r0.en <= head(UInt<4>(\"h6\"), 1)\r\n    tmp173.r0.addr <= asUInt(SInt<30>(\"o-744515272\"))\r\n    tmp173.w0.clk <= clock\r\n    tmp173.w0.en <= head(asUInt(inp_bb), 1)\r\n    tmp173.w0.addr <= inp_g\r\n    tmp173.w0.data <= asSInt(inp_g)\r\n    tmp173.w0.mask <= inp_g", "code_snippet_02": "module FIRRTLMem_1_1_0_5_2_0_1_0(\t// a_top_mod.fir:7:5\r\n  input        ro_clock_0, ro_en_0, ro_addr_0, wo_clock_0, wo_en_0, wo_addr_0, wo_mask_0,\r\n  input  [4:0] wo_data_0,\r\n  output [4:0] ro_data_0);\r\n\r\n  reg [4:0] Memory[0:1];\r\n\r\n  wire _T = wo_en_0 & wo_mask_0;\r\n  wire [4:0] _T_0 = Memory[wo_addr_0];\r\n  always @(posedge wo_clock_0) begin\r\n    if (_T)\r\n      _T_0 <= wo_data_0;\r\n  end // always @(posedge)\r\n  assign ro_data_0 = ro_en_0 ? Memory[ro_addr_0] : 5'bx;\t// a_top_mod.fir:7:5\r\nendmodule\r\n\r\nmodule top_mod(\t// a_top_mod.fir:3:10\r\n  input        clock,\r\n  input [23:0] inp_bb);\r\n\r\n  wire [4:0] tmp173_ro_data_0;\t// a_top_mod.fir:7:5\r\n\r\n  FIRRTLMem_1_1_0_5_2_0_1_0 tmp173 (\t// a_top_mod.fir:7:5\r\n    .ro_clock_0 (clock),\r\n    .ro_en_0    (1'h0),\t// a_top_mod.fir:16:21\r\n    .ro_addr_0  (1'h0),\t// a_top_mod.fir:16:21\r\n    .wo_clock_0 (clock),\r\n    .wo_en_0    (inp_bb[23]),\t// a_top_mod.fir:19:21\r\n    .wo_addr_0  (1'h0),\t// a_top_mod.fir:16:21\r\n    .wo_mask_0  (1'h0),\t// a_top_mod.fir:16:21\r\n    .wo_data_0  (5'h0),\t// a_top_mod.fir:21:20\r\n    .ro_data_0  (tmp173_ro_data_0)\r\n  );\r\nendmodule", "code_snippet_03": "Verilator 4.211 devel rev v4.210-70-gc69ddc46", "code_snippet_04": "%Error-PROCASSWIRE: a_top_mod.fir.mfc.v:12:7: Procedural assignment to wire, perhaps intended var (IEEE 1800-2017 6.5): '_T_0'\r\n                                            : ... In instance top_mod.tmp173\r\n   12 |       _T_0 <= wo_data_0;\r\n      |       ^~~~\r\n                    ... For error description see https://verilator.org/warn/PROCASSWIRE?v=4.211\r\n%Error: Exiting due to 1 error(s)\r\n        ... See the manual at https://verilator.org/verilator_doc.html for more assistance."}, {"number": 1664, "title": "[FIRRTL] Add data taps integration test, fix issues", "created_at": "2021-08-30T12:51:25Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Add the `DataTapTests` from the Scala implementation of FIRRTL as an integration test for the FIRRTL dialect. This uncovers a few subtle breakages in the `GrandCentralTaps` introduced by changes to the annotation scattering code that happened a while back. This fixes those issues and the test ensures we don't have any regressions of this in the future."}, {"number": 1645, "title": "[FIRRTL] Resolve `portAnnotations`/`arg_attrs` ambiguity", "created_at": "2021-08-26T17:54:53Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Our code base expects port annotations to live in the `portAnnotations` attribute on `FModuleOp` and `FExtModuleOp`, but the parser, printer, and op builders store these in the `arg_attrs` through the standard argument attribute mechanism of upstream MLIR. This PR fixes this by declaring `portAnnotations` as the way forward, and removes any redundant/conflicting portions in the code base. To keep things ergonomic for the custom syntax, we parse and print port annotations as part of the regular argument attributes, but then immediately separate them out into the `portAnnotations` where all of our code expects this to live.\r\n\r\n*Still breaks some tests, working on those.*"}, {"number": 1643, "title": "[FIRRTL] (dshl) long mismatch", "created_at": "2021-08-26T06:34:00Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_db: SInt<0>\r\n    output tmp27: UInt<512>\r\n    node tmp25 = dshl(UInt<27>(6567271), asUInt(inp_db))\r\n    tmp27 <= dshl(UInt(2183), tail(tmp25, 17))\r\n```\r\n\r\nCompiled with `firtool` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [511:0] tmp27);\r\n\r\n  assign tmp27 = 512'h443800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;\t// a_top_mod.fir:2:10, :6:11\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [511:0] tmp27\r\n);\r\n  assign tmp27 = 512'h0;\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nERROR: Found 5 unproven $equiv cells in 'equiv_status -assert'.\r\n```", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_db: SInt<0>\r\n    output tmp27: UInt<512>\r\n    node tmp25 = dshl(UInt<27>(6567271), asUInt(inp_db))\r\n    tmp27 <= dshl(UInt(2183), tail(tmp25, 17))", "code_snippet_02": "module top_mod(\r\n  output [511:0] tmp27);\r\n\r\n  assign tmp27 = 512'h443800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;\t// a_top_mod.fir:2:10, :6:11\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  output [511:0] tmp27\r\n);\r\n  assign tmp27 = 512'h0;\r\nendmodule", "code_snippet_04": "ERROR: Found 5 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 1639, "title": "[FIRRTL] (add(a, a)) mismatch", "created_at": "2021-08-25T18:30:50Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_db: SInt<38>\r\n    output tmp1972: SInt<39>\r\n    tmp1972 <= add(inp_db, inp_db)\r\n```\r\n\r\nCompiled with `firtool` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [37:0] inp_db,\r\n  output [38:0] tmp1972);\r\n\r\n  wire [38:0] _T = {inp_db[37], inp_db};\t// a_top_mod.fir:6:16\r\n  assign tmp1972 = {_T[38:1], 1'h0};\t// a_top_mod.fir:3:10, :6:16\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [37:0] inp_db,\r\n  output [38:0] tmp1972\r\n);\r\n  assign tmp1972 = $signed(inp_db) + $signed(inp_db);\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nERROR: Found 37 unproven $equiv cells in 'equiv_status -assert'.\r\n```", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_db: SInt<38>\r\n    output tmp1972: SInt<39>\r\n    tmp1972 <= add(inp_db, inp_db)", "code_snippet_02": "module top_mod(\r\n  input  [37:0] inp_db,\r\n  output [38:0] tmp1972);\r\n\r\n  wire [38:0] _T = {inp_db[37], inp_db};\t// a_top_mod.fir:6:16\r\n  assign tmp1972 = {_T[38:1], 1'h0};\t// a_top_mod.fir:3:10, :6:16\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [37:0] inp_db,\r\n  output [38:0] tmp1972\r\n);\r\n  assign tmp1972 = $signed(inp_db) + $signed(inp_db);\r\nendmodule", "code_snippet_04": "ERROR: Found 37 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 1594, "title": "[HW] Register w/ Wire Reset Produces Two Always Blocks, not CSE'd", "created_at": "2021-08-17T22:09:31Z", "state": "closed", "labels": "bug, HW", "body": "As identified https://llvm.discourse.group/t/firtool-register-verilog-emitter/4097, formulations of registers that are reset by wires may cause multiple always blocks to be generated. \r\n\r\nConsider:\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"MyTop\"   {\r\n    firrtl.module @MyTop(in %clk: !firrtl.clock, in %reset: !firrtl.uint<1>, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<2>) {\r\n      %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1>\r\n      %reset_n = firrtl.wire  : !firrtl.uint<1>\r\n      %0 = firrtl.not %reset : (!firrtl.uint<1>) -> !firrtl.uint<1>\r\n      firrtl.connect %reset_n, %0 : !firrtl.uint<1>, !firrtl.uint<1>\r\n      %r = firrtl.regreset %clk, %reset_n, %c0_ui1  : !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %r, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %b, %r : !firrtl.uint<2>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis is getting lowered to two always blocks:\r\n\r\n```mlir\r\n  hw.module @MyTop(%clk: i1, %reset: i1, %a: i1) -> (%b: i2) {\r\n    %true = hw.constant true\r\n    %false = hw.constant false\r\n    %reset_n = sv.wire  : !hw.inout<i1>\r\n    %0 = comb.xor %reset, %true : i1\r\n    sv.assign %reset_n, %0 : i1\r\n    %1 = sv.read_inout %reset_n : !hw.inout<i1>\r\n    %r = sv.reg  : !hw.inout<i1>\r\n    sv.alwaysff(posedge %clk)  {\r\n    }(syncreset : posedge %1)  {\r\n      sv.passign %r, %false : i1\r\n    }\r\n    %2 = sv.read_inout %reset_n : !hw.inout<i1>\r\n    sv.alwaysff(posedge %clk)  {\r\n      sv.passign %r, %a : i1\r\n    }(syncreset : posedge %2)  {\r\n    }\r\n    %3 = sv.read_inout %r : !hw.inout<i1>\r\n    %4 = comb.concat %false, %3 : (i1, i1) -> i2\r\n    hw.output %4 : i2\r\n  }\r\n```\r\n\r\nThese two always blocks aren't cleaned up by HWCleanup because it runs before CSE can unify `%1` and `%2`.", "code_snippet_01": "module  {\r\n  firrtl.circuit \"MyTop\"   {\r\n    firrtl.module @MyTop(in %clk: !firrtl.clock, in %reset: !firrtl.uint<1>, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<2>) {\r\n      %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1>\r\n      %reset_n = firrtl.wire  : !firrtl.uint<1>\r\n      %0 = firrtl.not %reset : (!firrtl.uint<1>) -> !firrtl.uint<1>\r\n      firrtl.connect %reset_n, %0 : !firrtl.uint<1>, !firrtl.uint<1>\r\n      %r = firrtl.regreset %clk, %reset_n, %c0_ui1  : !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %r, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %b, %r : !firrtl.uint<2>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_02": "hw.module @MyTop(%clk: i1, %reset: i1, %a: i1) -> (%b: i2) {\r\n    %true = hw.constant true\r\n    %false = hw.constant false\r\n    %reset_n = sv.wire  : !hw.inout<i1>\r\n    %0 = comb.xor %reset, %true : i1\r\n    sv.assign %reset_n, %0 : i1\r\n    %1 = sv.read_inout %reset_n : !hw.inout<i1>\r\n    %r = sv.reg  : !hw.inout<i1>\r\n    sv.alwaysff(posedge %clk)  {\r\n    }(syncreset : posedge %1)  {\r\n      sv.passign %r, %false : i1\r\n    }\r\n    %2 = sv.read_inout %reset_n : !hw.inout<i1>\r\n    sv.alwaysff(posedge %clk)  {\r\n      sv.passign %r, %a : i1\r\n    }(syncreset : posedge %2)  {\r\n    }\r\n    %3 = sv.read_inout %r : !hw.inout<i1>\r\n    %4 = comb.concat %false, %3 : (i1, i1) -> i2\r\n    hw.output %4 : i2\r\n  }"}, {"number": 1587, "title": "[ExportVerilog] Mux Tree Lowering Producing Busted Verilog", "created_at": "2021-08-16T20:21:46Z", "state": "closed", "labels": "bug, ExportVerilog, Verilog/SystemVerilog", "body": "The mux tree lowering that was added in ee457605169c16b1ce1400201e66d06d723f282b is producing some invalid Verilog in certain situations.\r\n\r\nConsider the following FIRRTL IR:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    input idx: UInt<2>\r\n    input a: UInt<4>[4]\r\n    output b: UInt<4>\r\n\r\n    b <= a[idx]\r\n```\r\n\r\nThis is lowered to the following HW dialect mix:\r\n\r\n```mlir\r\nmodule attributes {firrtl.mainModule = \"Foo\"}  {\r\n  hw.module @Foo(%idx: i2, %a_0: i4, %a_1: i4, %a_2: i4, %a_3: i4) -> (%b: i4) {\r\n    %0 = hw.array_create %a_0, %a_1, %a_2, %a_3 : i4\r\n    %1 = hw.array_get %0[%idx] : !hw.array<4xi4>\r\n    hw.output %1 : i4\r\n  }\r\n}\r\n```\r\n\r\nAnd this produces the following Verilog:\r\n\r\n```verilog\r\nmodule Foo(\r\n  input  [1:0] idx,\r\n  input  [3:0] a_0, a_1, a_2, a_3,\r\n  output [3:0] b);\r\n\r\n  assign b = ({{a_0}, {a_1}, {a_2}, {a_3}})[idx];\t// Tmp.fir:2:10, :7:12\r\nendmodule\r\n```\r\n\r\nThe problem is that the wire associated with `{{a_0}, {a_1}, ...}` cannot be inlined as this becomes illegal Verilog.  This can be hit for situations where the mux-encoded wire is small enough to be inlined.  The problem doesn't show up for situations where the mux-encoded wire is getting spilled.\r\n\r\nConcretely, the above has to emit as:\r\n\r\n```verilog\r\nwire bar [3:0][3:0] = {{a_0}, {a_1}, ...};\r\nassign b = bar[idx];\r\n```\r\n\r\nThe other two inlined approaches both are wrong. \r\n\r\nThe following is trying to bit extract out of a concatenation:\r\n\r\n```verilog\r\nassign b = {{a_0}, {a_1}, ...}[idx];\r\n```\r\n\r\nThe following is just illegal:\r\n\r\n```verilog\r\nassign b = ({{a_0}, {a_1}, ...})[idx];\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input idx: UInt<2>\r\n    input a: UInt<4>[4]\r\n    output b: UInt<4>\r\n\r\n    b <= a[idx]", "code_snippet_02": "module attributes {firrtl.mainModule = \"Foo\"}  {\r\n  hw.module @Foo(%idx: i2, %a_0: i4, %a_1: i4, %a_2: i4, %a_3: i4) -> (%b: i4) {\r\n    %0 = hw.array_create %a_0, %a_1, %a_2, %a_3 : i4\r\n    %1 = hw.array_get %0[%idx] : !hw.array<4xi4>\r\n    hw.output %1 : i4\r\n  }\r\n}", "code_snippet_03": "module Foo(\r\n  input  [1:0] idx,\r\n  input  [3:0] a_0, a_1, a_2, a_3,\r\n  output [3:0] b);\r\n\r\n  assign b = ({{a_0}, {a_1}, {a_2}, {a_3}})[idx];\t// Tmp.fir:2:10, :7:12\r\nendmodule", "code_snippet_04": "wire bar [3:0][3:0] = {{a_0}, {a_1}, ...};\r\nassign b = bar[idx];", "code_snippet_05": "assign b = {{a_0}, {a_1}, ...}[idx];", "code_snippet_06": "assign b = ({{a_0}, {a_1}, ...})[idx];"}, {"number": 1541, "title": "[FIRRTL] name conflict resolution mismatch", "created_at": "2021-08-10T23:59:40Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod:\r\n  module top_mod:\r\n    input a: { b: UInt<1> }\r\n    input a_b: UInt<2>\r\n```\r\n\r\nCompiled with `firtool` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input       a_b,\r\n  input [1:0] a_b_0);\r\n\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input        a__b,\r\n  input  [1:0] a_b\r\n);\r\nendmodule\r\n```\r\n\r\nnote:\r\nNot only names are different, but also order of the conflict resolution.", "code_snippet_01": "circuit top_mod:\r\n  module top_mod:\r\n    input a: { b: UInt<1> }\r\n    input a_b: UInt<2>", "code_snippet_02": "module top_mod(\r\n  input       a_b,\r\n  input [1:0] a_b_0);\r\n\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input        a__b,\r\n  input  [1:0] a_b\r\n);\r\nendmodule"}, {"number": 1531, "title": "[FIRRTL] Add WidthSpec Scala tests, fix issues", "created_at": "2021-08-06T12:32:26Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Port the `WidthSpec` tests from the Scala FIRRTL implementation over into an integration test for firtool. This uncovers a few integer overflow issues in the parser/types, which this fixes alongside the tests.\r\n\r\n### Todo\r\n- [x] Land #1527 "}, {"number": 1518, "title": "[FIRRTL] (false negative) don't touch invalid reg", "created_at": "2021-08-03T23:13:25Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 32\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input arst: AsyncReset\r\n    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))\r\n    tmp107 is invalid\r\n```\r\n\r\nand annotation file:\r\n\r\n```json\r\n[{\"class\":\"firrtl.transforms.DontTouchAnnotation\",\"target\":\"~top_mod|top_mod>tmp107\"}]\r\n```\r\n\r\nCompiled with `valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --imconstprop --annotation-file=${INPUT}.json --mlir-timing --verilog -o=$VFILE2` produces this error:\r\n\r\n```cpp\r\na_top_mod.fir:7:12: error: 'firrtl.connect' op LowerToHW couldn't handle this operation\r\n    tmp107 is invalid\r\n           ^\r\na_top_mod.fir:7:12: note: see current operation: \"firrtl.connect\"(%6, %3) : (!firrtl.uint<1>, !firrtl.uint) -> ()\r\na_top_mod.fir:6:52: error: value has an unsupported verilog type '!firrtl.uint<1>'\r\n    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))\r\n                                                   ^\r\na_top_mod.fir:6:52: note: see current operation: %0 = \"firrtl.constant\"() {value = 0 : ui1} : () -> !firrtl.uint<1>\r\na_top_mod.fir:7:12: error: value has an unsupported verilog type '!firrtl.uint'\r\n    tmp107 is invalid\r\n           ^\r\na_top_mod.fir:7:12: note: see current operation: %1 = \"firrtl.invalidvalue\"() : () -> !firrtl.uint\r\na_top_mod.fir:3:10: error: value has an unsupported verilog type '!firrtl.clock'\r\n  module top_mod :\r\n         ^\r\na_top_mod.fir:3:10: note: see current operation: %2 = \"firrtl.stdIntCast\"(%arg0) : (i1) -> !firrtl.clock\r\na_top_mod.fir:3:10: error: value has an unsupported verilog type '!firrtl.asyncreset'\r\n  module top_mod :\r\n         ^\r\na_top_mod.fir:3:10: note: see current operation: %3 = \"firrtl.stdIntCast\"(%arg1) : (i1) -> !firrtl.asyncreset\r\na_top_mod.fir:6:5: error: value has an unsupported verilog type '!firrtl.uint<1>'\r\n    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))\r\n    ^\r\na_top_mod.fir:6:5: note: see current operation: %5 = \"firrtl.regreset\"(%2, %3, %0) {annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}], name = \"tmp107\"} : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.uint<1>\r\na_top_mod.fir:6:52: error: 'firrtl.constant' op cannot emit this operation to Verilog\r\n    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))\r\n                                                   ^\r\na_top_mod.fir:6:52: note: see current operation: %0 = \"firrtl.constant\"() {value = 0 : ui1} : () -> !firrtl.uint<1>\r\na_top_mod.fir:7:12: error: 'firrtl.invalidvalue' op cannot emit this operation to Verilog\r\n    tmp107 is invalid\r\n           ^\r\na_top_mod.fir:7:12: note: see current operation: %1 = \"firrtl.invalidvalue\"() : () -> !firrtl.uint\r\na_top_mod.fir:3:10: error: 'firrtl.stdIntCast' op cannot emit this operation to Verilog\r\n  module top_mod :\r\n         ^\r\na_top_mod.fir:3:10: note: see current operation: %2 = \"firrtl.stdIntCast\"(%arg0) : (i1) -> !firrtl.clock\r\na_top_mod.fir:3:10: error: 'firrtl.stdIntCast' op cannot emit this operation to Verilog\r\n  module top_mod :\r\n         ^\r\na_top_mod.fir:3:10: note: see current operation: %3 = \"firrtl.stdIntCast\"(%arg1) : (i1) -> !firrtl.asyncreset\r\na_top_mod.fir:6:5: error: 'firrtl.regreset' op cannot emit this operation to Verilog\r\n    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))\r\n    ^\r\na_top_mod.fir:6:5: note: see current operation: %5 = \"firrtl.regreset\"(%2, %3, %0) {annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}], name = \"tmp107\"} : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.uint<1>\r\na_top_mod.fir:7:12: error: 'firrtl.connect' op cannot emit this operation to Verilog\r\n    tmp107 is invalid\r\n           ^\r\na_top_mod.fir:7:12: note: see current operation: \"firrtl.connect\"(%5, %1) : (!firrtl.uint<1>, !firrtl.uint) -> ()\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input   clock,\r\n  input   arst\r\n);\r\nendmodule\r\n```\r\n", "code_snippet_01": "; seed: 32\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input arst: AsyncReset\r\n    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))\r\n    tmp107 is invalid", "code_snippet_02": "[{\"class\":\"firrtl.transforms.DontTouchAnnotation\",\"target\":\"~top_mod|top_mod>tmp107\"}]", "code_snippet_03": "a_top_mod.fir:7:12: error: 'firrtl.connect' op LowerToHW couldn't handle this operation\r\n    tmp107 is invalid\r\n           ^\r\na_top_mod.fir:7:12: note: see current operation: \"firrtl.connect\"(%6, %3) : (!firrtl.uint<1>, !firrtl.uint) -> ()\r\na_top_mod.fir:6:52: error: value has an unsupported verilog type '!firrtl.uint<1>'\r\n    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))\r\n                                                   ^\r\na_top_mod.fir:6:52: note: see current operation: %0 = \"firrtl.constant\"() {value = 0 : ui1} : () -> !firrtl.uint<1>\r\na_top_mod.fir:7:12: error: value has an unsupported verilog type '!firrtl.uint'\r\n    tmp107 is invalid\r\n           ^\r\na_top_mod.fir:7:12: note: see current operation: %1 = \"firrtl.invalidvalue\"() : () -> !firrtl.uint\r\na_top_mod.fir:3:10: error: value has an unsupported verilog type '!firrtl.clock'\r\n  module top_mod :\r\n         ^\r\na_top_mod.fir:3:10: note: see current operation: %2 = \"firrtl.stdIntCast\"(%arg0) : (i1) -> !firrtl.clock\r\na_top_mod.fir:3:10: error: value has an unsupported verilog type '!firrtl.asyncreset'\r\n  module top_mod :\r\n         ^\r\na_top_mod.fir:3:10: note: see current operation: %3 = \"firrtl.stdIntCast\"(%arg1) : (i1) -> !firrtl.asyncreset\r\na_top_mod.fir:6:5: error: value has an unsupported verilog type '!firrtl.uint<1>'\r\n    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))\r\n    ^\r\na_top_mod.fir:6:5: note: see current operation: %5 = \"firrtl.regreset\"(%2, %3, %0) {annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}], name = \"tmp107\"} : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.uint<1>\r\na_top_mod.fir:6:52: error: 'firrtl.constant' op cannot emit this operation to Verilog\r\n    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))\r\n                                                   ^\r\na_top_mod.fir:6:52: note: see current operation: %0 = \"firrtl.constant\"() {value = 0 : ui1} : () -> !firrtl.uint<1>\r\na_top_mod.fir:7:12: error: 'firrtl.invalidvalue' op cannot emit this operation to Verilog\r\n    tmp107 is invalid\r\n           ^\r\na_top_mod.fir:7:12: note: see current operation: %1 = \"firrtl.invalidvalue\"() : () -> !firrtl.uint\r\na_top_mod.fir:3:10: error: 'firrtl.stdIntCast' op cannot emit this operation to Verilog\r\n  module top_mod :\r\n         ^\r\na_top_mod.fir:3:10: note: see current operation: %2 = \"firrtl.stdIntCast\"(%arg0) : (i1) -> !firrtl.clock\r\na_top_mod.fir:3:10: error: 'firrtl.stdIntCast' op cannot emit this operation to Verilog\r\n  module top_mod :\r\n         ^\r\na_top_mod.fir:3:10: note: see current operation: %3 = \"firrtl.stdIntCast\"(%arg1) : (i1) -> !firrtl.asyncreset\r\na_top_mod.fir:6:5: error: 'firrtl.regreset' op cannot emit this operation to Verilog\r\n    reg tmp107: UInt, clock with: (reset => (arst, UInt(0)))\r\n    ^\r\na_top_mod.fir:6:5: note: see current operation: %5 = \"firrtl.regreset\"(%2, %3, %0) {annotations = [{class = \"firrtl.transforms.DontTouchAnnotation\"}], name = \"tmp107\"} : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.uint<1>\r\na_top_mod.fir:7:12: error: 'firrtl.connect' op cannot emit this operation to Verilog\r\n    tmp107 is invalid\r\n           ^\r\na_top_mod.fir:7:12: note: see current operation: \"firrtl.connect\"(%5, %1) : (!firrtl.uint<1>, !firrtl.uint) -> ()", "code_snippet_04": "module top_mod(\r\n  input   clock,\r\n  input   arst\r\n);\r\nendmodule"}, {"number": 1514, "title": "[FIRRTL] (core dump) (!intType.hasWidth() || (unsigned)intType.getWidthOrSentinel() == value.getBitWidth()) && \"value / type width mismatch\"", "created_at": "2021-08-03T04:19:43Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program:\r\n\r\n```python\r\n; seed: 220\r\ncircuit top_mod :\r\n  module mod_0 :\r\n    input clock: Clock\r\n    input inp_bb: SInt<0>\r\n    reg tmp23: UInt<16>, clock\r\n    wire _tmp31: UInt<17>\r\n    wire _tmp58: UInt<17>\r\n    tmp23 <= tail(SInt(\"o-713317423\"), 13)\r\n    _tmp31 <= add(UInt<2>(\"h1\"), tmp23)\r\n    node tmp49 = or(_tmp31, asUInt(SInt<5>(\"h-5\")))\r\n    _tmp58 <= and(inp_bb, asSInt(tmp49))\r\n    skip\r\n  module top_mod :\r\n    input clock: Clock\r\n    inst U0 of mod_0\r\n    U0 is invalid\r\n    U0.clock <= clock\r\n```\r\n\r\nCompiled with `valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2` fails with the following core dump:\r\n\r\n```cpp\r\nfirtool: /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:34: mlir::IntegerAttr getIntAttr(mlir::Type, const llvm::APInt&): Assertion `(!intType.hasWidth() || (unsigned)intType.getWidthOrSentinel() == value.getBitWidth()) && \"value / type width mismatch\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v\r\n #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20\r\n #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)\r\n #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)\r\n #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)\r\n #9 0x00000000008d2cfe getIntAttr(mlir::Type, llvm::APInt const&) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:34:3\r\n#10 0x00000000008d8778 circt::firrtl::AsSIntPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:752:24\r\n#11 0x00000000008b5441 mlir::LogicalResult mlir::Op<circt::firrtl::AsSIntPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::AsSIntPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1723:53\r\n#12 0x00000000008ae812 _ZZN4mlir2OpIN5circt6firrtl12AsSIntPrimOpEJNS_7OpTrait10ZeroRegionENS4_9OneResultENS4_14OneTypedResultINS2_8SIntTypeEE4ImplENS4_13ZeroSuccessorENS4_10OneOperandENS_20InferTypeOpInterface5TraitENS_23MemoryEffectOpInterface5TraitEEE17getFoldHookFnImplIS3_EENSt9enable_ifIXaasrN4llvm11disjunctionIJSt7is_sameINS6_IT_EENS5_ISN_EEESM_ISO_SO_ESM_ISO_NS9_4ImplISN_EEESM_ISO_NSB_ISN_EEESM_ISO_NSC_ISN_EEESM_ISO_NSD_5TraitISN_EEESM_ISO_NSF_5TraitISN_EEEEEE5valuesrNSK_6detail8detectorIvNSH_22has_single_result_foldEJSN_EE7value_tE5valueENSK_15unique_functionIKFNS_13LogicalResultEPNS_9OperationENSK_8ArrayRefINS_9AttributeEEERNSK_15SmallVectorImplINS_12OpFoldResultEEEEEEE4typeEvENKUlS1E_S1H_S1L_E_clES1E_S1H_S1L_ /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1685:12\r\n#13 0x00000000008c7811 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&>::CallImpl<std::enable_if<(llvm::disjunction<std::is_same<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp>, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::ZeroSuccessor<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::OneOperand<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::InferTypeOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::MemoryEffectOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > > >::value) && (llvm::detail::detector<void, mlir::Op<circt::firrtl::AsSIntPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::has_single_result_fold, mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >::value_t::value), llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const> >::type mlir::Op<circt::firrtl::AsSIntPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::getFoldHookFnImpl<circt::firrtl::AsSIntPrimOp>()::'lambda'(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>(void*, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:217:3\r\n#14 0x000000000080c596 llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>::operator()(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:405:3\r\n#15 0x000000000080ba3e mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:131:3\r\n#16 0x00000000008045b6 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:556:30\r\n#17 0x000000000064c4c1 (anonymous namespace)::IMConstPropPass::visitOperation(mlir::Operation*) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:608:13\r\n#18 0x000000000064b093 (anonymous namespace)::IMConstPropPass::runOnOperation() /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:304:48\r\n#19 0x0000000000ba989d mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:386:27\r\n#20 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15\r\n#21 0x0000000000bac665 auto mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)::operator()<std::pair<mlir::Operation*, mlir::AnalysisManager> >(auto&) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:607:20\r\n#22 0x0000000000bac84e mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<std::pair<mlir::Operation*, mlir::AnalysisManager>*, std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto, auto, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:49:17\r\n#23 0x0000000000bac021 mlir::LogicalResult mlir::failableParallelForEach<std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto&&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1\r\n#24 0x0000000000baaab5 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:13\r\n#25 0x0000000000baa24f mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:523:1\r\n#26 0x0000000000ba987e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:383:28\r\n#27 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15\r\n#28 0x0000000000bab084 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:689:40\r\n#29 0x0000000000baaf0b mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:669:69\r\n#30 0x0000000000406529 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:297:13\r\n#31 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30\r\n#32 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31\r\n#33 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)\r\n#34 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 43: 26250 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2\r\n```\r\n", "code_snippet_01": "; seed: 220\r\ncircuit top_mod :\r\n  module mod_0 :\r\n    input clock: Clock\r\n    input inp_bb: SInt<0>\r\n    reg tmp23: UInt<16>, clock\r\n    wire _tmp31: UInt<17>\r\n    wire _tmp58: UInt<17>\r\n    tmp23 <= tail(SInt(\"o-713317423\"), 13)\r\n    _tmp31 <= add(UInt<2>(\"h1\"), tmp23)\r\n    node tmp49 = or(_tmp31, asUInt(SInt<5>(\"h-5\")))\r\n    _tmp58 <= and(inp_bb, asSInt(tmp49))\r\n    skip\r\n  module top_mod :\r\n    input clock: Clock\r\n    inst U0 of mod_0\r\n    U0 is invalid\r\n    U0.clock <= clock", "code_snippet_02": "firtool: /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:34: mlir::IntegerAttr getIntAttr(mlir::Type, const llvm::APInt&): Assertion `(!intType.hasWidth() || (unsigned)intType.getWidthOrSentinel() == value.getBitWidth()) && \"value / type width mismatch\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v\r\n #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20\r\n #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)\r\n #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)\r\n #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)\r\n #9 0x00000000008d2cfe getIntAttr(mlir::Type, llvm::APInt const&) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:34:3\r\n#10 0x00000000008d8778 circt::firrtl::AsSIntPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:752:24\r\n#11 0x00000000008b5441 mlir::LogicalResult mlir::Op<circt::firrtl::AsSIntPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::AsSIntPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1723:53\r\n#12 0x00000000008ae812 _ZZN4mlir2OpIN5circt6firrtl12AsSIntPrimOpEJNS_7OpTrait10ZeroRegionENS4_9OneResultENS4_14OneTypedResultINS2_8SIntTypeEE4ImplENS4_13ZeroSuccessorENS4_10OneOperandENS_20InferTypeOpInterface5TraitENS_23MemoryEffectOpInterface5TraitEEE17getFoldHookFnImplIS3_EENSt9enable_ifIXaasrN4llvm11disjunctionIJSt7is_sameINS6_IT_EENS5_ISN_EEESM_ISO_SO_ESM_ISO_NS9_4ImplISN_EEESM_ISO_NSB_ISN_EEESM_ISO_NSC_ISN_EEESM_ISO_NSD_5TraitISN_EEESM_ISO_NSF_5TraitISN_EEEEEE5valuesrNSK_6detail8detectorIvNSH_22has_single_result_foldEJSN_EE7value_tE5valueENSK_15unique_functionIKFNS_13LogicalResultEPNS_9OperationENSK_8ArrayRefINS_9AttributeEEERNSK_15SmallVectorImplINS_12OpFoldResultEEEEEEE4typeEvENKUlS1E_S1H_S1L_E_clES1E_S1H_S1L_ /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1685:12\r\n#13 0x00000000008c7811 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&>::CallImpl<std::enable_if<(llvm::disjunction<std::is_same<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp>, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::ZeroSuccessor<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::OpTrait::OneOperand<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::InferTypeOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > >, circt::firrtl::AsSIntPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >, mlir::MemoryEffectOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> > > >::value) && (llvm::detail::detector<void, mlir::Op<circt::firrtl::AsSIntPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::has_single_result_fold, mlir::OpTrait::OneResult<circt::firrtl::AsSIntPrimOp> >::value_t::value), llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const> >::type mlir::Op<circt::firrtl::AsSIntPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::SIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::getFoldHookFnImpl<circt::firrtl::AsSIntPrimOp>()::'lambda'(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>(void*, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:217:3\r\n#14 0x000000000080c596 llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>::operator()(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:405:3\r\n#15 0x000000000080ba3e mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:131:3\r\n#16 0x00000000008045b6 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:556:30\r\n#17 0x000000000064c4c1 (anonymous namespace)::IMConstPropPass::visitOperation(mlir::Operation*) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:608:13\r\n#18 0x000000000064b093 (anonymous namespace)::IMConstPropPass::runOnOperation() /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:304:48\r\n#19 0x0000000000ba989d mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:386:27\r\n#20 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15\r\n#21 0x0000000000bac665 auto mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)::operator()<std::pair<mlir::Operation*, mlir::AnalysisManager> >(auto&) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:607:20\r\n#22 0x0000000000bac84e mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<std::pair<mlir::Operation*, mlir::AnalysisManager>*, std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto, auto, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:49:17\r\n#23 0x0000000000bac021 mlir::LogicalResult mlir::failableParallelForEach<std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto&&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1\r\n#24 0x0000000000baaab5 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:13\r\n#25 0x0000000000baa24f mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:523:1\r\n#26 0x0000000000ba987e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:383:28\r\n#27 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15\r\n#28 0x0000000000bab084 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:689:40\r\n#29 0x0000000000baaf0b mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:669:69\r\n#30 0x0000000000406529 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:297:13\r\n#31 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30\r\n#32 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31\r\n#33 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)\r\n#34 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 43: 26250 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2"}, {"number": 1513, "title": "[FIRRTL] (core dump) Ptr >= BufStart && Ptr <= Buffer->getBufferEnd()", "created_at": "2021-08-03T03:49:06Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Running `firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v`\r\n\r\nI am getting this error at random:\r\n```\r\nfirtool\r\nfirtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:97: unsigned int llvm::SourceMgr::SrcBuffer::getLineNumberSpecialized(const char*) const [with T = short unsigned int]: Assertion `Ptr >= BufStart && Ptr <= Buffer->getBufferEnd()' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v\r\n1.      In-Flight Diagnostics:\r\n    loc(\"a_top_mod.fir\":419:14): error: expected statement to be on its own line\r\n #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20\r\n #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)\r\n #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)\r\n #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)\r\n #9 0x000000000045ac32 unsigned int llvm::SourceMgr::SrcBuffer::getLineNumberSpecialized<unsigned short>(char const*) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:98:13\r\n#10 0x0000000000457a5c llvm::SourceMgr::SrcBuffer::getLineNumber(char const*) const (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:115:50\r\n#11 0x0000000000457d83 llvm::SourceMgr::getLineAndColumn(llvm::SMLoc, unsigned int) const (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:188:41\r\n#12 0x00000000005bd4d9 circt::firrtl::FIRLexer::translateLocation(llvm::SMLoc) (.localalias) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRLexer.cpp:172:50\r\n#13 0x0000000000565e25 (anonymous namespace)::FIRParser::translateLocation(llvm::SMLoc) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:189:3\r\n#14 0x000000000056af90 (anonymous namespace)::LazyLocationListener::endStatement((anonymous namespace)::FIRParser&) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:1412:33\r\n#15 0x00000000005719b2 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2124:10\r\n#16 0x000000000057192a (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2115:24\r\n#17 0x0000000000574209 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int)::'lambda'(mlir::Block&)::operator()(mlir::Block&) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2545:42\r\n#18 0x000000000057446f (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2549:17\r\n#19 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#20 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#21 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#22 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#23 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#24 0x000000000057192a (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2115:24\r\n#25 0x0000000000574209 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int)::'lambda'(mlir::Block&)::operator()(mlir::Block&) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2545:42\r\n#26 0x000000000057446f (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2549:17\r\n#27 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#28 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#29 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#30 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#31 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#32 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#33 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#34 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#35 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#36 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#37 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#38 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#39 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#40 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#41 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#42 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#43 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#44 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#45 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#46 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#47 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#48 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#49 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#50 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#51 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#52 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#53 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#54 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#55 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#56 0x000000000057192a (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2115:24\r\n#57 0x000000000057a53c (anonymous namespace)::FIRCircuitParser::parseModuleBody((anonymous namespace)::FIRCircuitParser::DeferredModuleToParse&) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3449:48\r\n#58 0x000000000057a5e9 (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)::operator()(unsigned long) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3548:28\r\n#59 0x000000000057cc1e mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:65:17\r\n#60 0x000000000057cec5 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:81:3\r\n#61 0x000000000057c55e mlir::LogicalResult mlir::failableParallelForEach<llvm::iota_range<unsigned long>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, llvm::iota_range<unsigned long>&&, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1\r\n#62 0x000000000057bd9b mlir::LogicalResult mlir::failableParallelForEachN<(anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, unsigned long, unsigned long, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:114:1\r\n#63 0x000000000057aee3 (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3546:50\r\n#64 0x000000000057b3d0 circt::firrtl::importFIRFile(llvm::SourceMgr&, mlir::MLIRContext*, circt::firrtl::FIRParserOptions) (.localalias) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3600:59\r\n#65 0x0000000000405bfd processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:198:56\r\n#66 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30\r\n#67 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31\r\n#68 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)\r\n#69 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 43: 22168 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2\r\n```", "code_snippet_01": "firtool\r\nfirtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:97: unsigned int llvm::SourceMgr::SrcBuffer::getLineNumberSpecialized(const char*) const [with T = short unsigned int]: Assertion `Ptr >= BufStart && Ptr <= Buffer->getBufferEnd()' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v\r\n1.      In-Flight Diagnostics:\r\n    loc(\"a_top_mod.fir\":419:14): error: expected statement to be on its own line\r\n #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20\r\n #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)\r\n #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)\r\n #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)\r\n #9 0x000000000045ac32 unsigned int llvm::SourceMgr::SrcBuffer::getLineNumberSpecialized<unsigned short>(char const*) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:98:13\r\n#10 0x0000000000457a5c llvm::SourceMgr::SrcBuffer::getLineNumber(char const*) const (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:115:50\r\n#11 0x0000000000457d83 llvm::SourceMgr::getLineAndColumn(llvm::SMLoc, unsigned int) const (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/SourceMgr.cpp:188:41\r\n#12 0x00000000005bd4d9 circt::firrtl::FIRLexer::translateLocation(llvm::SMLoc) (.localalias) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRLexer.cpp:172:50\r\n#13 0x0000000000565e25 (anonymous namespace)::FIRParser::translateLocation(llvm::SMLoc) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:189:3\r\n#14 0x000000000056af90 (anonymous namespace)::LazyLocationListener::endStatement((anonymous namespace)::FIRParser&) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:1412:33\r\n#15 0x00000000005719b2 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2124:10\r\n#16 0x000000000057192a (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2115:24\r\n#17 0x0000000000574209 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int)::'lambda'(mlir::Block&)::operator()(mlir::Block&) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2545:42\r\n#18 0x000000000057446f (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2549:17\r\n#19 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#20 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#21 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#22 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#23 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#24 0x000000000057192a (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2115:24\r\n#25 0x0000000000574209 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int)::'lambda'(mlir::Block&)::operator()(mlir::Block&) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2545:42\r\n#26 0x000000000057446f (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2549:17\r\n#27 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#28 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#29 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#30 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#31 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#32 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#33 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#34 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#35 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#36 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#37 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#38 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#39 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#40 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#41 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#42 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#43 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#44 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#45 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#46 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#47 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#48 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#49 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#50 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#51 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#52 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#53 0x00000000005745f5 (anonymous namespace)::FIRStmtParser::parseWhen(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2574:37\r\n#54 0x0000000000571ae9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtImpl(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2168:32\r\n#55 0x0000000000571998 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2122:36\r\n#56 0x000000000057192a (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:2115:24\r\n#57 0x000000000057a53c (anonymous namespace)::FIRCircuitParser::parseModuleBody((anonymous namespace)::FIRCircuitParser::DeferredModuleToParse&) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3449:48\r\n#58 0x000000000057a5e9 (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)::operator()(unsigned long) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3548:28\r\n#59 0x000000000057cc1e mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:65:17\r\n#60 0x000000000057cec5 mlir::LogicalResult mlir::failableParallelForEach<llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, llvm::detail::SafeIntIterator<unsigned long, false>, llvm::detail::SafeIntIterator<unsigned long, false>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:81:3\r\n#61 0x000000000057c55e mlir::LogicalResult mlir::failableParallelForEach<llvm::iota_range<unsigned long>, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, llvm::iota_range<unsigned long>&&, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1\r\n#62 0x000000000057bd9b mlir::LogicalResult mlir::failableParallelForEachN<(anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)>(mlir::MLIRContext*, unsigned long, unsigned long, (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*)::'lambda'(unsigned long)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:114:1\r\n#63 0x000000000057aee3 (anonymous namespace)::FIRCircuitParser::parseCircuit(llvm::MemoryBuffer const*) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3546:50\r\n#64 0x000000000057b3d0 circt::firrtl::importFIRFile(llvm::SourceMgr&, mlir::MLIRContext*, circt::firrtl::FIRParserOptions) (.localalias) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:3600:59\r\n#65 0x0000000000405bfd processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:198:56\r\n#66 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30\r\n#67 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31\r\n#68 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)\r\n#69 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 43: 22168 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2"}, {"number": 1512, "title": "[FIRRTL] (core dump) ShiftAmt <= BitWidth && \"Invalid shift amount\"", "created_at": "2021-08-03T03:25:24Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program:\r\n\r\n```python\r\n; seed: 153\r\ncircuit top_mod :\r\n  module mod_0 :\r\n    input clock: Clock\r\n    input arst: AsyncReset\r\n    input inp_cb: UInt<67>\r\n    output fsm_97_next: UInt<4>\r\n    reg fsm_97_state: UInt, clock with: (reset => (arst, UInt(0)))\r\n    node tmp24 = xor(inp_cb, asUInt(SInt<14>(42)))\r\n    node tmp73 = dshl(UInt<20>(42), head(tmp24, 5))\r\n    when eq(fsm_97_state, UInt<4>(10)) :\r\n      when xorr(tmp73) :\r\n        fsm_97_next <= UInt<4>(0)\r\n      else :\r\n        fsm_97_next <= fsm_97_state\r\n    else :\r\n      fsm_97_next <= fsm_97_state\r\n    fsm_97_state <= fsm_97_next\r\n  module top_mod :\r\n    inst U0 of mod_0\r\n    U0 is invalid\r\n```\r\n\r\nCompiled with `valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2` fails with the following core dump:\r\n\r\n```cpp\r\nfirtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:995: void llvm::APInt::lshrInPlace(unsigned int): Assertion `ShiftAmt <= BitWidth && \"Invalid shift amount\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v\r\n #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20\r\n #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)\r\n #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)\r\n #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)\r\n #9 0x00000000004fc5c3 llvm::APInt::lshrInPlace(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:996:21\r\n#10 0x000000000050e77b llvm::APInt::lshr(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:990:12\r\n#11 0x00000000008d9e3a circt::firrtl::BitsPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:973:63\r\n#12 0x00000000008b5dbb mlir::LogicalResult mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::BitsPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1723:53\r\n#13 0x00000000008aef34 _ZZN4mlir2OpIN5circt6firrtl10BitsPrimOpEJNS_7OpTrait10ZeroRegionENS4_9OneResultENS4_14OneTypedResultINS2_8UIntTypeEE4ImplENS4_13ZeroSuccessorENS4_10OneOperandENS_20InferTypeOpInterface5TraitENS_23MemoryEffectOpInterface5TraitEEE17getFoldHookFnImplIS3_EENSt9enable_ifIXaasrN4llvm11disjunctionIJSt7is_sameINS6_IT_EENS5_ISN_EEESM_ISO_SO_ESM_ISO_NS9_4ImplISN_EEESM_ISO_NSB_ISN_EEESM_ISO_NSC_ISN_EEESM_ISO_NSD_5TraitISN_EEESM_ISO_NSF_5TraitISN_EEEEEE5valuesrNSK_6detail8detectorIvNSH_22has_single_result_foldEJSN_EE7value_tE5valueENSK_15unique_functionIKFNS_13LogicalResultEPNS_9OperationENSK_8ArrayRefINS_9AttributeEEERNSK_15SmallVectorImplINS_12OpFoldResultEEEEEEE4typeEvENKUlS1E_S1H_S1L_E_clES1E_S1H_S1L_ /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1685:12\r\n#14 0x00000000008c7fed mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&>::CallImpl<std::enable_if<(llvm::disjunction<std::is_same<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp>, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::ZeroSuccessor<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::OneOperand<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::InferTypeOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::MemoryEffectOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > > >::value) && (llvm::detail::detector<void, mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::has_single_result_fold, mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >::value_t::value), llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const> >::type mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::getFoldHookFnImpl<circt::firrtl::BitsPrimOp>()::'lambda'(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>(void*, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:217:3\r\n#15 0x000000000080c596 llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>::operator()(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:405:3\r\n#16 0x000000000080ba3e mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:131:3\r\n#17 0x00000000008045b6 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:556:30\r\n#18 0x000000000064c4c1 (anonymous namespace)::IMConstPropPass::visitOperation(mlir::Operation*) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:608:13\r\n#19 0x000000000064b093 (anonymous namespace)::IMConstPropPass::runOnOperation() /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:304:48\r\n#20 0x0000000000ba989d mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:386:27\r\n#21 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15\r\n#22 0x0000000000bac665 auto mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)::operator()<std::pair<mlir::Operation*, mlir::AnalysisManager> >(auto&) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:607:20\r\n#23 0x0000000000bac84e mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<std::pair<mlir::Operation*, mlir::AnalysisManager>*, std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto, auto, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:49:17\r\n#24 0x0000000000bac021 mlir::LogicalResult mlir::failableParallelForEach<std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto&&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1\r\n#25 0x0000000000baaab5 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:13\r\n#26 0x0000000000baa24f mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:523:1\r\n#27 0x0000000000ba987e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:383:28\r\n#28 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15\r\n#29 0x0000000000bab084 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:689:40\r\n#30 0x0000000000baaf0b mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:669:69\r\n#31 0x0000000000406529 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:297:13\r\n#32 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30\r\n#33 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31\r\n#34 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)\r\n#35 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 43: 20930 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2\r\n```\r\n", "code_snippet_01": "; seed: 153\r\ncircuit top_mod :\r\n  module mod_0 :\r\n    input clock: Clock\r\n    input arst: AsyncReset\r\n    input inp_cb: UInt<67>\r\n    output fsm_97_next: UInt<4>\r\n    reg fsm_97_state: UInt, clock with: (reset => (arst, UInt(0)))\r\n    node tmp24 = xor(inp_cb, asUInt(SInt<14>(42)))\r\n    node tmp73 = dshl(UInt<20>(42), head(tmp24, 5))\r\n    when eq(fsm_97_state, UInt<4>(10)) :\r\n      when xorr(tmp73) :\r\n        fsm_97_next <= UInt<4>(0)\r\n      else :\r\n        fsm_97_next <= fsm_97_state\r\n    else :\r\n      fsm_97_next <= fsm_97_state\r\n    fsm_97_state <= fsm_97_next\r\n  module top_mod :\r\n    inst U0 of mod_0\r\n    U0 is invalid", "code_snippet_02": "firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:995: void llvm::APInt::lshrInPlace(unsigned int): Assertion `ShiftAmt <= BitWidth && \"Invalid shift amount\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc.v\r\n #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20\r\n #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)\r\n #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)\r\n #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)\r\n #9 0x00000000004fc5c3 llvm::APInt::lshrInPlace(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:996:21\r\n#10 0x000000000050e77b llvm::APInt::lshr(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:990:12\r\n#11 0x00000000008d9e3a circt::firrtl::BitsPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLFolds.cpp:973:63\r\n#12 0x00000000008b5dbb mlir::LogicalResult mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::BitsPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1723:53\r\n#13 0x00000000008aef34 _ZZN4mlir2OpIN5circt6firrtl10BitsPrimOpEJNS_7OpTrait10ZeroRegionENS4_9OneResultENS4_14OneTypedResultINS2_8UIntTypeEE4ImplENS4_13ZeroSuccessorENS4_10OneOperandENS_20InferTypeOpInterface5TraitENS_23MemoryEffectOpInterface5TraitEEE17getFoldHookFnImplIS3_EENSt9enable_ifIXaasrN4llvm11disjunctionIJSt7is_sameINS6_IT_EENS5_ISN_EEESM_ISO_SO_ESM_ISO_NS9_4ImplISN_EEESM_ISO_NSB_ISN_EEESM_ISO_NSC_ISN_EEESM_ISO_NSD_5TraitISN_EEESM_ISO_NSF_5TraitISN_EEEEEE5valuesrNSK_6detail8detectorIvNSH_22has_single_result_foldEJSN_EE7value_tE5valueENSK_15unique_functionIKFNS_13LogicalResultEPNS_9OperationENSK_8ArrayRefINS_9AttributeEEERNSK_15SmallVectorImplINS_12OpFoldResultEEEEEEE4typeEvENKUlS1E_S1H_S1L_E_clES1E_S1H_S1L_ /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OpDefinition.h:1685:12\r\n#14 0x00000000008c7fed mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&>::CallImpl<std::enable_if<(llvm::disjunction<std::is_same<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp>, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::ZeroSuccessor<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::OpTrait::OneOperand<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::InferTypeOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > >, circt::firrtl::BitsPrimOp<mlir::OpTrait::ZeroRegion<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >, mlir::MemoryEffectOpInterface::Trait<mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> > > >::value) && (llvm::detail::detector<void, mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::has_single_result_fold, mlir::OpTrait::OneResult<circt::firrtl::BitsPrimOp> >::value_t::value), llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const> >::type mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::InferTypeOpInterface::Trait, mlir::MemoryEffectOpInterface::Trait>::getFoldHookFnImpl<circt::firrtl::BitsPrimOp>()::'lambda'(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>(void*, mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:217:3\r\n#15 0x000000000080c596 llvm::unique_function<mlir::LogicalResult (mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const>::operator()(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/FunctionExtras.h:405:3\r\n#16 0x000000000080ba3e mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:131:3\r\n#17 0x00000000008045b6 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:556:30\r\n#18 0x000000000064c4c1 (anonymous namespace)::IMConstPropPass::visitOperation(mlir::Operation*) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:608:13\r\n#19 0x000000000064b093 (anonymous namespace)::IMConstPropPass::runOnOperation() /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:304:48\r\n#20 0x0000000000ba989d mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:386:27\r\n#21 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15\r\n#22 0x0000000000bac665 auto mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)::operator()<std::pair<mlir::Operation*, mlir::AnalysisManager> >(auto&) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:607:20\r\n#23 0x0000000000bac84e mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<std::pair<mlir::Operation*, mlir::AnalysisManager>*, std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto, auto, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:49:17\r\n#24 0x0000000000bac021 mlir::LogicalResult mlir::failableParallelForEach<std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto&&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1\r\n#25 0x0000000000baaab5 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:13\r\n#26 0x0000000000baa24f mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:523:1\r\n#27 0x0000000000ba987e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:383:28\r\n#28 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15\r\n#29 0x0000000000bab084 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:689:40\r\n#30 0x0000000000baaf0b mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:669:69\r\n#31 0x0000000000406529 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:297:13\r\n#32 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30\r\n#33 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31\r\n#34 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)\r\n#35 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 43: 20930 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2"}, {"number": 1511, "title": "[FIRRTL] (code dump) type/value width mismatch materializing constant", "created_at": "2021-08-03T02:51:49Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program:\r\n\r\n```python\r\n; seed: 133\r\ncircuit top_mod :\r\n  module mod_1 :\r\n    input clock: Clock\r\n    input arst: AsyncReset\r\n    input inp_bb: SInt<26>\r\n    reg tmp61: UInt<26>, clock with: (reset => (arst, UInt<26>(0)))\r\n    tmp61 <= xor(SInt(0), inp_bb)\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input arst: AsyncReset\r\n    inst U1 of mod_1\r\n    U1 is invalid\r\n    ; U1\r\n    U1.arst <= arst\r\n    U1.clock <= clock\r\n```\r\n\r\nCompiled with `valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE2` fails with the following core dump:\r\n\r\n```cpp\r\nfirtool: /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLDialect.cpp:325: virtual mlir::Operation* circt::firrtl::FIRRTLDialect::materializeConstant(mlir::OpBuilder&, mlir::Attribute, mlir::Type, mlir::Location): Assertion `(!intType.hasWidth() || (unsigned)intType.getWidthOrSentinel() == attrValue.getValue().getBitWidth()) && \"type/value width mismatch materializing constant\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc2.v\r\n1.       #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20\r\n #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)\r\n #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)\r\n #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)\r\n #9 0x0000000000895621 circt::firrtl::FIRRTLDialect::materializeConstant(mlir::OpBuilder&, mlir::Attribute, mlir::Type, mlir::Location) (.localalias) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLDialect.cpp:325:5\r\n#10 0x000000000064c9c6 (anonymous namespace)::IMConstPropPass::rewriteModuleBody(circt::firrtl::FModuleOp)::'lambda'(mlir::Value)::operator()(mlir::Value) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:661:58\r\n#11 0x000000000064cdeb (anonymous namespace)::IMConstPropPass::rewriteModuleBody(circt::firrtl::FModuleOp) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:716:17\r\n#12 0x000000000064e522 auto (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)::operator()<circt::firrtl::FModuleOp>(auto) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:313:63\r\n#13 0x000000000064e555 auto void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'(auto&&)::operator()<circt::firrtl::FModuleOp>(auto&&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:125:63\r\n#14 0x000000000064e609 mlir::LogicalResult mlir::failableParallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'(auto&&)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:65:17\r\n#15 0x000000000064e8a3 mlir::LogicalResult mlir::failableParallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'(auto&&)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:81:3\r\n#16 0x000000000064de44 void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:124:32\r\n#17 0x000000000064d4c0 void mlir::parallelForEach<llvm::iterator_range<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> > >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto&&, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:136:18\r\n#18 0x000000000064b13c (anonymous namespace)::IMConstPropPass::runOnOperation() /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:316:17\r\n#19 0x0000000000ba989d mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:386:27\r\n#20 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15\r\n#21 0x0000000000bac665 auto mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)::operator()<std::pair<mlir::Operation*, mlir::AnalysisManager> >(auto&) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:607:20\r\n#22 0x0000000000bac84e mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<std::pair<mlir::Operation*, mlir::AnalysisManager>*, std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto, auto, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:49:17\r\n#23 0x0000000000bac021 mlir::LogicalResult mlir::failableParallelForEach<std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto&&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1\r\n#24 0x0000000000baaab5 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:13\r\n#25 0x0000000000baa24f mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:523:1\r\n#26 0x0000000000ba987e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:383:28\r\n#27 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15\r\n#28 0x0000000000bab084 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:689:40\r\n#29 0x0000000000baaf0b mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:669:69\r\n#30 0x0000000000406529 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:297:13\r\n#31 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30\r\n#32 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31\r\n#33 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)\r\n#34 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 56: 17325 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE3\r\n```\r\n", "code_snippet_01": "; seed: 133\r\ncircuit top_mod :\r\n  module mod_1 :\r\n    input clock: Clock\r\n    input arst: AsyncReset\r\n    input inp_bb: SInt<26>\r\n    reg tmp61: UInt<26>, clock with: (reset => (arst, UInt<26>(0)))\r\n    tmp61 <= xor(SInt(0), inp_bb)\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input arst: AsyncReset\r\n    inst U1 of mod_1\r\n    U1 is invalid\r\n    ; U1\r\n    U1.arst <= arst\r\n    U1.clock <= clock", "code_snippet_02": "firtool: /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLDialect.cpp:325: virtual mlir::Operation* circt::firrtl::FIRRTLDialect::materializeConstant(mlir::OpBuilder&, mlir::Attribute, mlir::Type, mlir::Location): Assertion `(!intType.hasWidth() || (unsigned)intType.getWidthOrSentinel() == attrValue.getValue().getBitWidth()) && \"type/value width mismatch materializing constant\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-hw --infer-widths --mlir-timing --verilog -o=a_top_mod.fir.mfc2.v\r\n1.       #0 0x00000000004e2be7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004e2caa PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004e0bf1 llvm::sys::RunSignalHandlers() (.localalias) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:97:20\r\n #3 0x00000000004e2612 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x000000000488b970 __restore_rt (/lib64/libpthread.so.0+0x13970)\r\n #5 0x0000000004a93322 raise (/lib64/libc.so.6+0x3d322)\r\n #6 0x0000000004a7c864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x0000000004a7c749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x0000000004a8b9d6 (/lib64/libc.so.6+0x359d6)\r\n #9 0x0000000000895621 circt::firrtl::FIRRTLDialect::materializeConstant(mlir::OpBuilder&, mlir::Attribute, mlir::Type, mlir::Location) (.localalias) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/FIRRTLDialect.cpp:325:5\r\n#10 0x000000000064c9c6 (anonymous namespace)::IMConstPropPass::rewriteModuleBody(circt::firrtl::FModuleOp)::'lambda'(mlir::Value)::operator()(mlir::Value) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:661:58\r\n#11 0x000000000064cdeb (anonymous namespace)::IMConstPropPass::rewriteModuleBody(circt::firrtl::FModuleOp) /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:716:17\r\n#12 0x000000000064e522 auto (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)::operator()<circt::firrtl::FModuleOp>(auto) const /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:313:63\r\n#13 0x000000000064e555 auto void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'(auto&&)::operator()<circt::firrtl::FModuleOp>(auto&&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:125:63\r\n#14 0x000000000064e609 mlir::LogicalResult mlir::failableParallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'(auto&&)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:65:17\r\n#15 0x000000000064e8a3 mlir::LogicalResult mlir::failableParallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&)::'lambda'(auto&&)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:81:3\r\n#16 0x000000000064de44 void mlir::parallelForEach<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto, auto, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:124:32\r\n#17 0x000000000064d4c0 void mlir::parallelForEach<llvm::iterator_range<mlir::detail::op_iterator<circt::firrtl::FModuleOp, llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation, true, false, void>, false, false> > >, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)>(mlir::MLIRContext*, auto&&, (anonymous namespace)::IMConstPropPass::runOnOperation()::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:136:18\r\n#18 0x000000000064b13c (anonymous namespace)::IMConstPropPass::runOnOperation() /home/drom/work/github/llvm/circt/lib/Dialect/FIRRTL/Transforms/IMConstProp.cpp:316:17\r\n#19 0x0000000000ba989d mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:386:27\r\n#20 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15\r\n#21 0x0000000000bac665 auto mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)::operator()<std::pair<mlir::Operation*, mlir::AnalysisManager> >(auto&) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:607:20\r\n#22 0x0000000000bac84e mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<std::pair<mlir::Operation*, mlir::AnalysisManager>*, std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto, auto, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:49:17\r\n#23 0x0000000000bac021 mlir::LogicalResult mlir::failableParallelForEach<std::vector<std::pair<mlir::Operation*, mlir::AnalysisManager>, std::allocator<std::pair<mlir::Operation*, mlir::AnalysisManager> > >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&>(mlir::MLIRContext*, auto&&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(auto&)&) /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/Threading.h:99:1\r\n#24 0x0000000000baaab5 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:13\r\n#25 0x0000000000baa24f mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:523:1\r\n#26 0x0000000000ba987e mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:383:28\r\n#27 0x0000000000ba9b13 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:445:15\r\n#28 0x0000000000bab084 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:689:40\r\n#29 0x0000000000baaf0b mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:669:69\r\n#30 0x0000000000406529 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, mlir::TimingScope&, mlir::MLIRContext&, std::function<mlir::LogicalResult (mlir::ModuleOp)>) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:297:13\r\n#31 0x0000000000406c47 executeFirtool(mlir::MLIRContext&) /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:377:30\r\n#32 0x0000000000406e29 main /home/drom/work/github/llvm/circt/tools/firtool/firtool.cpp:413:31\r\n#33 0x0000000004a7db35 __libc_start_main (/lib64/libc.so.6+0x27b35)\r\n#34 0x000000000040584e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 56: 17325 Aborted                 (core dumped) valgrind -q $FIRTOOL $INPUT --lower-to-hw --infer-widths --mlir-timing --verilog -o=$VFILE3"}, {"number": 1491, "title": "[FIRRTL] Infer width from mux sel for known result", "created_at": "2021-07-29T04:38:57Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Relax short circuit logic inside InferWidths so that a MuxPrimOp still\r\ngenerates constraints from its select line (which sets a hard\r\nrequirement on a 1-bit width) even if the width of the mux result is\r\nalready known.\r\n\r\nPreviously, this would set no constraints derived from the select line if the width was already known. This would cause circuits like the following to have uninferred widths:\r\n\r\n```scala\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input sel: UInt\r\n    input t: UInt<1>\r\n    input f: UInt<1>\r\n    output out: UInt<1>\r\n\r\n    out <= mux(sel, t, f)\r\n```", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input sel: UInt\r\n    input t: UInt<1>\r\n    input f: UInt<1>\r\n    output out: UInt<1>\r\n\r\n    out <= mux(sel, t, f)"}, {"number": 1488, "title": "[FIRRTL] imconstprop mismatch", "created_at": "2021-07-28T19:33:55Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module Bar :\r\n    input a: UInt<1>\r\n    input b: UInt<1>\r\n    output c: UInt<1>\r\n    output d: UInt<1>\r\n    c <= b\r\n    wire _c: UInt<1>\r\n    _c <= xor(a, c)\r\n    d <= _c\r\n  module top_mod :\r\n    input a: UInt<1>\r\n    input b: UInt<1>\r\n    output c: UInt<1>\r\n    output d: UInt<1>\r\n    inst bar of Bar\r\n    bar.a <= a\r\n    bar.b <= b\r\n    c <= bar.c\r\n    d <= bar.d\r\n```\r\n\r\nCompiled with `firtool -imconstprop` produces this Verilog:\r\n\r\n```verilog\r\nmodule Bar(\r\n  input  a, b,\r\n  output c, d);\r\n\r\n  assign c = b;\t// a_top_mod.fir:2:10\r\n  assign d = 1'h0;\t// a_top_mod.fir:2:10, :8:5\r\nendmodule\r\n\r\nmodule top_mod(\r\n  input  a, b,\r\n  output c, d);\r\n\r\n  wire bar_d;\t// a_top_mod.fir:16:5\r\n\r\n  Bar bar (\t// a_top_mod.fir:16:5\r\n    .a (a),\r\n    .b (b),\r\n    .c (c),\r\n    .d (bar_d)\r\n  );\r\n  assign d = 1'h0;\t// a_top_mod.fir:11:10, :16:5\r\nendmodule\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/511872/127385642-59d723fc-1f03-49a6-bfd7-09f6b403c1f1.png)\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:\r\n\r\n```verilog\r\nmodule Bar(\r\n  input   a,\r\n  input   b,\r\n  output  c,\r\n  output  d\r\n);\r\n  assign c = b;\r\n  assign d = a ^ c;\r\nendmodule\r\nmodule top_mod(\r\n  input   a,\r\n  input   b,\r\n  output  c,\r\n  output  d\r\n);\r\n  wire  bar_a;\r\n  wire  bar_b;\r\n  wire  bar_c;\r\n  wire  bar_d;\r\n  Bar bar (\r\n    .a(bar_a),\r\n    .b(bar_b),\r\n    .c(bar_c),\r\n    .d(bar_d)\r\n  );\r\n  assign c = bar_c;\r\n  assign d = bar_d;\r\n  assign bar_a = a;\r\n  assign bar_b = b;\r\nendmodule\r\n\r\n```\r\n![image](https://user-images.githubusercontent.com/511872/127385700-ac28908c-3e7d-4d2b-952d-67b7dedec153.png)\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\n```", "code_snippet_01": "circuit top_mod :\r\n  module Bar :\r\n    input a: UInt<1>\r\n    input b: UInt<1>\r\n    output c: UInt<1>\r\n    output d: UInt<1>\r\n    c <= b\r\n    wire _c: UInt<1>\r\n    _c <= xor(a, c)\r\n    d <= _c\r\n  module top_mod :\r\n    input a: UInt<1>\r\n    input b: UInt<1>\r\n    output c: UInt<1>\r\n    output d: UInt<1>\r\n    inst bar of Bar\r\n    bar.a <= a\r\n    bar.b <= b\r\n    c <= bar.c\r\n    d <= bar.d", "code_snippet_02": "module Bar(\r\n  input  a, b,\r\n  output c, d);\r\n\r\n  assign c = b;\t// a_top_mod.fir:2:10\r\n  assign d = 1'h0;\t// a_top_mod.fir:2:10, :8:5\r\nendmodule\r\n\r\nmodule top_mod(\r\n  input  a, b,\r\n  output c, d);\r\n\r\n  wire bar_d;\t// a_top_mod.fir:16:5\r\n\r\n  Bar bar (\t// a_top_mod.fir:16:5\r\n    .a (a),\r\n    .b (b),\r\n    .c (c),\r\n    .d (bar_d)\r\n  );\r\n  assign d = 1'h0;\t// a_top_mod.fir:11:10, :16:5\r\nendmodule", "code_snippet_03": "module Bar(\r\n  input   a,\r\n  input   b,\r\n  output  c,\r\n  output  d\r\n);\r\n  assign c = b;\r\n  assign d = a ^ c;\r\nendmodule\r\nmodule top_mod(\r\n  input   a,\r\n  input   b,\r\n  output  c,\r\n  output  d\r\n);\r\n  wire  bar_a;\r\n  wire  bar_b;\r\n  wire  bar_c;\r\n  wire  bar_d;\r\n  Bar bar (\r\n    .a(bar_a),\r\n    .b(bar_b),\r\n    .c(bar_c),\r\n    .d(bar_d)\r\n  );\r\n  assign c = bar_c;\r\n  assign d = bar_d;\r\n  assign bar_a = a;\r\n  assign bar_b = b;\r\nendmodule", "code_snippet_04": "ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 1485, "title": "[FIRRTL] Handle Illegal Aggregate Connects in Parser (or LowerTypes?)", "created_at": "2021-07-28T02:25:50Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Currently, we will convert illegal ground connects to partial connects where the RHS is larger than the LHS. However, if a user passes in an aggregate with this property, we need to emit element-wise partial connects.  (Emitting an aggregate partial connect will change connection semantics.)  Currently `LowerTypes` will create an illegal connect when it needs to pad.\r\n\r\nConsider:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    input a: {a: UInt<2>}\r\n    output b: {a: UInt<1>}\r\n\r\n    b <= a\r\n```\r\n\r\nThis produces: \r\n\r\n```\r\n# firtool Foo.fir                    \r\nFoo.fir:6:7: error: destination width 1 is not greater than or equal to source width 2\r\n    b <= a\r\n      ^\r\nFoo.fir:6:7: note: see current operation: \"firrtl.connect\"(%arg1, %arg0) : (!firrtl.uint<1>, !firrtl.uint<2>) -> ()\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input a: {a: UInt<2>}\r\n    output b: {a: UInt<1>}\r\n\r\n    b <= a", "code_snippet_02": "# firtool Foo.fir                    \r\nFoo.fir:6:7: error: destination width 1 is not greater than or equal to source width 2\r\n    b <= a\r\n      ^\r\nFoo.fir:6:7: note: see current operation: \"firrtl.connect\"(%arg1, %arg0) : (!firrtl.uint<1>, !firrtl.uint<2>) -> ()"}, {"number": 1478, "title": "[FIRRTL] IMConstProp Bug: Output used as wire", "created_at": "2021-07-25T07:06:20Z", "state": "closed", "labels": "bug, FIRRTL", "body": "One more IMConstProp bug.  Registers in instances that read from an output port are getting incorrectly optimized away. Note: this bug doesn't seem to exist for modules where the register is in the top module.  \r\n\r\nConsider the following circuit where register `%r` reads from output port `%a` and also writes to it (effectively creating a self connection):\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\"   {\r\n  firrtl.module @Bar(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {\r\n    %r = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>\r\n    %0 = firrtl.not %a : (!firrtl.uint<1>) -> !firrtl.uint<1>\r\n    firrtl.connect %r, %0 : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %a, %r : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {\r\n    %bar_clock, %bar_a = firrtl.instance @Bar  {name = \"bar\"} : !firrtl.clock, !firrtl.uint<1>\r\n    firrtl.connect %bar_clock, %clock : !firrtl.clock, !firrtl.clock\r\n    firrtl.connect %a, %bar_a : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nIMConstProp is deleting the register `%r` when it should keep it around.  After IMConstProp, the circuit is:\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\"   {\r\n  firrtl.module @Bar(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    %bar_clock, %bar_a = firrtl.instance @Bar  {name = \"bar\"} : !firrtl.clock, !firrtl.uint<1>\r\n    firrtl.connect %bar_clock, %clock : !firrtl.clock, !firrtl.clock\r\n    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\n### Background\r\n\r\nThe source FIRRTL for this is:\r\n\r\n```scala\r\ncircuit Foo :\r\n  module Bar :\r\n    input clock : Clock\r\n    output a : UInt<1>\r\n\r\n    reg r : UInt<1>, clock\r\n    r <= not(a)\r\n    a <= r\r\n\r\n  module Foo :\r\n    input clock : Clock\r\n    output a : UInt<1>\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    a <= bar.a\r\n```\r\n\r\nRunning this through the Scala FIRRTL Compiler produces the following:\r\n\r\n```verilog\r\nmodule Bar(\r\n  input   clock,\r\n  output  a\r\n);\r\n  reg  r;\r\n  assign a = r;\r\n  always @(posedge clock) begin\r\n    r <= ~a;\r\n  end\r\nendmodule\r\nmodule Foo(\r\n  input   clock,\r\n  output  a\r\n);\r\n  wire  bar_clock;\r\n  wire  bar_a;\r\n  Bar bar (\r\n    .clock(bar_clock),\r\n    .a(bar_a)\r\n  );\r\n  assign a = bar_a;\r\n  assign bar_clock = clock;\r\nendmodule\r\n\r\n```\r\n\r\nRunning this through CIRCT produces:\r\n\r\n```verilog\r\nmodule Bar(\r\n  input  clock,\r\n  output a);\r\n\r\n  assign a = 1'h0;\t// Foo.fir:2:10, :6:5\r\nendmodule\r\n\r\nmodule Foo(\r\n  input  clock,\r\n  output a);\r\n\r\n  wire bar_a;\t// Foo.fir:14:5\r\n\r\n  Bar bar (\t// Foo.fir:14:5\r\n    .clock (clock),\r\n    .a     (bar_a)\r\n  );\r\n  assign a = 1'h0;\t// Foo.fir:10:10, :14:5\r\nendmodule\r\n```\r\n\r\nI was surprised that formulations where the register is in the top module work. I.e., the following compiles just fine:\r\n\r\n```scala\r\ncircuit Foo :\r\n  module Foo :\r\n    input clock : Clock\r\n    output a : UInt<1>\r\n\r\n    reg r : UInt<1>, clock\r\n    r <= not(a)\r\n    a <= r\r\n```", "code_snippet_01": "firrtl.circuit \"Foo\"   {\r\n  firrtl.module @Bar(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {\r\n    %r = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>\r\n    %0 = firrtl.not %a : (!firrtl.uint<1>) -> !firrtl.uint<1>\r\n    firrtl.connect %r, %0 : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %a, %r : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {\r\n    %bar_clock, %bar_a = firrtl.instance @Bar  {name = \"bar\"} : !firrtl.clock, !firrtl.uint<1>\r\n    firrtl.connect %bar_clock, %clock : !firrtl.clock, !firrtl.clock\r\n    firrtl.connect %a, %bar_a : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_02": "firrtl.circuit \"Foo\"   {\r\n  firrtl.module @Bar(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n  firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    %bar_clock, %bar_a = firrtl.instance @Bar  {name = \"bar\"} : !firrtl.clock, !firrtl.uint<1>\r\n    firrtl.connect %bar_clock, %clock : !firrtl.clock, !firrtl.clock\r\n    firrtl.connect %a, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_03": "circuit Foo :\r\n  module Bar :\r\n    input clock : Clock\r\n    output a : UInt<1>\r\n\r\n    reg r : UInt<1>, clock\r\n    r <= not(a)\r\n    a <= r\r\n\r\n  module Foo :\r\n    input clock : Clock\r\n    output a : UInt<1>\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    a <= bar.a", "code_snippet_04": "module Bar(\r\n  input   clock,\r\n  output  a\r\n);\r\n  reg  r;\r\n  assign a = r;\r\n  always @(posedge clock) begin\r\n    r <= ~a;\r\n  end\r\nendmodule\r\nmodule Foo(\r\n  input   clock,\r\n  output  a\r\n);\r\n  wire  bar_clock;\r\n  wire  bar_a;\r\n  Bar bar (\r\n    .clock(bar_clock),\r\n    .a(bar_a)\r\n  );\r\n  assign a = bar_a;\r\n  assign bar_clock = clock;\r\nendmodule", "code_snippet_05": "module Bar(\r\n  input  clock,\r\n  output a);\r\n\r\n  assign a = 1'h0;\t// Foo.fir:2:10, :6:5\r\nendmodule\r\n\r\nmodule Foo(\r\n  input  clock,\r\n  output a);\r\n\r\n  wire bar_a;\t// Foo.fir:14:5\r\n\r\n  Bar bar (\t// Foo.fir:14:5\r\n    .clock (clock),\r\n    .a     (bar_a)\r\n  );\r\n  assign a = 1'h0;\t// Foo.fir:10:10, :14:5\r\nendmodule", "code_snippet_06": "circuit Foo :\r\n  module Foo :\r\n    input clock : Clock\r\n    output a : UInt<1>\r\n\r\n    reg r : UInt<1>, clock\r\n    r <= not(a)\r\n    a <= r"}, {"number": 1477, "title": "[FIRRTL] Add Verifier Check that Register Init Type Matches Register Type", "created_at": "2021-07-25T05:47:48Z", "state": "closed", "labels": "bug, good first issue, FIRRTL", "body": "Add a check that FIRRTL's `regreset` errors if the type of the reset value doesn't match the type of reset.  E.g., the following should fail because a vector register is being reset to a ground type.  However, it does not fail and will crash LowerTypes:\r\n\r\n```mlir\r\n%r = firrtl.regreset %clock, %reset, %c0_ui1  : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.vector<uint<1>, 1>\r\n```\r\n\r\nI think there's something clever that can be done here with the `AllTypesMatch` or `AllTypesMatchWith` ODS functions (or something similar). However, I'm not finding an immediate solution. ", "code_snippet_01": "%r = firrtl.regreset %clock, %reset, %c0_ui1  : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.vector<uint<1>, 1>"}, {"number": 1471, "title": "[FIRRTL] (mux) zero-width false positive", "created_at": "2021-07-23T01:51:42Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input y: UInt<0>\r\n    input a: UInt<8>\r\n    input b: UInt<8>\r\n    output res: UInt<8>\r\n    res <= mux(y, a, b)\r\n```\r\n\r\nCompiled with `firtool` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [7:0] a, b,\r\n  output [7:0] res);\r\n\r\n  assign res = b;\t// a_top_mod.fir:2:10\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT` produces this Error:\r\n\r\n```\r\nException in thread \"main\" firrtl.passes.CheckTypes$MuxCondUInt: : [module top_mod]\r\n   A mux condition must be of type 1-bit UInt.\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input y: UInt<0>\r\n    input a: UInt<8>\r\n    input b: UInt<8>\r\n    output res: UInt<8>\r\n    res <= mux(y, a, b)", "code_snippet_02": "module top_mod(\r\n  input  [7:0] a, b,\r\n  output [7:0] res);\r\n\r\n  assign res = b;\t// a_top_mod.fir:2:10\r\nendmodule", "code_snippet_03": "Exception in thread \"main\" firrtl.passes.CheckTypes$MuxCondUInt: : [module top_mod]\r\n   A mux condition must be of type 1-bit UInt."}, {"number": 1466, "title": "[FIRRTL][IMConstProp] Bug with Instance Input -> Wire -> Output", "created_at": "2021-07-22T07:51:35Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Here's a fun one.  Consider the following FIRRTL dialect.  There is an _input port_ of an instance connected to a wire connected to an output, `b`. What should the value of `b` be?  \r\n\r\n```mlir\r\nfirrtl.circuit \"Top\"   {\r\n  firrtl.extmodule @Ext(in %a: !firrtl.uint<1>)\r\n  firrtl.module @Top(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n    %ext_a = firrtl.instance @Ext  {name = \"ext\"} : !firrtl.uint<1>\r\n    firrtl.connect %ext_a, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    %w = firrtl.wire  : !firrtl.uint<1>\r\n    firrtl.connect %w, %ext_a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %b, %w : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }  \r\n}\r\n```\r\n\r\nIMConstProp is botching this.  It removes the wire and connects `%b` to invalid.\r\n\r\nI.e., if you compile this with: `circt-opt Top.mlir -pass-pipeline='firrtl.circuit(firrtl-imconstprop)'` you get:\r\n\r\n```verilog\r\nfirrtl.circuit \"Top\"   {\r\n  firrtl.extmodule @Ext(in %a: !firrtl.uint<1>)\r\n  firrtl.module @Top(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n    %ext_a = firrtl.instance @Ext  {name = \"ext\"} : !firrtl.uint<1>\r\n    firrtl.connect %ext_a, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nFor a perhaps easier to read version of the above, you can compile the following FIRRTL text:\r\n\r\n```scala\r\ncircuit Top:\r\n  extmodule Ext:\r\n    input a: UInt<1>\r\n\r\n  module Top:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    inst ext of Ext\r\n    ext.a <= a\r\n\r\n    wire w: UInt<1>\r\n    w <= ext.a\r\n\r\n    b <= w\r\n```\r\n\r\nWith CIRCT you get:\r\n\r\n```verilog\r\nmodule Top(\r\n  input  a,\r\n  output b);\r\n\r\n  Ext ext (\t// Top.fir:9:5\r\n    .a (a)\r\n  );\r\n  assign b = 1'h0;\t// Top.fir:5:10, :12:5\r\nendmodule\r\n```\r\n\r\nWith the Scala FIRRTL Compiler (SFC) you get:\r\n\r\n```verilog\r\nmodule Top(\r\n  input   a,\r\n  output  b\r\n);\r\n  wire  ext_a;\r\n  Ext ext (\r\n    .a(ext_a)\r\n  );\r\n  assign b = ext_a;\r\n  assign ext_a = a;\r\nendmodule\r\n```", "code_snippet_01": "firrtl.circuit \"Top\"   {\r\n  firrtl.extmodule @Ext(in %a: !firrtl.uint<1>)\r\n  firrtl.module @Top(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n    %ext_a = firrtl.instance @Ext  {name = \"ext\"} : !firrtl.uint<1>\r\n    firrtl.connect %ext_a, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    %w = firrtl.wire  : !firrtl.uint<1>\r\n    firrtl.connect %w, %ext_a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.connect %b, %w : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }  \r\n}", "code_snippet_02": "firrtl.circuit \"Top\"   {\r\n  firrtl.extmodule @Ext(in %a: !firrtl.uint<1>)\r\n  firrtl.module @Top(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n    %ext_a = firrtl.instance @Ext  {name = \"ext\"} : !firrtl.uint<1>\r\n    firrtl.connect %ext_a, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_03": "circuit Top:\r\n  extmodule Ext:\r\n    input a: UInt<1>\r\n\r\n  module Top:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    inst ext of Ext\r\n    ext.a <= a\r\n\r\n    wire w: UInt<1>\r\n    w <= ext.a\r\n\r\n    b <= w", "code_snippet_04": "module Top(\r\n  input  a,\r\n  output b);\r\n\r\n  Ext ext (\t// Top.fir:9:5\r\n    .a (a)\r\n  );\r\n  assign b = 1'h0;\t// Top.fir:5:10, :12:5\r\nendmodule", "code_snippet_05": "module Top(\r\n  input   a,\r\n  output  b\r\n);\r\n  wire  ext_a;\r\n  Ext ext (\r\n    .a(ext_a)\r\n  );\r\n  assign b = ext_a;\r\n  assign ext_a = a;\r\nendmodule"}, {"number": 1465, "title": "[FIRRTL][IMConstProp] Bug with Self-Driven Register", "created_at": "2021-07-22T07:03:13Z", "state": "closed", "labels": "bug, FIRRTL", "body": "IMConstProp is botching the following example. Start with an oscillator called `foobar` that toggles every cycle:\r\n\r\n```mlir\r\nfirrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {\r\n  %foobar = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>\r\n  %0 = firrtl.not %foobar : (!firrtl.uint<1>) -> !firrtl.uint<1>\r\n  firrtl.connect %foobar, %0 : !firrtl.uint<1>, !firrtl.uint<1>\r\n  firrtl.connect %a, %foobar : !firrtl.uint<1>, !firrtl.uint<1>\r\n}\r\n```\r\n\r\nAfter IMConstprop, this will produce:\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\"   {\r\n  firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {\r\n    %foobar = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>\r\n    firrtl.connect %a, %foobar : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nThe self connection is removed which is illegal to do.  I haven't looked at IMConstProp to see what might be going on here.\r\n\r\nFor possibly easier inspection, this is taken from the following FIRRTL text:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    input clock: Clock\r\n    output a: UInt<1>\r\n\r\n    reg foobar: UInt<1>, clock\r\n\r\n    foobar <= not(foobar)\r\n    a <= foobar\r\n```\r\n\r\nGoing all the way to Verilog gives us (trimming randomization logic):\r\n\r\n```verilog\r\nmodule Foo(\r\n  input  clock,\r\n  output a);\r\n\r\n  reg foobar;\t// Tmp.fir:6:5\r\n  assign a = foobar;\t// Tmp.fir:2:10\r\nendmodule\r\n```\r\n\r\nThe Scala FIRRTL Compiler (SFC) produces:\r\n\r\n```verilog\r\nmodule Foo(\r\n  input   clock,\r\n  output  a\r\n);\r\n  reg  foobar;\r\n  assign a = foobar;\r\n  always @(posedge clock) begin\r\n    foobar <= ~foobar;\r\n  end\r\nendmodule\r\n```\r\n", "code_snippet_01": "firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {\r\n  %foobar = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>\r\n  %0 = firrtl.not %foobar : (!firrtl.uint<1>) -> !firrtl.uint<1>\r\n  firrtl.connect %foobar, %0 : !firrtl.uint<1>, !firrtl.uint<1>\r\n  firrtl.connect %a, %foobar : !firrtl.uint<1>, !firrtl.uint<1>\r\n}", "code_snippet_02": "firrtl.circuit \"Foo\"   {\r\n  firrtl.module @Foo(in %clock: !firrtl.clock, out %a: !firrtl.uint<1>) {\r\n    %foobar = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>\r\n    firrtl.connect %a, %foobar : !firrtl.uint<1>, !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_03": "circuit Foo:\r\n  module Foo:\r\n    input clock: Clock\r\n    output a: UInt<1>\r\n\r\n    reg foobar: UInt<1>, clock\r\n\r\n    foobar <= not(foobar)\r\n    a <= foobar", "code_snippet_04": "module Foo(\r\n  input  clock,\r\n  output a);\r\n\r\n  reg foobar;\t// Tmp.fir:6:5\r\n  assign a = foobar;\t// Tmp.fir:2:10\r\nendmodule", "code_snippet_05": "module Foo(\r\n  input   clock,\r\n  output  a\r\n);\r\n  reg  foobar;\r\n  assign a = foobar;\r\n  always @(posedge clock) begin\r\n    foobar <= ~foobar;\r\n  end\r\nendmodule"}, {"number": 1453, "title": "[FIRRTL] Lower Types Vector Lowering Bug", "created_at": "2021-07-20T19:52:12Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Annotations on vectors aren't being handled correctly during FIRRTL's LowerTypes pass:\r\n\r\n- If the annotation is on the first element, everything is lowered correctly. \r\n- If the annotation is on an element after the first element, the annotation is lowered to both that element and the one before it.\r\n\r\n\r\nConsider the following circuit with the annotation `\"a\"` on the first element of a wire:\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo() {\r\n      %a = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [1, 1], {a}>]} : !firrtl.vector<uint<1>, 4>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAfter types are lowered, this becomes:\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo() {\r\n      %a_0 = firrtl.wire  {annotations = [{a}]} : !firrtl.uint<1>\r\n      %a_1 = firrtl.wire  : !firrtl.uint<1>\r\n      %a_2 = firrtl.wire  : !firrtl.uint<1>\r\n      %a_3 = firrtl.wire  : !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis looks great.\r\n\r\nNow if you annotate the second element:\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo() {\r\n      %a = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [2, 2], {a}>]} : !firrtl.vector<uint<1>, 4>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis lowers to:\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo() {\r\n      %a_0 = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [1, 1], {a}>]} : !firrtl.uint<1>\r\n      %a_1 = firrtl.wire  {annotations = [{a}]} : !firrtl.uint<1>\r\n      %a_2 = firrtl.wire  : !firrtl.uint<1>\r\n      %a_3 = firrtl.wire  : !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAnd just so it's clear that only the element before is annotated, this is what happens for the third element:\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo() {\r\n      %a_0 = firrtl.wire  : !firrtl.uint<1>\r\n      %a_1 = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [1, 1], {a}>]} : !firrtl.uint<1>\r\n      %a_2 = firrtl.wire  {annotations = [{a}]} : !firrtl.uint<1>\r\n      %a_3 = firrtl.wire  : !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n\r\n```", "code_snippet_01": "module  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo() {\r\n      %a = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [1, 1], {a}>]} : !firrtl.vector<uint<1>, 4>\r\n    }\r\n  }\r\n}", "code_snippet_02": "module  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo() {\r\n      %a_0 = firrtl.wire  {annotations = [{a}]} : !firrtl.uint<1>\r\n      %a_1 = firrtl.wire  : !firrtl.uint<1>\r\n      %a_2 = firrtl.wire  : !firrtl.uint<1>\r\n      %a_3 = firrtl.wire  : !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_03": "module  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo() {\r\n      %a = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [2, 2], {a}>]} : !firrtl.vector<uint<1>, 4>\r\n    }\r\n  }\r\n}", "code_snippet_04": "module  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo() {\r\n      %a_0 = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [1, 1], {a}>]} : !firrtl.uint<1>\r\n      %a_1 = firrtl.wire  {annotations = [{a}]} : !firrtl.uint<1>\r\n      %a_2 = firrtl.wire  : !firrtl.uint<1>\r\n      %a_3 = firrtl.wire  : !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_05": "module  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo() {\r\n      %a_0 = firrtl.wire  : !firrtl.uint<1>\r\n      %a_1 = firrtl.wire  {annotations = [#firrtl.subAnno<fieldID = [1, 1], {a}>]} : !firrtl.uint<1>\r\n      %a_2 = firrtl.wire  {annotations = [{a}]} : !firrtl.uint<1>\r\n      %a_3 = firrtl.wire  : !firrtl.uint<1>\r\n    }\r\n  }\r\n}"}, {"number": 1450, "title": "[ExportVerilog] Add option to force posedge/negedge values to be in a wire", "created_at": "2021-07-20T13:17:02Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Some tools don't like it if the `x` in a `@(posedge x)` is not strictly a name referring to a wire. Specifically, we've seen `localparam x = ...; @(posedge x)` break. We should add an option to ExportVerilog/firtool that forces all values used in sensitivity lists of processes to be spilled into wires."}, {"number": 1449, "title": "[FIRRTL] Grand Central DataTap Needs to Tap in Parent Module", "created_at": "2021-07-20T05:30:13Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Currently, if you try to data tap into the current module, the generated XMR will have no hierarchy.  I don't think this will resolve correctly.  Instead, there should be an additional level of hierarchy.\r\n\r\nConsider (and sorry for the verbosity) the following.  This is trying to tap `~Top|GCTDataTap>r`:\r\n\r\n```scala\r\ncircuit Top : %[\r\n[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\": \"~Top|DataTap\",\r\n    \"keys\": [\r\n      {\r\n        \"class\": \"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\": \"~Top|GCTDataTap>r\",\r\n        \"portName\": \"~Top|DataTap>_0\"\r\n      }\r\n    ]\r\n  }\r\n]]\r\n  extmodule DataTap :\r\n    output _0 : UInt<1>\r\n\r\n    defname = DataTap\r\n\r\n  module Bar:\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    reg r : UInt<1>, clock\r\n\r\n    r <= a\r\n    b <= r\r\n\r\n\r\n  module GCTDataTap :\r\n    input clock : Clock\r\n    input a : UInt<1>\r\n    output b : UInt<1>\r\n\r\n    reg r : UInt<1>, clock\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    bar.a <= a\r\n    r <= bar.b\r\n    b <= r\r\n\r\n    wire cloneType : UInt<1>\r\n    inst DataTap of DataTap\r\n    DataTap._0 is invalid\r\n    cloneType <= DataTap._0\r\n\r\n  module Top:\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    inst DUT of GCTDataTap\r\n    DUT.clock <= clock\r\n    DUT.a <= a\r\n    b <= DUT.b\r\n\r\n```\r\n\r\nThe generated XMR is:\r\n\r\n```verilog\r\nmodule DataTap_impl_0(\r\n  output _0);\r\n\r\n  assign _0 = r;        // gct/DataTap.fir:15:13\r\nendmodule\r\n```\r\n\r\nAnd for confirmation that this is a problem, Verilator can't find `r`:\r\n```\r\n%Error: /dev/stdin:37:15: Can't find definition of variable: 'r'\r\n   37 |   assign _0 = r;  \r\n      |               ^\r\n%Error: Exiting due to 1 error(s)\r\n```\r\n\r\nHowever, if I instead tap `~Top|Bar>r`, everything works.  This produces the following Verilog and Verilator is happy:\r\n\r\n```verilog\r\nmodule DataTap_impl_0(\r\n  output _0);\r\n\r\n  assign _0 = bar.r;    // gct/DataTap.fir:15:13\r\nendmodule\r\n```\r\n\r\n(Also, who knew that Verilator could handle hierarchical references?  To test this, I'm just using `firtool Foo.fir | verilator --lint-only /dev/stdin`.)", "code_snippet_01": "circuit Top : %[\r\n[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\": \"~Top|DataTap\",\r\n    \"keys\": [\r\n      {\r\n        \"class\": \"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\": \"~Top|GCTDataTap>r\",\r\n        \"portName\": \"~Top|DataTap>_0\"\r\n      }\r\n    ]\r\n  }\r\n]]\r\n  extmodule DataTap :\r\n    output _0 : UInt<1>\r\n\r\n    defname = DataTap\r\n\r\n  module Bar:\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    reg r : UInt<1>, clock\r\n\r\n    r <= a\r\n    b <= r\r\n\r\n\r\n  module GCTDataTap :\r\n    input clock : Clock\r\n    input a : UInt<1>\r\n    output b : UInt<1>\r\n\r\n    reg r : UInt<1>, clock\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    bar.a <= a\r\n    r <= bar.b\r\n    b <= r\r\n\r\n    wire cloneType : UInt<1>\r\n    inst DataTap of DataTap\r\n    DataTap._0 is invalid\r\n    cloneType <= DataTap._0\r\n\r\n  module Top:\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    inst DUT of GCTDataTap\r\n    DUT.clock <= clock\r\n    DUT.a <= a\r\n    b <= DUT.b", "code_snippet_02": "module DataTap_impl_0(\r\n  output _0);\r\n\r\n  assign _0 = r;        // gct/DataTap.fir:15:13\r\nendmodule", "code_snippet_03": "%Error: /dev/stdin:37:15: Can't find definition of variable: 'r'\r\n   37 |   assign _0 = r;  \r\n      |               ^\r\n%Error: Exiting due to 1 error(s)", "code_snippet_04": "module DataTap_impl_0(\r\n  output _0);\r\n\r\n  assign _0 = bar.r;    // gct/DataTap.fir:15:13\r\nendmodule"}, {"number": 1384, "title": "[FIRRTL] Support LiteralDataTapKey in grand central data taps pass", "created_at": "2021-07-07T07:01:19Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Currently the `GrandCentralTaps` pass complains about `LiteralDataTapKey` not being supported. These should be fairly straightforward to implement (possibly requiring parsing of FIR-style literals)."}, {"number": 1375, "title": "Accept ReferenceDataTapKey on FIRRTL nodes", "created_at": "2021-07-06T12:28:50Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The FIRRTL `GrandCentralTaps` pass currently complains about `ReferenceDataTapKey` annotations on `firrtl.node` ops. These should actually be allowed, since the nodes get a name assigned during Verilog emission that can be used in a hierarchical lookup. These annotations do appear on nodes also out in the wild."}, {"number": 1356, "title": "Syntax error in generated System Verilog with struct in register.", "created_at": "2021-07-01T05:51:53Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "I'm looking at a case like the following:\r\n\r\n```mlir\r\nhw.module @Test(%in: !hw.struct<a: i1, b: i1>, %clk: i1) -> (%out: !hw.struct<a: i1, b: i1>) {\r\n  %0 = seq.compreg %in, %clk : !hw.struct<a: i1, b: i1>\r\n  hw.output %0 : !hw.struct<a: i1, b: i1>\r\n}\r\n```\r\n\r\nThe desire is to register a packed struct. Technically, we're trying to register a packed array of packed structs, but just a struct is sufficient to demonstrate this issue.\r\n\r\nI think it should be legal to register a packed struct, or a packed array of packed structs, but please stop me here if I'm wrong.\r\n\r\nTo lower this, I am using the following passes:\r\n\r\n```sh\r\ncirct-opt test.mlir -lower-seq-to-sv -hw-legalize-names\r\n```\r\n\r\nWhich produces:\r\n\r\n```mlir\r\nmodule  {\r\n  hw.module @Test(%in: !hw.struct<a: i1, b: i1>, %clk: i1) -> (%out: !hw.struct<a: i1, b: i1>) {\r\n    %_T = sv.reg  : !hw.inout<struct<a: i1, b: i1>>\r\n    %0 = sv.read_inout %_T : !hw.inout<struct<a: i1, b: i1>>\r\n    sv.alwaysff(posedge %clk)  {\r\n      sv.passign %_T, %in : !hw.struct<a: i1, b: i1>\r\n    }\r\n    hw.output %0 : !hw.struct<a: i1, b: i1>\r\n  }\r\n}\r\n```\r\n\r\nUnless I'm missing something, so far so good. The issue is in the generated System Verilog.\r\n\r\nI'm using:\r\n\r\n```sh\r\ncirct-translate -export-verilog\r\n```\r\n\r\nWhich produces:\r\n\r\n```verilog\r\nmodule Test(\r\n  input  struct packed {logic a; logic b; } in,\r\n  input                                     clk,\r\n  output struct packed {logic a; logic b; } out);\r\n\r\n  reg struct packed {logic a; logic b; } _T;\t// <stdin>:3:11\r\n\r\n  always @(posedge clk)\t// <stdin>:5:5\r\n    _T <= in;\t// <stdin>:6:7\r\n  assign out = _T;\t// <stdin>:4:10, :8:5\r\nendmodule\r\n```\r\n\r\nThis seems like a faithful translation of the IR, but the issue is on the `reg` line.\r\n\r\nRunning that through Verilator with:\r\n\r\n```sh\r\nverilator -sv -lint-only\r\n```\r\n\r\nProduces these errors:\r\n\r\n```sh\r\n%Error: /tmp/a:6:7: syntax error, unexpected struct\r\n    6 |   reg struct packed {logic a; logic b; } _T;\r\n      |       ^~~~~~\r\n%Error: /tmp/a:6:40: syntax error, unexpected '}'\r\n    6 |   reg struct packed {logic a; logic b; } _T;\r\n      |                                        ^\r\n%Error: Exiting due to 2 error(s)\r\n```\r\n\r\nIf I manually remove the `reg ` from the System Verilog, Verilator doesn't complain. @teqdruid has reported the same behavior from Questa. My reading of section 6.8 of the spec seems to confirm the removal of `reg ` is correct: in the grammar defined in section 6.8, `data_type` appears to support `reg` or a `struct` type, but not `reg struct ...`.\r\n\r\nIs this something we can adjust in the ExportVerilog handling of registers of structs (and arrays of structs)? If there's consensus that this is the right line of thought, I can take that task.", "code_snippet_01": "hw.module @Test(%in: !hw.struct<a: i1, b: i1>, %clk: i1) -> (%out: !hw.struct<a: i1, b: i1>) {\r\n  %0 = seq.compreg %in, %clk : !hw.struct<a: i1, b: i1>\r\n  hw.output %0 : !hw.struct<a: i1, b: i1>\r\n}", "code_snippet_02": "circt-opt test.mlir -lower-seq-to-sv -hw-legalize-names", "code_snippet_03": "module  {\r\n  hw.module @Test(%in: !hw.struct<a: i1, b: i1>, %clk: i1) -> (%out: !hw.struct<a: i1, b: i1>) {\r\n    %_T = sv.reg  : !hw.inout<struct<a: i1, b: i1>>\r\n    %0 = sv.read_inout %_T : !hw.inout<struct<a: i1, b: i1>>\r\n    sv.alwaysff(posedge %clk)  {\r\n      sv.passign %_T, %in : !hw.struct<a: i1, b: i1>\r\n    }\r\n    hw.output %0 : !hw.struct<a: i1, b: i1>\r\n  }\r\n}", "code_snippet_04": "circt-translate -export-verilog", "code_snippet_05": "module Test(\r\n  input  struct packed {logic a; logic b; } in,\r\n  input                                     clk,\r\n  output struct packed {logic a; logic b; } out);\r\n\r\n  reg struct packed {logic a; logic b; } _T;\t// <stdin>:3:11\r\n\r\n  always @(posedge clk)\t// <stdin>:5:5\r\n    _T <= in;\t// <stdin>:6:7\r\n  assign out = _T;\t// <stdin>:4:10, :8:5\r\nendmodule", "code_snippet_06": "verilator -sv -lint-only", "code_snippet_07": "%Error: /tmp/a:6:7: syntax error, unexpected struct\r\n    6 |   reg struct packed {logic a; logic b; } _T;\r\n      |       ^~~~~~\r\n%Error: /tmp/a:6:40: syntax error, unexpected '}'\r\n    6 |   reg struct packed {logic a; logic b; } _T;\r\n      |                                        ^\r\n%Error: Exiting due to 2 error(s)"}, {"number": 1350, "title": "[FIRRTL] Verify Zero-width Behavior", "created_at": "2021-06-30T05:17:39Z", "state": "closed", "labels": "bug, FIRRTL", "body": "It's unclear to me if CIRCT is aligning with Scala FIRRTL Compiler zero width behavior as defined in: \r\n- https://github.com/chipsalliance/firrtl/blob/master/src/test/scala/firrtlTests/ZeroWidthTests.scala\r\n\r\nVerify that CIRCT is doing the right thing here, expand this issue with any differences that may exist, and close this once CIRCT passes all these tests.\r\n\r\n- [x] Port\r\n- [x] Add\r\n- [x] Mux: https://github.com/llvm/circt/pull/1349\r\n- [ ] ???"}, {"number": 1312, "title": "[FIRRTL] Windows build broken", "created_at": "2021-06-22T19:35:37Z", "state": "closed", "labels": "bug, FIRRTL", "body": "https://github.com/llvm/circt/actions/runs/961864100\r\n\r\n```\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRTokenKinds.def(132,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRTokenKinds.def(132,1): error C2065: 'lp_': undeclared identifier (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRTokenKinds.def(132,1): error C2059: syntax error: ':' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRTokenKinds.def(155,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRTokenKinds.def(156,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRTokenKinds.def(164,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\n```", "code_snippet_01": "D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRTokenKinds.def(132,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRTokenKinds.def(132,1): error C2065: 'lp_': undeclared identifier (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRTokenKinds.def(132,1): error C2059: syntax error: ':' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRTokenKinds.def(155,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRTokenKinds.def(156,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRTokenKinds.def(164,1): error C2039: 'lp_': is not a member of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRLexer.h(29): message : see declaration of 'circt::firrtl::FIRToken' (compiling source file D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\Import\\FIRParser.cpp) [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\Import\\obj.CIRCTImportFIRRTL.vcxproj]"}, {"number": 1303, "title": "[FIRRTL] Allow connecting `uint` to `reset`", "created_at": "2021-06-21T15:20:56Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following connect currently breaks:\r\n```firrtl\r\ncircuit test :\r\n  module test :\r\n    output out : Reset\r\n    out <= UInt(1)\r\n```\r\nWith the following message:\r\n```plain\r\nerror: type mismatch between destination '!firrtl.reset' and source '!firrtl.uint'\r\n  firrtl.connect %out, %c1_ui : !firrtl.reset, !firrtl.uint\r\n  ^\r\n```\r\nThe connect *does* work for `out <= UInt<1>(1)`.\r\n\r\nThis should work according to the following reset inference test case: https://github.com/chipsalliance/firrtl/blob/eb0841d27f5cd077c5f27f339ef9eb86cbe64599/src/test/scala/firrtlTests/InferResetsSpec.scala#L129-L134", "code_snippet_01": "circuit test :\r\n  module test :\r\n    output out : Reset\r\n    out <= UInt(1)", "code_snippet_02": "error: type mismatch between destination '!firrtl.reset' and source '!firrtl.uint'\r\n  firrtl.connect %out, %c1_ui : !firrtl.reset, !firrtl.uint\r\n  ^"}, {"number": 1302, "title": "[FIRRTL] Allow connecting `Reset` and `AsyncReset`", "created_at": "2021-06-21T15:12:36Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Bundles where corresponding fields have a reset type should be allowed in connects, but the following code breaks:\r\n```firrtl\r\ncircuit top :\r\n  module top :\r\n    input foo : { a : AsyncReset, flip b: Reset }\r\n    output bar : { a : Reset, flip b: AsyncReset }\r\n    bar <= foo\r\n```\r\nWith the following error:\r\n```plain\r\nerror: type mismatch between destination '!firrtl.bundle<a: reset, b: flip<asyncreset>>'\r\n                              and source '!firrtl.bundle<a: asyncreset, b: flip<reset>>'\r\n    bar <= foo\r\n        ^\r\n```\r\nThis only occurs if the resets are nested in bundles or vectors. Directly connecting a `AsyncReset` to a `Reset` wire, or vice versa, works.\r\n\r\nExtracted from test case for [reset inference](https://github.com/chipsalliance/firrtl/blob/eb0841d27f5cd077c5f27f339ef9eb86cbe64599/src/test/scala/firrtlTests/InferResetsSpec.scala#L96-L105).", "code_snippet_01": "circuit top :\r\n  module top :\r\n    input foo : { a : AsyncReset, flip b: Reset }\r\n    output bar : { a : Reset, flip b: AsyncReset }\r\n    bar <= foo", "code_snippet_02": "error: type mismatch between destination '!firrtl.bundle<a: reset, b: flip<asyncreset>>'\r\n                              and source '!firrtl.bundle<a: asyncreset, b: flip<reset>>'\r\n    bar <= foo\r\n        ^"}, {"number": 1289, "title": "[FIRRTL] (dshl, tail, mul) width inference mismatch", "created_at": "2021-06-16T16:43:39Z", "state": "open", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\nProduces different width for the output port `_tmp40`\r\n\r\n```python\r\n; seed: 1144\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output _tmp40: UInt\r\n    wire tmp19: UInt\r\n    tmp19 <= mul(UInt(\"o20575\"), UInt<1>(0))\r\n    _tmp40 <= dshl(UInt(\"b10011010000001011101\"), tail(tmp19, 15))\r\n```\r\n\r\nCompiled with `firtool` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [19:0] _tmp40);\r\n\r\n  assign _tmp40 = 20'h9A05D;\t// a_top_mod.fir:3:3, :7:20\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [18:0] _tmp40\r\n);\r\n  assign _tmp40 = 19'h1a05d;\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nERROR: Can't match gold port `_tmp40_gold' to a gate port.\r\n```", "code_snippet_01": "; seed: 1144\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output _tmp40: UInt\r\n    wire tmp19: UInt\r\n    tmp19 <= mul(UInt(\"o20575\"), UInt<1>(0))\r\n    _tmp40 <= dshl(UInt(\"b10011010000001011101\"), tail(tmp19, 15))", "code_snippet_02": "module top_mod(\r\n  output [19:0] _tmp40);\r\n\r\n  assign _tmp40 = 20'h9A05D;\t// a_top_mod.fir:3:3, :7:20\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  output [18:0] _tmp40\r\n);\r\n  assign _tmp40 = 19'h1a05d;\r\nendmodule", "code_snippet_04": "ERROR: Can't match gold port `_tmp40_gold' to a gate port."}, {"number": 1288, "title": "[FIRRTL] (dshl, head) mismatch", "created_at": "2021-06-16T15:53:05Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 759\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_cb: UInt<60>\r\n    output _tmp66: UInt<91>\r\n    wire tmp12: SInt\r\n    wire _tmp13: UInt\r\n    wire tmp58: UInt\r\n    tmp12 <= shl(SInt(\"b-100101100101\"), 1)\r\n    _tmp13 <= dshl(inp_cb, tail(asUInt(tmp12), 11))\r\n    tmp58 <= pad(inp_cb, 41)\r\n    _tmp66 <= dshl(_tmp13, head(tmp58, 0))\r\n```\r\n\r\nCompiled with `firtool` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [59:0] inp_cb,\r\n  output [90:0] _tmp66);\r\n\r\n  assign _tmp66 = {24'h0, {1'h0, inp_cb, 6'h0} << 67'h0};\t// a_top_mod.fir:3:3, :10:15, :12:15\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [59:0] inp_cb,\r\n  output [90:0] _tmp66\r\n);\r\n  wire [65:0] _GEN_0 = {inp_cb, 6'h0};\r\n  wire [66:0] _GEN_1 = {{1'd0}, _GEN_0};\r\n  wire [59:0] _GEN_2 = {{1'd0}, _GEN_1[58:0]};\r\n  assign _tmp66 = {{31'd0}, _GEN_2};\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nERROR: Found 7 unproven $equiv cells in 'equiv_status -assert'.\r\n```", "code_snippet_01": "; seed: 759\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_cb: UInt<60>\r\n    output _tmp66: UInt<91>\r\n    wire tmp12: SInt\r\n    wire _tmp13: UInt\r\n    wire tmp58: UInt\r\n    tmp12 <= shl(SInt(\"b-100101100101\"), 1)\r\n    _tmp13 <= dshl(inp_cb, tail(asUInt(tmp12), 11))\r\n    tmp58 <= pad(inp_cb, 41)\r\n    _tmp66 <= dshl(_tmp13, head(tmp58, 0))", "code_snippet_02": "module top_mod(\r\n  input  [59:0] inp_cb,\r\n  output [90:0] _tmp66);\r\n\r\n  assign _tmp66 = {24'h0, {1'h0, inp_cb, 6'h0} << 67'h0};\t// a_top_mod.fir:3:3, :10:15, :12:15\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [59:0] inp_cb,\r\n  output [90:0] _tmp66\r\n);\r\n  wire [65:0] _GEN_0 = {inp_cb, 6'h0};\r\n  wire [66:0] _GEN_1 = {{1'd0}, _GEN_0};\r\n  wire [59:0] _GEN_2 = {{1'd0}, _GEN_1[58:0]};\r\n  assign _tmp66 = {{31'd0}, _GEN_2};\r\nendmodule", "code_snippet_04": "ERROR: Found 7 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 1271, "title": "[FIRRTL] Width Inference Problem with Cycle", "created_at": "2021-06-14T20:19:50Z", "state": "closed", "labels": "bug, FIRRTL, infer width", "body": "The following circuit causes an error during width inference of register `a`. However, the SFC infers a width of two.\r\n\r\n```scala\r\ncircuit Bar :\r\n  module Bar :\r\n    input clock : Clock\r\n    input cond : UInt<1>\r\n\r\n    reg a : UInt, clock\r\n\r\n    node _false = add(a, UInt<1>(0))\r\n    node false = tail(_false, 1)\r\n    a <= mux(cond, UInt<2>(0), false)\r\n```\r\n\r\nWith the MFC, I get:\r\n```\r\nBar.fir:6:5: error: 'firrtl.reg' op is constrained to be wider than itself\r\n    reg a : UInt, clock\r\n    ^\r\nBar.fir:6:5: note: see current operation: %a = \"firrtl.reg\"(%clock) {annotations = [], name = \"a\"} : (!firrtl.clock) -> !firrtl.uint\r\nBar.fir:8:19: note: constrained width W >= W+2 here:\r\n    node _false = add(a, UInt<1>(0))\r\n                  ^\r\nBar.fir:9:18: note: constrained width W >= W+1 here:\r\n    node false = tail(_false, 1)\r\n                 ^\r\nBar.fir:10:10: note: constrained width W >= W+1 here:\r\n    a <= mux(cond, UInt<2>(0), false)\r\n         ^\r\n```\r\n\r\nWith the SFC, I get:\r\n```scala\r\ncircuit Bar :\r\n  module Bar :\r\n    input clock : Clock\r\n    input cond : UInt<1>\r\n\r\n    reg a : UInt<2>, clock with :\r\n      reset => (UInt<1>(\"h0\"), a)\r\n    node _false = add(a, UInt<1>(\"h0\"))\r\n    node false = tail(_false, 1)\r\n    a <= mux(cond, UInt<2>(\"h0\"), false)\r\n```", "code_snippet_01": "circuit Bar :\r\n  module Bar :\r\n    input clock : Clock\r\n    input cond : UInt<1>\r\n\r\n    reg a : UInt, clock\r\n\r\n    node _false = add(a, UInt<1>(0))\r\n    node false = tail(_false, 1)\r\n    a <= mux(cond, UInt<2>(0), false)", "code_snippet_02": "Bar.fir:6:5: error: 'firrtl.reg' op is constrained to be wider than itself\r\n    reg a : UInt, clock\r\n    ^\r\nBar.fir:6:5: note: see current operation: %a = \"firrtl.reg\"(%clock) {annotations = [], name = \"a\"} : (!firrtl.clock) -> !firrtl.uint\r\nBar.fir:8:19: note: constrained width W >= W+2 here:\r\n    node _false = add(a, UInt<1>(0))\r\n                  ^\r\nBar.fir:9:18: note: constrained width W >= W+1 here:\r\n    node false = tail(_false, 1)\r\n                 ^\r\nBar.fir:10:10: note: constrained width W >= W+1 here:\r\n    a <= mux(cond, UInt<2>(0), false)\r\n         ^", "code_snippet_03": "circuit Bar :\r\n  module Bar :\r\n    input clock : Clock\r\n    input cond : UInt<1>\r\n\r\n    reg a : UInt<2>, clock with :\r\n      reset => (UInt<1>(\"h0\"), a)\r\n    node _false = add(a, UInt<1>(\"h0\"))\r\n    node false = tail(_false, 1)\r\n    a <= mux(cond, UInt<2>(\"h0\"), false)"}, {"number": 1270, "title": "[FIRRTL] Connect Verifier False Positive", "created_at": "2021-06-14T19:17:39Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following circuit (extracted from a real design) is tripping a connect op verifier error:\r\n\r\n```scala\r\ncircuit Foo :\r\n  module Foo :\r\n    input source: UInt<1>\r\n    input cond: UInt<1>\r\n\r\n    wire a_set : UInt<1>\r\n    a_set <= UInt<1>(\"h0\")\r\n    when cond :\r\n      node _a_set_T = dshl(UInt<1>(\"h1\"), source)\r\n      a_set <= _a_set_T\r\n```\r\n\r\nThe MFC's InferWidths pass is currently erroring out with:\r\n```\r\nfire-drill/TileLinkMonitor.hi.fir:10:13: error: destination width 1 is not greater than or equal to source width 2\r\n      a_set <= _a_set_T\r\n            ^\r\nfire-drill/TileLinkMonitor.hi.fir:10:13: note: see current operation: \"firrtl.connect\"(%a_set, %1) : (!firrtl.uint<1>, !firrtl.uint<2>) -> ()\r\n```\r\n\r\nHowever, the SFC allows this through. The SFC doesn't align with the spec and does auto-truncation on connects. \ud83e\udd37\u200d\u2640\ufe0f \r\n\r\nThe eventual SFC output Verilog is:\r\n```\r\nmodule Foo(\r\n  input   source,\r\n  input   cond\r\n);\r\n  wire [1:0] _a_set_T = 2'h1 << source;\r\n  wire [1:0] _GEN_0 = cond ? _a_set_T : 2'h0; // @[]\r\n  wire  a_set = _GEN_0[0];\r\nendmodule\r\n```", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input source: UInt<1>\r\n    input cond: UInt<1>\r\n\r\n    wire a_set : UInt<1>\r\n    a_set <= UInt<1>(\"h0\")\r\n    when cond :\r\n      node _a_set_T = dshl(UInt<1>(\"h1\"), source)\r\n      a_set <= _a_set_T", "code_snippet_02": "fire-drill/TileLinkMonitor.hi.fir:10:13: error: destination width 1 is not greater than or equal to source width 2\r\n      a_set <= _a_set_T\r\n            ^\r\nfire-drill/TileLinkMonitor.hi.fir:10:13: note: see current operation: \"firrtl.connect\"(%a_set, %1) : (!firrtl.uint<1>, !firrtl.uint<2>) -> ()", "code_snippet_03": "module Foo(\r\n  input   source,\r\n  input   cond\r\n);\r\n  wire [1:0] _a_set_T = 2'h1 << source;\r\n  wire [1:0] _GEN_0 = cond ? _a_set_T : 2'h0; // @[]\r\n  wire  a_set = _GEN_0[0];\r\nendmodule"}, {"number": 1215, "title": "[FIRRTL] (dshr, and) mismatch", "created_at": "2021-06-08T01:22:33Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_e: SInt<58>\r\n    output tmp116: UInt<58>\r\n    wire tmp109: SInt<58>\r\n    tmp109 <= dshr(inp_e, tail(UInt<21>(\"h1935b6\"), 11))\r\n    tmp116 <= and(asSInt(UInt<9>(\"o246\")), tmp109)\r\n```\r\n\r\nCompiled with `firtool` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [57:0] inp_e,\r\n  output [57:0] tmp116);\r\n\r\n  assign tmp116 = $signed(inp_e) >>> 58'sh1B6 & 58'hA6;\t// a_top_mod.fir:2:3, :6:15, :7:15\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [57:0] inp_e,\r\n  output [57:0] tmp116\r\n);\r\n  wire  _GEN_1 = inp_e[57];\r\n  wire [57:0] tmp109 = {58{_GEN_1}};\r\n  assign tmp116 = 58'sha6 & $signed(tmp109);\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nERROR: Found 4 unproven $equiv cells in 'equiv_status -assert'.\r\n```", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_e: SInt<58>\r\n    output tmp116: UInt<58>\r\n    wire tmp109: SInt<58>\r\n    tmp109 <= dshr(inp_e, tail(UInt<21>(\"h1935b6\"), 11))\r\n    tmp116 <= and(asSInt(UInt<9>(\"o246\")), tmp109)", "code_snippet_02": "module top_mod(\r\n  input  [57:0] inp_e,\r\n  output [57:0] tmp116);\r\n\r\n  assign tmp116 = $signed(inp_e) >>> 58'sh1B6 & 58'hA6;\t// a_top_mod.fir:2:3, :6:15, :7:15\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [57:0] inp_e,\r\n  output [57:0] tmp116\r\n);\r\n  wire  _GEN_1 = inp_e[57];\r\n  wire [57:0] tmp109 = {58{_GEN_1}};\r\n  assign tmp116 = 58'sha6 & $signed(tmp109);\r\nendmodule", "code_snippet_04": "ERROR: Found 4 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 1188, "title": "[FIRRTL] Integration test times out", "created_at": "2021-06-02T17:26:27Z", "state": "closed", "labels": "bug, FIRRTL", "body": "![image](https://user-images.githubusercontent.com/1498080/120525409-f5b43d80-c38c-11eb-88f4-05cb7f46dc23.png)\r\n\r\nhttps://github.com/llvm/circt/runs/2727815005?check_suite_focus=true"}, {"number": 1187, "title": "FIRRTL Error involving Division Fold", "created_at": "2021-06-02T15:49:51Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following circuit crashes `firtool`. \r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    input divisor: UInt<1>\r\n    output result: UInt<0>\r\n\r\n    wire dividend: UInt<0>\r\n    dividend is invalid\r\n\r\n    result <= div(dividend, divisor)\r\n```\r\n\r\nThe issue is that `div(x, invalid)` or `div(invalid, x)` is trying to fold to `UInt<$width>(0)` where `$width` is the result type. This is the usual problem where `APInt` can't have a zero width.\r\n\r\nThis started to show up on `circt/perf`'s test1 because inter-module constant propagation got turned on in e73115d5969905b2def85af062d3feb15c204003 which tickles this for test1. The minimal circuit above hits the same code path but goes through the `SimpleCanonicalizer` which means that this will fail even without/before e73115d5969905b2def85af062d3feb15c204003.", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input divisor: UInt<1>\r\n    output result: UInt<0>\r\n\r\n    wire dividend: UInt<0>\r\n    dividend is invalid\r\n\r\n    result <= div(dividend, divisor)"}, {"number": 1181, "title": "LowerTypes Exposes Bare Flips that Trip Primop Verifier", "created_at": "2021-05-31T03:35:43Z", "state": "closed", "labels": "bug", "body": "Consider the following circuit:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Bar:\r\n    output a: { flip a: UInt<1> }\r\n    input b: UInt<1>\r\n  module Foo:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    inst bar of Bar\r\n    bar is invalid\r\n\r\n    b <= and(bar.a.a, bar.b)\r\n```\r\n\r\nBoth `bar.a.a` and `bar.b` have sink flow. However, the `bar.a.a` reference results in a malformed `and` op (according to its verifier). That verifier requires that no flips appear:\r\n\r\n```mlir\r\n%0 = \"firrtl.asPassive\"(%bar_b) : (!firrtl.flip<uint<1>>) -> !firrtl.uint<1>\r\n%1 = \"firrtl.and\"(%bar_a_a, %0) : (!firrtl.flip<uint<1>>, !firrtl.uint<1>) -> !firrtl.uint<1>\r\n```\r\n\r\nThe reason why this _doesn't_ fail for `bar.b` is because an `asPassive` op is inserted during parsing. The parser checks for flips used as right-hand-side expression in a primitive op. However, this is just a subset of \"sink used as source\".\r\n\r\nThere are a bunch of ways that this could be fixed:\r\n\r\n1) Expand the parser check to look for sinks used as sources and insert `asPassive` when needed.\r\n2) Lower Types should recognize this case and insert `asPassive`.\r\n3) This verifier should stop checking flip and actually check flow.\r\n\r\n### Background\r\n\r\nThis is a reduced case that shows up when trying to compile a middle FIRRTL file from Chipyard. This pattern occurs in the `TLError` module.", "code_snippet_01": "circuit Foo:\r\n  module Bar:\r\n    output a: { flip a: UInt<1> }\r\n    input b: UInt<1>\r\n  module Foo:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    inst bar of Bar\r\n    bar is invalid\r\n\r\n    b <= and(bar.a.a, bar.b)", "code_snippet_02": "%0 = \"firrtl.asPassive\"(%bar_b) : (!firrtl.flip<uint<1>>) -> !firrtl.uint<1>\r\n%1 = \"firrtl.and\"(%bar_a_a, %0) : (!firrtl.flip<uint<1>>, !firrtl.uint<1>) -> !firrtl.uint<1>"}, {"number": 1173, "title": "[ExpandWhens] Strip flip types off of bundles before casting", "created_at": "2021-05-28T06:22:16Z", "state": "closed", "labels": "bug, FIRRTL", "body": "This code was erroneously assuming that the operand of subfield op was\r\nalways a bundle type.  BundleType can be wrapped in a FlipType if it is\r\nan `in` port of an InstanceOp.  This change strips the flip type from\r\nthe bundle type when it is there."}, {"number": 1161, "title": "[FIRRTL] Remove black box annotations after ingesting them", "created_at": "2021-05-27T17:37:38Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Currently the `BlackBoxReader` pass ingests black box annotations and reads the files into `sv.verbatim` files, but leaves the annotations there. This makes the pass non-idempotent, which is bad (running it again will replicate the black boxes). Run the transform twice in the test to reproduce this bug, then remove the annotation."}, {"number": 1158, "title": "[FIRRTL] Windows build broken", "created_at": "2021-05-26T18:45:22Z", "state": "closed", "labels": "bug, FIRRTL", "body": "https://github.com/llvm/circt/runs/2675122003?check_suite_focus=true\r\n\r\n```\r\nD:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\FIRRTLTypes.cpp(701,23): error C2398: Element '1': conversion from 'size_t' to 'T &&' requires a narrowing conversion [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\obj.CIRCTFIRRTL.vcxproj]\r\n          with\r\n          [\r\n              T=unsigned int\r\n          ]\r\n```\r\n\r\nMaybe this was already fixed, but last nights Windows build failed.", "code_snippet_01": "D:\\a\\circt\\circt\\lib\\Dialect\\FIRRTL\\FIRRTLTypes.cpp(701,23): error C2398: Element '1': conversion from 'size_t' to 'T &&' requires a narrowing conversion [D:\\a\\circt\\circt\\build_release\\lib\\Dialect\\FIRRTL\\obj.CIRCTFIRRTL.vcxproj]\r\n          with\r\n          [\r\n              T=unsigned int\r\n          ]"}, {"number": 1153, "title": "[FIRRTL] Don't fold mux with unknown result width", "created_at": "2021-05-26T10:32:42Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Fix an issue around mux canonicalization where folding a mux to one of its operands can result in invalidation of subsequent IR if the mux result does not have a known width. For example, picking an unsized constant can lead to the constant resolving to a width more narrow than assumed in the remaining IR. This change refuses to fold and canonicalize any multiplexers that have unkown result width.\r\n\r\nFixes #1142."}, {"number": 1121, "title": "[FIRRTL] LowerTypes: fix handing of mux ops", "created_at": "2021-05-21T19:37:06Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Mux lowering forgot to check when the type was not a bundle, leading to\r\nlots of crashes"}, {"number": 1102, "title": "[FIRRTL] Fix constant width inference and connection truncation", "created_at": "2021-05-20T15:28:34Z", "state": "closed", "labels": "bug, FIRRTL, infer width", "body": "* Width inference can cause the RHS of a connect operation to become wider than the LHS. The behaviour prescribed by the Scala FIRRTL compiler is to insert a `bits` operation to truncate the RHS to the appropriate width. Add this behaviour to the InferWidths pass. Fixes #1088, fixes #1089, fixes #1091, fixes #1092, fixes #1093, fixes #1094, fixes #1095, fixes #1096, fixes #1097, fixes #1099.\r\n* Fix an issue where unsized constants would infer a width that could be wider than the minimum number of bits necessary to represent the constant. This fixes width inference to properly compute the number of bits necessary to represent a signed/unsigned constant. Also updates the APInt store in ConstantOp after width inference. Fixes #1090, fixes #1098.\r\n\r\nThis will make @drom very happy :wink: "}, {"number": 1101, "title": "[FIRRTL] Connecting wide constant to narrow port crashes canonicalizer", "created_at": "2021-05-20T14:07:52Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The canonicalizer currently crashes in `TailPrimOp::fold` on the following FIRRTL input:\r\n```firrtl\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output y: SInt<4>\r\n    y <= SInt<10>(9)  // note the constant being wider than the port\r\n```\r\n\r\nThis translates to the following MLIR before canonicalization:\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"top_mod\"  {\r\n    firrtl.module @top_mod(in %x: !firrtl.sint<5>, out %y: !firrtl.sint<4>) {\r\n      %c9_si10 = firrtl.constant 9 : !firrtl.sint<10>\r\n      firrtl.partialconnect %y, %c9_si10 : !firrtl.sint<4>, !firrtl.sint<10>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nRunning the above through `circt-opt --simple-canonicalizer` triggers the crash. Stack trace:\r\n```plain\r\ncirct-opt: ../llvm/mlir/include/mlir/IR/Types.h:243: U mlir::Type::cast() const [U = circt::firrtl::UIntType]: Assertion `isa<U>()' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.  Program arguments: circt-opt --simple-canonicalizer\r\n #0 0x00007fc815bc7701 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) llvm/llvm/lib/Support/Unix/Signals.inc:565:13\r\n #1 0x00007fc815bc5760 llvm::sys::RunSignalHandlers() llvm/llvm/lib/Support/Signals.cpp:77:18\r\n #2 0x00007fc815bc7c2d SignalHandler(int) llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007fc8178dc960 __restore_rt (/usr/lib/libpthread.so.0+0x13960)\r\n #4 0x00007fc815561ef5 raise (/usr/lib/libc.so.6+0x3cef5)\r\n #5 0x00007fc81554b862 abort (/usr/lib/libc.so.6+0x26862)\r\n #6 0x00007fc81554b747 _nl_load_domain.cold (/usr/lib/libc.so.6+0x26747)\r\n #7 0x00007fc81555a646 (/usr/lib/libc.so.6+0x35646)\r\n #8 0x00007fc8175663cd llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> >::updatePointer(long, void*) llvm/llvm/include/llvm/ADT/PointerIntPair.h:178:5\r\n #9 0x00007fc8175663cd llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> > >::setPointerAndInt(void*, int) & llvm/llvm/include/llvm/ADT/PointerIntPair.h:76:29\r\n#10 0x00007fc8175663cd llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> > >::PointerIntPair(void*, int) llvm/llvm/include/llvm/ADT/PointerIntPair.h:54:5\r\n#11 0x00007fc8175663cd llvm::pointer_union_detail::PointerUnionMembers<llvm::PointerUnion<mlir::Attribute, mlir::Value>, llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> > >, 0, mlir::Attribute, mlir::Value>::PointerUnionMembers(mlir::Attribute) llvm/llvm/include/llvm/ADT/PointerUnion.h:118:16\r\n#12 0x00007fc8175663cd llvm::PointerUnion<mlir::Attribute, mlir::Value>::PointerUnion(mlir::Attribute) llvm/llvm/include/llvm/ADT/PointerUnion.h:168:15\r\n#13 0x00007fc8175663cd mlir::OpFoldResult::OpFoldResult(mlir::Attribute) llvm/mlir/include/mlir/IR/OpDefinition.h:207:41\r\n#14 0x00007fc8175663cd circt::firrtl::TailPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) lib/Dialect/FIRRTL/FIRRTLFolds.cpp:947:14\r\n#15 0x00007fc81755c470 mlir::LogicalResult mlir::Op<circt::firrtl::TailPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::TailPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) llvm/mlir/include/mlir/IR/OpDefinition.h:1702:49\r\n```\r\n\r\nApparently the partial connect gets mapped to a `tail` operation but somehow the sign of the result is off.", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    output y: SInt<4>\r\n    y <= SInt<10>(9)  // note the constant being wider than the port", "code_snippet_02": "module  {\r\n  firrtl.circuit \"top_mod\"  {\r\n    firrtl.module @top_mod(in %x: !firrtl.sint<5>, out %y: !firrtl.sint<4>) {\r\n      %c9_si10 = firrtl.constant 9 : !firrtl.sint<10>\r\n      firrtl.partialconnect %y, %c9_si10 : !firrtl.sint<4>, !firrtl.sint<10>\r\n    }\r\n  }\r\n}", "code_snippet_03": "circt-opt: ../llvm/mlir/include/mlir/IR/Types.h:243: U mlir::Type::cast() const [U = circt::firrtl::UIntType]: Assertion `isa<U>()' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.  Program arguments: circt-opt --simple-canonicalizer\r\n #0 0x00007fc815bc7701 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) llvm/llvm/lib/Support/Unix/Signals.inc:565:13\r\n #1 0x00007fc815bc5760 llvm::sys::RunSignalHandlers() llvm/llvm/lib/Support/Signals.cpp:77:18\r\n #2 0x00007fc815bc7c2d SignalHandler(int) llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007fc8178dc960 __restore_rt (/usr/lib/libpthread.so.0+0x13960)\r\n #4 0x00007fc815561ef5 raise (/usr/lib/libc.so.6+0x3cef5)\r\n #5 0x00007fc81554b862 abort (/usr/lib/libc.so.6+0x26862)\r\n #6 0x00007fc81554b747 _nl_load_domain.cold (/usr/lib/libc.so.6+0x26747)\r\n #7 0x00007fc81555a646 (/usr/lib/libc.so.6+0x35646)\r\n #8 0x00007fc8175663cd llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> >::updatePointer(long, void*) llvm/llvm/include/llvm/ADT/PointerIntPair.h:178:5\r\n #9 0x00007fc8175663cd llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> > >::setPointerAndInt(void*, int) & llvm/llvm/include/llvm/ADT/PointerIntPair.h:76:29\r\n#10 0x00007fc8175663cd llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> > >::PointerIntPair(void*, int) llvm/llvm/include/llvm/ADT/PointerIntPair.h:54:5\r\n#11 0x00007fc8175663cd llvm::pointer_union_detail::PointerUnionMembers<llvm::PointerUnion<mlir::Attribute, mlir::Value>, llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Attribute, mlir::Value> > >, 0, mlir::Attribute, mlir::Value>::PointerUnionMembers(mlir::Attribute) llvm/llvm/include/llvm/ADT/PointerUnion.h:118:16\r\n#12 0x00007fc8175663cd llvm::PointerUnion<mlir::Attribute, mlir::Value>::PointerUnion(mlir::Attribute) llvm/llvm/include/llvm/ADT/PointerUnion.h:168:15\r\n#13 0x00007fc8175663cd mlir::OpFoldResult::OpFoldResult(mlir::Attribute) llvm/mlir/include/mlir/IR/OpDefinition.h:207:41\r\n#14 0x00007fc8175663cd circt::firrtl::TailPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) lib/Dialect/FIRRTL/FIRRTLFolds.cpp:947:14\r\n#15 0x00007fc81755c470 mlir::LogicalResult mlir::Op<circt::firrtl::TailPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::TailPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) llvm/mlir/include/mlir/IR/OpDefinition.h:1702:49"}, {"number": 1071, "title": "[LLHD] Buffer over-read during simulation", "created_at": "2021-05-18T08:40:48Z", "state": "closed", "labels": "bug, LLHD", "body": "In `LLHD/Engine.cpp`, a memory bytebuffer is converted to an APInt.  In order to do this, the buffer is converted from `uint8_t*` to `uint64_t*`, and the size of the buffer is rounded up to the next 64 bits.  After this, the constructor of APInt reads past the end of the original bytebuffer.\r\n\r\n```c++\r\n      APInt buff(\r\n          curr.size * 8,\r\n          llvm::makeArrayRef(reinterpret_cast<uint64_t *>(curr.value.get()),\r\n                             llvm::divideCeil(curr.size, 8)));\r\n```\r\n\r\nThere seems to be a purpose built function to do what we want, although I haven't checked how the memory buffer is supposed to be used on big endian systems.\r\n```c++\r\n      APInt buff(curr.size * 8, 0);\r\n      LoadIntFromMemory(buff, curr.value.get(), curr.size);\r\n```\r\n\r\nThere are at least two places that will have to be fixed:\r\nhttps://github.com/llvm/circt/blob/main/lib/Dialect/LLHD/Simulator/Engine.cpp#L131\r\nhttps://github.com/llvm/circt/blob/main/lib/Dialect/LLHD/Simulator/State.cpp#L113", "code_snippet_01": "c++\r\n      APInt buff(\r\n          curr.size * 8,\r\n          llvm::makeArrayRef(reinterpret_cast<uint64_t *>(curr.value.get()),\r\n                             llvm::divideCeil(curr.size, 8)));", "code_snippet_02": "c++\r\n      APInt buff(curr.size * 8, 0);\r\n      LoadIntFromMemory(buff, curr.value.get(), curr.size);"}, {"number": 1069, "title": "[LLHD] Don't erase ops in the folder for Connect and Drv", "created_at": "2021-05-18T07:22:36Z", "state": "closed", "labels": "bug, LLHD", "body": "The folder does not allow an op to be explicitly erased, which was\r\ncausing the folder to use-after-free.  There doesn't seem to be a good\r\nway to implement the folding of an op with no results, so this was\r\nre-implemented as a canonicalization."}, {"number": 1068, "title": "[HandshakeToFIRRTL] Fix use of stack allocated vector.", "created_at": "2021-05-18T07:18:16Z", "state": "closed", "labels": "bug, Handshake", "body": "The stack allocated vector values was allocated inside a for loop and a\r\nreference to it was stored in to an SmallVector.  Asan picked up the\r\ninvalid dangling reference. The SmallVector was changed to hold (own)\r\nthe child-vector instead of keeping a reference."}, {"number": 1065, "title": "[CI] Most tests fail on Ubuntu 18.04", "created_at": "2021-05-17T17:43:44Z", "state": "open", "labels": "bug", "body": "I have a Docker-based repro: https://github.com/llvm/circt/blob/crashes-1804/utils/run-docker-1804.sh. Just run `./utils/run-docker-1804.sh`. This is running the LLVM build in the release config w/ asserts enabled and CIRCT in debug. I've attached a log of the crashes: [test_fails.log](https://github.com/llvm/circt/files/6495753/test_fails.log).\r\n\r\n\r\n```\r\nFailed Tests (210):\r\n  CIRCT :: CAPI/ir.c\r\n  CIRCT :: Conversion/FIRRTLToHW/errors.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-errors.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-module.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/zero-width.mlir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/connect.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_inouts.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_ins.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_none.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_outs.fir\r\n  CIRCT :: Conversion/HWToLLHD/errors.mlir\r\n  CIRCT :: Conversion/HWToLLHD/structure.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/simple_addi.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_branch.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_buffer.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_cmerge.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_conditional_branch.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_constant.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_fork.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_join.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_lazy_fork.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_load.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_memory.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_merge.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_mux.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_sink.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_store.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_arithmetic.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_bitwise.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_entity.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_extract.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_insert.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_memory.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_process_persistence.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_signals.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_simple.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_value_creation.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_wait.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/errors.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-for.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-load-store.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test1.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test10.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test11.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test12.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test13.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test14.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test15.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test16.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test17.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test18.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test19.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test2.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test20.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test21.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test22.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test23.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test24.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test25.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test26.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test27.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test28.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test29.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test3.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test30.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test31.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test32.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test33.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test34.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test35.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test4.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test5.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test6.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test7.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test8.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test9.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_canonicalize.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer_errors.mlir\r\n  CIRCT :: Conversion/StandardToStaticLogic/test_pipeline.mlir\r\n  CIRCT :: Dialect/ESI/connectivity.mlir\r\n  CIRCT :: Dialect/ESI/errors.mlir\r\n  CIRCT :: Dialect/ESI/lowering.mlir\r\n  CIRCT :: Dialect/ESI/modwrap.mlir\r\n  CIRCT :: Dialect/ESI/wrapif-lowering.mlir\r\n  CIRCT :: Dialect/FIRRTL/annotations.fir\r\n  CIRCT :: Dialect/FIRRTL/blackbox-memory.mlir\r\n  CIRCT :: Dialect/FIRRTL/canonicalization.mlir\r\n  CIRCT :: Dialect/FIRRTL/check-widths-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/connect-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/connect.mlir\r\n  CIRCT :: Dialect/FIRRTL/const-prop-single-module.mlir\r\n  CIRCT :: Dialect/FIRRTL/cse.mlir\r\n  CIRCT :: Dialect/FIRRTL/errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/expand-whens-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/expand-whens.mlir\r\n  CIRCT :: Dialect/FIRRTL/imconstprop.mlir\r\n  CIRCT :: Dialect/FIRRTL/infer-widths-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/infer-widths.mlir\r\n  CIRCT :: Dialect/FIRRTL/inliner.mlir\r\n  CIRCT :: Dialect/FIRRTL/lower-types-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/lower-types.mlir\r\n  CIRCT :: Dialect/FIRRTL/parse-basic.fir\r\n  CIRCT :: Dialect/FIRRTL/parse-errors.fir\r\n  CIRCT :: Dialect/FIRRTL/parse-locations.fir\r\n  CIRCT :: Dialect/FIRRTL/test.mlir\r\n  CIRCT :: Dialect/HW/basic.mlir\r\n  CIRCT :: Dialect/HW/bitwise.mlir\r\n  CIRCT :: Dialect/HW/canonicalization.mlir\r\n  CIRCT :: Dialect/HW/errors.mlir\r\n  CIRCT :: Dialect/HW/greybox.mlir\r\n  CIRCT :: Dialect/HW/modules.mlir\r\n  CIRCT :: Dialect/HW/svEmitErrors.mlir\r\n  CIRCT :: Dialect/HW/typedecls.mlir\r\n  CIRCT :: Dialect/HW/types.mlir\r\n  CIRCT :: Dialect/Handshake/errors.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/constant.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/extract.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/memory.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/probeCSE.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/signalOps.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_entity.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_relations.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_sig.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_sig_errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/IR/array.mlir\r\n  CIRCT :: Dialect/LLHD/IR/bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/IR/connect-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/connect.mlir\r\n  CIRCT :: Dialect/LLHD/IR/const.mlir\r\n  CIRCT :: Dialect/LLHD/IR/entity.mlir\r\n  CIRCT :: Dialect/LLHD/IR/extract-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/extract.mlir\r\n  CIRCT :: Dialect/LLHD/IR/insert-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/insert.mlir\r\n  CIRCT :: Dialect/LLHD/IR/inst-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/inst.mlir\r\n  CIRCT :: Dialect/LLHD/IR/memory.mlir\r\n  CIRCT :: Dialect/LLHD/IR/proc.mlir\r\n  CIRCT :: Dialect/LLHD/IR/reg.mlir\r\n  CIRCT :: Dialect/LLHD/IR/signal-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/signal.mlir\r\n  CIRCT :: Dialect/LLHD/IR/time.mlir\r\n  CIRCT :: Dialect/LLHD/IR/tuple.mlir\r\n  CIRCT :: Dialect/LLHD/IR/wait.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_arbitrary_signal_size.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_array_boundary_check.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_bit_precision_drives.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_process.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_reg.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_shifts.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_simple.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_wait.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/earlyCodeMotion.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/memoryToBlockArgument.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/processLowering.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/processLoweringErrors.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/totalFunctionInlining.mlir\r\n  CIRCT :: Dialect/MSFT/location.mlir\r\n  CIRCT :: Dialect/MSFT/opt-errors.mlir\r\n  CIRCT :: Dialect/MSFT/translate-errors.mlir\r\n  CIRCT :: Dialect/SV/basic.mlir\r\n  CIRCT :: Dialect/SV/canonicalization.mlir\r\n  CIRCT :: Dialect/SV/errors.mlir\r\n  CIRCT :: Dialect/SV/hw-cleanup.mlir\r\n  CIRCT :: Dialect/SV/hw-generator-callout.mlir\r\n  CIRCT :: Dialect/SV/hw-legalize-names-errors.mlir\r\n  CIRCT :: Dialect/SV/hw-legalize-names.mlir\r\n  CIRCT :: Dialect/SV/hw-memsim.mlir\r\n  CIRCT :: Dialect/SV/interfaces.mlir\r\n  CIRCT :: Dialect/SV/prettify-verilog.mlir\r\n  CIRCT :: Dialect/Seq/basic.mlir\r\n  CIRCT :: ExportVerilog/hw-dialect.mlir\r\n  CIRCT :: ExportVerilog/hw-typedecls.mlir\r\n  CIRCT :: ExportVerilog/line-length.mlir\r\n  CIRCT :: ExportVerilog/load-dialect.mlir\r\n  CIRCT :: ExportVerilog/sv-alwaysff.mlir\r\n  CIRCT :: ExportVerilog/sv-dialect.mlir\r\n  CIRCT :: ExportVerilog/sv-interfaces.mlir\r\n  CIRCT :: ExportVerilog/verilog-basic.mlir\r\n  CIRCT :: ExportVerilog/verilog-errors.mlir\r\n  CIRCT :: circt-opt/trivial.mlir\r\n  CIRCT :: circt-translate/parse_int64.fir\r\n  CIRCT :: firtool/firtool.fir\r\n  CIRCT :: firtool/firtool.mlir\r\n  CIRCT :: firtool/optimizations.fir\r\n  CIRCT :: firtool/phase-ordering.fir\r\n  CIRCT :: firtool/split-verilog.mlir\r\n  CIRCT :: firtool/style.fir\r\n  CIRCT :: handshake-runner/call_bb.mlir\r\n  CIRCT :: handshake-runner/cdiv-old-std.mlir\r\n  CIRCT :: handshake-runner/cdiv-std.mlir\r\n  CIRCT :: handshake-runner/complex_bb.mlir\r\n  CIRCT :: handshake-runner/floydwarshall-std.mlir\r\n  CIRCT :: handshake-runner/histogram-std.mlir\r\n  CIRCT :: handshake-runner/loadstore.mlir\r\n  CIRCT :: handshake-runner/loop-check-1-std.mlir\r\n  CIRCT :: handshake-runner/loop-check-2-std.mlir\r\n  CIRCT :: handshake-runner/matmul-check-std.mlir\r\n  CIRCT :: handshake-runner/matmul-std.mlir\r\n  CIRCT :: handshake-runner/memory_simple_2_std.mlir\r\n  CIRCT :: handshake-runner/memory_simple_std.mlir\r\n  CIRCT :: handshake-runner/simple_loop.mlir\r\n\r\n\r\nTesting Time: 1.34s\r\n  Unsupported:   4\r\n  Passed     :   6\r\n  Failed     : 210\r\n```", "code_snippet_01": "Failed Tests (210):\r\n  CIRCT :: CAPI/ir.c\r\n  CIRCT :: Conversion/FIRRTLToHW/errors.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-errors.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-module.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/zero-width.mlir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/connect.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_inouts.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_ins.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_none.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_outs.fir\r\n  CIRCT :: Conversion/HWToLLHD/errors.mlir\r\n  CIRCT :: Conversion/HWToLLHD/structure.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/simple_addi.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_branch.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_buffer.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_cmerge.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_conditional_branch.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_constant.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_fork.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_join.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_lazy_fork.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_load.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_memory.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_merge.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_mux.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_sink.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_store.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_arithmetic.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_bitwise.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_entity.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_extract.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_insert.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_memory.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_process_persistence.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_signals.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_simple.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_value_creation.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_wait.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/errors.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-for.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-load-store.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test1.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test10.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test11.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test12.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test13.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test14.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test15.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test16.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test17.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test18.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test19.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test2.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test20.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test21.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test22.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test23.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test24.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test25.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test26.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test27.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test28.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test29.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test3.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test30.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test31.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test32.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test33.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test34.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test35.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test4.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test5.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test6.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test7.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test8.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test9.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_canonicalize.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer_errors.mlir\r\n  CIRCT :: Conversion/StandardToStaticLogic/test_pipeline.mlir\r\n  CIRCT :: Dialect/ESI/connectivity.mlir\r\n  CIRCT :: Dialect/ESI/errors.mlir\r\n  CIRCT :: Dialect/ESI/lowering.mlir\r\n  CIRCT :: Dialect/ESI/modwrap.mlir\r\n  CIRCT :: Dialect/ESI/wrapif-lowering.mlir\r\n  CIRCT :: Dialect/FIRRTL/annotations.fir\r\n  CIRCT :: Dialect/FIRRTL/blackbox-memory.mlir\r\n  CIRCT :: Dialect/FIRRTL/canonicalization.mlir\r\n  CIRCT :: Dialect/FIRRTL/check-widths-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/connect-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/connect.mlir\r\n  CIRCT :: Dialect/FIRRTL/const-prop-single-module.mlir\r\n  CIRCT :: Dialect/FIRRTL/cse.mlir\r\n  CIRCT :: Dialect/FIRRTL/errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/expand-whens-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/expand-whens.mlir\r\n  CIRCT :: Dialect/FIRRTL/imconstprop.mlir\r\n  CIRCT :: Dialect/FIRRTL/infer-widths-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/infer-widths.mlir\r\n  CIRCT :: Dialect/FIRRTL/inliner.mlir\r\n  CIRCT :: Dialect/FIRRTL/lower-types-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/lower-types.mlir\r\n  CIRCT :: Dialect/FIRRTL/parse-basic.fir\r\n  CIRCT :: Dialect/FIRRTL/parse-errors.fir\r\n  CIRCT :: Dialect/FIRRTL/parse-locations.fir\r\n  CIRCT :: Dialect/FIRRTL/test.mlir\r\n  CIRCT :: Dialect/HW/basic.mlir\r\n  CIRCT :: Dialect/HW/bitwise.mlir\r\n  CIRCT :: Dialect/HW/canonicalization.mlir\r\n  CIRCT :: Dialect/HW/errors.mlir\r\n  CIRCT :: Dialect/HW/greybox.mlir\r\n  CIRCT :: Dialect/HW/modules.mlir\r\n  CIRCT :: Dialect/HW/svEmitErrors.mlir\r\n  CIRCT :: Dialect/HW/typedecls.mlir\r\n  CIRCT :: Dialect/HW/types.mlir\r\n  CIRCT :: Dialect/Handshake/errors.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/constant.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/extract.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/memory.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/probeCSE.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/signalOps.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_entity.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_relations.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_sig.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_sig_errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/IR/array.mlir\r\n  CIRCT :: Dialect/LLHD/IR/bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/IR/connect-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/connect.mlir\r\n  CIRCT :: Dialect/LLHD/IR/const.mlir\r\n  CIRCT :: Dialect/LLHD/IR/entity.mlir\r\n  CIRCT :: Dialect/LLHD/IR/extract-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/extract.mlir\r\n  CIRCT :: Dialect/LLHD/IR/insert-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/insert.mlir\r\n  CIRCT :: Dialect/LLHD/IR/inst-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/inst.mlir\r\n  CIRCT :: Dialect/LLHD/IR/memory.mlir\r\n  CIRCT :: Dialect/LLHD/IR/proc.mlir\r\n  CIRCT :: Dialect/LLHD/IR/reg.mlir\r\n  CIRCT :: Dialect/LLHD/IR/signal-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/signal.mlir\r\n  CIRCT :: Dialect/LLHD/IR/time.mlir\r\n  CIRCT :: Dialect/LLHD/IR/tuple.mlir\r\n  CIRCT :: Dialect/LLHD/IR/wait.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_arbitrary_signal_size.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_array_boundary_check.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_bit_precision_drives.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_process.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_reg.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_shifts.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_simple.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_wait.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/earlyCodeMotion.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/memoryToBlockArgument.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/processLowering.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/processLoweringErrors.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/totalFunctionInlining.mlir\r\n  CIRCT :: Dialect/MSFT/location.mlir\r\n  CIRCT :: Dialect/MSFT/opt-errors.mlir\r\n  CIRCT :: Dialect/MSFT/translate-errors.mlir\r\n  CIRCT :: Dialect/SV/basic.mlir\r\n  CIRCT :: Dialect/SV/canonicalization.mlir\r\n  CIRCT :: Dialect/SV/errors.mlir\r\n  CIRCT :: Dialect/SV/hw-cleanup.mlir\r\n  CIRCT :: Dialect/SV/hw-generator-callout.mlir\r\n  CIRCT :: Dialect/SV/hw-legalize-names-errors.mlir\r\n  CIRCT :: Dialect/SV/hw-legalize-names.mlir\r\n  CIRCT :: Dialect/SV/hw-memsim.mlir\r\n  CIRCT :: Dialect/SV/interfaces.mlir\r\n  CIRCT :: Dialect/SV/prettify-verilog.mlir\r\n  CIRCT :: Dialect/Seq/basic.mlir\r\n  CIRCT :: ExportVerilog/hw-dialect.mlir\r\n  CIRCT :: ExportVerilog/hw-typedecls.mlir\r\n  CIRCT :: ExportVerilog/line-length.mlir\r\n  CIRCT :: ExportVerilog/load-dialect.mlir\r\n  CIRCT :: ExportVerilog/sv-alwaysff.mlir\r\n  CIRCT :: ExportVerilog/sv-dialect.mlir\r\n  CIRCT :: ExportVerilog/sv-interfaces.mlir\r\n  CIRCT :: ExportVerilog/verilog-basic.mlir\r\n  CIRCT :: ExportVerilog/verilog-errors.mlir\r\n  CIRCT :: circt-opt/trivial.mlir\r\n  CIRCT :: circt-translate/parse_int64.fir\r\n  CIRCT :: firtool/firtool.fir\r\n  CIRCT :: firtool/firtool.mlir\r\n  CIRCT :: firtool/optimizations.fir\r\n  CIRCT :: firtool/phase-ordering.fir\r\n  CIRCT :: firtool/split-verilog.mlir\r\n  CIRCT :: firtool/style.fir\r\n  CIRCT :: handshake-runner/call_bb.mlir\r\n  CIRCT :: handshake-runner/cdiv-old-std.mlir\r\n  CIRCT :: handshake-runner/cdiv-std.mlir\r\n  CIRCT :: handshake-runner/complex_bb.mlir\r\n  CIRCT :: handshake-runner/floydwarshall-std.mlir\r\n  CIRCT :: handshake-runner/histogram-std.mlir\r\n  CIRCT :: handshake-runner/loadstore.mlir\r\n  CIRCT :: handshake-runner/loop-check-1-std.mlir\r\n  CIRCT :: handshake-runner/loop-check-2-std.mlir\r\n  CIRCT :: handshake-runner/matmul-check-std.mlir\r\n  CIRCT :: handshake-runner/matmul-std.mlir\r\n  CIRCT :: handshake-runner/memory_simple_2_std.mlir\r\n  CIRCT :: handshake-runner/memory_simple_std.mlir\r\n  CIRCT :: handshake-runner/simple_loop.mlir\r\n\r\n\r\nTesting Time: 1.34s\r\n  Unsupported:   4\r\n  Passed     :   6\r\n  Failed     : 210"}, {"number": 1047, "title": "Tools in CI crash across the board", "created_at": "2021-05-13T14:08:10Z", "state": "closed", "labels": "bug", "body": "Added two minimal changes (9746cd7 and 8156388) which now cause CI to produce tools and tests that all crash in weird locations: https://github.com/llvm/circt/runs/2575814179. Seems unrelated to the change. PR with the changes reverted to check if they somehow caused the problem: #1046."}, {"number": 1034, "title": "Segfault in test/Dialect/RTL/errors.mlir", "created_at": "2021-05-09T04:29:22Z", "state": "closed", "labels": "bug", "body": "test/Dialect/RTL/errors.mlir segfaults in getModuleResultNameAttr for the test of incorrect return result count.  The generic op printer when called from emitError uses getAsmResultNames gets the names of the returns on the referenced module based on the number of results on the instance, which is exactly what the test case is looking for.\r\n\r\nI haven't looked into why a segfault passes lit."}, {"number": 1031, "title": "[circt-rtl-sim] Run each simulation in its own directory", "created_at": "2021-05-07T23:19:42Z", "state": "closed", "labels": "bug", "body": "Some simulators don't like being run in parallel in the same directory. Also, reset the handshake tests to include all IEEE simulators."}, {"number": 1023, "title": "[CAPI] Guard esi::exportCosimSchema by CAPNP ifdef", "created_at": "2021-05-07T06:11:03Z", "state": "closed", "labels": "bug, ESI", "body": "C API fails to link on builds that have CAPNP disabled, since some of the symbols in the C++ API get dropped. Make the corresponding uses in the C API conditional on the presence of the same ifdef, so things link again."}, {"number": 1001, "title": "LowerTypes Parallelism Bug?", "created_at": "2021-05-04T00:11:09Z", "state": "closed", "labels": "bug, FIRRTL", "body": "I'm seeing issues on `main` where FIRRT's LowerTypes transform is trying to erase block args which still have uses. This only happens with multithreading on.\r\n\r\nYou should be able to reproduce with the following `Foo.mlir`:\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Foo\"  {\r\n    firrtl.module @Bar(%a: !firrtl.bundle<a: uint<1>>, %b: !firrtl.flip<bundle<a: uint<1>>>) {\r\n      firrtl.connect %b, %a : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>\r\n    }\r\n    firrtl.module @Foo(%a: !firrtl.bundle<a: uint<1>>, %b: !firrtl.flip<bundle<a: uint<1>>>) {\r\n      %bar_a, %bar_b = firrtl.instance @Bar  {name = \"bar\"} : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>\r\n      firrtl.connect %bar_a, %a : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>\r\n      firrtl.connect %b, %bar_b : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThen put this in a while loop:\r\n\r\n```bash\r\nwhile circt-opt -pass-pipeline='firrtl.circuit(firrtl-lower-types)' Foo.mlir; do echo \"works\"; done\r\n```\r\n\r\nThis should eventually crash.\r\n\r\nAlternatively, running without parallelism on shouldn't produce a crash:\r\n\r\n```bash\r\nwhile circt-opt -mlir-disable-threading -pass-pipeline='firrtl.circuit(firrtl-lower-types)' Foo.mlir; do echo \"works\"; done\r\n```\r\n\r\nAn example error log is below:\r\n\r\n<details>\r\n <summary>Full log</summary>\r\n\r\n```text\r\nAssertion failed: (use_empty() && \"Cannot destroy a value that still has uses!\"), function ~IRObjectWithUseList, file /Users/schuylere/repos/github.com/llvm/circt/llvm/mlir/include/mlir/IR/UseDefLists.h, line 37.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: circt-opt -pass-pipeline=firrtl.circuit(firrtl-lower-types) Foo.mlir\r\n1.\t2.\tStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  circt-opt                0x000000010fc8897d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  circt-opt                0x000000010fc88f2b PrintStackTraceSignalHandler(void*) + 27\r\n2  circt-opt                0x000000010fc86c8b llvm::sys::RunSignalHandlers() + 123\r\n3  circt-opt                0x000000010fc8b598 SignalHandler(int) + 232\r\n4  libsystem_platform.dylib 0x00007fff20384d7d _sigtramp + 29\r\n5  circt-opt                0x00000001111e9f80 _dyld_private + 0\r\n6  libsystem_c.dylib        0x00007fff20294411 abort + 120\r\n7  libsystem_c.dylib        0x00007fff202937e8 err + 0\r\n8  circt-opt                0x00000001102778c2 mlir::IRObjectWithUseList<mlir::OpOperand>::~IRObjectWithUseList() + 98\r\n9  circt-opt                0x0000000110277858 mlir::detail::ValueImpl::~ValueImpl() + 24\r\n10 circt-opt                0x0000000110277838 mlir::detail::BlockArgumentImpl::~BlockArgumentImpl() + 24\r\n11 circt-opt                0x0000000110277815 mlir::detail::BlockArgumentImpl::~BlockArgumentImpl() + 21\r\n12 circt-opt                0x0000000110274f4c mlir::BlockArgument::destroy() + 44\r\n13 circt-opt                0x000000011027670d mlir::Block::eraseArguments(llvm::function_ref<bool (mlir::BlockArgument)>) + 173\r\n14 circt-opt                0x0000000110276658 mlir::Block::eraseArguments(llvm::BitVector const&) + 72\r\n15 circt-opt                0x00000001102765d3 mlir::Block::eraseArguments(llvm::ArrayRef<unsigned int>) + 179\r\n16 circt-opt                0x000000010fcc4fed (anonymous namespace)::TypeLoweringVisitor::visitDecl(circt::firrtl::FModuleOp) + 1549\r\n17 circt-opt                0x000000010fcc4233 (anonymous namespace)::TypeLoweringVisitor::lowerModule(mlir::Operation*) + 83\r\n18 circt-opt                0x000000010fcc27f3 auto (anonymous namespace)::LowerTypesPass::runAsync()::$_8::operator()<unsigned long>(unsigned long) const + 147\r\n19 circt-opt                0x000000010fcc270f void llvm::parallel::detail::parallel_for_each_n<unsigned long, (anonymous namespace)::LowerTypesPass::runAsync()::$_8>(unsigned long, unsigned long, (anonymous namespace)::LowerTypesPass::runAsync()::$_8) + 415\r\n20 circt-opt                0x000000010fcc135d void llvm::parallelForEachN<(anonymous namespace)::LowerTypesPass::runAsync()::$_8>(unsigned long, unsigned long, (anonymous namespace)::LowerTypesPass::runAsync()::$_8) + 109\r\n21 circt-opt                0x000000010fcc111f (anonymous namespace)::LowerTypesPass::runAsync() + 191\r\n22 circt-opt                0x000000010fcc02dd (anonymous namespace)::LowerTypesPass::runOnOperation() + 61\r\n23 circt-opt                0x0000000110afaadb mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 587\r\n24 circt-opt                0x0000000110afb137 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359\r\n25 circt-opt                0x0000000110b0fa3f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const + 559\r\n26 circt-opt                0x0000000110b0f558 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 152\r\n27 circt-opt                0x0000000110afc984 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 180\r\n28 circt-opt                0x0000000110afbf6f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 1279\r\n29 circt-opt                0x0000000110afad8d mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) + 77\r\n30 circt-opt                0x0000000110afaac6 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 566\r\n31 circt-opt                0x0000000110afb137 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359\r\n32 circt-opt                0x0000000110afda69 mlir::PassManager::run(mlir::Operation*) + 985\r\n33 circt-opt                0x00000001103fccf8 performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, mlir::PassPipelineCLParser const&) + 520\r\n34 circt-opt                0x00000001103fb36b processBuffer(llvm::raw_ostream&, std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&) + 331\r\n35 circt-opt                0x00000001103fb166 mlir::MlirOptMain(llvm::raw_ostream&, std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool) + 358\r\n36 circt-opt                0x00000001103fc0fe mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) + 3310\r\n37 circt-opt                0x000000010fab5b5f main + 159\r\n38 libdyld.dylib            0x00007fff2035af3d start + 1\r\n39 libdyld.dylib            0x0000000000000003 start + 18446603339975774407\r\n```\r\n\r\n</details>", "code_snippet_01": "module  {\r\n  firrtl.circuit \"Foo\"  {\r\n    firrtl.module @Bar(%a: !firrtl.bundle<a: uint<1>>, %b: !firrtl.flip<bundle<a: uint<1>>>) {\r\n      firrtl.connect %b, %a : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>\r\n    }\r\n    firrtl.module @Foo(%a: !firrtl.bundle<a: uint<1>>, %b: !firrtl.flip<bundle<a: uint<1>>>) {\r\n      %bar_a, %bar_b = firrtl.instance @Bar  {name = \"bar\"} : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>\r\n      firrtl.connect %bar_a, %a : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>\r\n      firrtl.connect %b, %bar_b : !firrtl.flip<bundle<a: uint<1>>>, !firrtl.bundle<a: uint<1>>\r\n    }\r\n  }\r\n}", "code_snippet_02": "while circt-opt -pass-pipeline='firrtl.circuit(firrtl-lower-types)' Foo.mlir; do echo \"works\"; done", "code_snippet_03": "while circt-opt -mlir-disable-threading -pass-pipeline='firrtl.circuit(firrtl-lower-types)' Foo.mlir; do echo \"works\"; done", "code_snippet_04": "Assertion failed: (use_empty() && \"Cannot destroy a value that still has uses!\"), function ~IRObjectWithUseList, file /Users/schuylere/repos/github.com/llvm/circt/llvm/mlir/include/mlir/IR/UseDefLists.h, line 37.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: circt-opt -pass-pipeline=firrtl.circuit(firrtl-lower-types) Foo.mlir\r\n1.\t2.\tStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  circt-opt                0x000000010fc8897d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  circt-opt                0x000000010fc88f2b PrintStackTraceSignalHandler(void*) + 27\r\n2  circt-opt                0x000000010fc86c8b llvm::sys::RunSignalHandlers() + 123\r\n3  circt-opt                0x000000010fc8b598 SignalHandler(int) + 232\r\n4  libsystem_platform.dylib 0x00007fff20384d7d _sigtramp + 29\r\n5  circt-opt                0x00000001111e9f80 _dyld_private + 0\r\n6  libsystem_c.dylib        0x00007fff20294411 abort + 120\r\n7  libsystem_c.dylib        0x00007fff202937e8 err + 0\r\n8  circt-opt                0x00000001102778c2 mlir::IRObjectWithUseList<mlir::OpOperand>::~IRObjectWithUseList() + 98\r\n9  circt-opt                0x0000000110277858 mlir::detail::ValueImpl::~ValueImpl() + 24\r\n10 circt-opt                0x0000000110277838 mlir::detail::BlockArgumentImpl::~BlockArgumentImpl() + 24\r\n11 circt-opt                0x0000000110277815 mlir::detail::BlockArgumentImpl::~BlockArgumentImpl() + 21\r\n12 circt-opt                0x0000000110274f4c mlir::BlockArgument::destroy() + 44\r\n13 circt-opt                0x000000011027670d mlir::Block::eraseArguments(llvm::function_ref<bool (mlir::BlockArgument)>) + 173\r\n14 circt-opt                0x0000000110276658 mlir::Block::eraseArguments(llvm::BitVector const&) + 72\r\n15 circt-opt                0x00000001102765d3 mlir::Block::eraseArguments(llvm::ArrayRef<unsigned int>) + 179\r\n16 circt-opt                0x000000010fcc4fed (anonymous namespace)::TypeLoweringVisitor::visitDecl(circt::firrtl::FModuleOp) + 1549\r\n17 circt-opt                0x000000010fcc4233 (anonymous namespace)::TypeLoweringVisitor::lowerModule(mlir::Operation*) + 83\r\n18 circt-opt                0x000000010fcc27f3 auto (anonymous namespace)::LowerTypesPass::runAsync()::$_8::operator()<unsigned long>(unsigned long) const + 147\r\n19 circt-opt                0x000000010fcc270f void llvm::parallel::detail::parallel_for_each_n<unsigned long, (anonymous namespace)::LowerTypesPass::runAsync()::$_8>(unsigned long, unsigned long, (anonymous namespace)::LowerTypesPass::runAsync()::$_8) + 415\r\n20 circt-opt                0x000000010fcc135d void llvm::parallelForEachN<(anonymous namespace)::LowerTypesPass::runAsync()::$_8>(unsigned long, unsigned long, (anonymous namespace)::LowerTypesPass::runAsync()::$_8) + 109\r\n21 circt-opt                0x000000010fcc111f (anonymous namespace)::LowerTypesPass::runAsync() + 191\r\n22 circt-opt                0x000000010fcc02dd (anonymous namespace)::LowerTypesPass::runOnOperation() + 61\r\n23 circt-opt                0x0000000110afaadb mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 587\r\n24 circt-opt                0x0000000110afb137 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359\r\n25 circt-opt                0x0000000110b0fa3f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const + 559\r\n26 circt-opt                0x0000000110b0f558 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 152\r\n27 circt-opt                0x0000000110afc984 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 180\r\n28 circt-opt                0x0000000110afbf6f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 1279\r\n29 circt-opt                0x0000000110afad8d mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) + 77\r\n30 circt-opt                0x0000000110afaac6 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 566\r\n31 circt-opt                0x0000000110afb137 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359\r\n32 circt-opt                0x0000000110afda69 mlir::PassManager::run(mlir::Operation*) + 985\r\n33 circt-opt                0x00000001103fccf8 performActions(llvm::raw_ostream&, bool, bool, llvm::SourceMgr&, mlir::MLIRContext*, mlir::PassPipelineCLParser const&) + 520\r\n34 circt-opt                0x00000001103fb36b processBuffer(llvm::raw_ostream&, std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, bool, bool, bool, bool, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&) + 331\r\n35 circt-opt                0x00000001103fb166 mlir::MlirOptMain(llvm::raw_ostream&, std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, mlir::PassPipelineCLParser const&, mlir::DialectRegistry&, bool, bool, bool, bool, bool) + 358\r\n36 circt-opt                0x00000001103fc0fe mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) + 3310\r\n37 circt-opt                0x000000010fab5b5f main + 159\r\n38 libdyld.dylib            0x00007fff2035af3d start + 1\r\n39 libdyld.dylib            0x0000000000000003 start + 18446603339975774407"}, {"number": 998, "title": "Non-deterministic failures in lower-types.mlir tests", "created_at": "2021-05-03T22:00:33Z", "state": "closed", "labels": "bug, FIRRTL", "body": "After https://github.com/llvm/circt/pull/997, I seem to be finding some non-deterministic test failures related to LowerTypes.\r\n\r\nOne issue is related to an index out of bounds error (attributes.txt). I tried adding a bounds check, but that exposed what appears to be the real issue: a firrtl.invalidvalue is being erased which still has uses. I tracked it down to this test: https://github.com/llvm/circt/blob/03de9739896ec4d2ad6df60948cce24185a67dd0/test/Dialect/FIRRTL/lower-types.mlir#L370.\r\n\r\nAnother issue, which pops up occasionally when the above is commented out, has to do with attempting to drop_front on a string that doesn't have the required number of characters (drop_front.txt). I haven't tracked this down yet, but it is related to the InstanceOp lowering in LowerTypes.\r\n\r\nIt's strange to me this doesn't get caught in CI, but I guess my workstation has enough parallelism to reveal it, while our build machines don't. I'm also not sure yet if this is a personal problem or others will face it. Is it worth reverting the LLVM version bump for now, since it seems related to parallelism?\r\n\r\n[attributes.txt](https://github.com/llvm/circt/files/6417990/attributes.txt)\r\n[drop_front.txt](https://github.com/llvm/circt/files/6417992/drop_front.txt)"}, {"number": 976, "title": "[FIRRTL] reg \"sink not fully initialized\" (false negative)", "created_at": "2021-04-29T01:09:40Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    reg tmp42: UInt<10>, clock with: (reset => (reset, UInt<10>(0)))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --lower-types` generates this error:\r\n\r\n```\r\na_top_mod.fir:6:5: error: sink not fully initialized.\r\n    reg tmp42: UInt<10>, clock with: (reset => (reset, UInt<10>(0)))\r\n    ^\r\na_top_mod.fir:6:5: note: see current operation: %tmp42 = \"firrtl.regreset\"(%clock, %reset, %c0_ui10) {annotations = [], name = \"tmp42\"} : (!firrtl.clock, !firrtl.uint<1>, !firrtl.uint<10>) -> !firrtl.uint<10>\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input   clock,\r\n  input   reset\r\n);\r\nendmodule\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    reg tmp42: UInt<10>, clock with: (reset => (reset, UInt<10>(0)))", "code_snippet_02": "a_top_mod.fir:6:5: error: sink not fully initialized.\r\n    reg tmp42: UInt<10>, clock with: (reset => (reset, UInt<10>(0)))\r\n    ^\r\na_top_mod.fir:6:5: note: see current operation: %tmp42 = \"firrtl.regreset\"(%clock, %reset, %c0_ui10) {annotations = [], name = \"tmp42\"} : (!firrtl.clock, !firrtl.uint<1>, !firrtl.uint<10>) -> !firrtl.uint<10>", "code_snippet_03": "module top_mod(\r\n  input   clock,\r\n  input   reset\r\n);\r\nendmodule"}, {"number": 955, "title": "65 bit constant gets changed", "created_at": "2021-04-24T02:36:35Z", "state": "closed", "labels": "bug", "body": "LowerToRTL negates this unsigned constant (ui65 : 0x10000000000000000) leading to canonicalize thinking it is zero.\r\n\r\n```module  {\r\n  firrtl.circuit \"foo\"  {\r\n    firrtl.module @foo(%io_in_valid: !firrtl.uint<1>, %foo: !firrtl.flip<uint<65>>) {\r\n      %c18446744073709551616_ui65 = firrtl.constant(18446744073709551616 : ui65) : !firrtl.uint<65>\r\n      %c0_ui65 = firrtl.constant(0 : ui65) : !firrtl.uint<65>\r\n      %0 = firrtl.mux(%io_in_valid, %c18446744073709551616_ui65, %c0_ui65) : (!firrtl.uint<1>, !firrtl.uint<65>, !firrtl.uint<65>) -> !firrtl.uint<65>\r\n      firrtl.connect %foo, %0 : !firrtl.flip<uint<65>>, !firrtl.uint<65>\r\n    }\r\n  }\r\n}\r\n```", "code_snippet_01": "module  {\r\n  firrtl.circuit \"foo\"  {\r\n    firrtl.module @foo(%io_in_valid: !firrtl.uint<1>, %foo: !firrtl.flip<uint<65>>) {\r\n      %c18446744073709551616_ui65 = firrtl.constant(18446744073709551616 : ui65) : !firrtl.uint<65>\r\n      %c0_ui65 = firrtl.constant(0 : ui65) : !firrtl.uint<65>\r\n      %0 = firrtl.mux(%io_in_valid, %c18446744073709551616_ui65, %c0_ui65) : (!firrtl.uint<1>, !firrtl.uint<65>, !firrtl.uint<65>) -> !firrtl.uint<65>\r\n      firrtl.connect %foo, %0 : !firrtl.flip<uint<65>>, !firrtl.uint<65>\r\n    }\r\n  }\r\n}"}, {"number": 952, "title": "[FIRRTL] Fix use-after-free in connect canonicalization", "created_at": "2021-04-22T22:18:12Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Fixes #951"}, {"number": 947, "title": "[firtool] crash in parser when modify the file from another process", "created_at": "2021-04-22T16:54:19Z", "state": "closed", "labels": "bug, FIRRTL", "body": "I am getting random crashes like this:\r\n\r\nThis might be related to FIR file abruptly cut at  random point.\r\n\r\n```\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --lower-types --lowering-options=noAlwaysFF --pass-timing --verilog -o=a_top_mod_new.v\r\n #0 0x000000000043d2dd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x43d2dd)\r\n #1 0x000000000043b134 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x43b134)\r\n #2 0x000000000043b293 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x43b293)\r\n #3 0x00007faf0eb14a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #4 0x000000000042254e llvm::StringRef::find_last_of(llvm::StringRef, unsigned long) const (../../llvm/circt/build/bin/firtool+0x42254e)\r\n #5 0x0000000000420a6d llvm::SourceMgr::getLineAndColumn(llvm::SMLoc, unsigned int) const (../../llvm/circt/build/bin/firtool+0x420a6d)\r\n #6 0x000000000047eff4 circt::firrtl::FIRLexer::translateLocation(llvm::SMLoc) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRLexer.cpp:119:66\r\n #7 0x000000000046b7b2 (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRTokenKinds.def:165:1\r\n #8 0x00000000004700fb (anonymous namespace)::FIRStmtParser::parseExpImpl(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&, bool) (.constprop.0) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1161:5\r\n #9 0x0000000000471c7b (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1373:9\r\n#10 0x0000000000471d5c std::_Function_handler<mlir::ParseResult (), (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()>::_M_invoke(std::_Any_data const&) /usr/include/c++/10/bits/std_function.h:293:7\r\n#11 0x0000000000461225 (anonymous namespace)::FIRParser::parseListUntil(circt::firrtl::FIRToken::Kind, std::function<mlir::ParseResult ()> const&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:313:5\r\n#12 0x0000000000468fb8 (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1383:8\r\n#13 0x00000000004700fb (anonymous namespace)::FIRStmtParser::parseExpImpl(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&, bool) (.constprop.0) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1161:5\r\n#14 0x0000000000471c7b (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1373:9\r\n#15 0x0000000000471d5c std::_Function_handler<mlir::ParseResult (), (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()>::_M_invoke(std::_Any_data const&) /usr/include/c++/10/bits/std_function.h:293:7\r\n#16 0x0000000000461225 (anonymous namespace)::FIRParser::parseListUntil(circt::firrtl::FIRToken::Kind, std::function<mlir::ParseResult ()> const&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:313:5\r\n#17 0x0000000000468fb8 (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1383:8\r\n#18 0x00000000004700fb (anonymous namespace)::FIRStmtParser::parseExpImpl(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&, bool) (.constprop.0) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1161:5\r\n#19 0x0000000000470d9b (anonymous namespace)::FIRStmtParser::parseLeadingExpStmt(mlir::Value, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2099:62\r\n#20 0x0000000000477d15 llvm::SmallVectorTemplateCommon<mlir::Operation*, void>::begin() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:253:45\r\n#21 0x0000000000477d15 llvm::SmallVectorTemplateCommon<mlir::Operation*, void>::end() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:255:32\r\n#22 0x0000000000477d15 llvm::SmallVector<mlir::Operation*, 8u>::~SmallVector() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:1175:24\r\n#23 0x0000000000477d15 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1680:33\r\n#24 0x000000000047aa04 (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1630:5\r\n#25 0x000000000047cc03 llvm::DenseMap<std::pair<mlir::Attribute, mlir::Type>, mlir::Value, llvm::DenseMapInfo<std::pair<mlir::Attribute, mlir::Type> >, llvm::detail::DenseMapPair<std::pair<mlir::Attribute, mlir::Type>, mlir::Value> >::~DenseMap() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/DenseMap.h:755:50\r\n#26 0x000000000047cc03 ~FIRModuleContext /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1023:8\r\n#27 0x000000000047cc03 parseModule /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2823:20\r\n#28 0x000000000047cc03 parseCircuit /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2927:75\r\n#29 0x000000000047cc03 circt::firrtl::importFIRRTL(llvm::SourceMgr&, mlir::MLIRContext*, circt::firrtl::FIRParserOptions) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2957:53\r\n#30 0x000000000040c620 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:162:5\r\n#31 0x000000000040866f processBufferIntoSingleStream /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:253:8\r\n#32 0x000000000040866f main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:323:15\r\n#33 0x00007faf0e582b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#34 0x0000000000409fbe _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 15: 14926 Bus error               (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --lower-types --lowering-options=noAlwaysFF --pass-timing --verilog -o=$VFILE2\r\n[2]+  Done                    ./bin/cli.js -n -I 200 -O 10000 --verif false --ordered true fir -o a_top_mod.fir\r\ndrom@linux-sydi:~/work/github/drom/circt-fuzzer> ./bin/cli.js -s 528570 -n -I 200 -O 10000 --verif false --ordered true fir -o a_top_mod.fir & ./process1.sh \r\n```", "code_snippet_01": "PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --lower-types --lowering-options=noAlwaysFF --pass-timing --verilog -o=a_top_mod_new.v\r\n #0 0x000000000043d2dd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x43d2dd)\r\n #1 0x000000000043b134 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x43b134)\r\n #2 0x000000000043b293 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x43b293)\r\n #3 0x00007faf0eb14a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #4 0x000000000042254e llvm::StringRef::find_last_of(llvm::StringRef, unsigned long) const (../../llvm/circt/build/bin/firtool+0x42254e)\r\n #5 0x0000000000420a6d llvm::SourceMgr::getLineAndColumn(llvm::SMLoc, unsigned int) const (../../llvm/circt/build/bin/firtool+0x420a6d)\r\n #6 0x000000000047eff4 circt::firrtl::FIRLexer::translateLocation(llvm::SMLoc) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRLexer.cpp:119:66\r\n #7 0x000000000046b7b2 (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRTokenKinds.def:165:1\r\n #8 0x00000000004700fb (anonymous namespace)::FIRStmtParser::parseExpImpl(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&, bool) (.constprop.0) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1161:5\r\n #9 0x0000000000471c7b (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1373:9\r\n#10 0x0000000000471d5c std::_Function_handler<mlir::ParseResult (), (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()>::_M_invoke(std::_Any_data const&) /usr/include/c++/10/bits/std_function.h:293:7\r\n#11 0x0000000000461225 (anonymous namespace)::FIRParser::parseListUntil(circt::firrtl::FIRToken::Kind, std::function<mlir::ParseResult ()> const&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:313:5\r\n#12 0x0000000000468fb8 (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1383:8\r\n#13 0x00000000004700fb (anonymous namespace)::FIRStmtParser::parseExpImpl(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&, bool) (.constprop.0) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1161:5\r\n#14 0x0000000000471c7b (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1373:9\r\n#15 0x0000000000471d5c std::_Function_handler<mlir::ParseResult (), (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&)::'lambda'()>::_M_invoke(std::_Any_data const&) /usr/include/c++/10/bits/std_function.h:293:7\r\n#16 0x0000000000461225 (anonymous namespace)::FIRParser::parseListUntil(circt::firrtl::FIRToken::Kind, std::function<mlir::ParseResult ()> const&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:313:5\r\n#17 0x0000000000468fb8 (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1383:8\r\n#18 0x00000000004700fb (anonymous namespace)::FIRStmtParser::parseExpImpl(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&, bool) (.constprop.0) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1161:5\r\n#19 0x0000000000470d9b (anonymous namespace)::FIRStmtParser::parseLeadingExpStmt(mlir::Value, llvm::SmallVectorImpl<mlir::Operation*>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2099:62\r\n#20 0x0000000000477d15 llvm::SmallVectorTemplateCommon<mlir::Operation*, void>::begin() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:253:45\r\n#21 0x0000000000477d15 llvm::SmallVectorTemplateCommon<mlir::Operation*, void>::end() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:255:32\r\n#22 0x0000000000477d15 llvm::SmallVector<mlir::Operation*, 8u>::~SmallVector() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:1175:24\r\n#23 0x0000000000477d15 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1680:33\r\n#24 0x000000000047aa04 (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1630:5\r\n#25 0x000000000047cc03 llvm::DenseMap<std::pair<mlir::Attribute, mlir::Type>, mlir::Value, llvm::DenseMapInfo<std::pair<mlir::Attribute, mlir::Type> >, llvm::detail::DenseMapPair<std::pair<mlir::Attribute, mlir::Type>, mlir::Value> >::~DenseMap() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/DenseMap.h:755:50\r\n#26 0x000000000047cc03 ~FIRModuleContext /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:1023:8\r\n#27 0x000000000047cc03 parseModule /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2823:20\r\n#28 0x000000000047cc03 parseCircuit /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2927:75\r\n#29 0x000000000047cc03 circt::firrtl::importFIRRTL(llvm::SourceMgr&, mlir::MLIRContext*, circt::firrtl::FIRParserOptions) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Import/FIRParser.cpp:2957:53\r\n#30 0x000000000040c620 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:162:5\r\n#31 0x000000000040866f processBufferIntoSingleStream /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:253:8\r\n#32 0x000000000040866f main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:323:15\r\n#33 0x00007faf0e582b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#34 0x0000000000409fbe _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 15: 14926 Bus error               (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --lower-types --lowering-options=noAlwaysFF --pass-timing --verilog -o=$VFILE2\r\n[2]+  Done                    ./bin/cli.js -n -I 200 -O 10000 --verif false --ordered true fir -o a_top_mod.fir\r\ndrom@linux-sydi:~/work/github/drom/circt-fuzzer> ./bin/cli.js -s 528570 -n -I 200 -O 10000 --verif false --ordered true fir -o a_top_mod.fir & ./process1.sh"}, {"number": 942, "title": "[FIRRTL]`is invalid` not working for registers in the parser", "created_at": "2021-04-21T07:36:32Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Setting registers to invalid is not working correctly in the parser.  \r\n```firrtl\r\n; ./bin/circt-translate --import-firrtl  ./test.fir\r\ncircuit F :\r\n  module F :\r\n    input clock : Clock\r\n    \r\n    ; output port works as expected\r\n    output out : UInt<1>\r\n    out is invalid\r\n    \r\n    ; register is never set to invalid\r\n    reg r : UInt<1>, clock\r\n    r is invalid\r\n```\r\n\r\n```mlir\r\nfirrtl.circuit \"F\"  {\r\n  firrtl.module @F(%clock: !firrtl.clock, %out: !firrtl.flip<uint<1>>) {\r\n    %0 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %out, %0 : !firrtl.flip<uint<1>>, !firrtl.uint<1>\r\n    %r = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>\r\n    %1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nThis is because the register value has a passive type, and we do not emit connects to invalid when the LHS is passive.  Switching the parser to emit a connect when the LHS is passive makes the following test fail. This test is represented in the repo [here](https://github.com/llvm/circt/blob/main/test/Dialect/FIRRTL/parse-basic.fir#L112).\r\n\r\n```firrtl\r\ncircuit F:\r\n  module F:\r\n    input a : UInt<1>\r\n    a is invalid\r\n```\r\n```\r\n./test2.fir:4:7: error: 'firrtl.connect' op connection destination must be a non-passive type or a duplex value\r\n    a is invalid\r\n      ^\r\n./test2.fir:4:7: note: see current operation: \"firrtl.connect\"(%a, %0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n```\r\n\r\nCould this be fixed with the coming changes to flip canonicalization?", "code_snippet_01": "; ./bin/circt-translate --import-firrtl  ./test.fir\r\ncircuit F :\r\n  module F :\r\n    input clock : Clock\r\n    \r\n    ; output port works as expected\r\n    output out : UInt<1>\r\n    out is invalid\r\n    \r\n    ; register is never set to invalid\r\n    reg r : UInt<1>, clock\r\n    r is invalid", "code_snippet_02": "firrtl.circuit \"F\"  {\r\n  firrtl.module @F(%clock: !firrtl.clock, %out: !firrtl.flip<uint<1>>) {\r\n    %0 = firrtl.invalidvalue : !firrtl.uint<1>\r\n    firrtl.connect %out, %0 : !firrtl.flip<uint<1>>, !firrtl.uint<1>\r\n    %r = firrtl.reg %clock  : (!firrtl.clock) -> !firrtl.uint<1>\r\n    %1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_03": "circuit F:\r\n  module F:\r\n    input a : UInt<1>\r\n    a is invalid", "code_snippet_04": "./test2.fir:4:7: error: 'firrtl.connect' op connection destination must be a non-passive type or a duplex value\r\n    a is invalid\r\n      ^\r\n./test2.fir:4:7: note: see current operation: \"firrtl.connect\"(%a, %0) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()"}, {"number": 919, "title": "[FIRRTL] Type Canonicalization Considered Harmful", "created_at": "2021-04-14T15:58:36Z", "state": "closed", "labels": "bug, FIRRTL", "body": "FIRRTL Dialect type canonicalization is destroying information that is needed to preserve connection semantics.\r\n\r\nConsider the following circuit which has three different connections.\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n\r\n    wire a: {flip a: {flip a: UInt<1>}}\r\n    wire b: {flip a: {flip a: UInt<1>}}\r\n    \r\n    b <- a\r\n    b.a <- a.a\r\n    b.a.a <- a.a.a\r\n```\r\n\r\nIf you run each of these through the SFC, you will get:\r\n\r\n1. `b <- a` => `b.a.a <- a.a.a`\r\n2. `b.a <- a.a` => `a.a.a <- b.a.a` (_The connection is reversed._)\r\n3. `b.a.a <- a.a.a` => `b.a.a <- a.a.a`\r\n\r\nHowever, the above circuit will type canonicalize into:\r\n```scala\r\n    wire a: {a: {a: UInt<1>}}\r\n    wire b: {a: {a: UInt<1>}}\r\n```\r\n\r\nIn this situation, the behavior of connection (2) is _incorrectly_ changed into `b.a <- a.a`.\r\n\r\nI _think_ that wires are the only operation that have this behavior, but I'm not sure. The problem may show up anywhere that the SFC is relying on flip information that canonicalization is removing.\r\n\r\nI think we can get around this by adding information to wires (and anything else that needs it) that stores the original, un-canonicalized type, and uses this information as an aid to resolve connection semantics.\r\n\r\n### Explanation\r\n\r\nIn the SFC, connection semantics for _duplex flow_ are purely evaluated based on the type of the expression. This means that the expression `b.a` has type `!firrtl.bundle<a: flip<UInt<1>>`. A connection using this subfield will come out flipped because it has an odd number of flips going down to the leaf.", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n\r\n    wire a: {flip a: {flip a: UInt<1>}}\r\n    wire b: {flip a: {flip a: UInt<1>}}\r\n    \r\n    b <- a\r\n    b.a <- a.a\r\n    b.a.a <- a.a.a", "code_snippet_02": "wire a: {a: {a: UInt<1>}}\r\n    wire b: {a: {a: UInt<1>}}"}, {"number": 917, "title": "[FIRRTL] Use operand type to determine sign for const folding", "created_at": "2021-04-14T08:39:28Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Use the operand types instead of the operation's result type when deciding whether to perform sign or zero extension of constants for folding. This is important for comparison operators, where the result type is always `uint<1>`, yet signed operands should be sign-extended. Fixes #912."}, {"number": 914, "title": "[FIRRTL] (neg) mismatch", "created_at": "2021-04-13T03:49:49Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 162\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp21: SInt<6>\r\n    tmp21 <= validif(UInt<1>(\"b0\"), SInt<6>(\"b1111\"))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:\r\n\r\n```verilog\r\n// Standard header to adapt well known macros to our needs.\r\n\r\nmodule top_mod(\r\n  output [5:0] tmp21);\r\n\r\n  assign tmp21 = 6'h0;\t// a_top_mod.fir:3:3, :5:14\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [5:0] tmp21\r\n);\r\n  assign tmp21 = 6'shf;\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nERROR: Found 4 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "; seed: 162\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp21: SInt<6>\r\n    tmp21 <= validif(UInt<1>(\"b0\"), SInt<6>(\"b1111\"))", "code_snippet_02": "// Standard header to adapt well known macros to our needs.\r\n\r\nmodule top_mod(\r\n  output [5:0] tmp21);\r\n\r\n  assign tmp21 = 6'h0;\t// a_top_mod.fir:3:3, :5:14\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  output [5:0] tmp21\r\n);\r\n  assign tmp21 = 6'shf;\r\nendmodule", "code_snippet_04": "ERROR: Found 4 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 907, "title": "Parsing Instance Connects Broken", "created_at": "2021-04-09T15:45:51Z", "state": "open", "labels": "bug, FIRRTL", "body": "Connections involving instances fail to parse, but work in the Scala FIRRTL Compiler.\r\n\r\nThe following currently fails:\r\n```scala\r\ncircuit Instance:\r\n  module Sub:\r\n    output a: UInt<1>\r\n    a <= UInt<1>(0)\r\n\r\n  module Instance:\r\n    output a: {a: UInt<1>}\r\n\r\n    inst sub of Sub\r\n    a <= sub\r\n    a <- sub\r\n```\r\n\r\nThe error is: \r\n\r\n```\r\n# circt-translate --import-firrtl new/Instance.fir\r\nnew/Instance.fir:11:5: error: expected '.' in field reference\r\n    a <- sub\r\n    ^\r\n```\r\n\r\nGlancing at the parser, it looks like it expects `sub` to be in the value table, but it isn't. [There is special logic to handle `sub is invalid`](https://github.com/llvm/circt/blob/main/lib/Dialect/FIRRTL/Import/FIRParser.cpp#L1187), but that needs to be extended to handle connections to submodules. If this isn't a `sub is invalid` situation, then the parser expects to see a subfield.", "code_snippet_01": "circuit Instance:\r\n  module Sub:\r\n    output a: UInt<1>\r\n    a <= UInt<1>(0)\r\n\r\n  module Instance:\r\n    output a: {a: UInt<1>}\r\n\r\n    inst sub of Sub\r\n    a <= sub\r\n    a <- sub", "code_snippet_02": "# circt-translate --import-firrtl new/Instance.fir\r\nnew/Instance.fir:11:5: error: expected '.' in field reference\r\n    a <- sub\r\n    ^"}, {"number": 900, "title": "Lack of mux folding causes unreachable code which tools complain about", "created_at": "2021-04-08T20:48:32Z", "state": "closed", "labels": "bug", "body": "```\r\ncircuit MuxTree :\r\n  module MuxTree :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input c1 : UInt<1>\r\n    input c2 : UInt<1>\r\n    input d1 : UInt<5>\r\n    input d2 : UInt<5>\r\n    input d3 : UInt<5>\r\n    output foo : UInt<5>\r\n    \r\n\r\n    node baz = mux(c1,d2, d3) \r\n    node bar = mux(c1, d1, baz) \r\n    foo <= bar \r\n```\r\nGives\r\n```\r\nmodule MuxTree(\r\n  input        clock, reset, c1, c2,\r\n  input  [4:0] d1, d2, d3,\r\n  output [4:0] foo);\r\n\r\n  assign foo = c1 ? d1 : c1 ? d2 : d3; \r\nendmodule\r\n```\r\nassigning d2 to foo is unreachable and generates warnings.", "code_snippet_01": "circuit MuxTree :\r\n  module MuxTree :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input c1 : UInt<1>\r\n    input c2 : UInt<1>\r\n    input d1 : UInt<5>\r\n    input d2 : UInt<5>\r\n    input d3 : UInt<5>\r\n    output foo : UInt<5>\r\n    \r\n\r\n    node baz = mux(c1,d2, d3) \r\n    node bar = mux(c1, d1, baz) \r\n    foo <= bar", "code_snippet_02": "module MuxTree(\r\n  input        clock, reset, c1, c2,\r\n  input  [4:0] d1, d2, d3,\r\n  output [4:0] foo);\r\n\r\n  assign foo = c1 ? d1 : c1 ? d2 : d3; \r\nendmodule"}, {"number": 894, "title": "[ExportVerilog] Emit constants as localparam", "created_at": "2021-04-07T13:55:31Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Emit `rtl.constant` operations as `localparam` when we decide to print them as out-of-line expressions. This requires additional special treatment since the localparam cannot be reassigned and the value must be provided already at the declaration site.\r\n\r\nWhen `rtl.constant` operations are used before defined, move the definition up to the beginning of the block, similar to wire/reg. This avoids introducing a temporary dynamic wire and emits the constant as a localparam.\r\n\r\nThis fixes #884 by moving the constant reset values of always_ff statements into localparams."}, {"number": 889, "title": "[Python] RTL support library broken port names", "created_at": "2021-04-05T21:22:09Z", "state": "closed", "labels": "bug", "body": "The recent change to port names https://github.com/llvm/circt/commit/b6b3cb9f9fe7746f5646b66bfa5a2f31812fc6bd broke the RTLModuleOp python wrapper. I've managed to fix it partially, but the autowrapping stuff is still broken."}, {"number": 887, "title": "error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.", "created_at": "2021-04-05T18:37:33Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "A bunch of the integration tests are broken with error messages like this:\r\n\r\n```\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:10:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @B(%a: i1 { rtl.inout }) -> (i1 {rtl.name = \"b\"}, i1 {rtl.name = \"c\"}) {\r\n^\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:10:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @B(%a: i1 { rtl.inout }) -> (i1 {rtl.name = \"b\"}, i1 {rtl.name = \"c\"}) {\r\n^\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:16:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @A(%d: i1, %e: i1) -> (i1 {rtl.name = \"f\"}) {\r\n^\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:21:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @AAA(%d: i1, %e: i1) -> (i1 {rtl.name = \"f\"}) {\r\n^\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:26:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @AB(%w: i1, %x: i1) -> (i1 {rtl.name = \"y\"}, i1 {rtl.name = \"z\"}) {\r\n^\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:26:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @AB(%w: i1, %x: i1) -> (i1 {rtl.name = \"y\"}, i1 {rtl.name = \"z\"}) {\r\n^\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:32:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @shl(%a: i1) -> (i1 {rtl.name = \"b\"}) {\r\n^\r\n\r\n--\r\n```", "code_snippet_01": "/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:10:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @B(%a: i1 { rtl.inout }) -> (i1 {rtl.name = \"b\"}, i1 {rtl.name = \"c\"}) {\r\n^\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:10:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @B(%a: i1 { rtl.inout }) -> (i1 {rtl.name = \"b\"}, i1 {rtl.name = \"c\"}) {\r\n^\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:16:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @A(%d: i1, %e: i1) -> (i1 {rtl.name = \"f\"}) {\r\n^\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:21:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @AAA(%d: i1, %e: i1) -> (i1 {rtl.name = \"f\"}) {\r\n^\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:26:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @AB(%w: i1, %x: i1) -> (i1 {rtl.name = \"y\"}, i1 {rtl.name = \"z\"}) {\r\n^\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:26:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @AB(%w: i1, %x: i1) -> (i1 {rtl.name = \"y\"}, i1 {rtl.name = \"z\"}) {\r\n^\r\n/home/jodemme/circt/integration_test/EmitVerilog/lint.mlir:32:1: error: unexpected error: 'rtl.module' op Found port without a name. Port names are required for Verilog synthesis.\r\n\r\nrtl.module @shl(%a: i1) -> (i1 {rtl.name = \"b\"}) {\r\n^\r\n\r\n--"}, {"number": 884, "title": "Warning that Verilog may cause mismatches between simulation and synthesis", "created_at": "2021-04-03T13:53:29Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The formal verification tool flags this as a warning (not error).  I have attached the MLIR output and a corrected version below.\r\n\r\nWarning: Variable(s) is(are) being read asynchronously. This may cause simulation-synthesis mismatches. (Signal: _T_0 Block: testcase_mfc.sv Line: 43) \r\nThe problem with this description is that the simulation model does not react to changes in reset_data while reset_enable is held high.\r\nIn Verilog, you can't add _T_0 to the sensitivity list without breaking the model. You must verify that your model does not rely on the fact that during reset, the simulator holds tmp50 steady even though _TMP_50 changes. The synthesized register will be transparent during reset.\r\n\r\nOr change the RTL, to have constant driving reset line.\r\n\r\n_The FIR file_circuit top_mod :\r\n```verilog\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input arst: AsyncReset\r\n    input inp_i: SInt<170>\r\n    output out_i: SInt<170>\r\n    reg tmp50: SInt<2>, clock with: (reset => (arst, SInt<2>(0)))\r\n    tmp50 <= inp_i\r\n    out_i <= tmp50\r\n```\r\n\r\n**The output that produces the warning (just the relevant section):\r\n```verilog\r\n always_ff @(posedge clock or posedge arst**) begin      // testcase.fir:9:5\r\n    if (arst)   // testcase.fir:9:5\r\n      **tmp50 <= _T_0;    // testcase.fir:9:5**\r\n    else        // testcase.fir:9:5\r\n      tmp50 <= _T;      // testcase.fir:10:11\r\n  end // always_ff @(posedge or posedge)\r\n```\r\n\r\n**The structure that is read without warnings:**\r\n```verilog\r\nmodule top_mod(\r\n  input          clock,\r\n  input          reset,\r\n  input          arst,\r\n  input  [169:0] inp_i,\r\n  output [169:0] out_i\r\n);\r\n`ifdef RANDOMIZE_REG_INIT\r\n  reg [31:0] _RAND_0;\r\n`endif // RANDOMIZE_REG_INIT\r\n  reg [1:0] tmp50;\r\n  assign out_i = {{168{tmp50[1]}},tmp50};\r\n  always @(posedge clock or posedge arst) begin\r\n    if (arst) begin\r\n      **tmp50 <= 2'sh0;**\r\n    end else begin\r\n      tmp50 <= inp_i[1:0];\r\n    end\r\n  end\r\n```\r\n", "code_snippet_01": "module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input arst: AsyncReset\r\n    input inp_i: SInt<170>\r\n    output out_i: SInt<170>\r\n    reg tmp50: SInt<2>, clock with: (reset => (arst, SInt<2>(0)))\r\n    tmp50 <= inp_i\r\n    out_i <= tmp50", "code_snippet_02": "always_ff @(posedge clock or posedge arst**) begin      // testcase.fir:9:5\r\n    if (arst)   // testcase.fir:9:5\r\n      **tmp50 <= _T_0;    // testcase.fir:9:5**\r\n    else        // testcase.fir:9:5\r\n      tmp50 <= _T;      // testcase.fir:10:11\r\n  end // always_ff @(posedge or posedge)", "code_snippet_03": "module top_mod(\r\n  input          clock,\r\n  input          reset,\r\n  input          arst,\r\n  input  [169:0] inp_i,\r\n  output [169:0] out_i\r\n);\r\n`ifdef RANDOMIZE_REG_INIT\r\n  reg [31:0] _RAND_0;\r\n`endif // RANDOMIZE_REG_INIT\r\n  reg [1:0] tmp50;\r\n  assign out_i = {{168{tmp50[1]}},tmp50};\r\n  always @(posedge clock or posedge arst) begin\r\n    if (arst) begin\r\n      **tmp50 <= 2'sh0;**\r\n    end else begin\r\n      tmp50 <= inp_i[1:0];\r\n    end\r\n  end"}, {"number": 865, "title": "ifdef isn't a statement for purposes of begin/end", "created_at": "2021-03-31T22:27:24Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```andrew@narya:~/src/circt/build$ ./bin/firtool foo.mlir \r\nmodule  {\r\n  rtl.module @M1(%clock: i1, %cond: i1, %val: i8) {\r\n    sv.always posedge %clock  {\r\n      sv.ifdef.procedural \"SYNTHESIS\"  {\r\n      }\r\n    }\r\n    %wire42 = sv.wire  : !rtl.inout<i42>\r\n    rtl.output\r\n  }\r\n}\r\nandrew@narya:~/src/circt/build$ ./bin/firtool foo.mlir  -verilog\r\nmodule M1(\r\n  input       clock, cond,\r\n  input [7:0] val);\r\n\r\n  always @(posedge clock)       // foo.mlir:2:3\r\n    `ifndef SYNTHESIS   // foo.mlir:3:5\r\n    `endif\r\nendmodule```\r\nThat always block needs begin/end so that following real statements are parsed as in the always", "code_snippet_01": "andrew@narya:~/src/circt/build$ ./bin/firtool foo.mlir \r\nmodule  {\r\n  rtl.module @M1(%clock: i1, %cond: i1, %val: i8) {\r\n    sv.always posedge %clock  {\r\n      sv.ifdef.procedural \"SYNTHESIS\"  {\r\n      }\r\n    }\r\n    %wire42 = sv.wire  : !rtl.inout<i42>\r\n    rtl.output\r\n  }\r\n}\r\nandrew@narya:~/src/circt/build$ ./bin/firtool foo.mlir  -verilog\r\nmodule M1(\r\n  input       clock, cond,\r\n  input [7:0] val);\r\n\r\n  always @(posedge clock)       // foo.mlir:2:3\r\n    `ifndef SYNTHESIS   // foo.mlir:3:5\r\n    `endif\r\nendmodule"}, {"number": 863, "title": "[ExportVerilog] [Integration Tests] Naming broken and crashes", "created_at": "2021-03-31T21:31:04Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "One (or more) of today's verilog emission commits broke the integration tests. This showed up in the ESI integration tests, but I think that's only because they are the most comprehensive and/or use ExportVerilog differently than FIRRTL. It broke 4 tests total (one unit test, 3 integration tests), but I'm only including the lit output from two which are representative of the other failures.\r\n\r\n```\r\nFAIL: CIRCT :: ESI/system/basic.mlir (1 of 14)\r\n******************** TEST 'CIRCT :: ESI/system/basic.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 2';   /home/jodemme/circt/build/bin/circt-opt /home/jodemme/circt/integration_test/ESI/system/basic.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-rtl -verify-diagnostics > /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp1.mlir\r\n: 'RUN: at line 3';   /home/jodemme/circt/build/bin/circt-translate /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp1.mlir -export-verilog -verify-diagnostics > /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv\r\n: 'RUN: at line 4';   /home/jodemme/circt/build/bin/circt-rtl-sim.py /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv /home/jodemme/circt/include/circt/Dialect/ESI/ESIPrimitives.sv /home/jodemme/circt/integration_test/ESI/system/../supplements/integers.sv --cycles 150 | /home/jodemme/circt/llvm/build/bin/FileCheck /home/jodemme/circt/integration_test/ESI/system/basic.mlir\r\n--\r\nExit Code: 2\r\n\r\nCommand Output (stderr):\r\n--\r\n%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:55:15: Operator ASSIGNW expects 32 bits on the Assign RHS, but Assign RHS's VARREF '_T_5' generates 1 bits.\r\n                                                                                                     : ... In instance top\r\n   55 |   assign _T_4 = _T_5;\r\n      |               ^\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.\r\n%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:56:15: Operator ASSIGNW expects 1 bits on the Assign RHS, but Assign RHS's VARREF '_T_4' generates 32 bits.\r\n                                                                                                     : ... In instance top\r\n   56 |   assign _T_3 = _T_4;\r\n      |               ^\r\n%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:62:6: Input port connection 'a' expects 32 bits on the pin connection, but pin connection's VARREF '_T_3' generates 1 bits.\r\n                                                                                                    : ... In instance top\r\n   62 |     .a       (_T_3),\r\n      |      ^\r\n%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:70:15: Operator ASSIGNW expects 32 bits on the Assign RHS, but Assign RHS's VARREF '_T_2' generates 1 bits.\r\n                                                                                                     : ... In instance top\r\n   70 |   assign _T_1 = _T_2;\r\n      |               ^\r\n%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:71:15: Operator ASSIGNW expects 1 bits on the Assign RHS, but Assign RHS's VARREF '_T_1' generates 32 bits.\r\n                                                                                                     : ... In instance top\r\n   71 |   assign _T_0 = _T_1;\r\n      |               ^\r\n%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:74:20: Operator ASSIGNW expects 32 bits on the Assign RHS, but Assign RHS's VARREF '_T_0' generates 1 bits.\r\n                                                                                                     : ... In instance top\r\n   74 |   assign _T_7.data = _T_0;\r\n      |                    ^\r\n%Error: Exiting due to 6 warning(s)\r\nCompletedProcess(args=['/home/jodemme/circt/ext/bin/verilator', '--cc', '--top-module', 'top', '-sv', '--build', '--exe', '--Mdir', 'basic.mlir.tmp2.sv.obj_dir', '--assert', '/home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv', '/home/jodemme/circt/include/circt/Dialect/ESI/ESIPrimitives.sv', '/home/jodemme/circt/integration_test/ESI/system/../supplements/integers.sv', '/home/jodemme/circt/build/bin/driver.cpp'], returncode=1)\r\nFileCheck error: '<stdin>' is empty.\r\nFileCheck command line:  /home/jodemme/circt/llvm/build/bin/FileCheck /home/jodemme/circt/integration_test/ESI/system/basic.mlir\r\n\r\n--\r\n```\r\n\r\n```\r\n********************\r\nFAIL: CIRCT :: ESI/cosim/basic.mlir (7 of 14)\r\n******************** TEST 'CIRCT :: ESI/cosim/basic.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 2';   /home/jodemme/circt/build/bin/circt-opt /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-rtl | /home/jodemme/circt/build/bin/circt-translate --export-verilog > /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp1.sv\r\n: 'RUN: at line 3';   /home/jodemme/circt/build/bin/circt-translate /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir -export-esi-capnp -verify-diagnostics > /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp2.capnp\r\n: 'RUN: at line 4';   /home/jodemme/circt/build/bin/esi-cosim-runner.py --schema /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp2.capnp /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp1.sv /home/jodemme/circt/integration_test/ESI/cosim/../supplements/integers.sv\r\n--\r\nExit Code: 134\r\n\r\nCommand Output (stderr):\r\n--\r\n<unknown>:0: error: invalid element for rtl.inout type\r\ncirct-translate: /home/jodemme/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:96: static ConcreteT mlir::detail::StorageUserBase<ConcreteT, BaseT, StorageT, UniquerT, Traits>::get(mlir::MLIRContext*, Args ...) [with Args = {mlir::Type}; ConcreteT = circt::rtl::InOutType; BaseT = mlir::Type; StorageT = circt::rtl::detail::InOutTypeStorage; UniquerT = mlir::detail::TypeUniquer; Traits = {}]: Assertion `succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: /home/jodemme/circt/build/bin/circt-translate --export-verilog\r\n #0 0x00007fe1524db6ea llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/jodemme/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:11\r\n #1 0x00007fe1524db8bb PrintStackTraceSignalHandler(void*) /home/jodemme/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00007fe1524d9e8b llvm::sys::RunSignalHandlers() /home/jodemme/circt/llvm/llvm/lib/Support/Signals.cpp:70:5\r\n #3 0x00007fe1524dc031 SignalHandler(int) /home/jodemme/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007fe151d75d60 (/lib/x86_64-linux-gnu/libc.so.6+0x3bd60)\r\n #5 0x00007fe151d75ce1 raise ./signal/../sysdeps/unix/sysv/linux/raise.c:51:1\r\n #6 0x00007fe151d5f537 abort ./stdlib/abort.c:81:7\r\n #7 0x00007fe151d5f40f get_sysdep_segment_value ./intl/loadmsgcat.c:509:8\r\n #8 0x00007fe151d5f40f _nl_load_domain ./intl/loadmsgcat.c:970:34\r\n #9 0x00007fe151d6e662 (/lib/x86_64-linux-gnu/libc.so.6+0x34662)\r\n#10 0x00007fe151a64f29 circt::rtl::InOutType mlir::detail::StorageUserBase<circt::rtl::InOutType, mlir::Type, circt::rtl::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get<mlir::Type>(mlir::MLIRContext*, mlir::Type) /home/jodemme/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:96:5\r\n#11 0x00007fe151a606c3 circt::rtl::InOutType::get(mlir::MLIRContext*, mlir::Type) /home/jodemme/circt/build/include/circt/Dialect/RTL/RTLTypes.cpp.inc:147:1\r\n#12 0x00007fe151d10532 circt::rtl::InOutType::get(mlir::Type) /home/jodemme/circt/build/include/circt/Dialect/RTL/RTLTypes.h.inc:66:5\r\n#13 0x00007fe151ce744d circt::sv::WireOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Type, mlir::StringAttr) /home/jodemme/circt/lib/Dialect/SV/SVOps.cpp:835:47\r\n#14 0x00007fe1525a8d79 circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type>(mlir::Location, mlir::Type&&) /home/jodemme/circt/llvm/mlir/include/mlir/IR/Builders.h:399:31\r\n#15 0x00007fe1525a3dcb circt::sv::WireOp mlir::ImplicitLocOpBuilder::create<circt::sv::WireOp, mlir::Type>(mlir::Type&&) /home/jodemme/circt/llvm/mlir/include/mlir/IR/ImplicitLocOpBuilder.h:68:3\r\n#16 0x00007fe15258b6ca lowerUsersToTemporaryWire(mlir::Operation&) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2503:59\r\n#17 0x00007fe15258bd64 (anonymous namespace)::ModuleEmitter::prepareRTLModule(mlir::Block&) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2598:32\r\n#18 0x00007fe15258be9a (anonymous namespace)::ModuleEmitter::emitRTLModule(circt::rtl::RTLModuleOp) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2608:58\r\n#19 0x00007fe15258c9ed (anonymous namespace)::UnifiedEmitter::emitMLIRModule() /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2777:7\r\n#20 0x00007fe15258d669 circt::exportVerilog(mlir::ModuleOp, llvm::raw_ostream&) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2911:42\r\n#21 0x00007fe1527683c5 mlir::LogicalResult std::__invoke_impl<mlir::LogicalResult, mlir::LogicalResult (*&)(mlir::ModuleOp, llvm::raw_ostream&), mlir::ModuleOp, llvm::raw_ostream&>(std::__invoke_other, mlir::LogicalResult (*&)(mlir::ModuleOp, llvm::raw_ostream&), mlir::ModuleOp&&, llvm::raw_ostream&) /usr/include/c++/10/bits/invoke.h:60:70\r\n#22 0x00007fe152767e30 _ZSt10__invoke_rIN4mlir13LogicalResultERPFS1_NS0_8ModuleOpERN4llvm11raw_ostreamEEJS2_S5_EENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt7is_voidIT_EESt14is_convertibleINSt15__invoke_resultIT0_JDpT1_EE4typeESD_EEE5valueESD_E4typeEOSI_DpOSJ_ /usr/include/c++/10/bits/invoke.h:143:5\r\n#23 0x00007fe1527677f9 std::_Function_handler<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&), mlir::LogicalResult (*)(mlir::ModuleOp, llvm::raw_ostream&)>::_M_invoke(std::_Any_data const&, mlir::ModuleOp&&, llvm::raw_ostream&) /usr/include/c++/10/bits/std_function.h:293:7\r\n#24 0x00007fe152531090 std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)>::operator()(mlir::ModuleOp, llvm::raw_ostream&) const /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:622:14\r\n#25 0x00007fe15252ab00 mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1::operator()(llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*) const /home/jodemme/circt/llvm/mlir/lib/Translation/Translation.cpp:107:12\r\n#26 0x00007fe15252aa1c mlir::LogicalResult std::__invoke_impl<mlir::LogicalResult, mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*>(std::__invoke_other, mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:60:14\r\n#27 0x00007fe15252a98c std::enable_if<__and_<std::__not_<std::is_void<mlir::LogicalResult> >, std::is_convertible<std::__invoke_result<mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*>::type, mlir::LogicalResult> >::value, mlir::LogicalResult>::type std::__invoke_r<mlir::LogicalResult, mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*>(mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:141:14\r\n#28 0x00007fe15252a7ec std::_Function_handler<mlir::LogicalResult (llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*), mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1>::_M_invoke(std::_Any_data const&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:291:9\r\n#29 0x00007fe15252dbf5 std::function<mlir::LogicalResult (llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*)>::operator()(llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*) const /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:622:14\r\n#30 0x00007fe152529a2f mlir::mlirTranslateMain(int, char**, llvm::StringRef)::$_3::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/jodemme/circt/llvm/mlir/lib/Translation/Translation.cpp:188:14\r\n#31 0x00007fe15252980d mlir::mlirTranslateMain(int, char**, llvm::StringRef) /home/jodemme/circt/llvm/mlir/lib/Translation/Translation.cpp:203:21\r\n#32 0x000055ad5c7b1f66 main /home/jodemme/circt/tools/circt-translate/circt-translate.cpp:20:22\r\n#33 0x00007fe151d60d0a __libc_start_main ./csu/../csu/libc-start.c:308:16\r\n#34 0x000055ad5c7b1e6a _start (/home/jodemme/circt/build/bin/circt-translate+0x1e6a)\r\n/home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.script: line 3: 27275 Done                    /home/jodemme/circt/build/bin/circt-opt /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-rtl\r\n     27277 Aborted                 | /home/jodemme/circt/build/bin/circt-translate --export-verilog > /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp1.sv\r\n\r\n--\r\n```\r\n", "code_snippet_01": "FAIL: CIRCT :: ESI/system/basic.mlir (1 of 14)\r\n******************** TEST 'CIRCT :: ESI/system/basic.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 2';   /home/jodemme/circt/build/bin/circt-opt /home/jodemme/circt/integration_test/ESI/system/basic.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-rtl -verify-diagnostics > /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp1.mlir\r\n: 'RUN: at line 3';   /home/jodemme/circt/build/bin/circt-translate /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp1.mlir -export-verilog -verify-diagnostics > /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv\r\n: 'RUN: at line 4';   /home/jodemme/circt/build/bin/circt-rtl-sim.py /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv /home/jodemme/circt/include/circt/Dialect/ESI/ESIPrimitives.sv /home/jodemme/circt/integration_test/ESI/system/../supplements/integers.sv --cycles 150 | /home/jodemme/circt/llvm/build/bin/FileCheck /home/jodemme/circt/integration_test/ESI/system/basic.mlir\r\n--\r\nExit Code: 2\r\n\r\nCommand Output (stderr):\r\n--\r\n%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:55:15: Operator ASSIGNW expects 32 bits on the Assign RHS, but Assign RHS's VARREF '_T_5' generates 1 bits.\r\n                                                                                                     : ... In instance top\r\n   55 |   assign _T_4 = _T_5;\r\n      |               ^\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.\r\n%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:56:15: Operator ASSIGNW expects 1 bits on the Assign RHS, but Assign RHS's VARREF '_T_4' generates 32 bits.\r\n                                                                                                     : ... In instance top\r\n   56 |   assign _T_3 = _T_4;\r\n      |               ^\r\n%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:62:6: Input port connection 'a' expects 32 bits on the pin connection, but pin connection's VARREF '_T_3' generates 1 bits.\r\n                                                                                                    : ... In instance top\r\n   62 |     .a       (_T_3),\r\n      |      ^\r\n%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:70:15: Operator ASSIGNW expects 32 bits on the Assign RHS, but Assign RHS's VARREF '_T_2' generates 1 bits.\r\n                                                                                                     : ... In instance top\r\n   70 |   assign _T_1 = _T_2;\r\n      |               ^\r\n%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:71:15: Operator ASSIGNW expects 1 bits on the Assign RHS, but Assign RHS's VARREF '_T_1' generates 32 bits.\r\n                                                                                                     : ... In instance top\r\n   71 |   assign _T_0 = _T_1;\r\n      |               ^\r\n%Warning-WIDTH: /home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv:74:20: Operator ASSIGNW expects 32 bits on the Assign RHS, but Assign RHS's VARREF '_T_0' generates 1 bits.\r\n                                                                                                     : ... In instance top\r\n   74 |   assign _T_7.data = _T_0;\r\n      |                    ^\r\n%Error: Exiting due to 6 warning(s)\r\nCompletedProcess(args=['/home/jodemme/circt/ext/bin/verilator', '--cc', '--top-module', 'top', '-sv', '--build', '--exe', '--Mdir', 'basic.mlir.tmp2.sv.obj_dir', '--assert', '/home/jodemme/circt/build/integration_test/ESI/system/Output/basic.mlir.tmp2.sv', '/home/jodemme/circt/include/circt/Dialect/ESI/ESIPrimitives.sv', '/home/jodemme/circt/integration_test/ESI/system/../supplements/integers.sv', '/home/jodemme/circt/build/bin/driver.cpp'], returncode=1)\r\nFileCheck error: '<stdin>' is empty.\r\nFileCheck command line:  /home/jodemme/circt/llvm/build/bin/FileCheck /home/jodemme/circt/integration_test/ESI/system/basic.mlir\r\n\r\n--", "code_snippet_02": "********************\r\nFAIL: CIRCT :: ESI/cosim/basic.mlir (7 of 14)\r\n******************** TEST 'CIRCT :: ESI/cosim/basic.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 2';   /home/jodemme/circt/build/bin/circt-opt /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-rtl | /home/jodemme/circt/build/bin/circt-translate --export-verilog > /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp1.sv\r\n: 'RUN: at line 3';   /home/jodemme/circt/build/bin/circt-translate /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir -export-esi-capnp -verify-diagnostics > /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp2.capnp\r\n: 'RUN: at line 4';   /home/jodemme/circt/build/bin/esi-cosim-runner.py --schema /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp2.capnp /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp1.sv /home/jodemme/circt/integration_test/ESI/cosim/../supplements/integers.sv\r\n--\r\nExit Code: 134\r\n\r\nCommand Output (stderr):\r\n--\r\n<unknown>:0: error: invalid element for rtl.inout type\r\ncirct-translate: /home/jodemme/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:96: static ConcreteT mlir::detail::StorageUserBase<ConcreteT, BaseT, StorageT, UniquerT, Traits>::get(mlir::MLIRContext*, Args ...) [with Args = {mlir::Type}; ConcreteT = circt::rtl::InOutType; BaseT = mlir::Type; StorageT = circt::rtl::detail::InOutTypeStorage; UniquerT = mlir::detail::TypeUniquer; Traits = {}]: Assertion `succeeded(ConcreteT::verify(getDefaultDiagnosticEmitFn(ctx), args...))' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: /home/jodemme/circt/build/bin/circt-translate --export-verilog\r\n #0 0x00007fe1524db6ea llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/jodemme/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:11\r\n #1 0x00007fe1524db8bb PrintStackTraceSignalHandler(void*) /home/jodemme/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00007fe1524d9e8b llvm::sys::RunSignalHandlers() /home/jodemme/circt/llvm/llvm/lib/Support/Signals.cpp:70:5\r\n #3 0x00007fe1524dc031 SignalHandler(int) /home/jodemme/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007fe151d75d60 (/lib/x86_64-linux-gnu/libc.so.6+0x3bd60)\r\n #5 0x00007fe151d75ce1 raise ./signal/../sysdeps/unix/sysv/linux/raise.c:51:1\r\n #6 0x00007fe151d5f537 abort ./stdlib/abort.c:81:7\r\n #7 0x00007fe151d5f40f get_sysdep_segment_value ./intl/loadmsgcat.c:509:8\r\n #8 0x00007fe151d5f40f _nl_load_domain ./intl/loadmsgcat.c:970:34\r\n #9 0x00007fe151d6e662 (/lib/x86_64-linux-gnu/libc.so.6+0x34662)\r\n#10 0x00007fe151a64f29 circt::rtl::InOutType mlir::detail::StorageUserBase<circt::rtl::InOutType, mlir::Type, circt::rtl::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get<mlir::Type>(mlir::MLIRContext*, mlir::Type) /home/jodemme/circt/llvm/mlir/include/mlir/IR/StorageUniquerSupport.h:96:5\r\n#11 0x00007fe151a606c3 circt::rtl::InOutType::get(mlir::MLIRContext*, mlir::Type) /home/jodemme/circt/build/include/circt/Dialect/RTL/RTLTypes.cpp.inc:147:1\r\n#12 0x00007fe151d10532 circt::rtl::InOutType::get(mlir::Type) /home/jodemme/circt/build/include/circt/Dialect/RTL/RTLTypes.h.inc:66:5\r\n#13 0x00007fe151ce744d circt::sv::WireOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Type, mlir::StringAttr) /home/jodemme/circt/lib/Dialect/SV/SVOps.cpp:835:47\r\n#14 0x00007fe1525a8d79 circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type>(mlir::Location, mlir::Type&&) /home/jodemme/circt/llvm/mlir/include/mlir/IR/Builders.h:399:31\r\n#15 0x00007fe1525a3dcb circt::sv::WireOp mlir::ImplicitLocOpBuilder::create<circt::sv::WireOp, mlir::Type>(mlir::Type&&) /home/jodemme/circt/llvm/mlir/include/mlir/IR/ImplicitLocOpBuilder.h:68:3\r\n#16 0x00007fe15258b6ca lowerUsersToTemporaryWire(mlir::Operation&) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2503:59\r\n#17 0x00007fe15258bd64 (anonymous namespace)::ModuleEmitter::prepareRTLModule(mlir::Block&) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2598:32\r\n#18 0x00007fe15258be9a (anonymous namespace)::ModuleEmitter::emitRTLModule(circt::rtl::RTLModuleOp) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2608:58\r\n#19 0x00007fe15258c9ed (anonymous namespace)::UnifiedEmitter::emitMLIRModule() /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2777:7\r\n#20 0x00007fe15258d669 circt::exportVerilog(mlir::ModuleOp, llvm::raw_ostream&) /home/jodemme/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:2911:42\r\n#21 0x00007fe1527683c5 mlir::LogicalResult std::__invoke_impl<mlir::LogicalResult, mlir::LogicalResult (*&)(mlir::ModuleOp, llvm::raw_ostream&), mlir::ModuleOp, llvm::raw_ostream&>(std::__invoke_other, mlir::LogicalResult (*&)(mlir::ModuleOp, llvm::raw_ostream&), mlir::ModuleOp&&, llvm::raw_ostream&) /usr/include/c++/10/bits/invoke.h:60:70\r\n#22 0x00007fe152767e30 _ZSt10__invoke_rIN4mlir13LogicalResultERPFS1_NS0_8ModuleOpERN4llvm11raw_ostreamEEJS2_S5_EENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt7is_voidIT_EESt14is_convertibleINSt15__invoke_resultIT0_JDpT1_EE4typeESD_EEE5valueESD_E4typeEOSI_DpOSJ_ /usr/include/c++/10/bits/invoke.h:143:5\r\n#23 0x00007fe1527677f9 std::_Function_handler<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&), mlir::LogicalResult (*)(mlir::ModuleOp, llvm::raw_ostream&)>::_M_invoke(std::_Any_data const&, mlir::ModuleOp&&, llvm::raw_ostream&) /usr/include/c++/10/bits/std_function.h:293:7\r\n#24 0x00007fe152531090 std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)>::operator()(mlir::ModuleOp, llvm::raw_ostream&) const /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:622:14\r\n#25 0x00007fe15252ab00 mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1::operator()(llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*) const /home/jodemme/circt/llvm/mlir/lib/Translation/Translation.cpp:107:12\r\n#26 0x00007fe15252aa1c mlir::LogicalResult std::__invoke_impl<mlir::LogicalResult, mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*>(std::__invoke_other, mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:60:14\r\n#27 0x00007fe15252a98c std::enable_if<__and_<std::__not_<std::is_void<mlir::LogicalResult> >, std::is_convertible<std::__invoke_result<mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*>::type, mlir::LogicalResult> >::value, mlir::LogicalResult>::type std::__invoke_r<mlir::LogicalResult, mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*>(mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/invoke.h:141:14\r\n#28 0x00007fe15252a7ec std::_Function_handler<mlir::LogicalResult (llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*), mlir::TranslateFromMLIRRegistration::TranslateFromMLIRRegistration(llvm::StringRef, std::function<mlir::LogicalResult (mlir::ModuleOp, llvm::raw_ostream&)> const&, std::function<void (mlir::DialectRegistry&)>)::$_1>::_M_invoke(std::_Any_data const&, llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:291:9\r\n#29 0x00007fe15252dbf5 std::function<mlir::LogicalResult (llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*)>::operator()(llvm::SourceMgr&, llvm::raw_ostream&, mlir::MLIRContext*) const /usr/bin/../lib/gcc/x86_64-linux-gnu/10/../../../../include/c++/10/bits/std_function.h:622:14\r\n#30 0x00007fe152529a2f mlir::mlirTranslateMain(int, char**, llvm::StringRef)::$_3::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const /home/jodemme/circt/llvm/mlir/lib/Translation/Translation.cpp:188:14\r\n#31 0x00007fe15252980d mlir::mlirTranslateMain(int, char**, llvm::StringRef) /home/jodemme/circt/llvm/mlir/lib/Translation/Translation.cpp:203:21\r\n#32 0x000055ad5c7b1f66 main /home/jodemme/circt/tools/circt-translate/circt-translate.cpp:20:22\r\n#33 0x00007fe151d60d0a __libc_start_main ./csu/../csu/libc-start.c:308:16\r\n#34 0x000055ad5c7b1e6a _start (/home/jodemme/circt/build/bin/circt-translate+0x1e6a)\r\n/home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.script: line 3: 27275 Done                    /home/jodemme/circt/build/bin/circt-opt /home/jodemme/circt/integration_test/ESI/cosim/basic.mlir --lower-esi-to-physical --lower-esi-ports --lower-esi-to-rtl\r\n     27277 Aborted                 | /home/jodemme/circt/build/bin/circt-translate --export-verilog > /home/jodemme/circt/build/integration_test/ESI/cosim/Output/basic.mlir.tmp1.sv\r\n\r\n--"}, {"number": 860, "title": "[FIRRTL] crash in ExportVerilog: use-before-def creating a wire with incorrect type", "created_at": "2021-03-31T17:59:16Z", "state": "closed", "labels": "bug, FIRRTL", "body": "```mlir\r\n// ./bin/firtool ./crash-inout.mlir --verilog\r\nrtl.module @ArrayLHS(%clock: i1) -> () {\r\n  %false = rtl.constant false\r\n  sv.alwaysff(posedge %clock)  {\r\n    sv.passign %reg, %false : i1\r\n  }\r\n  %reg = sv.reg  : !rtl.inout<i1>\r\n}\r\n```\r\nSince `%reg` is used before its defined, the code is attempting to create a wire for it.  This is resulting in a wire of type `rtl.inout<inout<i1>>`:\r\n```\r\n<unknown>:0: error: invalid element for rtl.inout type\r\n\r\n    frame #3: 0x00007fff203f29d6 libsystem_c.dylib`__assert_rtn + 314\r\n  * frame #4: 0x00000001036a2904 libCIRCTRTL.dylib`circt::rtl::InOutType mlir::detail::StorageUserBase<circt::rtl::InOutType, mlir::Type, circt::rtl::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get<mlir::Type>(ctx=0x00007ffeefbff470, args=Type @ 0x00007ffeefbfdce0) at StorageUniquerSupport.h:96:5\r\n    frame #5: 0x00000001036a2865 libCIRCTRTL.dylib`circt::rtl::InOutType::get(context=0x00007ffeefbff470, elementType=Type @ 0x00007ffeefbfdd10) at RTLTypes.cpp.inc:146:10\r\n    frame #6: 0x00000001032695f9 libCIRCTSV.dylib`circt::rtl::InOutType::get(elementType=Type @ 0x00007ffeefbfdd40) at RTLTypes.h.inc:65:14\r\n    frame #7: 0x000000010326d525 libCIRCTSV.dylib`circt::sv::WireOp::build(odsBuilder=0x00007ffeefbfe108, odsState=0x00007ffeefbfded0, elementType=Type @ 0x00007ffeefbfddc8, name=StringAttr @ 0x00007ffeefbfddc0) at SVOps.cpp:833:21\r\n    frame #8: 0x0000000100228e5c libCIRCTExportVerilog.dylib`circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type>(this=0x00007ffeefbfe108, location=Location @ 0x00007ffeefbfdec0, args=0x00007ffeefbfe0b0) at Builders.h:398:5\r\n    frame #9: 0x0000000100228aec libCIRCTExportVerilog.dylib`circt::sv::WireOp mlir::ImplicitLocOpBuilder::create<circt::sv::WireOp, mlir::Type>(this=0x00007ffeefbfe108, args=0x00007ffeefbfe0b0) at ImplicitLocOpBuilder.h:67:23\r\n    frame #10: 0x000000010021f34a libCIRCTExportVerilog.dylib`lowerUsersToTemporaryWire(op=0x000000010fc36300) at ExportVerilog.cpp:2505:28\r\n```", "code_snippet_01": "// ./bin/firtool ./crash-inout.mlir --verilog\r\nrtl.module @ArrayLHS(%clock: i1) -> () {\r\n  %false = rtl.constant false\r\n  sv.alwaysff(posedge %clock)  {\r\n    sv.passign %reg, %false : i1\r\n  }\r\n  %reg = sv.reg  : !rtl.inout<i1>\r\n}", "code_snippet_02": "<unknown>:0: error: invalid element for rtl.inout type\r\n\r\n    frame #3: 0x00007fff203f29d6 libsystem_c.dylib`__assert_rtn + 314\r\n  * frame #4: 0x00000001036a2904 libCIRCTRTL.dylib`circt::rtl::InOutType mlir::detail::StorageUserBase<circt::rtl::InOutType, mlir::Type, circt::rtl::detail::InOutTypeStorage, mlir::detail::TypeUniquer>::get<mlir::Type>(ctx=0x00007ffeefbff470, args=Type @ 0x00007ffeefbfdce0) at StorageUniquerSupport.h:96:5\r\n    frame #5: 0x00000001036a2865 libCIRCTRTL.dylib`circt::rtl::InOutType::get(context=0x00007ffeefbff470, elementType=Type @ 0x00007ffeefbfdd10) at RTLTypes.cpp.inc:146:10\r\n    frame #6: 0x00000001032695f9 libCIRCTSV.dylib`circt::rtl::InOutType::get(elementType=Type @ 0x00007ffeefbfdd40) at RTLTypes.h.inc:65:14\r\n    frame #7: 0x000000010326d525 libCIRCTSV.dylib`circt::sv::WireOp::build(odsBuilder=0x00007ffeefbfe108, odsState=0x00007ffeefbfded0, elementType=Type @ 0x00007ffeefbfddc8, name=StringAttr @ 0x00007ffeefbfddc0) at SVOps.cpp:833:21\r\n    frame #8: 0x0000000100228e5c libCIRCTExportVerilog.dylib`circt::sv::WireOp mlir::OpBuilder::create<circt::sv::WireOp, mlir::Type>(this=0x00007ffeefbfe108, location=Location @ 0x00007ffeefbfdec0, args=0x00007ffeefbfe0b0) at Builders.h:398:5\r\n    frame #9: 0x0000000100228aec libCIRCTExportVerilog.dylib`circt::sv::WireOp mlir::ImplicitLocOpBuilder::create<circt::sv::WireOp, mlir::Type>(this=0x00007ffeefbfe108, args=0x00007ffeefbfe0b0) at ImplicitLocOpBuilder.h:67:23\r\n    frame #10: 0x000000010021f34a libCIRCTExportVerilog.dylib`lowerUsersToTemporaryWire(op=0x000000010fc36300) at ExportVerilog.cpp:2505:28"}, {"number": 859, "title": "VerilogEmitter crashes on out of order use of sv.reg", "created_at": "2021-03-31T17:32:44Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The changes I put in to handle out of order references to values in a graph region don't handle inout types correctly.\r\n\r\nWill fix.\r\n\r\n"}, {"number": 855, "title": "-rtl-legalize-names crashes on nameless reg", "created_at": "2021-03-31T05:31:43Z", "state": "closed", "labels": "bug", "body": "Names are optional on regs and wires, but `-rtl-legalize-names` isn't handling this.  Instead of being optional, we should make these attributes always required but possibly empty.\r\n\r\nI'll work on it."}, {"number": 854, "title": "circt-translate crashes with small testcase", "created_at": "2021-03-31T01:08:17Z", "state": "closed", "labels": "bug", "body": "I think this is either an MLIR bug or a bug in how we're using it, but this works fine:\r\n\r\n```\r\n$ cat x1.mlir\r\nrtl.module @cyclic(%a: i1) -> (%b: i1) {\r\n  %ASB = sv.wire : !rtl.inout<i1>\r\n  %1 = comb.add %0, %0 : i1\r\n  %0 = comb.shl %a, %a : i1\r\n  %2 = comb.add %1, %1 : i1\r\n  rtl.output %2 : i1\r\n}\r\n\r\n$ circt-translate x1.mlir -export-verilog \r\n```\r\n\r\nHowever if you delete the ASB wire, we get:\r\n\r\n```\r\n$ cat x1.mlir \r\nrtl.module @cyclic(%a: i1) -> (%b: i1) {\r\n  %1 = comb.add %0, %0 : i1\r\n  %0 = comb.shl %a, %a : i1\r\n  %2 = comb.add %1, %1 : i1\r\n  rtl.output %2 : i1\r\n}\r\n$ circt-translate x1.mlir -export-verilog \r\nLLVM ERROR: Building op `sv.wire` but it isn't registered in this MLIRContext\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: circt-translate x1.mlir -export-verilog\r\n... crash\r\n```\r\n", "code_snippet_01": "$ cat x1.mlir\r\nrtl.module @cyclic(%a: i1) -> (%b: i1) {\r\n  %ASB = sv.wire : !rtl.inout<i1>\r\n  %1 = comb.add %0, %0 : i1\r\n  %0 = comb.shl %a, %a : i1\r\n  %2 = comb.add %1, %1 : i1\r\n  rtl.output %2 : i1\r\n}\r\n\r\n$ circt-translate x1.mlir -export-verilog", "code_snippet_02": "$ cat x1.mlir \r\nrtl.module @cyclic(%a: i1) -> (%b: i1) {\r\n  %1 = comb.add %0, %0 : i1\r\n  %0 = comb.shl %a, %a : i1\r\n  %2 = comb.add %1, %1 : i1\r\n  rtl.output %2 : i1\r\n}\r\n$ circt-translate x1.mlir -export-verilog \r\nLLVM ERROR: Building op `sv.wire` but it isn't registered in this MLIRContext\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: circt-translate x1.mlir -export-verilog\r\n... crash"}, {"number": 850, "title": "[FIRRTL] Handle folding of 0-width LEQ/LT/GEQ/GT", "created_at": "2021-03-30T11:59:41Z", "state": "closed", "labels": "bug, FIRRTL", "body": "* Fix an issue in comparison folding in case the left-hand argument is a non-constant value of width 0. Fixes #847."}, {"number": 847, "title": "[FIRRTL] (geq) (core dump)", "created_at": "2021-03-30T03:59:02Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 12\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_h: UInt<0>\r\n    wire tmp10: SInt<0>\r\n    wire tmp25: SInt<29>\r\n    wire tmp28: UInt<1>\r\n    tmp10 <= asSInt(inp_h)\r\n    tmp25 <= SInt<29>(-1)\r\n    tmp28 <= geq(tmp10, tmp25)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:\r\n\r\n```mlir\r\nfirtool\r\nfirtool: ../llvm/llvm/include/llvm/ADT/APInt.h:280: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && \"bitwidth too small\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n1.      2.       #0 0x00000000004be4f7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004be5ae PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004bc5a4 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bdf4a SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f8b67bbaa30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #5 0x00007f8b6763e4a5 raise (/lib64/libc.so.6+0x3d4a5)\r\n #6 0x00007f8b67627864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f8b67627749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f8b676369b6 (/lib64/libc.so.6+0x359b6)\r\n #9 0x0000000000727d4b circt::firrtl::GEQPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) (../../llvm/circt/build/bin/firtool+0x727d4b)\r\n#10 0x000000000071cda4 mlir::LogicalResult mlir::Op<circt::firrtl::GEQPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::GEQPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) (../../llvm/circt/build/bin/firtool+0x71cda4)\r\n#11 0x00000000006bbdb6 mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:128:3\r\n#12 0x00000000006b4f12 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:553:30\r\n#13 0x000000000078be1f mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#14 0x000000000078b7a4 mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#15 0x00000000007718cb (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:192:21\r\n#16 0x0000000000771bee mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:256:35\r\n#17 0x0000000000771ada mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:236:1\r\n#18 0x0000000000703ca4 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:36:3\r\n#19 0x00000000008ed8bb mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:407:36\r\n#20 0x00000000008edae7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:448:15\r\n#21 0x00000000008ee7c2 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:624:68\r\n#22 0x00000000008f1a0b mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7\r\n#23 0x00000000008f19ac void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:143:16\r\n#24 0x00000000008f0ed3 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40\r\n#25 0x00000000008eecd7 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:601:24\r\n#26 0x00000000008ee203 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:526:1\r\n#27 0x00000000008ed89c mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:404:28\r\n#28 0x00000000008edae7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:448:15\r\n#29 0x00000000008ee7c2 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:624:68\r\n#30 0x00000000008f1a0b mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7\r\n#31 0x00000000008f19ac void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:143:16\r\n#32 0x00000000008f0ed3 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40\r\n#33 0x00000000008eecd7 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:601:24\r\n#34 0x00000000008ee203 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:526:1\r\n#35 0x00000000008ed89c mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:404:28\r\n#36 0x00000000008edae7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:448:15\r\n#37 0x00000000008efc27 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:901:74\r\n#38 0x000000000040e193 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40e193)\r\n#39 0x000000000040b3d1 main (../../llvm/circt/build/bin/firtool+0x40b3d1)\r\n#40 0x00007f8b67628b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#41 0x000000000040b76e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: \u0441\u0442\u0440\u043e\u043a\u0430 26: 13260 Aborted                 (\u0441\u0442\u0435\u043a \u043f\u0430\u043c\u044f\u0442\u0438 \u0441\u0431\u0440\u043e\u0448\u0435\u043d \u043d\u0430 \u0434\u0438\u0441\u043a) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2\r\n```\r\nCompiled with firrtl-1.5-SNAPSHOT --dont-fold div produces this Verilog:\r\n\r\n```\r\nmodule top_mod(\r\n  input   clock,\r\n  input   reset\r\n);\r\nendmodule\r\n```\r\nExpected behavior: not to crash\r\n", "code_snippet_01": "; seed: 12\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_h: UInt<0>\r\n    wire tmp10: SInt<0>\r\n    wire tmp25: SInt<29>\r\n    wire tmp28: UInt<1>\r\n    tmp10 <= asSInt(inp_h)\r\n    tmp25 <= SInt<29>(-1)\r\n    tmp28 <= geq(tmp10, tmp25)", "code_snippet_02": "firtool\r\nfirtool: ../llvm/llvm/include/llvm/ADT/APInt.h:280: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && \"bitwidth too small\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n1.      2.       #0 0x00000000004be4f7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004be5ae PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004bc5a4 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bdf4a SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f8b67bbaa30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #5 0x00007f8b6763e4a5 raise (/lib64/libc.so.6+0x3d4a5)\r\n #6 0x00007f8b67627864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f8b67627749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f8b676369b6 (/lib64/libc.so.6+0x359b6)\r\n #9 0x0000000000727d4b circt::firrtl::GEQPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) (../../llvm/circt/build/bin/firtool+0x727d4b)\r\n#10 0x000000000071cda4 mlir::LogicalResult mlir::Op<circt::firrtl::GEQPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::GEQPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) (../../llvm/circt/build/bin/firtool+0x71cda4)\r\n#11 0x00000000006bbdb6 mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:128:3\r\n#12 0x00000000006b4f12 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:553:30\r\n#13 0x000000000078be1f mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#14 0x000000000078b7a4 mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#15 0x00000000007718cb (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:192:21\r\n#16 0x0000000000771bee mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:256:35\r\n#17 0x0000000000771ada mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternSet const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:236:1\r\n#18 0x0000000000703ca4 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:36:3\r\n#19 0x00000000008ed8bb mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:407:36\r\n#20 0x00000000008edae7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:448:15\r\n#21 0x00000000008ee7c2 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:624:68\r\n#22 0x00000000008f1a0b mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7\r\n#23 0x00000000008f19ac void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:143:16\r\n#24 0x00000000008f0ed3 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40\r\n#25 0x00000000008eecd7 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:601:24\r\n#26 0x00000000008ee203 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:526:1\r\n#27 0x00000000008ed89c mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:404:28\r\n#28 0x00000000008edae7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:448:15\r\n#29 0x00000000008ee7c2 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:624:68\r\n#30 0x00000000008f1a0b mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7\r\n#31 0x00000000008f19ac void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:143:16\r\n#32 0x00000000008f0ed3 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40\r\n#33 0x00000000008eecd7 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:601:24\r\n#34 0x00000000008ee203 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:526:1\r\n#35 0x00000000008ed89c mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:404:28\r\n#36 0x00000000008edae7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:448:15\r\n#37 0x00000000008efc27 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:901:74\r\n#38 0x000000000040e193 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40e193)\r\n#39 0x000000000040b3d1 main (../../llvm/circt/build/bin/firtool+0x40b3d1)\r\n#40 0x00007f8b67628b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#41 0x000000000040b76e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: \u0441\u0442\u0440\u043e\u043a\u0430 26: 13260 Aborted                 (\u0441\u0442\u0435\u043a \u043f\u0430\u043c\u044f\u0442\u0438 \u0441\u0431\u0440\u043e\u0448\u0435\u043d \u043d\u0430 \u0434\u0438\u0441\u043a) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2", "code_snippet_03": "module top_mod(\r\n  input   clock,\r\n  input   reset\r\n);\r\nendmodule"}, {"number": 846, "title": "Respect Procedural/Non-procedural Regions when Unwinding Inlined, Long Line Expressions", "created_at": "2021-03-30T00:11:58Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Two fixes:\r\n\r\n1) Pass around the current statement when doing Verilog emission of expressions and sub-expressions. This avoids problems where inlining an expression, defined in a non-procedural region, into a procedural region was then unwound due to the emitted Verilog line being too long. The type of region (procedural vs. non-procedural) in which the inlined expression was *defined* was then incorrectly used to generate a temporary. This changes this to compute the region based on the type of the statement.\r\n\r\n2) Reset `outOfLineExpressions` pointer set if these have already been emitted. Without doing this, later use/def of something in the pointer set would cause duplicate emission. (I'm much less confident that this modification is sound. I had a difficult time following all the `ExportVerilog` logic and may have missed something.)\r\n\r\nRegardless, the test cases are sound and can be re-used if there's a better solution here.\r\n\r\nFixes #838."}, {"number": 844, "title": "[FIRRTL] mem (mismatch)", "created_at": "2021-03-29T19:09:38Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 56\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input en: UInt<1>\r\n    input addr1: UInt<17>\r\n    input wdata: SInt<19>\r\n    output tmp16: SInt<10>\r\n    mem tmp14:\r\n      data-type => SInt<10>\r\n      depth => 16\r\n      read-latency => 1\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r1\r\n      writer => w0\r\n    tmp14.r1.clk <= clock\r\n    tmp14.r1.en <= en\r\n    tmp14.r1.addr <= addr1\r\n    tmp14.w0.clk <= clock\r\n    tmp14.w0.en <= en\r\n    tmp14.w0.addr <= asUInt(SInt<7>(\"h-28\"))\r\n    tmp14.w0.data <= wdata\r\n    tmp14.w0.mask <= UInt<25>(\"hffffff\")\r\n    tmp16 <= tmp14.r1.data\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:\r\n\r\n```verilog\r\n...\r\nmodule top_mod(\r\n  input         clock, en,\r\n  input  [16:0] addr1,\r\n  input  [18:0] wdata,\r\n  output [9:0]  tmp16);\r\n\r\n  reg  [9:0] tmp14[0:15];\t// a_top_mod.fir:9:5\r\n  reg        tmp14_r1_en_pipe[0:0];\t// a_top_mod.fir:9:5\r\n  reg  [3:0] tmp14_r1_addr_pipe[0:0];\t// a_top_mod.fir:9:5\r\n  wire [3:0] tmp14_r1_addr;\t// a_top_mod.fir:9:5\r\n  wire [3:0] _T;\t// a_top_mod.fir:9:5\r\n  wire [9:0] _T_0;\t// a_top_mod.fir:23:19\r\n\r\n  always_ff @(posedge clock) begin\t// a_top_mod.fir:9:5\r\n    tmp14_r1_en_pipe[1'h0] <= en;\t// a_top_mod.fir:9:5\r\n    if (en)\t// a_top_mod.fir:9:5\r\n      tmp14_r1_addr_pipe[1'h0] <= _T;\t// a_top_mod.fir:9:5\r\n    if (en)\t// a_top_mod.fir:9:5\r\n      tmp14[4'h8] <= _T_0;\t// a_top_mod.fir:9:5, :22:19\r\n  end // always_ff @(posedge)\r\n...\r\n  assign _T = tmp14_r1_addr;\t// a_top_mod.fir:9:5\r\n  assign tmp14_r1_addr = addr1[3:0];\t// a_top_mod.fir:19:19\r\n  assign _T_0 = wdata[9:0];\t// a_top_mod.fir:23:19\r\n  assign tmp16 = tmp14[tmp14_r1_addr_pipe[1'h0]];\t// a_top_mod.fir:3:3, :9:5\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input         clock,\r\n  input         en,\r\n  input  [16:0] addr1,\r\n  input  [18:0] wdata,\r\n  output [9:0]  tmp16\r\n);\r\n...\r\n  reg [9:0] tmp14 [0:15];\r\n  wire [9:0] tmp14_r1_data;\r\n  wire [3:0] tmp14_r1_addr;\r\n  wire [9:0] tmp14_w0_data;\r\n  wire [3:0] tmp14_w0_addr;\r\n  wire  tmp14_w0_mask;\r\n  wire  tmp14_w0_en;\r\n  reg  tmp14_r1_en_pipe_0;\r\n  reg [3:0] tmp14_r1_addr_pipe_0;\r\n  assign tmp14_r1_addr = tmp14_r1_addr_pipe_0;\r\n  assign tmp14_r1_data = tmp14[tmp14_r1_addr];\r\n  assign tmp14_w0_data = wdata[9:0];\r\n  assign tmp14_w0_addr = 4'h8;\r\n  assign tmp14_w0_mask = 1'h1;\r\n  assign tmp14_w0_en = en;\r\n  assign tmp16 = tmp14_r1_data;\r\n  always @(posedge clock) begin\r\n    if (tmp14_w0_en & tmp14_w0_mask) begin\r\n      tmp14[tmp14_w0_addr] <= tmp14_w0_data;\r\n    end\r\n    tmp14_r1_en_pipe_0 <= en;\r\n    if (en) begin\r\n      tmp14_r1_addr_pipe_0 <= addr1[3:0];\r\n    end\r\n  end\r\n// Register and memory initialization\r\n...\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nyosys 0\r\nWarning: Replacing memory \\tmp14 with list of registers. See a_top_mod_new.sv:53\r\nWarning: Replacing memory \\tmp14_r1_addr_pipe with list of registers. See a_top_mod_new.sv:51\r\nWarning: Replacing memory \\tmp14_r1_en_pipe with list of registers. See a_top_mod_new.sv:49\r\nERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 1\r\nWarning: Replacing memory \\tmp14 with list of registers. See a_top_mod_new.sv:53\r\nWarning: Replacing memory \\tmp14_r1_addr_pipe with list of registers. See a_top_mod_new.sv:51\r\nWarning: Replacing memory \\tmp14_r1_en_pipe with list of registers. See a_top_mod_new.sv:49\r\nERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 2\r\nWarning: Replacing memory \\tmp14 with list of registers. See a_top_mod_new.sv:53\r\nWarning: Replacing memory \\tmp14_r1_addr_pipe with list of registers. See a_top_mod_new.sv:51\r\nWarning: Replacing memory \\tmp14_r1_en_pipe with list of registers. See a_top_mod_new.sv:49\r\nERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "; seed: 56\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input en: UInt<1>\r\n    input addr1: UInt<17>\r\n    input wdata: SInt<19>\r\n    output tmp16: SInt<10>\r\n    mem tmp14:\r\n      data-type => SInt<10>\r\n      depth => 16\r\n      read-latency => 1\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r1\r\n      writer => w0\r\n    tmp14.r1.clk <= clock\r\n    tmp14.r1.en <= en\r\n    tmp14.r1.addr <= addr1\r\n    tmp14.w0.clk <= clock\r\n    tmp14.w0.en <= en\r\n    tmp14.w0.addr <= asUInt(SInt<7>(\"h-28\"))\r\n    tmp14.w0.data <= wdata\r\n    tmp14.w0.mask <= UInt<25>(\"hffffff\")\r\n    tmp16 <= tmp14.r1.data", "code_snippet_02": "...\r\nmodule top_mod(\r\n  input         clock, en,\r\n  input  [16:0] addr1,\r\n  input  [18:0] wdata,\r\n  output [9:0]  tmp16);\r\n\r\n  reg  [9:0] tmp14[0:15];\t// a_top_mod.fir:9:5\r\n  reg        tmp14_r1_en_pipe[0:0];\t// a_top_mod.fir:9:5\r\n  reg  [3:0] tmp14_r1_addr_pipe[0:0];\t// a_top_mod.fir:9:5\r\n  wire [3:0] tmp14_r1_addr;\t// a_top_mod.fir:9:5\r\n  wire [3:0] _T;\t// a_top_mod.fir:9:5\r\n  wire [9:0] _T_0;\t// a_top_mod.fir:23:19\r\n\r\n  always_ff @(posedge clock) begin\t// a_top_mod.fir:9:5\r\n    tmp14_r1_en_pipe[1'h0] <= en;\t// a_top_mod.fir:9:5\r\n    if (en)\t// a_top_mod.fir:9:5\r\n      tmp14_r1_addr_pipe[1'h0] <= _T;\t// a_top_mod.fir:9:5\r\n    if (en)\t// a_top_mod.fir:9:5\r\n      tmp14[4'h8] <= _T_0;\t// a_top_mod.fir:9:5, :22:19\r\n  end // always_ff @(posedge)\r\n...\r\n  assign _T = tmp14_r1_addr;\t// a_top_mod.fir:9:5\r\n  assign tmp14_r1_addr = addr1[3:0];\t// a_top_mod.fir:19:19\r\n  assign _T_0 = wdata[9:0];\t// a_top_mod.fir:23:19\r\n  assign tmp16 = tmp14[tmp14_r1_addr_pipe[1'h0]];\t// a_top_mod.fir:3:3, :9:5\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input         clock,\r\n  input         en,\r\n  input  [16:0] addr1,\r\n  input  [18:0] wdata,\r\n  output [9:0]  tmp16\r\n);\r\n...\r\n  reg [9:0] tmp14 [0:15];\r\n  wire [9:0] tmp14_r1_data;\r\n  wire [3:0] tmp14_r1_addr;\r\n  wire [9:0] tmp14_w0_data;\r\n  wire [3:0] tmp14_w0_addr;\r\n  wire  tmp14_w0_mask;\r\n  wire  tmp14_w0_en;\r\n  reg  tmp14_r1_en_pipe_0;\r\n  reg [3:0] tmp14_r1_addr_pipe_0;\r\n  assign tmp14_r1_addr = tmp14_r1_addr_pipe_0;\r\n  assign tmp14_r1_data = tmp14[tmp14_r1_addr];\r\n  assign tmp14_w0_data = wdata[9:0];\r\n  assign tmp14_w0_addr = 4'h8;\r\n  assign tmp14_w0_mask = 1'h1;\r\n  assign tmp14_w0_en = en;\r\n  assign tmp16 = tmp14_r1_data;\r\n  always @(posedge clock) begin\r\n    if (tmp14_w0_en & tmp14_w0_mask) begin\r\n      tmp14[tmp14_w0_addr] <= tmp14_w0_data;\r\n    end\r\n    tmp14_r1_en_pipe_0 <= en;\r\n    if (en) begin\r\n      tmp14_r1_addr_pipe_0 <= addr1[3:0];\r\n    end\r\n  end\r\n// Register and memory initialization\r\n...\r\nendmodule", "code_snippet_04": "yosys 0\r\nWarning: Replacing memory \\tmp14 with list of registers. See a_top_mod_new.sv:53\r\nWarning: Replacing memory \\tmp14_r1_addr_pipe with list of registers. See a_top_mod_new.sv:51\r\nWarning: Replacing memory \\tmp14_r1_en_pipe with list of registers. See a_top_mod_new.sv:49\r\nERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 1\r\nWarning: Replacing memory \\tmp14 with list of registers. See a_top_mod_new.sv:53\r\nWarning: Replacing memory \\tmp14_r1_addr_pipe with list of registers. See a_top_mod_new.sv:51\r\nWarning: Replacing memory \\tmp14_r1_en_pipe with list of registers. See a_top_mod_new.sv:49\r\nERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 2\r\nWarning: Replacing memory \\tmp14 with list of registers. See a_top_mod_new.sv:53\r\nWarning: Replacing memory \\tmp14_r1_addr_pipe with list of registers. See a_top_mod_new.sv:51\r\nWarning: Replacing memory \\tmp14_r1_en_pipe with list of registers. See a_top_mod_new.sv:49\r\nERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 842, "title": "[FIRRTL] Yosys integration test failing", "created_at": "2021-03-29T18:12:52Z", "state": "closed", "labels": "bug, FIRRTL", "body": "https://github.com/llvm/circt/runs/2218231196?check_suite_focus=true\r\n\r\n```\r\nFAIL: CIRCT :: EmitVerilog/verilog_equiv.fir (11 of 14)\r\n******************** TEST 'CIRCT :: EmitVerilog/verilog_equiv.fir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 2';   split-file /__w/circt/circt/integration_test/EmitVerilog/verilog_equiv.fir /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp\r\n: 'RUN: at line 3';   /__w/circt/circt/build/bin/firtool /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir --format=fir --lower-to-rtl -verilog -o /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir.v\r\n: 'RUN: at line 4';   /__w/circt/circt/build/bin/firtool /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir --format=fir --lower-to-rtl -verilog -o /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v\r\n: 'RUN: at line 5';   /__w/circt/circt/build/bin/firtool /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.fir --format=fir --lower-to-rtl -verilog -o /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.fir.v\r\n: 'RUN: at line 6';   /__w/circt/circt/integration_test/EmitVerilog/../../utils/equiv-rtl.sh /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir.v /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.v test_mod\r\n: 'RUN: at line 7';   /__w/circt/circt/integration_test/EmitVerilog/../../utils/equiv-rtl.sh /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.v test_unary\r\n: 'RUN: at line 8';   /__w/circt/circt/integration_test/EmitVerilog/../../utils/equiv-rtl.sh /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.fir.v /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.v test_prim\r\n--\r\nExit Code: 1\r\n\r\nCommand Output (stdout):\r\n--\r\nComparing /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir.v and /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.v with test_mod Missing Dir .\r\nPASS,INDUCT\r\nComparing /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v and /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.v with test_unary Missing Dir .\r\nTrying SAT /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v and /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.v with test_unary Missing Dir .\r\nFAIL\r\n\r\n--\r\nCommand Output (stderr):\r\n--\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nERROR: Called with -verify and proof did fail!\r\n\r\n--\r\n```", "code_snippet_01": "FAIL: CIRCT :: EmitVerilog/verilog_equiv.fir (11 of 14)\r\n******************** TEST 'CIRCT :: EmitVerilog/verilog_equiv.fir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 2';   split-file /__w/circt/circt/integration_test/EmitVerilog/verilog_equiv.fir /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp\r\n: 'RUN: at line 3';   /__w/circt/circt/build/bin/firtool /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir --format=fir --lower-to-rtl -verilog -o /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir.v\r\n: 'RUN: at line 4';   /__w/circt/circt/build/bin/firtool /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir --format=fir --lower-to-rtl -verilog -o /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v\r\n: 'RUN: at line 5';   /__w/circt/circt/build/bin/firtool /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.fir --format=fir --lower-to-rtl -verilog -o /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.fir.v\r\n: 'RUN: at line 6';   /__w/circt/circt/integration_test/EmitVerilog/../../utils/equiv-rtl.sh /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir.v /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.v test_mod\r\n: 'RUN: at line 7';   /__w/circt/circt/integration_test/EmitVerilog/../../utils/equiv-rtl.sh /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.v test_unary\r\n: 'RUN: at line 8';   /__w/circt/circt/integration_test/EmitVerilog/../../utils/equiv-rtl.sh /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.fir.v /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_prim.v test_prim\r\n--\r\nExit Code: 1\r\n\r\nCommand Output (stdout):\r\n--\r\nComparing /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.fir.v and /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_mod.v with test_mod Missing Dir .\r\nPASS,INDUCT\r\nComparing /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v and /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.v with test_unary Missing Dir .\r\nTrying SAT /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.fir.v and /__w/circt/circt/build/integration_test/EmitVerilog/Output/verilog_equiv.fir.tmp/test_unary.v with test_unary Missing Dir .\r\nFAIL\r\n\r\n--\r\nCommand Output (stderr):\r\n--\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nERROR: Called with -verify and proof did fail!\r\n\r\n--"}, {"number": 841, "title": "[FIRRTL] counter mismatch", "created_at": "2021-03-29T17:33:42Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 22\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input arst: AsyncReset\r\n    output _tmp16: UInt<10>\r\n    reg state_9: UInt<10>, clock with: (reset => (arst, UInt<1>(0)))\r\n    wire next_9: UInt<10>\r\n    state_9 <= next_9\r\n    next_9 <= add(state_9, UInt<1>(1))\r\n    _tmp16 <= state_9\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:\r\n\r\n```verilog\r\n...\r\nmodule top_mod(\r\n  input        clock, arst,\r\n  output [9:0] _tmp16);\r\n\r\n  reg  [9:0] state_9;\t// a_top_mod.fir:7:5\r\n  wire [9:0] next_9;\t// a_top_mod.fir:8:5\r\n  wire [9:0] _T;\t// a_top_mod.fir:9:13\r\n\r\n  always_ff @(posedge clock or posedge arst) begin\t// a_top_mod.fir:7:5\r\n    if (arst)\t// a_top_mod.fir:7:5\r\n      state_9 <= 10'h0;\t// a_top_mod.fir:7:5\r\n    else\t// a_top_mod.fir:7:5\r\n      state_9 <= _T;\t// a_top_mod.fir:9:13\r\n  end // always_ff @(posedge or posedge)\r\n...\r\n  assign _T = next_9;\t// a_top_mod.fir:9:13\r\n  wire [10:0] _T_0 = {1'h0, state_9} + 11'h1;\t// a_top_mod.fir:7:57, :10:15\r\n  assign next_9 = _T_0[9:0];\t// a_top_mod.fir:10:12\r\n  assign _tmp16 = state_9;\t// a_top_mod.fir:3:3\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input        clock,\r\n  input        arst,\r\n  output [9:0] _tmp16\r\n);\r\n...\r\n  reg [9:0] state_9;\r\n  wire [10:0] _GEN_0 = state_9 + 10'h1;\r\n  assign _tmp16 = state_9;\r\n  always @(posedge clock or posedge arst) begin\r\n    if (arst) begin\r\n      state_9 <= 10'h0;\r\n    end else begin\r\n      state_9 <= _GEN_0[9:0];\r\n    end\r\n  end\r\n...\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nyosys 1\r\nWarning: No SAT model available for cell $procdff$3_gold ($adff).\r\nWarning: No SAT model available for cell $procdff$6_gate ($adff).\r\nERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n\r\nThat is maybe because of `ADFF` not found by YoSyS (investigating)\r\n", "code_snippet_01": "; seed: 22\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input arst: AsyncReset\r\n    output _tmp16: UInt<10>\r\n    reg state_9: UInt<10>, clock with: (reset => (arst, UInt<1>(0)))\r\n    wire next_9: UInt<10>\r\n    state_9 <= next_9\r\n    next_9 <= add(state_9, UInt<1>(1))\r\n    _tmp16 <= state_9", "code_snippet_02": "...\r\nmodule top_mod(\r\n  input        clock, arst,\r\n  output [9:0] _tmp16);\r\n\r\n  reg  [9:0] state_9;\t// a_top_mod.fir:7:5\r\n  wire [9:0] next_9;\t// a_top_mod.fir:8:5\r\n  wire [9:0] _T;\t// a_top_mod.fir:9:13\r\n\r\n  always_ff @(posedge clock or posedge arst) begin\t// a_top_mod.fir:7:5\r\n    if (arst)\t// a_top_mod.fir:7:5\r\n      state_9 <= 10'h0;\t// a_top_mod.fir:7:5\r\n    else\t// a_top_mod.fir:7:5\r\n      state_9 <= _T;\t// a_top_mod.fir:9:13\r\n  end // always_ff @(posedge or posedge)\r\n...\r\n  assign _T = next_9;\t// a_top_mod.fir:9:13\r\n  wire [10:0] _T_0 = {1'h0, state_9} + 11'h1;\t// a_top_mod.fir:7:57, :10:15\r\n  assign next_9 = _T_0[9:0];\t// a_top_mod.fir:10:12\r\n  assign _tmp16 = state_9;\t// a_top_mod.fir:3:3\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input        clock,\r\n  input        arst,\r\n  output [9:0] _tmp16\r\n);\r\n...\r\n  reg [9:0] state_9;\r\n  wire [10:0] _GEN_0 = state_9 + 10'h1;\r\n  assign _tmp16 = state_9;\r\n  always @(posedge clock or posedge arst) begin\r\n    if (arst) begin\r\n      state_9 <= 10'h0;\r\n    end else begin\r\n      state_9 <= _GEN_0[9:0];\r\n    end\r\n  end\r\n...\r\nendmodule", "code_snippet_04": "yosys 1\r\nWarning: No SAT model available for cell $procdff$3_gold ($adff).\r\nWarning: No SAT model available for cell $procdff$6_gate ($adff).\r\nERROR: Found 10 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 839, "title": "multi-port memories can cause writes in different always blocks", "created_at": "2021-03-29T16:56:17Z", "state": "closed", "labels": "bug, FIRRTL", "body": "due to the clocks being assigned to wires and the wires not deliminated, the always blocks aren't merged."}, {"number": 838, "title": "wire generated in always block", "created_at": "2021-03-29T16:55:00Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Probably long name spilling.\r\n\r\n```\r\ncircuit testcase :\r\n  module testcase :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input io_enq_bits_prediction_branch_base_prediction : UInt<1>\r\n    input io_deq_ready : UInt<1>\r\n    output io_deq_bits_prediction_branch_prediction : UInt<1>\r\n    output io_count : UInt<1>\r\n\r\n    mem ram_prediction_branch_base_prediction : @[Decoupled.scala 218:16]\r\n      data-type => UInt<1>\r\n      depth => 1\r\n      read-latency => 0\r\n      write-latency => 1\r\n      reader => io_deq_bits_MPORT\r\n      writer => MPORT\r\n      read-under-write => undefined\r\n```\r\n\r\n", "code_snippet_01": "circuit testcase :\r\n  module testcase :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input io_enq_bits_prediction_branch_base_prediction : UInt<1>\r\n    input io_deq_ready : UInt<1>\r\n    output io_deq_bits_prediction_branch_prediction : UInt<1>\r\n    output io_count : UInt<1>\r\n\r\n    mem ram_prediction_branch_base_prediction : @[Decoupled.scala 218:16]\r\n      data-type => UInt<1>\r\n      depth => 1\r\n      read-latency => 0\r\n      write-latency => 1\r\n      reader => io_deq_bits_MPORT\r\n      writer => MPORT\r\n      read-under-write => undefined"}, {"number": 832, "title": "[FIRRTL] vector (core dump)", "created_at": "2021-03-26T19:13:47Z", "state": "closed", "labels": "bug, enhancement, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n module top_mod :\r\n   input addr: UInt<8>\r\n   input wdata: UInt<8>\r\n   output rdata: UInt<8>\r\n   wire vec0: UInt<8>[4]\r\n   vec0[addr] <= wdata\r\n   rdata <= vec0[addr]\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:\r\n\r\n```mlir\r\nfirtool\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n1.       #0 0x000000000043d1cd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x43d1cd)\r\n #1 0x000000000043afd4 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x43afd4)\r\n #2 0x000000000043b133 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x43b133)\r\n #3 0x00007f765eb03a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #4 0x00000000005644c6 mlir::Type::getDialect() const (../../llvm/circt/build/bin/firtool+0x5644c6)\r\n #5 0x00000000005890a9 circt::firrtl::__mlir_ods_local_type_constraint_FIRRTL12(mlir::Operation*, mlir::Type, llvm::StringRef, unsigned int) /home/drom/work/github/llvm/circt/build/include/circt/Dialect/FIRRTL/FIRRTL.cpp.inc:143:3\r\n #6 0x00000000005a14ec circt::firrtl::SubaccessOp::verify() /home/drom/work/github/llvm/circt/build/include/circt/Dialect/FIRRTL/FIRRTL.cpp.inc:12308:7\r\n #7 0x000000000057599f mlir::Op<circt::firrtl::SubaccessOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::FIRRTLType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1713:3\r\n #8 0x0000000000566d74 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) (../../llvm/circt/build/bin/firtool+0x566d74)\r\n #9 0x00000000005671f8 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) (../../llvm/circt/build/bin/firtool+0x5671f8)\r\n#10 0x00000000005671f8 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) (../../llvm/circt/build/bin/firtool+0x5671f8)\r\n#11 0x0000000000568387 mlir::verify(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x568387)\r\n#12 0x00000000006a7eea mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x6a7eea)\r\n#13 0x00000000006a80c0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x6a80c0)\r\n#14 0x00000000006a74e2 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x6a74e2)\r\n#15 0x00000000006a7d26 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x6a7d26)\r\n#16 0x00000000006a80c0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x6a80c0)\r\n#17 0x00000000006ab144 mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x6ab144)\r\n#18 0x000000000040c10c processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:210:3\r\n#19 0x00000000004084ba processBufferIntoSingleStream /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:235:8\r\n#20 0x00000000004084ba main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:304:15\r\n#21 0x00007f765e571b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#22 0x0000000000409cee _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 26:  7889 Segmentation fault      (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2\r\n```\r\nExpected behavior: not to crash\r\n", "code_snippet_01": "circuit top_mod :\r\n module top_mod :\r\n   input addr: UInt<8>\r\n   input wdata: UInt<8>\r\n   output rdata: UInt<8>\r\n   wire vec0: UInt<8>[4]\r\n   vec0[addr] <= wdata\r\n   rdata <= vec0[addr]", "code_snippet_02": "firtool\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n1.       #0 0x000000000043d1cd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x43d1cd)\r\n #1 0x000000000043afd4 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x43afd4)\r\n #2 0x000000000043b133 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x43b133)\r\n #3 0x00007f765eb03a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #4 0x00000000005644c6 mlir::Type::getDialect() const (../../llvm/circt/build/bin/firtool+0x5644c6)\r\n #5 0x00000000005890a9 circt::firrtl::__mlir_ods_local_type_constraint_FIRRTL12(mlir::Operation*, mlir::Type, llvm::StringRef, unsigned int) /home/drom/work/github/llvm/circt/build/include/circt/Dialect/FIRRTL/FIRRTL.cpp.inc:143:3\r\n #6 0x00000000005a14ec circt::firrtl::SubaccessOp::verify() /home/drom/work/github/llvm/circt/build/include/circt/Dialect/FIRRTL/FIRRTL.cpp.inc:12308:7\r\n #7 0x000000000057599f mlir::Op<circt::firrtl::SubaccessOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::FIRRTLType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1713:3\r\n #8 0x0000000000566d74 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) (../../llvm/circt/build/bin/firtool+0x566d74)\r\n #9 0x00000000005671f8 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) (../../llvm/circt/build/bin/firtool+0x5671f8)\r\n#10 0x00000000005671f8 (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) (../../llvm/circt/build/bin/firtool+0x5671f8)\r\n#11 0x0000000000568387 mlir::verify(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x568387)\r\n#12 0x00000000006a7eea mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x6a7eea)\r\n#13 0x00000000006a80c0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x6a80c0)\r\n#14 0x00000000006a74e2 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) (../../llvm/circt/build/bin/firtool+0x6a74e2)\r\n#15 0x00000000006a7d26 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x6a7d26)\r\n#16 0x00000000006a80c0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x6a80c0)\r\n#17 0x00000000006ab144 mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x6ab144)\r\n#18 0x000000000040c10c processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::StringRef, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:210:3\r\n#19 0x00000000004084ba processBufferIntoSingleStream /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:235:8\r\n#20 0x00000000004084ba main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:304:15\r\n#21 0x00007f765e571b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#22 0x0000000000409cee _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 26:  7889 Segmentation fault      (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2"}, {"number": 821, "title": "[FIRRTL] (neg) mismatch", "created_at": "2021-03-24T21:41:54Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 9902\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_f: UInt<2>\r\n    output tmp32: SInt<3>\r\n    tmp32 <= neg(inp_f)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:\r\n\r\n```verilog\r\n// Standard header to adapt well known macros to our needs.\r\n\r\nmodule top_mod(\r\n  input  [1:0] inp_f,\r\n  output [2:0] tmp32);\r\n\r\n  assign tmp32 = 3'h0 - {inp_f[1], inp_f};\t// a_top_mod.fir:3:3, :6:14\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [1:0] inp_f,\r\n  output [2:0] tmp32\r\n);\r\n  assign tmp32 = 2'h0 - inp_f;\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nyosys 0\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 1\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 2\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "; seed: 9902\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_f: UInt<2>\r\n    output tmp32: SInt<3>\r\n    tmp32 <= neg(inp_f)", "code_snippet_02": "// Standard header to adapt well known macros to our needs.\r\n\r\nmodule top_mod(\r\n  input  [1:0] inp_f,\r\n  output [2:0] tmp32);\r\n\r\n  assign tmp32 = 3'h0 - {inp_f[1], inp_f};\t// a_top_mod.fir:3:3, :6:14\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [1:0] inp_f,\r\n  output [2:0] tmp32\r\n);\r\n  assign tmp32 = 2'h0 - inp_f;\r\nendmodule", "code_snippet_04": "yosys 0\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 1\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 2\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 819, "title": "[MLIR] CSE pass doesn't work on graph regions", "created_at": "2021-03-24T18:23:37Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program (Sorry it is quite long :( )\r\n\r\n```python\r\n; seed: 1184\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input arst: AsyncReset\r\n    input inp_b: SInt<14>\r\n    input inp_d: SInt<18>\r\n    input inp_e: SInt<19>\r\n    input inp_f: UInt<13>\r\n    input inp_h: SInt<4>\r\n    input inp_i: UInt<20>\r\n    input inp_j: UInt<2>\r\n    output tmp14: SInt<17>\r\n    output _tmp15: UInt<16>\r\n    output _tmp22: UInt<25>\r\n    output tmp23: SInt<62>\r\n    output _tmp32: UInt<24>\r\n    output tmp36: UInt<1>\r\n    wire tmp11: SInt<9>\r\n    reg tmp12: SInt<9>, clock\r\n    wire tmp13: SInt<9>\r\n    reg tmp16: UInt<52>, clock\r\n    wire tmp18: SInt<53>\r\n    reg tmp19: UInt<7>, clock\r\n    reg tmp21: SInt<10>, clock with: (reset => (arst, SInt<10>(0)))\r\n    reg tmp24: SInt<48>, clock\r\n    wire tmp26: SInt<3>\r\n    reg tmp27: SInt<3>, clock with: (reset => (reset, SInt<3>(0)))\r\n    wire tmp28: UInt<3>\r\n    reg tmp29: SInt<136>, clock with: (reset => (reset, SInt<136>(0)))\r\n    wire _tmp33: UInt<35>\r\n    wire _tmp41: UInt<61>\r\n    reg tmp44: SInt<8>, clock with: (reset => (reset, SInt<8>(0)))\r\n    mem tmp10:\r\n      data-type => SInt<9>\r\n      depth => 5\r\n      read-latency => 3\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      reader => r1\r\n      reader => r2\r\n      writer => w0\r\n      writer => w1\r\n    tmp10.r0.clk <= clock\r\n    tmp10.r0.en <= head(UInt<20>(\"hed052\"), 1)\r\n    tmp10.r0.addr <= inp_f\r\n    tmp10.r1.clk <= clock\r\n    tmp10.r1.en <= head(asUInt(inp_h), 1)\r\n    tmp10.r1.addr <= UInt<4>(\"h3\")\r\n    tmp10.r2.clk <= clock\r\n    tmp10.r2.en <= head(asUInt(inp_b), 1)\r\n    tmp10.r2.addr <= UInt<9>(407)\r\n    tmp10.w0.clk <= clock\r\n    tmp10.w0.en <= head(asUInt(SInt<28>(\"o-677523445\")), 1)\r\n    tmp10.w0.addr <= inp_i\r\n    tmp10.w0.data <= inp_d\r\n    tmp10.w0.mask <= asUInt(inp_h)\r\n    tmp10.w1.clk <= clock\r\n    tmp10.w1.en <= head(asUInt(SInt<24>(-2844022)), 1)\r\n    tmp10.w1.addr <= inp_j\r\n    tmp10.w1.data <= asSInt(inp_f)\r\n    tmp10.w1.mask <= asUInt(inp_e)\r\n    tmp11 <= tmp10.r0.data\r\n    tmp12 <= tmp10.r1.data\r\n    tmp13 <= tmp10.r2.data\r\n    tmp14 <= cvt(UInt<16>(\"b1010110101101010\"))\r\n    _tmp15 <= xor(UInt<16>(25416), asUInt(tmp11))\r\n    tmp16 <= cat(UInt<29>(\"b1101001100011010100110110\"), UInt<23>(\"o23563727\"))\r\n    tmp18 <= neg(tmp16)\r\n    tmp19 <= bits(UInt<16>(\"h80db\"), 14, 8)\r\n    assume(clock, xorr(tmp19), xorr(tmp19), \"assume20\")\r\n    tmp21 <= cvt(UInt<9>(472))\r\n    _tmp22 <= div(UInt<25>(\"o62507467\"), UInt<30>(\"h277f039a\"))\r\n    tmp23 <= mul(tmp18, tmp13)\r\n    tmp24 <= shl(SInt<27>(\"o24631356\"), 21)\r\n    mem tmp25:\r\n      data-type => SInt<3>\r\n      depth => 6\r\n      read-latency => 2\r\n      write-latency => 2\r\n      read-under-write => undefined\r\n      reader => r0\r\n      reader => r1\r\n      writer => w0\r\n      writer => w1\r\n    tmp25.r0.clk <= clock\r\n    tmp25.r0.en <= asUInt(SInt<1>(\"o0\"))\r\n    tmp25.r0.addr <= UInt<26>(49066379)\r\n    tmp25.r1.clk <= clock\r\n    tmp25.r1.en <= head(UInt<25>(19922223), 1)\r\n    tmp25.r1.addr <= UInt<28>(140227115)\r\n    tmp25.w0.clk <= clock\r\n    tmp25.w0.en <= head(asUInt(SInt<18>(\"b11010110111000011\")), 1)\r\n    tmp25.w0.addr <= UInt<12>(\"b111111000011\")\r\n    tmp25.w0.data <= asSInt(inp_j)\r\n    tmp25.w0.mask <= tmp19\r\n    tmp25.w1.clk <= clock\r\n    tmp25.w1.en <= head(asUInt(inp_d), 1)\r\n    tmp25.w1.addr <= asUInt(SInt<16>(-8793))\r\n    tmp25.w1.data <= asSInt(tmp19)\r\n    tmp25.w1.mask <= asUInt(tmp24)\r\n    tmp26 <= tmp25.r0.data\r\n    tmp27 <= tmp25.r1.data\r\n    tmp28 <= asUInt(UInt<3>(\"o5\"))\r\n    tmp29 <= dshl(SInt<9>(\"b-101000\"), tail(UInt<13>(3084), 6))\r\n    skip\r\n    _tmp32 <= xor(inp_f, UInt<24>(848336))\r\n    _tmp33 <= mul(UInt<17>(\"o261646\"), asUInt(inp_d))\r\n    mem tmp34:\r\n      data-type => SInt<8>\r\n      depth => 6\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n      writer => w1\r\n    tmp34.r0.clk <= clock\r\n    tmp34.r0.en <= head(asUInt(tmp13), 1)\r\n    tmp34.r0.addr <= UInt<21>(1533690)\r\n    tmp34.w0.clk <= clock\r\n    tmp34.w0.en <= head(tmp28, 1)\r\n    tmp34.w0.addr <= UInt<10>(631)\r\n    tmp34.w0.data <= SInt<6>(\"o-25\")\r\n    tmp34.w0.mask <= asUInt(inp_e)\r\n    tmp34.w1.clk <= clock\r\n    tmp34.w1.en <= asUInt(SInt<1>(\"b-1\"))\r\n    tmp34.w1.addr <= inp_f\r\n    tmp34.w1.data <= tmp26\r\n    tmp34.w1.mask <= UInt<5>(\"h18\")\r\n    tmp36 <= neq(asSInt(inp_j), SInt<16>(\"h8a0\"))\r\n    _tmp41 <= mul(asUInt(tmp24), inp_f)\r\n    mem tmp42:\r\n      data-type => SInt<8>\r\n      depth => 15\r\n      read-latency => 1\r\n      write-latency => 2\r\n      read-under-write => undefined\r\n      reader => r0\r\n      reader => r1\r\n      writer => w0\r\n    tmp42.r0.clk <= clock\r\n    tmp42.r0.en <= head(UInt<10>(966), 1)\r\n    tmp42.r0.addr <= asUInt(SInt<20>(\"h-3d191\"))\r\n    tmp42.r1.clk <= clock\r\n    tmp42.r1.en <= head(asUInt(SInt<7>(\"h2e\")), 1)\r\n    tmp42.r1.addr <= UInt<12>(\"he84\")\r\n    tmp42.w0.clk <= clock\r\n    tmp42.w0.en <= head(asUInt(SInt<5>(\"o15\")), 1)\r\n    tmp42.w0.addr <= asUInt(inp_e)\r\n    tmp42.w0.data <= asSInt(_tmp33)\r\n    tmp42.w0.mask <= UInt<12>(1246)\r\n    tmp44 <= tmp42.r1.data\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:\r\n\r\n```mlir\r\nfirtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:408: void llvm::DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT>::moveFromOldBuckets(BucketT*, BucketT*) [with DerivedT = llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, {anonymous}::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >; KeyT = mlir::Operation*; ValueT = llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*; KeyInfoT = {anonymous}::SimpleOperationInfo; BucketT = llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>]: Assertion `!FoundVal && \"Key already in new map?\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n #0 0x00000000004bc7a7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004bc85e PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004ba85e llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bc1fa SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f3e9eb69a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #5 0x00007f3e9e5ed4a5 raise (/lib64/libc.so.6+0x3d4a5)\r\n #6 0x00007f3e9e5d6864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f3e9e5d6749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f3e9e5e59b6 (/lib64/libc.so.6+0x359b6)\r\n #9 0x00000000006f9dca llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::moveFromOldBuckets(llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:409:43\r\n#10 0x00000000006f9bd3 llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::grow(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:816:53\r\n#11 0x00000000006f9888 llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::grow(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:538:3\r\n#12 0x00000000006f9265 llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>* llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::InsertIntoBucketImpl<mlir::Operation*>(mlir::Operation* const&, mlir::Operation* const&, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:582:22\r\n#13 0x00000000006f8813 llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>* llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::InsertIntoBucket<mlir::Operation* const&>(llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*, mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:547:37\r\n#14 0x00000000006f7b0e llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::FindAndConstruct(mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:326:44\r\n#15 0x00000000006f6d6b llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::operator[](mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:330:34\r\n#16 0x00000000006f7002 llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >::insertIntoScope(llvm::ScopedHashTableScope<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >*, mlir::Operation* const&, mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:218:54\r\n#17 0x00000000006f6670 llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >::insert(mlir::Operation* const&, mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:196:3\r\n#18 0x00000000006f5cf3 (anonymous namespace)::CSE::simplifyOperation(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:135:18\r\n#19 0x00000000006f5dd6 (anonymous namespace)::CSE::simplifyBlock(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Block*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:142:18\r\n#20 0x00000000006f6009 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43\r\n#21 0x00000000006f5e77 (anonymous namespace)::CSE::simplifyBlock(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Block*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:150:7\r\n#22 0x00000000006f6009 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43\r\n#23 0x00000000006f62b1 (anonymous namespace)::CSE::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:219:3\r\n#24 0x00000000008cd9b5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36\r\n#25 0x00000000008cdbe1 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15\r\n#26 0x00000000008cfd21 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74\r\n#27 0x000000000040dd68 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dd68)\r\n#28 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)\r\n#29 0x00007f3e9e5d7b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#30 0x000000000040b58e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: \u0441\u0442\u0440\u043e\u043a\u0430 26: 13458 Aborted                 (\u0441\u0442\u0435\u043a \u043f\u0430\u043c\u044f\u0442\u0438 \u0441\u0431\u0440\u043e\u0448\u0435\u043d \u043d\u0430 \u0434\u0438\u0441\u043a) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2\r\n```\r\n\r\nfirrtl-1.5.0-SNAPSHOT produces Verilog\r\n", "code_snippet_01": "; seed: 1184\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input arst: AsyncReset\r\n    input inp_b: SInt<14>\r\n    input inp_d: SInt<18>\r\n    input inp_e: SInt<19>\r\n    input inp_f: UInt<13>\r\n    input inp_h: SInt<4>\r\n    input inp_i: UInt<20>\r\n    input inp_j: UInt<2>\r\n    output tmp14: SInt<17>\r\n    output _tmp15: UInt<16>\r\n    output _tmp22: UInt<25>\r\n    output tmp23: SInt<62>\r\n    output _tmp32: UInt<24>\r\n    output tmp36: UInt<1>\r\n    wire tmp11: SInt<9>\r\n    reg tmp12: SInt<9>, clock\r\n    wire tmp13: SInt<9>\r\n    reg tmp16: UInt<52>, clock\r\n    wire tmp18: SInt<53>\r\n    reg tmp19: UInt<7>, clock\r\n    reg tmp21: SInt<10>, clock with: (reset => (arst, SInt<10>(0)))\r\n    reg tmp24: SInt<48>, clock\r\n    wire tmp26: SInt<3>\r\n    reg tmp27: SInt<3>, clock with: (reset => (reset, SInt<3>(0)))\r\n    wire tmp28: UInt<3>\r\n    reg tmp29: SInt<136>, clock with: (reset => (reset, SInt<136>(0)))\r\n    wire _tmp33: UInt<35>\r\n    wire _tmp41: UInt<61>\r\n    reg tmp44: SInt<8>, clock with: (reset => (reset, SInt<8>(0)))\r\n    mem tmp10:\r\n      data-type => SInt<9>\r\n      depth => 5\r\n      read-latency => 3\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      reader => r1\r\n      reader => r2\r\n      writer => w0\r\n      writer => w1\r\n    tmp10.r0.clk <= clock\r\n    tmp10.r0.en <= head(UInt<20>(\"hed052\"), 1)\r\n    tmp10.r0.addr <= inp_f\r\n    tmp10.r1.clk <= clock\r\n    tmp10.r1.en <= head(asUInt(inp_h), 1)\r\n    tmp10.r1.addr <= UInt<4>(\"h3\")\r\n    tmp10.r2.clk <= clock\r\n    tmp10.r2.en <= head(asUInt(inp_b), 1)\r\n    tmp10.r2.addr <= UInt<9>(407)\r\n    tmp10.w0.clk <= clock\r\n    tmp10.w0.en <= head(asUInt(SInt<28>(\"o-677523445\")), 1)\r\n    tmp10.w0.addr <= inp_i\r\n    tmp10.w0.data <= inp_d\r\n    tmp10.w0.mask <= asUInt(inp_h)\r\n    tmp10.w1.clk <= clock\r\n    tmp10.w1.en <= head(asUInt(SInt<24>(-2844022)), 1)\r\n    tmp10.w1.addr <= inp_j\r\n    tmp10.w1.data <= asSInt(inp_f)\r\n    tmp10.w1.mask <= asUInt(inp_e)\r\n    tmp11 <= tmp10.r0.data\r\n    tmp12 <= tmp10.r1.data\r\n    tmp13 <= tmp10.r2.data\r\n    tmp14 <= cvt(UInt<16>(\"b1010110101101010\"))\r\n    _tmp15 <= xor(UInt<16>(25416), asUInt(tmp11))\r\n    tmp16 <= cat(UInt<29>(\"b1101001100011010100110110\"), UInt<23>(\"o23563727\"))\r\n    tmp18 <= neg(tmp16)\r\n    tmp19 <= bits(UInt<16>(\"h80db\"), 14, 8)\r\n    assume(clock, xorr(tmp19), xorr(tmp19), \"assume20\")\r\n    tmp21 <= cvt(UInt<9>(472))\r\n    _tmp22 <= div(UInt<25>(\"o62507467\"), UInt<30>(\"h277f039a\"))\r\n    tmp23 <= mul(tmp18, tmp13)\r\n    tmp24 <= shl(SInt<27>(\"o24631356\"), 21)\r\n    mem tmp25:\r\n      data-type => SInt<3>\r\n      depth => 6\r\n      read-latency => 2\r\n      write-latency => 2\r\n      read-under-write => undefined\r\n      reader => r0\r\n      reader => r1\r\n      writer => w0\r\n      writer => w1\r\n    tmp25.r0.clk <= clock\r\n    tmp25.r0.en <= asUInt(SInt<1>(\"o0\"))\r\n    tmp25.r0.addr <= UInt<26>(49066379)\r\n    tmp25.r1.clk <= clock\r\n    tmp25.r1.en <= head(UInt<25>(19922223), 1)\r\n    tmp25.r1.addr <= UInt<28>(140227115)\r\n    tmp25.w0.clk <= clock\r\n    tmp25.w0.en <= head(asUInt(SInt<18>(\"b11010110111000011\")), 1)\r\n    tmp25.w0.addr <= UInt<12>(\"b111111000011\")\r\n    tmp25.w0.data <= asSInt(inp_j)\r\n    tmp25.w0.mask <= tmp19\r\n    tmp25.w1.clk <= clock\r\n    tmp25.w1.en <= head(asUInt(inp_d), 1)\r\n    tmp25.w1.addr <= asUInt(SInt<16>(-8793))\r\n    tmp25.w1.data <= asSInt(tmp19)\r\n    tmp25.w1.mask <= asUInt(tmp24)\r\n    tmp26 <= tmp25.r0.data\r\n    tmp27 <= tmp25.r1.data\r\n    tmp28 <= asUInt(UInt<3>(\"o5\"))\r\n    tmp29 <= dshl(SInt<9>(\"b-101000\"), tail(UInt<13>(3084), 6))\r\n    skip\r\n    _tmp32 <= xor(inp_f, UInt<24>(848336))\r\n    _tmp33 <= mul(UInt<17>(\"o261646\"), asUInt(inp_d))\r\n    mem tmp34:\r\n      data-type => SInt<8>\r\n      depth => 6\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n      writer => w1\r\n    tmp34.r0.clk <= clock\r\n    tmp34.r0.en <= head(asUInt(tmp13), 1)\r\n    tmp34.r0.addr <= UInt<21>(1533690)\r\n    tmp34.w0.clk <= clock\r\n    tmp34.w0.en <= head(tmp28, 1)\r\n    tmp34.w0.addr <= UInt<10>(631)\r\n    tmp34.w0.data <= SInt<6>(\"o-25\")\r\n    tmp34.w0.mask <= asUInt(inp_e)\r\n    tmp34.w1.clk <= clock\r\n    tmp34.w1.en <= asUInt(SInt<1>(\"b-1\"))\r\n    tmp34.w1.addr <= inp_f\r\n    tmp34.w1.data <= tmp26\r\n    tmp34.w1.mask <= UInt<5>(\"h18\")\r\n    tmp36 <= neq(asSInt(inp_j), SInt<16>(\"h8a0\"))\r\n    _tmp41 <= mul(asUInt(tmp24), inp_f)\r\n    mem tmp42:\r\n      data-type => SInt<8>\r\n      depth => 15\r\n      read-latency => 1\r\n      write-latency => 2\r\n      read-under-write => undefined\r\n      reader => r0\r\n      reader => r1\r\n      writer => w0\r\n    tmp42.r0.clk <= clock\r\n    tmp42.r0.en <= head(UInt<10>(966), 1)\r\n    tmp42.r0.addr <= asUInt(SInt<20>(\"h-3d191\"))\r\n    tmp42.r1.clk <= clock\r\n    tmp42.r1.en <= head(asUInt(SInt<7>(\"h2e\")), 1)\r\n    tmp42.r1.addr <= UInt<12>(\"he84\")\r\n    tmp42.w0.clk <= clock\r\n    tmp42.w0.en <= head(asUInt(SInt<5>(\"o15\")), 1)\r\n    tmp42.w0.addr <= asUInt(inp_e)\r\n    tmp42.w0.data <= asSInt(_tmp33)\r\n    tmp42.w0.mask <= UInt<12>(1246)\r\n    tmp44 <= tmp42.r1.data", "code_snippet_02": "firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:408: void llvm::DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT>::moveFromOldBuckets(BucketT*, BucketT*) [with DerivedT = llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, {anonymous}::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >; KeyT = mlir::Operation*; ValueT = llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*; KeyInfoT = {anonymous}::SimpleOperationInfo; BucketT = llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>]: Assertion `!FoundVal && \"Key already in new map?\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n #0 0x00000000004bc7a7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004bc85e PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004ba85e llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bc1fa SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f3e9eb69a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #5 0x00007f3e9e5ed4a5 raise (/lib64/libc.so.6+0x3d4a5)\r\n #6 0x00007f3e9e5d6864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f3e9e5d6749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f3e9e5e59b6 (/lib64/libc.so.6+0x359b6)\r\n #9 0x00000000006f9dca llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::moveFromOldBuckets(llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:409:43\r\n#10 0x00000000006f9bd3 llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::grow(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:816:53\r\n#11 0x00000000006f9888 llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::grow(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:538:3\r\n#12 0x00000000006f9265 llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>* llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::InsertIntoBucketImpl<mlir::Operation*>(mlir::Operation* const&, mlir::Operation* const&, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:582:22\r\n#13 0x00000000006f8813 llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>* llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::InsertIntoBucket<mlir::Operation* const&>(llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*>*, mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:547:37\r\n#14 0x00000000006f7b0e llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::FindAndConstruct(mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:326:44\r\n#15 0x00000000006f6d6b llvm::DenseMapBase<llvm::DenseMap<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >, mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*, (anonymous namespace)::SimpleOperationInfo, llvm::detail::DenseMapPair<mlir::Operation*, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>*> >::operator[](mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/DenseMap.h:330:34\r\n#16 0x00000000006f7002 llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >::insertIntoScope(llvm::ScopedHashTableScope<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >*, mlir::Operation* const&, mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:218:54\r\n#17 0x00000000006f6670 llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >::insert(mlir::Operation* const&, mlir::Operation* const&) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:196:3\r\n#18 0x00000000006f5cf3 (anonymous namespace)::CSE::simplifyOperation(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:135:18\r\n#19 0x00000000006f5dd6 (anonymous namespace)::CSE::simplifyBlock(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Block*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:142:18\r\n#20 0x00000000006f6009 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43\r\n#21 0x00000000006f5e77 (anonymous namespace)::CSE::simplifyBlock(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Block*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:150:7\r\n#22 0x00000000006f6009 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43\r\n#23 0x00000000006f62b1 (anonymous namespace)::CSE::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:219:3\r\n#24 0x00000000008cd9b5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36\r\n#25 0x00000000008cdbe1 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15\r\n#26 0x00000000008cfd21 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74\r\n#27 0x000000000040dd68 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dd68)\r\n#28 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)\r\n#29 0x00007f3e9e5d7b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#30 0x000000000040b58e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: \u0441\u0442\u0440\u043e\u043a\u0430 26: 13458 Aborted                 (\u0441\u0442\u0435\u043a \u043f\u0430\u043c\u044f\u0442\u0438 \u0441\u0431\u0440\u043e\u0448\u0435\u043d \u043d\u0430 \u0434\u0438\u0441\u043a) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2"}, {"number": 813, "title": "[MLIR] CSE pass: ThisEntry && \"Scope imbalance!\"' (core dump)", "created_at": "2021-03-24T03:41:35Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 27\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_b: SInt<1>\r\n    input inp_d: UInt<11>\r\n    input inp_g: UInt<18>\r\n    input inp_h: SInt<3>\r\n    input inp_i: SInt<1>\r\n    reg tmp11: UInt<1>, clock\r\n    reg tmp12: UInt<3>, clock\r\n    wire tmp15: UInt<18>\r\n    reg tmp19: SInt<5>, clock with: (reset => (reset, SInt<5>(0)))\r\n    wire _tmp22: SInt<20>\r\n    wire tmp32: SInt<32>\r\n    tmp11 <= neq(inp_i, inp_h)\r\n    tmp12 <= not(inp_h)\r\n    tmp15 <= div(inp_g, UInt<6>(0))\r\n    _tmp22 <= mul(inp_b, asSInt(UInt<19>(0)))\r\n    tmp32 <= dshl(SInt<1>(\"b-1\"), head(tmp15, 5))\r\n    mem tmp33:\r\n      data-type => UInt<5>\r\n      depth => 12\r\n      read-latency => 2\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      reader => r1\r\n      reader => r2\r\n      writer => w0\r\n      writer => w1\r\n    tmp33.r0.clk <= clock\r\n    tmp33.r0.en <= UInt<1>(1)\r\n    tmp33.r0.addr <= UInt<7>(0)\r\n    tmp33.r1.clk <= clock\r\n    tmp33.r1.en <= UInt<1>(1)\r\n    tmp33.r1.addr <= asUInt(_tmp22)\r\n    tmp33.r2.clk <= clock\r\n    tmp33.r2.en <= UInt<1>(1)\r\n    tmp33.r2.addr <= inp_d\r\n    tmp33.w0.clk <= clock\r\n    tmp33.w0.en <= UInt<1>(1)\r\n    tmp33.w0.addr <= UInt<19>(357565)\r\n    tmp33.w0.data <= UInt<9>(118)\r\n    tmp33.w0.mask <= tmp12\r\n    tmp33.w1.clk <= clock\r\n    tmp33.w1.en <= UInt<1>(1)\r\n    tmp33.w1.addr <= UInt<1>(1)\r\n    tmp33.w1.data <= asUInt(tmp32)\r\n    tmp33.w1.mask <= tmp12\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:\r\n\r\n```mlir\r\nfirtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:244: llvm::ScopedHashTableScope<K, V, KInfo, AllocatorTy>::~ScopedHashTableScope() [with K = mlir::Operation*; V = mlir::Operation*; KInfo = {anonymous}::SimpleOperationInfo; AllocatorTy = llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*> >]: Assertion `HT.TopLevelMap[ThisEntry->getKey()] == ThisEntry && \"Scope imbalance!\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n #0 0x00000000004bc7a7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004bc85e PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004ba85e llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bc1fa SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007efe9a1f2a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #5 0x00007efe99c764a5 raise (/lib64/libc.so.6+0x3d4a5)\r\n #6 0x00007efe99c5f864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007efe99c5f749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007efe99c6e9b6 (/lib64/libc.so.6+0x359b6)\r\n #9 0x00000000006f65ce llvm::ScopedHashTableScope<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >::~ScopedHashTableScope() /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:244:7\r\n#10 0x00000000006f60e8 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43\r\n#11 0x00000000006f5f47 (anonymous namespace)::CSE::simplifyBlock(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Block*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:150:7\r\n#12 0x00000000006f60d9 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43\r\n#13 0x00000000006f6381 (anonymous namespace)::CSE::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:219:3\r\n#14 0x00000000008cda85 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36\r\n#15 0x00000000008cdcb1 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15\r\n#16 0x00000000008cfdf1 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74\r\n#17 0x000000000040dd68 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dd68)\r\n#18 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)\r\n#19 0x00007efe99c60b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#20 0x000000000040b58e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: \u0441\u0442\u0440\u043e\u043a\u0430 26: 16934 Aborted                 (\u0441\u0442\u0435\u043a \u043f\u0430\u043c\u044f\u0442\u0438 \u0441\u0431\u0440\u043e\u0448\u0435\u043d \u043d\u0430 \u0434\u0438\u0441\u043a) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2\r\n```\r\n\r\nfirrtl-1.5.0-SNAPSHOT produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input         clock,\r\n  input         reset,\r\n  input         inp_b,\r\n  input  [10:0] inp_d,\r\n  input  [17:0] inp_g,\r\n  input  [2:0]  inp_h,\r\n  input         inp_i\r\n);\r\nendmodule\r\n```", "code_snippet_01": "; seed: 27\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_b: SInt<1>\r\n    input inp_d: UInt<11>\r\n    input inp_g: UInt<18>\r\n    input inp_h: SInt<3>\r\n    input inp_i: SInt<1>\r\n    reg tmp11: UInt<1>, clock\r\n    reg tmp12: UInt<3>, clock\r\n    wire tmp15: UInt<18>\r\n    reg tmp19: SInt<5>, clock with: (reset => (reset, SInt<5>(0)))\r\n    wire _tmp22: SInt<20>\r\n    wire tmp32: SInt<32>\r\n    tmp11 <= neq(inp_i, inp_h)\r\n    tmp12 <= not(inp_h)\r\n    tmp15 <= div(inp_g, UInt<6>(0))\r\n    _tmp22 <= mul(inp_b, asSInt(UInt<19>(0)))\r\n    tmp32 <= dshl(SInt<1>(\"b-1\"), head(tmp15, 5))\r\n    mem tmp33:\r\n      data-type => UInt<5>\r\n      depth => 12\r\n      read-latency => 2\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      reader => r1\r\n      reader => r2\r\n      writer => w0\r\n      writer => w1\r\n    tmp33.r0.clk <= clock\r\n    tmp33.r0.en <= UInt<1>(1)\r\n    tmp33.r0.addr <= UInt<7>(0)\r\n    tmp33.r1.clk <= clock\r\n    tmp33.r1.en <= UInt<1>(1)\r\n    tmp33.r1.addr <= asUInt(_tmp22)\r\n    tmp33.r2.clk <= clock\r\n    tmp33.r2.en <= UInt<1>(1)\r\n    tmp33.r2.addr <= inp_d\r\n    tmp33.w0.clk <= clock\r\n    tmp33.w0.en <= UInt<1>(1)\r\n    tmp33.w0.addr <= UInt<19>(357565)\r\n    tmp33.w0.data <= UInt<9>(118)\r\n    tmp33.w0.mask <= tmp12\r\n    tmp33.w1.clk <= clock\r\n    tmp33.w1.en <= UInt<1>(1)\r\n    tmp33.w1.addr <= UInt<1>(1)\r\n    tmp33.w1.data <= asUInt(tmp32)\r\n    tmp33.w1.mask <= tmp12", "code_snippet_02": "firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:244: llvm::ScopedHashTableScope<K, V, KInfo, AllocatorTy>::~ScopedHashTableScope() [with K = mlir::Operation*; V = mlir::Operation*; KInfo = {anonymous}::SimpleOperationInfo; AllocatorTy = llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*> >]: Assertion `HT.TopLevelMap[ThisEntry->getKey()] == ThisEntry && \"Scope imbalance!\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n #0 0x00000000004bc7a7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004bc85e PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004ba85e llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bc1fa SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007efe9a1f2a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #5 0x00007efe99c764a5 raise (/lib64/libc.so.6+0x3d4a5)\r\n #6 0x00007efe99c5f864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007efe99c5f749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007efe99c6e9b6 (/lib64/libc.so.6+0x359b6)\r\n #9 0x00000000006f65ce llvm::ScopedHashTableScope<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >::~ScopedHashTableScope() /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/ScopedHashTable.h:244:7\r\n#10 0x00000000006f60e8 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43\r\n#11 0x00000000006f5f47 (anonymous namespace)::CSE::simplifyBlock(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Block*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:150:7\r\n#12 0x00000000006f60d9 (anonymous namespace)::CSE::simplifyRegion(llvm::ScopedHashTable<mlir::Operation*, mlir::Operation*, (anonymous namespace)::SimpleOperationInfo, llvm::RecyclingAllocator<llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator, 4096ul, 4096ul, 128ul>, llvm::ScopedHashTableVal<mlir::Operation*, mlir::Operation*>, 32ul, 8ul> >&, mlir::DominanceInfo&, mlir::Region&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:169:43\r\n#13 0x00000000006f6381 (anonymous namespace)::CSE::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/CSE.cpp:219:3\r\n#14 0x00000000008cda85 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36\r\n#15 0x00000000008cdcb1 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15\r\n#16 0x00000000008cfdf1 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74\r\n#17 0x000000000040dd68 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dd68)\r\n#18 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)\r\n#19 0x00007efe99c60b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#20 0x000000000040b58e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: \u0441\u0442\u0440\u043e\u043a\u0430 26: 16934 Aborted                 (\u0441\u0442\u0435\u043a \u043f\u0430\u043c\u044f\u0442\u0438 \u0441\u0431\u0440\u043e\u0448\u0435\u043d \u043d\u0430 \u0434\u0438\u0441\u043a) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2", "code_snippet_03": "module top_mod(\r\n  input         clock,\r\n  input         reset,\r\n  input         inp_b,\r\n  input  [10:0] inp_d,\r\n  input  [17:0] inp_g,\r\n  input  [2:0]  inp_h,\r\n  input         inp_i\r\n);\r\nendmodule"}, {"number": 812, "title": "[FIRRTL] unexpected stdout", "created_at": "2021-03-24T01:14:59Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input r0en: UInt<1>\r\n    mem tmp41:\r\n      data-type => UInt<8>\r\n      depth => 10\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp41.r0.clk <= clock\r\n    tmp41.r0.en <= r0en\r\n    tmp41.r0.addr <= asUInt(SInt<25>(0))\r\n    tmp41.w0.clk <= clock\r\n    tmp41.w0.en <= r0en\r\n    tmp41.w0.addr <= asUInt(SInt<25>(0))\r\n    tmp41.w0.mask <= asUInt(SInt<25>(0))\r\n    tmp41.w0.data <= asUInt(SInt<25>(0))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types --verilog` produces unexpected `stdout` output:\r\n\r\n```\r\n%tmp41_r0_addr = sv.wire  : !rtl.inout<i4>\r\n%tmp41_r0_addr = sv.wire  : !rtl.inout<i4>\r\n%tmp41_r0_en = sv.wire  : !rtl.inout<i1>\r\n%tmp41_r0_en = sv.wire  : !rtl.inout<i1>\r\n%tmp41_r0_clk = sv.wire  : !rtl.inout<i1>\r\n%tmp41_r0_clk = sv.wire  : !rtl.inout<i1>\r\n%tmp41_r0_data = sv.wire  : !rtl.inout<i8>\r\n%tmp41_r0_data = sv.wire  : !rtl.inout<i8>\r\n%tmp41_w0_addr = sv.wire  : !rtl.inout<i4>\r\n%tmp41_w0_addr = sv.wire  : !rtl.inout<i4>\r\n%tmp41_w0_en = sv.wire  : !rtl.inout<i1>\r\n%tmp41_w0_en = sv.wire  : !rtl.inout<i1>\r\n%tmp41_w0_clk = sv.wire  : !rtl.inout<i1>\r\n%tmp41_w0_clk = sv.wire  : !rtl.inout<i1>\r\n%tmp41_w0_data = sv.wire  : !rtl.inout<i8>\r\n%tmp41_w0_data = sv.wire  : !rtl.inout<i8>\r\n%tmp41_w0_mask = sv.wire  : !rtl.inout<i1>\r\n%tmp41_w0_mask = sv.wire  : !rtl.inout<i1>\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input r0en: UInt<1>\r\n    mem tmp41:\r\n      data-type => UInt<8>\r\n      depth => 10\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp41.r0.clk <= clock\r\n    tmp41.r0.en <= r0en\r\n    tmp41.r0.addr <= asUInt(SInt<25>(0))\r\n    tmp41.w0.clk <= clock\r\n    tmp41.w0.en <= r0en\r\n    tmp41.w0.addr <= asUInt(SInt<25>(0))\r\n    tmp41.w0.mask <= asUInt(SInt<25>(0))\r\n    tmp41.w0.data <= asUInt(SInt<25>(0))", "code_snippet_02": "%tmp41_r0_addr = sv.wire  : !rtl.inout<i4>\r\n%tmp41_r0_addr = sv.wire  : !rtl.inout<i4>\r\n%tmp41_r0_en = sv.wire  : !rtl.inout<i1>\r\n%tmp41_r0_en = sv.wire  : !rtl.inout<i1>\r\n%tmp41_r0_clk = sv.wire  : !rtl.inout<i1>\r\n%tmp41_r0_clk = sv.wire  : !rtl.inout<i1>\r\n%tmp41_r0_data = sv.wire  : !rtl.inout<i8>\r\n%tmp41_r0_data = sv.wire  : !rtl.inout<i8>\r\n%tmp41_w0_addr = sv.wire  : !rtl.inout<i4>\r\n%tmp41_w0_addr = sv.wire  : !rtl.inout<i4>\r\n%tmp41_w0_en = sv.wire  : !rtl.inout<i1>\r\n%tmp41_w0_en = sv.wire  : !rtl.inout<i1>\r\n%tmp41_w0_clk = sv.wire  : !rtl.inout<i1>\r\n%tmp41_w0_clk = sv.wire  : !rtl.inout<i1>\r\n%tmp41_w0_data = sv.wire  : !rtl.inout<i8>\r\n%tmp41_w0_data = sv.wire  : !rtl.inout<i8>\r\n%tmp41_w0_mask = sv.wire  : !rtl.inout<i1>\r\n%tmp41_w0_mask = sv.wire  : !rtl.inout<i1>"}, {"number": 806, "title": "[LLHD] llhd-sim unable to simulate generated llhd dialect ", "created_at": "2021-03-22T22:30:35Z", "state": "open", "labels": "bug, LLHD", "body": "To simulate below llhd:\r\n\r\n```\r\nllhd.entity @adder(%clk: !llhd.sig, %res: !llhd.sig) \u2192 (%i5_output: !llhd.sig ) {\r\n%0 = llhd.const #llhd.time<0s, 0d, 1e> : !llhd.time\r\n%1 = llhd.const 16 : i32\r\nllhd.drv %i5_output, %1 after %0 : !llhd.sig\r\n}\r\n```\r\n\r\nshows this error:\r\n\r\n```\r\nAssertion failed: (idx < size()), function operator[], file \u2026/llvm/llvm/include/llvm/ADT/SmallVector.h, line 277.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0. Program arguments: \u2026/build/bin/llhd-sim addersvllhd.mlir -n 10 -r adder\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var LLVM_SYMBOLIZER_PATH to point to it):\r\n0 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca593d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca5eeb PrintStackTraceSignalHandler(void*) + 27\r\n2 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca3a6b llvm::sys::RunSignalHandlers() + 123\r\n3 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca83f8 SignalHandler(int) + 232\r\n4 libsystem_platform.dylib 0x00007fff6af445fd _sigtramp + 29\r\n5 libdyld.dylib 0x00007fff6ad4a78f dyldGlobalLockRelease() + 0\r\n6 libsystem_c.dylib 0x00007fff6ae1a808 abort + 120\r\n7 libsystem_c.dylib 0x00007fff6ae19ac6 err + 0\r\n8 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4fa48 llvm::SmallVectorTemplateCommon<circt::llhd::sim::Signal, void>::operator[](unsigned long) + 104\r\n9 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4f912 driveSignal + 178\r\n10 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011e1240f1 driveSignal + 6113425\r\n11 llhd-sim 0x000000010acda78e main + 1518\r\n12 libdyld.dylib 0x00007fff6ad4bcc9 start + 1\r\n```\r\n\r\nMy command to llhd-sim is -n 10 -r adder and I think the expect behaviour should be a constant signal at the output (signal i5_output being constantly at value 16). I was able to trace the code till line 235 of engine.cpp \r\n\r\n(ps: this is not the full code for my sv; I have reduced it to the simplest form to see if I can get an output. Originally my code just aborted when the reaches the adder.adder entity in state.)", "code_snippet_01": "llhd.entity @adder(%clk: !llhd.sig, %res: !llhd.sig) \u2192 (%i5_output: !llhd.sig ) {\r\n%0 = llhd.const #llhd.time<0s, 0d, 1e> : !llhd.time\r\n%1 = llhd.const 16 : i32\r\nllhd.drv %i5_output, %1 after %0 : !llhd.sig\r\n}", "code_snippet_02": "Assertion failed: (idx < size()), function operator[], file \u2026/llvm/llvm/include/llvm/ADT/SmallVector.h, line 277.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0. Program arguments: \u2026/build/bin/llhd-sim addersvllhd.mlir -n 10 -r adder\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var LLVM_SYMBOLIZER_PATH to point to it):\r\n0 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca593d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca5eeb PrintStackTraceSignalHandler(void*) + 27\r\n2 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca3a6b llvm::sys::RunSignalHandlers() + 123\r\n3 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca83f8 SignalHandler(int) + 232\r\n4 libsystem_platform.dylib 0x00007fff6af445fd _sigtramp + 29\r\n5 libdyld.dylib 0x00007fff6ad4a78f dyldGlobalLockRelease() + 0\r\n6 libsystem_c.dylib 0x00007fff6ae1a808 abort + 120\r\n7 libsystem_c.dylib 0x00007fff6ae19ac6 err + 0\r\n8 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4fa48 llvm::SmallVectorTemplateCommon<circt::llhd::sim::Signal, void>::operator[](unsigned long) + 104\r\n9 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4f912 driveSignal + 178\r\n10 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011e1240f1 driveSignal + 6113425\r\n11 llhd-sim 0x000000010acda78e main + 1518\r\n12 libdyld.dylib 0x00007fff6ad4bcc9 start + 1"}, {"number": 796, "title": "[FIRRTL] Memory leak, possibly from creating bundle types", "created_at": "2021-03-19T18:32:47Z", "state": "closed", "labels": "bug, FIRRTL", "body": "In https://github.com/llvm/circt/issues/775, it looked like there was a memory leak when running fir tool with valgrind: \r\n```\r\n==7544==    definitely lost: 67,728 bytes in 2 blocks\r\n==7544==    indirectly lost: 0 bytes in 0 blocks\r\n==7544==      possibly lost: 0 bytes in 0 blocks\r\n==7544==    still reachable: 40 bytes in 1 blocks\r\n==7544==         suppressed: 0 bytes in 0 blocks\r\n```\r\n\r\nI don't think there is a specific test case needed to reproduce. You can get more information out of valgrind by running `valgrind --leak-check=full --num-callers=50 firtool ...`\r\n\r\nI briefly looked at the backtrace and it looked like something from a created bundle type was leaked. I don\u2019t know what the issue is, but this might be relevant: https://github.com/llvm/llvm-project/commit/31bb8efd698304a8385ff79229ffbaa5613efdfb. This MLIR change is soon to be included in circt: https://github.com/llvm/circt/pull/792.", "code_snippet_01": "==7544==    definitely lost: 67,728 bytes in 2 blocks\r\n==7544==    indirectly lost: 0 bytes in 0 blocks\r\n==7544==      possibly lost: 0 bytes in 0 blocks\r\n==7544==    still reachable: 40 bytes in 1 blocks\r\n==7544==         suppressed: 0 bytes in 0 blocks"}, {"number": 795, "title": "[FIRRTL] Type lowering of registers crashes if name attribute not present", "created_at": "2021-03-19T18:28:07Z", "state": "closed", "labels": "bug", "body": "Operation name attribute is accessed without checking if it exists, at several places in LowerTypes, \r\nhttps://github.com/llvm/circt/blob/main/lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp#L574\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Foo\" {\r\n    firrtl.module @Foo(%clock: !firrtl.clock, %a_d: !firrtl.vector<uint<1>, 2>, %a_q: !firrtl.flip<vector<uint<1>, 2>>) {\r\n      %r = firrtl.reg %clock : (!firrtl.clock) -> !firrtl.vector<uint<1>, 2>\r\n      firrtl.connect %r, %a_d : !firrtl.vector<uint<1>, 2>, !firrtl.vector<uint<1>, 2>\r\n      firrtl.connect %a_q, %r : !firrtl.flip<vector<uint<1>, 2>>, !firrtl.vector<uint<1>, 2>\r\n    }\r\n  }\r\n}\r\n```\r\nOn running ``` circt-opt -pass-pipeline='firrtl.circuit(firrtl-lower-types)'``` produces the following crash, \r\n```\r\n0.      Program arguments: circt-opt -pass-pipeline=firrtl.circuit(firrtl-lower-types) crash.mlir\r\n1.      2.       #0 0x00000000013b163e llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:0\r\n #1 0x00000000013b16f5 PrintStackTraceSignalHandler(void*) /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:0\r\n #2 0x00000000013af3b3 llvm::sys::RunSignalHandlers() /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Signals.cpp:71:0\r\n #3 0x00000000013b0fbf SignalHandler(int) /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:0\r\n #4 0x00007fc273131890 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x12890)\r\n #5 0x00000000008361d4 mlir::StringAttr::getValue() const /home/prithayan/work/sifive/fork-circt/circt/llvm/build/tools/mlir/include/mlir/IR/BuiltinAttributes.cpp.inc:266:0\r\n #6 0x000000000043d1b3 (anonymous namespace)::TypeLoweringVisitor::visitDecl(circt::firrtl::RegOp) /home/prithayan/work/sifive/fork-circt/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:574:47\r\n```", "code_snippet_01": "module  {\r\n  firrtl.circuit \"Foo\" {\r\n    firrtl.module @Foo(%clock: !firrtl.clock, %a_d: !firrtl.vector<uint<1>, 2>, %a_q: !firrtl.flip<vector<uint<1>, 2>>) {\r\n      %r = firrtl.reg %clock : (!firrtl.clock) -> !firrtl.vector<uint<1>, 2>\r\n      firrtl.connect %r, %a_d : !firrtl.vector<uint<1>, 2>, !firrtl.vector<uint<1>, 2>\r\n      firrtl.connect %a_q, %r : !firrtl.flip<vector<uint<1>, 2>>, !firrtl.vector<uint<1>, 2>\r\n    }\r\n  }\r\n}", "code_snippet_02": "circt-opt -pass-pipeline='firrtl.circuit(firrtl-lower-types)'", "code_snippet_03": "0.      Program arguments: circt-opt -pass-pipeline=firrtl.circuit(firrtl-lower-types) crash.mlir\r\n1.      2.       #0 0x00000000013b163e llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:0\r\n #1 0x00000000013b16f5 PrintStackTraceSignalHandler(void*) /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:0\r\n #2 0x00000000013af3b3 llvm::sys::RunSignalHandlers() /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Signals.cpp:71:0\r\n #3 0x00000000013b0fbf SignalHandler(int) /home/prithayan/work/sifive/fork-circt/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:0\r\n #4 0x00007fc273131890 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x12890)\r\n #5 0x00000000008361d4 mlir::StringAttr::getValue() const /home/prithayan/work/sifive/fork-circt/circt/llvm/build/tools/mlir/include/mlir/IR/BuiltinAttributes.cpp.inc:266:0\r\n #6 0x000000000043d1b3 (anonymous namespace)::TypeLoweringVisitor::visitDecl(circt::firrtl::RegOp) /home/prithayan/work/sifive/fork-circt/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:574:47"}, {"number": 787, "title": "[FIRRTL] FIRRTL to RTL Memory Lowering Needs to Handle All Read Under Write Behaviors", "created_at": "2021-03-18T22:30:18Z", "state": "open", "labels": "bug, FIRRTL", "body": "Add support for the \"old\" read-under-write FIRRTL memory behavior. Currently, this is incorrectly emitted as \"new\".\r\n\r\nThe FIRRTL spec defines three read-under-write behaviors for memories. A read-under-write behavior is what happens if you try to read and write the same address on the same cycle These three behaviors are:\r\n\r\n1. New (return the value in the memory when the read was made)\r\n2. Old (return the value when the read was requested)\r\n3. Undefined (technically anything, but the Scala FIRRTL Compiler treats this as \"compiler's choice\" and chooses \"New\")\r\n\r\nNote that this only matters for read latencies > 0. These can be treated as equivalent if the ~read latency == 1~ read latency == 0."}, {"number": 785, "title": "[FIRRTL] LowerTypes for Aggregate Register Inits", "created_at": "2021-03-18T20:46:18Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Vector register lowering appears to not work.\r\n\r\nConsider the following circuit:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input a_d: UInt<1>[2]\r\n    output a_q: UInt<1>[2]\r\n\r\n    wire init: UInt<1>[2]\r\n    init[0] <= UInt<1>(0)\r\n    init[1] <= UInt<1>(0)\r\n\r\n    reg r: UInt<1>[2], clock with:\r\n      reset => (reset, init)\r\n\r\n    r <= a_d\r\n    a_q <= r\r\n```\r\n\r\nThis is crashing out in lower types:\r\n\r\n```bash\r\nfirtool -lower-to-rtl -enable-lower-types Foo.fir\r\n# Assertion failed: (entry && \"bundle lowering was not set\"), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 794.\r\n```\r\n\r\nI would expect this to generate something like what the Scala FIRRTL Compiler does here:\r\n\r\n```verilog\r\nmodule Foo(\r\n  input   clock,\r\n  input   reset,\r\n  input   a_d_0,\r\n  input   a_d_1,\r\n  output  a_q_0,\r\n  output  a_q_1\r\n);\r\n  reg  r_0;\r\n  reg  r_1;\r\n  assign a_q_0 = r_0;\r\n  assign a_q_1 = r_1;\r\n  always @(posedge clock) begin\r\n    if (reset) begin\r\n      r_0 <= 1'h0;\r\n    end else begin\r\n      r_0 <= a_d_0;\r\n    end\r\n    if (reset) begin\r\n      r_1 <= 1'h0;\r\n    end else begin\r\n      r_1 <= a_d_1;\r\n    end\r\n  end\r\nendmodule\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input a_d: UInt<1>[2]\r\n    output a_q: UInt<1>[2]\r\n\r\n    wire init: UInt<1>[2]\r\n    init[0] <= UInt<1>(0)\r\n    init[1] <= UInt<1>(0)\r\n\r\n    reg r: UInt<1>[2], clock with:\r\n      reset => (reset, init)\r\n\r\n    r <= a_d\r\n    a_q <= r", "code_snippet_02": "firtool -lower-to-rtl -enable-lower-types Foo.fir\r\n# Assertion failed: (entry && \"bundle lowering was not set\"), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 794.", "code_snippet_03": "module Foo(\r\n  input   clock,\r\n  input   reset,\r\n  input   a_d_0,\r\n  input   a_d_1,\r\n  output  a_q_0,\r\n  output  a_q_1\r\n);\r\n  reg  r_0;\r\n  reg  r_1;\r\n  assign a_q_0 = r_0;\r\n  assign a_q_1 = r_1;\r\n  always @(posedge clock) begin\r\n    if (reset) begin\r\n      r_0 <= 1'h0;\r\n    end else begin\r\n      r_0 <= a_d_0;\r\n    end\r\n    if (reset) begin\r\n      r_1 <= 1'h0;\r\n    end else begin\r\n      r_1 <= a_d_1;\r\n    end\r\n  end\r\nendmodule"}, {"number": 783, "title": "[FIRRTL] Handle Large Memories with Depth > 31 bits (Parser) and > 64 bits (IR)?", "created_at": "2021-03-18T16:17:59Z", "state": "closed", "labels": "bug, good first issue, FIRRTL", "body": "FIRRTL IR allows for memories to be arbitrarily deep. There are two limitations that we're setting on this:\r\n\r\n1) The FIRParser is using an `int32_t` to parse integers.\r\n2) The actual IR representation of depth is `Confined<I64Attr, [IntMinValue<1>]>:$depth`.\r\n\r\nThe (1) restriction can be easily bumped to an `int64_t`. \r\n\r\nThe (2) restriction is lower priority (do we really need to represent exabyte-sized memories in the IR right now?), but would be good to tackle eventually. I think this could be handled by switching to a hypotehtical `I128Attr`, using a hypothetical big number attribute, or we could switch to a string here.\r\n\r\nAn example that currently fails in the parser:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    mem memory:\r\n      data-type => UInt<8>\r\n      depth => 2147483648\r\n      reader => r\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n```\r\n\r\n```bash\r\nfirtool Foo.fir\r\n# Foo.fir:5:16: error: value is too big to handle\r\n#       depth => 2147483648\r\n#                ^\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    mem memory:\r\n      data-type => UInt<8>\r\n      depth => 2147483648\r\n      reader => r\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined", "code_snippet_02": "firtool Foo.fir\r\n# Foo.fir:5:16: error: value is too big to handle\r\n#       depth => 2147483648\r\n#                ^"}, {"number": 782, "title": "[FIRRTL] Memories can be called \"mem\"", "created_at": "2021-03-18T15:53:10Z", "state": "closed", "labels": "bug, FIRRTL", "body": "We currently incorrectly parse memories called `mem`. This is another variant of context-sensitive parsing issues, e.g., https://github.com/llvm/circt/issues/559.\r\n\r\nThe following should parse:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    input clock: Clock\r\n    input rAddr: UInt<4>\r\n    input rEn: UInt<1>\r\n    output rData: UInt<8>\r\n\r\n    mem mem:\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      reader => r\r\n      read-latency => 2\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    mem.r.clk <= clock\r\n    mem.r.en <= rEn\r\n    mem.r.addr <= rAddr\r\n    rData <= mem.r.data\r\n```\r\n\r\nCurrently this fails where the parser gets confused with the `mem.r.clk <= clock` statement:\r\n\r\n```bash\r\nfirtool Foo.fir                \r\n# Foo.fir:17:10: error: expected '<=', '<-', or 'is' in statement\r\n#     mem.r.clk <= clock\r\n#          ^\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input clock: Clock\r\n    input rAddr: UInt<4>\r\n    input rEn: UInt<1>\r\n    output rData: UInt<8>\r\n\r\n    mem mem:\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      reader => r\r\n      read-latency => 2\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    mem.r.clk <= clock\r\n    mem.r.en <= rEn\r\n    mem.r.addr <= rAddr\r\n    rData <= mem.r.data", "code_snippet_02": "firtool Foo.fir                \r\n# Foo.fir:17:10: error: expected '<=', '<-', or 'is' in statement\r\n#     mem.r.clk <= clock\r\n#          ^"}, {"number": 781, "title": "[FIRRTL] Parse RawString ExtModule Parameters", "created_at": "2021-03-18T15:39:28Z", "state": "closed", "labels": "bug, good first issue, FIRRTL", "body": "The Scala FIRRTL Compiler supports passing \"raw string\" parameters to blackboxes. These have single quotes as opposed to double quotes.\r\n\r\nAs an example, the following:\r\n\r\n```scala\r\nmodule BlackBoxTypeParam :\r\n  extmodule BlackBoxTypeParam :                                                                                    \r\n    output out : UInt<1>                                                                                           \r\n    defname = BlackBoxTypeParam                                                                                    \r\n    parameter T = 'bit'                                                                                            \r\n```\r\n\r\nBecomes in the Scala FIRRTL Compiler:\r\n\r\n```verilog\r\nmodule Foo(\r\n  output  out\r\n);\r\n  wire  bar_out;\r\n  BlackBoxTypeParam #(.T(bit)) bar (\r\n    .out(bar_out)\r\n  );\r\n  assign out = bar_out;\r\nendmodule\r\n```\r\n\r\nWe currently barf on the `'` when trying to parse this `.fir` file with `firtool`:\r\n\r\n```\r\nBlackBoxTypeParam.fir:5:19: error: unexpected character\r\n    parameter T = 'bit'\r\n```\r\n\r\nAs far as I can tell, if something is a raw string, it should be reproduced exactly in the Verilog output.", "code_snippet_01": "module BlackBoxTypeParam :\r\n  extmodule BlackBoxTypeParam :                                                                                    \r\n    output out : UInt<1>                                                                                           \r\n    defname = BlackBoxTypeParam                                                                                    \r\n    parameter T = 'bit'", "code_snippet_02": "module Foo(\r\n  output  out\r\n);\r\n  wire  bar_out;\r\n  BlackBoxTypeParam #(.T(bit)) bar (\r\n    .out(bar_out)\r\n  );\r\n  assign out = bar_out;\r\nendmodule", "code_snippet_03": "BlackBoxTypeParam.fir:5:19: error: unexpected character\r\n    parameter T = 'bit'"}, {"number": 779, "title": "[FIRRTL] Disallow Top-level Abstract Reset", "created_at": "2021-03-17T20:57:50Z", "state": "closed", "labels": "bug, good first issue, FIRRTL", "body": "The following circuit should be an error. Assumedly, this should be a verification hook added to either a FIRRTL circuit or to a module that is conditioned on it being the top module.\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    input a_d: UInt<1>\r\n    output a_q: UInt<1>\r\n    input r: Reset\r\n    input c: Clock\r\n\r\n\r\n    reg x: UInt<1>, c with:\r\n      reset => (r, UInt<1>(0))\r\n\r\n    x <= a_d\r\n    a_q <= x\r\n```\r\n\r\nWhen running with the Scala FIRRTL Compiler, this errors quickly:\r\n\r\n```bash\r\nfirrtl -i chiselTests/Reset.fir                     \r\n# Exception in thread \"main\" firrtl.passes.CheckHighFormLike$ResetInputException: : [module Foo] Abstract Reset not allowed as top-level input: r\r\n```\r\n\r\nWhen compiling with CIRCT, this happily goes all the way to Verilog and generates a synchronous reset flip flop.", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input a_d: UInt<1>\r\n    output a_q: UInt<1>\r\n    input r: Reset\r\n    input c: Clock\r\n\r\n\r\n    reg x: UInt<1>, c with:\r\n      reset => (r, UInt<1>(0))\r\n\r\n    x <= a_d\r\n    a_q <= x", "code_snippet_02": "firrtl -i chiselTests/Reset.fir                     \r\n# Exception in thread \"main\" firrtl.passes.CheckHighFormLike$ResetInputException: : [module Foo] Abstract Reset not allowed as top-level input: r"}, {"number": 778, "title": "[FIRRTL] mem 0-width (core dump)", "created_at": "2021-03-17T20:04:05Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input r0en: UInt<1>\r\n    mem tmp41:\r\n      data-type => UInt<0>\r\n      depth => 10\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp41.r0.clk <= clock\r\n    tmp41.r0.en <= r0en\r\n    tmp41.r0.addr <= asUInt(SInt<25>(0))\r\n    tmp41.w0.clk <= clock\r\n    tmp41.w0.en <= r0en\r\n    tmp41.w0.addr <= asUInt(SInt<25>(0))\r\n    tmp41.w0.mask <= asUInt(SInt<25>(0))\r\n    tmp41.w0.data <= asUInt(SInt<25>(0))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:\r\n\r\n```mlir\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n1.       #0 0x000000000043cccd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x43cccd)\r\n #1 0x000000000043aad4 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x43aad4)\r\n #2 0x000000000043ac33 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x43ac33)\r\n #3 0x00007f32ead06a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #4 0x000000000054673a mlir::detail::OperandStorage::OperandStorage(mlir::Operation*, mlir::ValueRange) (../../llvm/circt/build/bin/firtool+0x54673a)\r\n #5 0x000000000053b3b1 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, unsigned int) (../../llvm/circt/build/bin/firtool+0x53b3b1)\r\n #6 0x000000000053b479 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, mlir::RegionRange) (../../llvm/circt/build/bin/firtool+0x53b479)\r\n #7 0x000000000053b653 mlir::Operation::create(mlir::OperationState const&) (../../llvm/circt/build/bin/firtool+0x53b653)\r\n #8 0x00000000004f93ac mlir::OpBuilder::createOperation(mlir::OperationState const&) (../../llvm/circt/build/bin/firtool+0x4f93ac)\r\n #9 0x0000000000482ac5 circt::sv::ConnectOp mlir::OpBuilder::create<circt::sv::ConnectOp, mlir::Value&, mlir::Value&>(mlir::Location, mlir::Value&, mlir::Value&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/Builders.h:399:31\r\n#10 0x0000000000495d43 begin /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:253:45\r\n#11 0x0000000000495d43 end /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:255:32\r\n#12 0x0000000000495d43 ~SmallVector /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:1175:24\r\n#13 0x0000000000495d43 (anonymous namespace)::FIRRTLLowering::visitDecl(circt::firrtl::MemOp) /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:1865:36\r\n#14 0x0000000000497b34 operator()<circt::firrtl::MemOp> /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:211:53\r\n#15 0x0000000000497b34 Case<circt::firrtl::MemOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:116:22\r\n#16 0x0000000000497b34 Case<circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:40:40\r\n#17 0x0000000000497b34 Case<circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42\r\n#18 0x0000000000497b34 Case<circt::firrtl::CMemOp, circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42\r\n#19 0x0000000000497b34 dispatchDeclVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:210:43\r\n#20 0x0000000000497b34 visitInvalidStmt /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:270:37\r\n#21 0x0000000000497b34 operator()<mlir::Operation*> /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:165:44\r\n#22 0x0000000000497b34 Default<circt::firrtl::StmtVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchStmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:17)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:125:21\r\n#23 0x0000000000497b34 dispatchStmtVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:164:17\r\n#24 0x0000000000497b34 visitInvalidExpr /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:267:37\r\n#25 0x0000000000497b34 operator()<mlir::Operation*> /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:54:44\r\n#26 0x0000000000497b34 Default<circt::firrtl::ExprVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:15)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:125:21\r\n#27 0x0000000000497b34 dispatchExprVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:53:17\r\n#28 0x0000000000497b34 dispatchVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:262:37\r\n#29 0x0000000000497b34 (anonymous namespace)::FIRRTLLowering::run() /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:1116:18\r\n#30 0x0000000000499246 llvm::SmallVectorTemplateCommon<circt::sv::WireOp, void>::begin() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:253:45\r\n#31 0x0000000000499246 llvm::SmallVectorTemplateCommon<circt::sv::WireOp, void>::end() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:255:32\r\n#32 0x0000000000499246 llvm::SmallVector<circt::sv::WireOp, 6u>::~SmallVector() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:1175:24\r\n#33 0x0000000000499246 ~FIRRTLLowering /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:876:8\r\n#34 0x0000000000499246 lowerModuleOperations /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:1098:3\r\n#35 0x0000000000499246 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:746:24\r\n#36 0x000000000049b1f1 parallel_for_each_n<long unsigned int, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Parallel.h:162:25\r\n#37 0x000000000049b1f1 parallelForEachN<(anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Parallel.h:244:42\r\n#38 0x000000000049b1f1 (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:223:27\r\n#39 0x0000000000682385 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x682385)\r\n#40 0x00000000006824b0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x6824b0)\r\n#41 0x0000000000685594 mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x685594)\r\n#42 0x000000000040b915 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:167:3\r\n#43 0x00000000004080a6 processBufferIntoSingleStream /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:191:4\r\n#44 0x00000000004080a6 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:256:15\r\n#45 0x00007f32ea774b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#46 0x000000000040989e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 26: 20292 Segmentation fault      (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2\r\n```\r\n\r\nvalgrind reports\r\n\r\n```\r\n==20518== \r\n==20518== Process terminating with default action of signal 11 (SIGSEGV): dumping core\r\n==20518==  Access not within mapped region at address 0x0\r\n==20518==    at 0x54673A: mlir::detail::OperandStorage::OperandStorage(mlir::Operation*, mlir::ValueRange) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==    by 0x53B3B0: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, unsigned int) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==    by 0x53B478: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, mlir::RegionRange) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==    by 0x53B652: mlir::Operation::create(mlir::OperationState const&) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==    by 0x4F93AB: mlir::OpBuilder::createOperation(mlir::OperationState const&) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==    by 0x482AC4: circt::sv::ConnectOp mlir::OpBuilder::create<circt::sv::ConnectOp, mlir::Value&, mlir::Value&>(mlir::Location, mlir::Value&, mlir::Value&) (Builders.h:399)\r\n==20518==    by 0x495D42: create<circt::sv::ConnectOp, mlir::Value&, mlir::Value&> (ImplicitLocOpBuilder.h:83)\r\n==20518==    by 0x495D42: (anonymous namespace)::FIRRTLLowering::visitDecl(circt::firrtl::MemOp) (LowerToRTL.cpp:1908)\r\n==20518==    by 0x497B33: operator()<circt::firrtl::MemOp> (FIRRTLVisitors.h:211)\r\n==20518==    by 0x497B33: Case<circt::firrtl::MemOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> (TypeSwitch.h:116)\r\n==20518==    by 0x497B33: Case<circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> (TypeSwitch.h:40)\r\n==20518==    by 0x497B33: Case<circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> (TypeSwitch.h:41)\r\n==20518==    by 0x497B33: Case<circt::firrtl::CMemOp, circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)> > (TypeSwitch.h:41)\r\n==20518==    by 0x497B33: dispatchDeclVisitor (FIRRTLVisitors.h:210)\r\n==20518==    by 0x497B33: visitInvalidStmt (FIRRTLVisitors.h:270)\r\n==20518==    by 0x497B33: operator()<mlir::Operation*> (FIRRTLVisitors.h:165)\r\n==20518==    by 0x497B33: Default<circt::firrtl::StmtVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchStmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:17)> > (TypeSwitch.h:125)\r\n==20518==    by 0x497B33: dispatchStmtVisitor (FIRRTLVisitors.h:164)\r\n==20518==    by 0x497B33: visitInvalidExpr (FIRRTLVisitors.h:267)\r\n==20518==    by 0x497B33: operator()<mlir::Operation*> (FIRRTLVisitors.h:54)\r\n==20518==    by 0x497B33: Default<circt::firrtl::ExprVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:15)> > (TypeSwitch.h:125)\r\n==20518==    by 0x497B33: dispatchExprVisitor (FIRRTLVisitors.h:53)\r\n==20518==    by 0x497B33: dispatchVisitor (FIRRTLVisitors.h:262)\r\n==20518==    by 0x497B33: (anonymous namespace)::FIRRTLLowering::run() (LowerToRTL.cpp:1116)\r\n==20518==    by 0x499245: lowerModuleOperations (LowerToRTL.cpp:1098)\r\n==20518==    by 0x499245: (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) (LowerToRTL.cpp:746)\r\n==20518==    by 0x49B1F0: operator()<long unsigned int> (LowerToRTL.cpp:224)\r\n==20518==    by 0x49B1F0: parallel_for_each_n<long unsigned int, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > (Parallel.h:163)\r\n==20518==    by 0x49B1F0: parallelForEachN<(anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > (Parallel.h:244)\r\n==20518==    by 0x49B1F0: (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() (LowerToRTL.cpp:223)\r\n==20518==    by 0x682384: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==    by 0x6824AF: mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==  If you believe this happened as a result of a stack\r\n==20518==  overflow in your program's main thread (unlikely but\r\n==20518==  possible), you can try to increase the size of the\r\n==20518==  main thread stack using the --main-stacksize= flag.\r\n==20518==  The main thread stack size used in this run was 8388608.\r\n==20518== \r\n==20518== HEAP SUMMARY:\r\n==20518==     in use at exit: 518,681 bytes in 1,019 blocks\r\n==20518==   total heap usage: 1,293 allocs, 274 frees, 775,666 bytes allocated\r\n==20518== \r\n==20518== LEAK SUMMARY:\r\n==20518==    definitely lost: 67,584 bytes in 1 blocks\r\n==20518==    indirectly lost: 0 bytes in 0 blocks\r\n==20518==      possibly lost: 0 bytes in 0 blocks\r\n==20518==    still reachable: 451,097 bytes in 1,018 blocks\r\n==20518==         suppressed: 0 bytes in 0 blocks\r\n==20518== Rerun with --leak-check=full to see details of leaked memory\r\n==20518== \r\n==20518== For lists of detected and suppressed errors, rerun with: -s\r\n==20518== ERROR SUMMARY: 2 errors from 1 contexts (suppressed: 0 from 0)\r\n```\r\n\r\nfirrtl-1.5.0-SNAPSHOT also crashes :(", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input r0en: UInt<1>\r\n    mem tmp41:\r\n      data-type => UInt<0>\r\n      depth => 10\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp41.r0.clk <= clock\r\n    tmp41.r0.en <= r0en\r\n    tmp41.r0.addr <= asUInt(SInt<25>(0))\r\n    tmp41.w0.clk <= clock\r\n    tmp41.w0.en <= r0en\r\n    tmp41.w0.addr <= asUInt(SInt<25>(0))\r\n    tmp41.w0.mask <= asUInt(SInt<25>(0))\r\n    tmp41.w0.data <= asUInt(SInt<25>(0))", "code_snippet_02": "PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n1.       #0 0x000000000043cccd llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (../../llvm/circt/build/bin/firtool+0x43cccd)\r\n #1 0x000000000043aad4 llvm::sys::RunSignalHandlers() (../../llvm/circt/build/bin/firtool+0x43aad4)\r\n #2 0x000000000043ac33 SignalHandler(int) (../../llvm/circt/build/bin/firtool+0x43ac33)\r\n #3 0x00007f32ead06a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #4 0x000000000054673a mlir::detail::OperandStorage::OperandStorage(mlir::Operation*, mlir::ValueRange) (../../llvm/circt/build/bin/firtool+0x54673a)\r\n #5 0x000000000053b3b1 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, unsigned int) (../../llvm/circt/build/bin/firtool+0x53b3b1)\r\n #6 0x000000000053b479 mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, mlir::RegionRange) (../../llvm/circt/build/bin/firtool+0x53b479)\r\n #7 0x000000000053b653 mlir::Operation::create(mlir::OperationState const&) (../../llvm/circt/build/bin/firtool+0x53b653)\r\n #8 0x00000000004f93ac mlir::OpBuilder::createOperation(mlir::OperationState const&) (../../llvm/circt/build/bin/firtool+0x4f93ac)\r\n #9 0x0000000000482ac5 circt::sv::ConnectOp mlir::OpBuilder::create<circt::sv::ConnectOp, mlir::Value&, mlir::Value&>(mlir::Location, mlir::Value&, mlir::Value&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/Builders.h:399:31\r\n#10 0x0000000000495d43 begin /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:253:45\r\n#11 0x0000000000495d43 end /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:255:32\r\n#12 0x0000000000495d43 ~SmallVector /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:1175:24\r\n#13 0x0000000000495d43 (anonymous namespace)::FIRRTLLowering::visitDecl(circt::firrtl::MemOp) /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:1865:36\r\n#14 0x0000000000497b34 operator()<circt::firrtl::MemOp> /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:211:53\r\n#15 0x0000000000497b34 Case<circt::firrtl::MemOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:116:22\r\n#16 0x0000000000497b34 Case<circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:40:40\r\n#17 0x0000000000497b34 Case<circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42\r\n#18 0x0000000000497b34 Case<circt::firrtl::CMemOp, circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42\r\n#19 0x0000000000497b34 dispatchDeclVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:210:43\r\n#20 0x0000000000497b34 visitInvalidStmt /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:270:37\r\n#21 0x0000000000497b34 operator()<mlir::Operation*> /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:165:44\r\n#22 0x0000000000497b34 Default<circt::firrtl::StmtVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchStmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:17)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:125:21\r\n#23 0x0000000000497b34 dispatchStmtVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:164:17\r\n#24 0x0000000000497b34 visitInvalidExpr /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:267:37\r\n#25 0x0000000000497b34 operator()<mlir::Operation*> /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:54:44\r\n#26 0x0000000000497b34 Default<circt::firrtl::ExprVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:15)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:125:21\r\n#27 0x0000000000497b34 dispatchExprVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:53:17\r\n#28 0x0000000000497b34 dispatchVisitor /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:262:37\r\n#29 0x0000000000497b34 (anonymous namespace)::FIRRTLLowering::run() /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:1116:18\r\n#30 0x0000000000499246 llvm::SmallVectorTemplateCommon<circt::sv::WireOp, void>::begin() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:253:45\r\n#31 0x0000000000499246 llvm::SmallVectorTemplateCommon<circt::sv::WireOp, void>::end() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:255:32\r\n#32 0x0000000000499246 llvm::SmallVector<circt::sv::WireOp, 6u>::~SmallVector() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/SmallVector.h:1175:24\r\n#33 0x0000000000499246 ~FIRRTLLowering /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:876:8\r\n#34 0x0000000000499246 lowerModuleOperations /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:1098:3\r\n#35 0x0000000000499246 (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:746:24\r\n#36 0x000000000049b1f1 parallel_for_each_n<long unsigned int, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Parallel.h:162:25\r\n#37 0x000000000049b1f1 parallelForEachN<(anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/Support/Parallel.h:244:42\r\n#38 0x000000000049b1f1 (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() /home/drom/work/github/llvm/circt/build/../lib/Conversion/FIRRTLToRTL/LowerToRTL.cpp:223:27\r\n#39 0x0000000000682385 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (../../llvm/circt/build/bin/firtool+0x682385)\r\n#40 0x00000000006824b0 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (../../llvm/circt/build/bin/firtool+0x6824b0)\r\n#41 0x0000000000685594 mlir::PassManager::run(mlir::Operation*) (../../llvm/circt/build/bin/firtool+0x685594)\r\n#42 0x000000000040b915 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:167:3\r\n#43 0x00000000004080a6 processBufferIntoSingleStream /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:191:4\r\n#44 0x00000000004080a6 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:256:15\r\n#45 0x00007f32ea774b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#46 0x000000000040989e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 26: 20292 Segmentation fault      (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2", "code_snippet_03": "==20518== \r\n==20518== Process terminating with default action of signal 11 (SIGSEGV): dumping core\r\n==20518==  Access not within mapped region at address 0x0\r\n==20518==    at 0x54673A: mlir::detail::OperandStorage::OperandStorage(mlir::Operation*, mlir::ValueRange) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==    by 0x53B3B0: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, unsigned int) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==    by 0x53B478: mlir::Operation::create(mlir::Location, mlir::OperationName, mlir::TypeRange, mlir::ValueRange, mlir::DictionaryAttr, mlir::BlockRange, mlir::RegionRange) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==    by 0x53B652: mlir::Operation::create(mlir::OperationState const&) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==    by 0x4F93AB: mlir::OpBuilder::createOperation(mlir::OperationState const&) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==    by 0x482AC4: circt::sv::ConnectOp mlir::OpBuilder::create<circt::sv::ConnectOp, mlir::Value&, mlir::Value&>(mlir::Location, mlir::Value&, mlir::Value&) (Builders.h:399)\r\n==20518==    by 0x495D42: create<circt::sv::ConnectOp, mlir::Value&, mlir::Value&> (ImplicitLocOpBuilder.h:83)\r\n==20518==    by 0x495D42: (anonymous namespace)::FIRRTLLowering::visitDecl(circt::firrtl::MemOp) (LowerToRTL.cpp:1908)\r\n==20518==    by 0x497B33: operator()<circt::firrtl::MemOp> (FIRRTLVisitors.h:211)\r\n==20518==    by 0x497B33: Case<circt::firrtl::MemOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> (TypeSwitch.h:116)\r\n==20518==    by 0x497B33: Case<circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> (TypeSwitch.h:40)\r\n==20518==    by 0x497B33: Case<circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)>&> (TypeSwitch.h:41)\r\n==20518==    by 0x497B33: Case<circt::firrtl::CMemOp, circt::firrtl::InstanceOp, circt::firrtl::MemOp, circt::firrtl::NodeOp, circt::firrtl::RegOp, circt::firrtl::SMemOp, circt::firrtl::RegResetOp, circt::firrtl::WireOp, circt::firrtl::DeclVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchDeclVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:18)> > (TypeSwitch.h:41)\r\n==20518==    by 0x497B33: dispatchDeclVisitor (FIRRTLVisitors.h:210)\r\n==20518==    by 0x497B33: visitInvalidStmt (FIRRTLVisitors.h:270)\r\n==20518==    by 0x497B33: operator()<mlir::Operation*> (FIRRTLVisitors.h:165)\r\n==20518==    by 0x497B33: Default<circt::firrtl::StmtVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchStmtVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:17)> > (TypeSwitch.h:125)\r\n==20518==    by 0x497B33: dispatchStmtVisitor (FIRRTLVisitors.h:164)\r\n==20518==    by 0x497B33: visitInvalidExpr (FIRRTLVisitors.h:267)\r\n==20518==    by 0x497B33: operator()<mlir::Operation*> (FIRRTLVisitors.h:54)\r\n==20518==    by 0x497B33: Default<circt::firrtl::ExprVisitor<ConcreteType, ResultType, ExtraArgs>::dispatchExprVisitor<(anonymous namespace)::FIRRTLLowering, mlir::LogicalResult, {}>::<lambda(auto:15)> > (TypeSwitch.h:125)\r\n==20518==    by 0x497B33: dispatchExprVisitor (FIRRTLVisitors.h:53)\r\n==20518==    by 0x497B33: dispatchVisitor (FIRRTLVisitors.h:262)\r\n==20518==    by 0x497B33: (anonymous namespace)::FIRRTLLowering::run() (LowerToRTL.cpp:1116)\r\n==20518==    by 0x499245: lowerModuleOperations (LowerToRTL.cpp:1098)\r\n==20518==    by 0x499245: (anonymous namespace)::FIRRTLModuleLowering::lowerModuleBody(circt::firrtl::FModuleOp, (anonymous namespace)::CircuitLoweringState&) (LowerToRTL.cpp:746)\r\n==20518==    by 0x49B1F0: operator()<long unsigned int> (LowerToRTL.cpp:224)\r\n==20518==    by 0x49B1F0: parallel_for_each_n<long unsigned int, (anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > (Parallel.h:163)\r\n==20518==    by 0x49B1F0: parallelForEachN<(anonymous namespace)::FIRRTLModuleLowering::runOnOperation()::<lambda(auto:21)> > (Parallel.h:244)\r\n==20518==    by 0x49B1F0: (anonymous namespace)::FIRRTLModuleLowering::runOnOperation() (LowerToRTL.cpp:223)\r\n==20518==    by 0x682384: mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==    by 0x6824AF: mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (in /home/drom/work/github/llvm/circt/build/bin/firtool)\r\n==20518==  If you believe this happened as a result of a stack\r\n==20518==  overflow in your program's main thread (unlikely but\r\n==20518==  possible), you can try to increase the size of the\r\n==20518==  main thread stack using the --main-stacksize= flag.\r\n==20518==  The main thread stack size used in this run was 8388608.\r\n==20518== \r\n==20518== HEAP SUMMARY:\r\n==20518==     in use at exit: 518,681 bytes in 1,019 blocks\r\n==20518==   total heap usage: 1,293 allocs, 274 frees, 775,666 bytes allocated\r\n==20518== \r\n==20518== LEAK SUMMARY:\r\n==20518==    definitely lost: 67,584 bytes in 1 blocks\r\n==20518==    indirectly lost: 0 bytes in 0 blocks\r\n==20518==      possibly lost: 0 bytes in 0 blocks\r\n==20518==    still reachable: 451,097 bytes in 1,018 blocks\r\n==20518==         suppressed: 0 bytes in 0 blocks\r\n==20518== Rerun with --leak-check=full to see details of leaked memory\r\n==20518== \r\n==20518== For lists of detected and suppressed errors, rerun with: -s\r\n==20518== ERROR SUMMARY: 2 errors from 1 contexts (suppressed: 0 from 0)"}, {"number": 775, "title": "[FIRRTL] mem (core dump)", "created_at": "2021-03-17T05:22:21Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input r0en: UInt<1>\r\n    mem tmp41:\r\n      data-type => UInt<8>\r\n      depth => 10\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp41.r0.clk <= clock\r\n    tmp41.r0.en <= r0en\r\n    tmp41.r0.addr <= asUInt(SInt<25>(0))\r\n    tmp41.w0.clk <= clock\r\n    tmp41.w0.en <= r0en\r\n    tmp41.w0.addr <= asUInt(SInt<25>(0))\r\n    tmp41.w0.mask <= asUInt(SInt<25>(0))\r\n    tmp41.w0.data <= asUInt(SInt<25>(0))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:\r\n\r\n```mlir\r\nfirtool\r\nmalloc(): unsorted double linked list corrupted\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\nmalloc(): unsorted double linked list corrupted\r\n./process1.sh: line 25: 29968 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2\r\n```\r\n\r\nfirrtl-1.5.0-SNAPSHOT produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input   clock,\r\n  input   reset,\r\n  input   r0en\r\n);\r\nendmodule\r\n```", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input r0en: UInt<1>\r\n    mem tmp41:\r\n      data-type => UInt<8>\r\n      depth => 10\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp41.r0.clk <= clock\r\n    tmp41.r0.en <= r0en\r\n    tmp41.r0.addr <= asUInt(SInt<25>(0))\r\n    tmp41.w0.clk <= clock\r\n    tmp41.w0.en <= r0en\r\n    tmp41.w0.addr <= asUInt(SInt<25>(0))\r\n    tmp41.w0.mask <= asUInt(SInt<25>(0))\r\n    tmp41.w0.data <= asUInt(SInt<25>(0))", "code_snippet_02": "firtool\r\nmalloc(): unsorted double linked list corrupted\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\nmalloc(): unsorted double linked list corrupted\r\n./process1.sh: line 25: 29968 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2", "code_snippet_03": "module top_mod(\r\n  input   clock,\r\n  input   reset,\r\n  input   r0en\r\n);\r\nendmodule"}, {"number": 773, "title": "[FIRRTL] crash", "created_at": "2021-03-16T23:44:05Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 497\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_a: UInt<5>\r\n    input inp_b: {inp_c: {inp_j: UInt<5>}, inp_d: {inp_e: SInt<7>, inp_i: SInt<2>}, inp_g: {inp_h: UInt<14>}}\r\n    input inp_f: UInt<13>\r\n    output tmp8: SInt<25>\r\n    reg tmp6: UInt<5>, clock with: (reset => (reset, UInt<5>(0)))\r\n    reg tmp9: UInt<13>, clock\r\n    reg tmp10: SInt<8>, clock\r\n    wire tmp11: SInt<23>\r\n    reg tmp12: SInt<1>, clock with: (reset => (reset, SInt<1>(0)))\r\n    reg tmp13: SInt<11>, clock\r\n    reg tmp15: UInt<8>, clock\r\n    wire _tmp17: UInt<12>\r\n    wire tmp18: SInt<11>\r\n    reg tmp19: UInt<13>, clock with: (reset => (reset, UInt<13>(0)))\r\n    reg tmp23: SInt<11>, clock with: (reset => (reset, SInt<11>(0)))\r\n    tmp6 <= bits(inp_b.inp_g.inp_h, 4, 0)\r\n    tmp8 <= mux(head(tmp6, 1), SInt<23>(\"h1d0137\"), asSInt(UInt<25>(\"b100101111111101010010010\")))\r\n    tmp9 <= xor(inp_f, inp_b.inp_c.inp_j)\r\n    tmp10 <= neg(UInt<7>(\"h26\"))\r\n    tmp11 <= asSInt(UInt<23>(\"o5674546\"))\r\n    tmp12 <= validif(head(inp_f, 1), SInt<1>(\"b-1\"))\r\n    tmp13 <= shr(tmp8, 14)\r\n    tmp15 <= not(tmp10)\r\n    _tmp17 <= add(UInt<11>(\"b110001010\"), tmp15)\r\n    tmp18 <= rem(tmp13, asSInt(UInt<24>(9972122)))\r\n    tmp19 <= bits(inp_f, 12, 0)\r\n    tmp23 <= validif(head(asUInt(SInt<20>(\"o-71634\")), 1), tmp13)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:\r\n\r\n```mlir\r\nfirtool\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n #0 0x00000000004bc921 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004bc9d8 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004ba9d8 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bc374 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007fb20ef94a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #5 0x0000000000694d5e llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Dialect*, mlir::MLIRContext*>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Dialect*, mlir::MLIRContext*> > >::getInt() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerIntPair.h:61:57\r\n #6 0x0000000000695db3 bool llvm::PointerUnion<mlir::Dialect*, mlir::MLIRContext*>::is<mlir::Dialect*>() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:181:34\r\n #7 0x000000000069113c mlir::Dialect* llvm::PointerUnion<mlir::Dialect*, mlir::MLIRContext*>::dyn_cast<mlir::Dialect*>() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:195:5\r\n #8 0x0000000000687b59 mlir::Identifier::getDialect() /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/MLIRContext.cpp:801:1\r\n #9 0x00000000006a96f7 mlir::OperationName::getDialect() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:328:56\r\n#10 0x00000000006a176e mlir::Operation::getDialect() /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:214:67\r\n#11 0x00000000006a27fb mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:557:32\r\n#12 0x00000000007d23e9 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#13 0x00000000007d1d6e mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#14 0x00000000007b7f09 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#15 0x00000000007b8234 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#16 0x00000000007b8120 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#17 0x00000000006ed6ae (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:3\r\n#18 0x00000000008a4563 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36\r\n#19 0x00000000008a478f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15\r\n#20 0x00000000008a68cf mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74\r\n#21 0x000000000040dbfc processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dbfc)\r\n#22 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)\r\n#23 0x00007fb20ea02b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#24 0x000000000040b56e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: \u0441\u0442\u0440\u043e\u043a\u0430 25: 25590 Segmentation fault      (\u0441\u0442\u0435\u043a \u043f\u0430\u043c\u044f\u0442\u0438 \u0441\u0431\u0440\u043e\u0448\u0435\u043d \u043d\u0430 \u0434\u0438\u0441\u043a) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2\r\n```\r\n\r\nThe issue appears at random.\r\n", "code_snippet_01": "; seed: 497\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_a: UInt<5>\r\n    input inp_b: {inp_c: {inp_j: UInt<5>}, inp_d: {inp_e: SInt<7>, inp_i: SInt<2>}, inp_g: {inp_h: UInt<14>}}\r\n    input inp_f: UInt<13>\r\n    output tmp8: SInt<25>\r\n    reg tmp6: UInt<5>, clock with: (reset => (reset, UInt<5>(0)))\r\n    reg tmp9: UInt<13>, clock\r\n    reg tmp10: SInt<8>, clock\r\n    wire tmp11: SInt<23>\r\n    reg tmp12: SInt<1>, clock with: (reset => (reset, SInt<1>(0)))\r\n    reg tmp13: SInt<11>, clock\r\n    reg tmp15: UInt<8>, clock\r\n    wire _tmp17: UInt<12>\r\n    wire tmp18: SInt<11>\r\n    reg tmp19: UInt<13>, clock with: (reset => (reset, UInt<13>(0)))\r\n    reg tmp23: SInt<11>, clock with: (reset => (reset, SInt<11>(0)))\r\n    tmp6 <= bits(inp_b.inp_g.inp_h, 4, 0)\r\n    tmp8 <= mux(head(tmp6, 1), SInt<23>(\"h1d0137\"), asSInt(UInt<25>(\"b100101111111101010010010\")))\r\n    tmp9 <= xor(inp_f, inp_b.inp_c.inp_j)\r\n    tmp10 <= neg(UInt<7>(\"h26\"))\r\n    tmp11 <= asSInt(UInt<23>(\"o5674546\"))\r\n    tmp12 <= validif(head(inp_f, 1), SInt<1>(\"b-1\"))\r\n    tmp13 <= shr(tmp8, 14)\r\n    tmp15 <= not(tmp10)\r\n    _tmp17 <= add(UInt<11>(\"b110001010\"), tmp15)\r\n    tmp18 <= rem(tmp13, asSInt(UInt<24>(9972122)))\r\n    tmp19 <= bits(inp_f, 12, 0)\r\n    tmp23 <= validif(head(asUInt(SInt<20>(\"o-71634\")), 1), tmp13)", "code_snippet_02": "firtool\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.sv\r\n #0 0x00000000004bc921 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004bc9d8 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004ba9d8 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bc374 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007fb20ef94a30 __restore_rt (/lib64/libpthread.so.0+0x13a30)\r\n #5 0x0000000000694d5e llvm::PointerIntPair<void*, 1u, int, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Dialect*, mlir::MLIRContext*>, llvm::PointerIntPairInfo<void*, 1u, llvm::pointer_union_detail::PointerUnionUIntTraits<mlir::Dialect*, mlir::MLIRContext*> > >::getInt() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerIntPair.h:61:57\r\n #6 0x0000000000695db3 bool llvm::PointerUnion<mlir::Dialect*, mlir::MLIRContext*>::is<mlir::Dialect*>() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:181:34\r\n #7 0x000000000069113c mlir::Dialect* llvm::PointerUnion<mlir::Dialect*, mlir::MLIRContext*>::dyn_cast<mlir::Dialect*>() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/PointerUnion.h:195:5\r\n #8 0x0000000000687b59 mlir::Identifier::getDialect() /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/MLIRContext.cpp:801:1\r\n #9 0x00000000006a96f7 mlir::OperationName::getDialect() const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:328:56\r\n#10 0x00000000006a176e mlir::Operation::getDialect() /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:214:67\r\n#11 0x00000000006a27fb mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:557:32\r\n#12 0x00000000007d23e9 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#13 0x00000000007d1d6e mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#14 0x00000000007b7f09 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#15 0x00000000007b8234 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#16 0x00000000007b8120 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#17 0x00000000006ed6ae (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:3\r\n#18 0x00000000008a4563 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:36\r\n#19 0x00000000008a478f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:444:15\r\n#20 0x00000000008a68cf mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:896:74\r\n#21 0x000000000040dbfc processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::function<mlir::LogicalResult (mlir::OwningModuleRef)>) (../../llvm/circt/build/bin/firtool+0x40dbfc)\r\n#22 0x000000000040b203 main (../../llvm/circt/build/bin/firtool+0x40b203)\r\n#23 0x00007fb20ea02b25 __libc_start_main (/lib64/libc.so.6+0x27b25)\r\n#24 0x000000000040b56e _start /home/abuild/rpmbuild/BUILD/glibc-2.33/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: \u0441\u0442\u0440\u043e\u043a\u0430 25: 25590 Segmentation fault      (\u0441\u0442\u0435\u043a \u043f\u0430\u043c\u044f\u0442\u0438 \u0441\u0431\u0440\u043e\u0448\u0435\u043d \u043d\u0430 \u0434\u0438\u0441\u043a) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2"}, {"number": 755, "title": "Verilog Or Reduction Improperly Inlines Nots", "created_at": "2021-03-11T21:23:04Z", "state": "closed", "labels": "bug, Verilog/SystemVerilog", "body": "Verilog emission is generating things like \"or reduction\" \"not\", e.g., `|~foo` which is invalid Verilog.\r\n\r\nConsider:\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Foo\" {\r\n    firrtl.module @Foo(%a: !firrtl.uint<8>, %b: !firrtl.flip<uint<1>>) {\r\n      %0 = firrtl.not %a : (!firrtl.uint<8>) -> !firrtl.uint<8>\r\n      %1 = firrtl.orr %0 : (!firrtl.uint<8>) -> !firrtl.uint<1>\r\n      firrtl.connect %b, %1 : !firrtl.flip<uint<1>>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis produces:\r\n\r\n```verilog\r\nmodule Foo(\r\n  input  [7:0] a,\r\n  output       b);\r\n\r\n  assign b = |~a;\t// sunder/Foo.fir:2:3, :6:{10,14}\r\nendmodule\r\n```", "code_snippet_01": "module  {\r\n  firrtl.circuit \"Foo\" {\r\n    firrtl.module @Foo(%a: !firrtl.uint<8>, %b: !firrtl.flip<uint<1>>) {\r\n      %0 = firrtl.not %a : (!firrtl.uint<8>) -> !firrtl.uint<8>\r\n      %1 = firrtl.orr %0 : (!firrtl.uint<8>) -> !firrtl.uint<1>\r\n      firrtl.connect %b, %1 : !firrtl.flip<uint<1>>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_02": "module Foo(\r\n  input  [7:0] a,\r\n  output       b);\r\n\r\n  assign b = |~a;\t// sunder/Foo.fir:2:3, :6:{10,14}\r\nendmodule"}, {"number": 751, "title": "spilled temporaries in always blocks use continuous assign", "created_at": "2021-03-11T03:53:13Z", "state": "closed", "labels": "bug", "body": "When temporaries are generated inside an always block, they are written to with a continuous assign.  This is wrong.\r\nGetting more milage out of this example:\r\n```mlir\r\nrtl.module @foobar(%clock: i1, %arg1: i1, %arg2: i1, %arg3: i1) {\r\n    sv.always posedge %clock  {\r\n        sv.if %arg1  {\r\n          sv.fatal\r\n        }\r\n        //this forces a common subexpression to be output out-of-line\r\n        %610 = comb.and %arg1, %arg2 : i1\r\n        %611 = comb.and %arg3, %610 : i1\r\n        sv.if %610  {\r\n          sv.fatal\r\n        }\r\n        sv.if %611  {\r\n          sv.fatal\r\n        }\r\n    }\r\n    rtl.output\r\n  }\r\n```\r\nProduces:\r\n```verilog\r\nmodule foobar(\r\n  input clock, arg1, arg2, arg3);\r\n\r\n  always @(posedge clock) begin // bug.mlir:3:5\r\n    automatic logic _T; // bug.mlir:8:16\r\n\r\n    if (arg1)   // bug.mlir:4:9\r\n      $fatal;   // bug.mlir:5:11\r\n    assign _T = arg1 & arg2;    // bug.mlir:8:16\r\n    if (_T)     // bug.mlir:10:9\r\n      $fatal;   // bug.mlir:11:11\r\n    if (arg3 & _T)      // bug.mlir:9:16, :13:9\r\n      $fatal;   // bug.mlir:14:11\r\n  end // always @(posedge)\r\nendmodule\r\n```", "code_snippet_01": "rtl.module @foobar(%clock: i1, %arg1: i1, %arg2: i1, %arg3: i1) {\r\n    sv.always posedge %clock  {\r\n        sv.if %arg1  {\r\n          sv.fatal\r\n        }\r\n        //this forces a common subexpression to be output out-of-line\r\n        %610 = comb.and %arg1, %arg2 : i1\r\n        %611 = comb.and %arg3, %610 : i1\r\n        sv.if %610  {\r\n          sv.fatal\r\n        }\r\n        sv.if %611  {\r\n          sv.fatal\r\n        }\r\n    }\r\n    rtl.output\r\n  }", "code_snippet_02": "module foobar(\r\n  input clock, arg1, arg2, arg3);\r\n\r\n  always @(posedge clock) begin // bug.mlir:3:5\r\n    automatic logic _T; // bug.mlir:8:16\r\n\r\n    if (arg1)   // bug.mlir:4:9\r\n      $fatal;   // bug.mlir:5:11\r\n    assign _T = arg1 & arg2;    // bug.mlir:8:16\r\n    if (_T)     // bug.mlir:10:9\r\n      $fatal;   // bug.mlir:11:11\r\n    if (arg3 & _T)      // bug.mlir:9:16, :13:9\r\n      $fatal;   // bug.mlir:14:11\r\n  end // always @(posedge)\r\nendmodule"}, {"number": 750, "title": "RTL array_index_inout read vs. write (FIRRTL Memory Lowering Bug)", "created_at": "2021-03-11T00:19:36Z", "state": "closed", "labels": "bug, HW, Verilog/SystemVerilog", "body": "Currently, the following RTL (which is a minimum example of a FIRRTL Memory Lowering bug) causes bad Verilog to be emitted:\r\n\r\n```mlir\r\nmodule attributes {firrtl.mainModule = \"Foo\"}  {\r\n  rtl.module @Foo(%clock: i1, %a: i1) -> () {\r\n    %false = rtl.constant false\r\n    %memory_r_en_pipe = sv.reg  : !rtl.inout<uarray<1xi1>>\r\n    %3 = sv.array_index_inout %memory_r_en_pipe[%false] : !rtl.inout<uarray<1xi1>>, i1\r\n    sv.alwaysff(posedge %clock)  {\r\n      sv.passign %3, %a : i1\r\n    }\r\n    sv.initial  {\r\n      sv.bpassign %3, %false : i1\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis produces:\r\n```verilog\r\nmodule Foo(\r\n  input clock, a);\r\n  reg memory_r_en_pipe[0:0];\t// Foo.mlir:4:25\r\n  wire _T = 1'h0;\t// Foo.mlir:3:14\r\n  wire _T_0 = memory_r_en_pipe[_T];\t// Foo.mlir:5:10\r\n  always_ff @(posedge clock)\t// Foo.mlir:6:5\r\n    _T_0 <= a;\t// Foo.mlir:7:7\r\n  initial\t// Foo.mlir:9:5\r\n    _T_0 = _T;\t// Foo.mlir:10:7\r\nendmodule\r\n```\r\n\r\nThe problem is that the `%3 = sv.array_index_inout` is a write accessor here. You don't want the temporary wire to be generated. \r\n\r\nAlternatively, if the accessor is duplicated and placed inside the always and initial blocks:\r\n```mlir\r\nmodule attributes {firrtl.mainModule = \"Foo\"}  {\r\n  rtl.module @Foo(%clock: i1, %a: i1) -> () {\r\n    %false = rtl.constant false\r\n    %memory_r_en_pipe = sv.reg  : !rtl.inout<uarray<1xi1>>\r\n    sv.alwaysff(posedge %clock)  {\r\n      %3 = sv.array_index_inout %memory_r_en_pipe[%false] : !rtl.inout<uarray<1xi1>>, i1\r\n      sv.passign %3, %a : i1\r\n    }\r\n    sv.initial  {\r\n      %4 = sv.array_index_inout %memory_r_en_pipe[%false] : !rtl.inout<uarray<1xi1>>, i1\r\n      sv.bpassign %4, %false : i1\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nEverything works fine:\r\n```verilog\r\nmodule Foo(\r\n  input clock, a);\r\n  reg memory_r_en_pipe[0:0];\t// Foo.mlir:4:25\r\n  wire _T = 1'h0;\t// Foo.mlir:3:14\r\n  always_ff @(posedge clock)\t// Foo.mlir:5:5\r\n    memory_r_en_pipe[_T] <= a;\t// Foo.mlir:6:12, :7:7\r\n  initial\t// Foo.mlir:9:5\r\n    memory_r_en_pipe[_T] = _T;\t// Foo.mlir:10:12, :11:7\r\nendmodule\r\n```\r\n\r\n### Background/Discussion\r\n\r\nThe memory lowering introduced in #585 was generating code like this and it used to work. However, something changed within the past week and I haven't bisected to see where. \r\n\r\nIt's not immediately clear to me if the bug is in what #585 is doing (it should put the `array_index_inout` inside the blocks) or if something is broke in the RTL -> Verilog path.\r\n\r\nIt seems weird to me that `array_index_inout` can seemingly be a read accessor or a write accessor, based on context. I may be misusing this, but we may want to go more towards the `alloca` + `load` + `store` type model to make this explicit. (Or maybe this already exists?)", "code_snippet_01": "module attributes {firrtl.mainModule = \"Foo\"}  {\r\n  rtl.module @Foo(%clock: i1, %a: i1) -> () {\r\n    %false = rtl.constant false\r\n    %memory_r_en_pipe = sv.reg  : !rtl.inout<uarray<1xi1>>\r\n    %3 = sv.array_index_inout %memory_r_en_pipe[%false] : !rtl.inout<uarray<1xi1>>, i1\r\n    sv.alwaysff(posedge %clock)  {\r\n      sv.passign %3, %a : i1\r\n    }\r\n    sv.initial  {\r\n      sv.bpassign %3, %false : i1\r\n    }\r\n  }\r\n}", "code_snippet_02": "module Foo(\r\n  input clock, a);\r\n  reg memory_r_en_pipe[0:0];\t// Foo.mlir:4:25\r\n  wire _T = 1'h0;\t// Foo.mlir:3:14\r\n  wire _T_0 = memory_r_en_pipe[_T];\t// Foo.mlir:5:10\r\n  always_ff @(posedge clock)\t// Foo.mlir:6:5\r\n    _T_0 <= a;\t// Foo.mlir:7:7\r\n  initial\t// Foo.mlir:9:5\r\n    _T_0 = _T;\t// Foo.mlir:10:7\r\nendmodule", "code_snippet_03": "module attributes {firrtl.mainModule = \"Foo\"}  {\r\n  rtl.module @Foo(%clock: i1, %a: i1) -> () {\r\n    %false = rtl.constant false\r\n    %memory_r_en_pipe = sv.reg  : !rtl.inout<uarray<1xi1>>\r\n    sv.alwaysff(posedge %clock)  {\r\n      %3 = sv.array_index_inout %memory_r_en_pipe[%false] : !rtl.inout<uarray<1xi1>>, i1\r\n      sv.passign %3, %a : i1\r\n    }\r\n    sv.initial  {\r\n      %4 = sv.array_index_inout %memory_r_en_pipe[%false] : !rtl.inout<uarray<1xi1>>, i1\r\n      sv.bpassign %4, %false : i1\r\n    }\r\n  }\r\n}", "code_snippet_04": "module Foo(\r\n  input clock, a);\r\n  reg memory_r_en_pipe[0:0];\t// Foo.mlir:4:25\r\n  wire _T = 1'h0;\t// Foo.mlir:3:14\r\n  always_ff @(posedge clock)\t// Foo.mlir:5:5\r\n    memory_r_en_pipe[_T] <= a;\t// Foo.mlir:6:12, :7:7\r\n  initial\t// Foo.mlir:9:5\r\n    memory_r_en_pipe[_T] = _T;\t// Foo.mlir:10:12, :11:7\r\nendmodule"}, {"number": 746, "title": "Memory latency lowering introduces continuous assignments in always block", "created_at": "2021-03-10T16:10:36Z", "state": "closed", "labels": "bug", "body": "You can modify how many bad assignments happen by changing read-latency.\r\n```\r\ncircuit TLRAM :\r\n  module TLRAM :\r\n    input clock : Clock\r\n\r\n    mem syssram0_3 : @[DescribedSRAM.scala 19:26]\r\n      data-type => UInt<8>\r\n      depth => 8192\r\n      read-latency => 3\r\n      write-latency => 1\r\n      reader => MPORT\r\n      writer => MPORT_1\r\n      read-under-write => undefined\r\n    syssram0_3.MPORT.addr <= UInt<1>(0)\r\n    syssram0_3.MPORT.en <= UInt<1>(0)\r\n    syssram0_3.MPORT.clk <= clock\r\n    syssram0_3.MPORT_1.addr <= UInt<1>(0)\r\n    syssram0_3.MPORT_1.en <= UInt<1>(\"h0\")\r\n    syssram0_3.MPORT_1.clk <= clock\r\n    syssram0_3.MPORT_1.data <= UInt<1>(0)\r\n    syssram0_3.MPORT_1.mask <= UInt<1>(0)\r\n```\r\n", "code_snippet_01": "circuit TLRAM :\r\n  module TLRAM :\r\n    input clock : Clock\r\n\r\n    mem syssram0_3 : @[DescribedSRAM.scala 19:26]\r\n      data-type => UInt<8>\r\n      depth => 8192\r\n      read-latency => 3\r\n      write-latency => 1\r\n      reader => MPORT\r\n      writer => MPORT_1\r\n      read-under-write => undefined\r\n    syssram0_3.MPORT.addr <= UInt<1>(0)\r\n    syssram0_3.MPORT.en <= UInt<1>(0)\r\n    syssram0_3.MPORT.clk <= clock\r\n    syssram0_3.MPORT_1.addr <= UInt<1>(0)\r\n    syssram0_3.MPORT_1.en <= UInt<1>(\"h0\")\r\n    syssram0_3.MPORT_1.clk <= clock\r\n    syssram0_3.MPORT_1.data <= UInt<1>(0)\r\n    syssram0_3.MPORT_1.mask <= UInt<1>(0)"}, {"number": 736, "title": "Conjunction of equality tests generates bad code", "created_at": "2021-03-08T20:47:37Z", "state": "closed", "labels": "bug", "body": "Conjunction of equality tests generates bad code.\r\n```\r\n  rtl.module @LdQEntry(%clock: i1, %reset: i1, %a: i9,\r\n    %b :i1,\r\n    %c :i9\r\n){\r\n    %2 = comb.icmp eq %a, %c : i9\r\n    %4 = comb.icmp eq %b, %2 : i1\r\n    sv.always posedge %clock  {\r\n        sv.if %4  {\r\n          sv.fwrite \"Hi\"\r\n        }\r\n    }\r\n    rtl.output\r\n  }\r\n```\r\nProduces:\r\n```\r\nmodule LdQEntry(\r\n  input       clock, reset,\r\n  input [8:0] a,\r\n  input       b,\r\n  input [8:0] c);\r\n\r\n  wire _T = b == a == c;\t// tmp/bug.lo.rtl.mlir:5:10, :6:10\r\n  always @(posedge clock) begin\t// tmp/bug.lo.rtl.mlir:7:5\r\n    if (reset & _T)\t// tmp/bug.lo.rtl.mlir:8:14, :9:9\r\n      $fwrite(32'h80000002, \"Hi\");\t// tmp/bug.lo.rtl.mlir:10:11\r\n  end // always @(posedge)\r\nendmodule\r\n```\r\nVerilator rightly complains:\r\n```\r\n%Warning-WIDTH: tmp/bug.lo.mlir.sv:83:20: Operator EQ expects 9 bits on the LHS, but LHS's VARREF '_T_1' generates 1 bits.\r\n                                        : ... In instance LdQEntry\r\n   83 |   wire _T_2 = _T_1 == _T == _T_0;  \r\n      |                    ^~\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.\r\n%Warning-WIDTH: tmp/bug.lo.mlir.sv:83:26: Operator EQ expects 9 bits on the LHS, but LHS's EQ generates 1 bits.\r\n                                        : ... In instance LdQEntry\r\n   83 |   wire _T_2 = _T_1 == _T == _T_0;  \r\n      |                          ^~\r\n```", "code_snippet_01": "rtl.module @LdQEntry(%clock: i1, %reset: i1, %a: i9,\r\n    %b :i1,\r\n    %c :i9\r\n){\r\n    %2 = comb.icmp eq %a, %c : i9\r\n    %4 = comb.icmp eq %b, %2 : i1\r\n    sv.always posedge %clock  {\r\n        sv.if %4  {\r\n          sv.fwrite \"Hi\"\r\n        }\r\n    }\r\n    rtl.output\r\n  }", "code_snippet_02": "module LdQEntry(\r\n  input       clock, reset,\r\n  input [8:0] a,\r\n  input       b,\r\n  input [8:0] c);\r\n\r\n  wire _T = b == a == c;\t// tmp/bug.lo.rtl.mlir:5:10, :6:10\r\n  always @(posedge clock) begin\t// tmp/bug.lo.rtl.mlir:7:5\r\n    if (reset & _T)\t// tmp/bug.lo.rtl.mlir:8:14, :9:9\r\n      $fwrite(32'h80000002, \"Hi\");\t// tmp/bug.lo.rtl.mlir:10:11\r\n  end // always @(posedge)\r\nendmodule", "code_snippet_03": "%Warning-WIDTH: tmp/bug.lo.mlir.sv:83:20: Operator EQ expects 9 bits on the LHS, but LHS's VARREF '_T_1' generates 1 bits.\r\n                                        : ... In instance LdQEntry\r\n   83 |   wire _T_2 = _T_1 == _T == _T_0;  \r\n      |                    ^~\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.\r\n%Warning-WIDTH: tmp/bug.lo.mlir.sv:83:26: Operator EQ expects 9 bits on the LHS, but LHS's EQ generates 1 bits.\r\n                                        : ... In instance LdQEntry\r\n   83 |   wire _T_2 = _T_1 == _T == _T_0;  \r\n      |                          ^~"}, {"number": 728, "title": "splitting variadic expressions in a procedural block makes a temporary at the wrong place", "created_at": "2021-03-05T19:10:14Z", "state": "closed", "labels": "bug", "body": "splitting variadic expressions in a procedural block makes a temporary at the wrong place.  This is a follow-on to #720 \r\n```\r\nrtl.module @foo(%clock: i1, %a: i1 {rtl.name = \"asdfasdfasdfasdfafa\"}, %b: i1 {rtl.name = \"gasfdasafwjhijjafija\"})  {\r\n    sv.always posedge %clock  {\r\n          sv.fwrite \"force output\"\r\n        %cond = comb.and %a, %b, %a, %b, %a, %b : i1\r\n        sv.if %cond  {\r\n          sv.fwrite \"this cond is split\"\r\n        }\r\n    }\r\n    rtl.output \r\n  }\r\n```", "code_snippet_01": "rtl.module @foo(%clock: i1, %a: i1 {rtl.name = \"asdfasdfasdfasdfafa\"}, %b: i1 {rtl.name = \"gasfdasafwjhijjafija\"})  {\r\n    sv.always posedge %clock  {\r\n          sv.fwrite \"force output\"\r\n        %cond = comb.and %a, %b, %a, %b, %a, %b : i1\r\n        sv.if %cond  {\r\n          sv.fwrite \"this cond is split\"\r\n        }\r\n    }\r\n    rtl.output \r\n  }"}, {"number": 724, "title": "[ExportVerilog] Wire declaration and definition \"_tmp\" output twice", "created_at": "2021-03-05T04:01:37Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "I haven't tracked this down, but in a certain condition this line is emitted twice (identically) in different areas in the same scope:\r\n\r\n```\r\n  wire [31:0][7:0] _tmp = {{_T_9}, {_T_10}, {_T_11}, {_T_12}, {_T_13}, {_T_14}, {_T_15}, {_T_16}, {_T_17}, {_T_18}, {_T_19}, {_T_20}, {_T_21}, {_T_22}, {_T_23}, {_T_24}, {_T_25}, {_T_26}, {_T_27}, {_T_28}, {_T_29}, {_T_30}, {_T_31}, {_T_32}, {_T_33}, {_T_34}, {_T_35}, {_T_36}, {_T_37}, {_T_38}, {_T_39}, {_T_40}};\r\n```\r\n\r\nThe wire name points to https://github.com/llvm/circt/blob/main/lib/Translation/ExportVerilog/ExportVerilog.cpp#L956. I'll look into this further later, but I figured there is a decent chance that would be enough for @lattner to know what's going on.", "code_snippet_01": "wire [31:0][7:0] _tmp = {{_T_9}, {_T_10}, {_T_11}, {_T_12}, {_T_13}, {_T_14}, {_T_15}, {_T_16}, {_T_17}, {_T_18}, {_T_19}, {_T_20}, {_T_21}, {_T_22}, {_T_23}, {_T_24}, {_T_25}, {_T_26}, {_T_27}, {_T_28}, {_T_29}, {_T_30}, {_T_31}, {_T_32}, {_T_33}, {_T_34}, {_T_35}, {_T_36}, {_T_37}, {_T_38}, {_T_39}, {_T_40}};"}, {"number": 720, "title": "temporaries output in the middle of blocks", "created_at": "2021-03-04T16:25:38Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Consider the test case below.  A temporary is made for 610, which is output after the first if block.  Verilog requires variable declarations to be at the beginning of blocks.\r\n\r\n```mlir\r\nmodule {\r\n  rtl.module @foobar(%clock: i1, %arg1: i1, %arg2: i1, %arg3: i1) {\r\n    sv.always posedge %clock  {\r\n        sv.if %arg1  {\r\n          sv.fatal\r\n        }\r\n        //this forces a common subexpression to be output out-of-line\r\n        %610 = comb.and %arg1, %arg2 : i1\r\n        %611 = comb.and %arg3, %610 : i1\r\n        sv.if %610  {\r\n          sv.fatal\r\n        }\r\n        sv.if %611  {\r\n          sv.fatal\r\n        }\r\n    }\r\n    rtl.output\r\n  }\r\n}\r\n```", "code_snippet_01": "module {\r\n  rtl.module @foobar(%clock: i1, %arg1: i1, %arg2: i1, %arg3: i1) {\r\n    sv.always posedge %clock  {\r\n        sv.if %arg1  {\r\n          sv.fatal\r\n        }\r\n        //this forces a common subexpression to be output out-of-line\r\n        %610 = comb.and %arg1, %arg2 : i1\r\n        %611 = comb.and %arg3, %610 : i1\r\n        sv.if %610  {\r\n          sv.fatal\r\n        }\r\n        sv.if %611  {\r\n          sv.fatal\r\n        }\r\n    }\r\n    rtl.output\r\n  }\r\n}"}, {"number": 714, "title": "long-line splitting breaking begin/end", "created_at": "2021-03-03T23:40:39Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Another case from #701.  if we split a long line which is the only statement inside an if block and the temporary gets generated inside the some block, then we don't correctly generate the begin/end pair for the now-two-statement block.\r\n\r\nIt's fair to ask whether we should be putting the temporaries in the if-scope or in the op's original scope."}, {"number": 713, "title": "Wire in always block, part long line splitting", "created_at": "2021-03-03T23:37:08Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Possibly the cause of #701.  When long lines are split in EmitExpression, the temporary is later emitted in the always block.  The temporary emitter doesn't know about the correct type of declaration to make this legal (and @drom would say you should never do this as a matter of style).  The reason this particular temporary is emitted there rather than at the rtlmodule scope is that it started life as an sv::ifop which is one of 2 ops we generate inside alwaysff blocks (well, with a a couple changes to the memory lowering)."}, {"number": 709, "title": "Fix GCC Warnings", "created_at": "2021-03-02T21:46:17Z", "state": "closed", "labels": "bug, good first issue", "body": "There are currently some warnings when building with GCC, listed below.  Most of these should be pretty easy to fix.\r\n\r\n1. Control reaches end of `sv::CaseZOp::getLetter`\r\n```\r\nIn file included from /home/runner/work/circt/circt/include/circt/Dialect/SV/SVOps.h:43:0,\r\n                 from /home/runner/work/circt/circt/lib/Dialect/SV/SVOps.cpp:13:\r\n/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc: In static member function \u2018static char circt::sv::CaseZOp::getLetter(circt::sv::CaseZOp::PatternBit, bool)\u2019:\r\n/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc:609:5: warning: control reaches end of non-void function [-Wreturn-type]\r\n     }\r\n```\r\n\r\n2.  In `firrtl::verifyMemOp()` portNamesSet may be uninitialized\r\n\r\nThis problem manifests multiple times, possibly everywhere SmallDenseSet is used.\r\n\r\n```\r\nIn file included from /home/runner/work/circt/circt/llvm/install/include/mlir/Support/InterfaceSupport.h:17:0,\r\n                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/StorageUniquerSupport.h:16,\r\n                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/AttributeSupport.h:17,\r\n                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/Attributes.h:12,\r\n                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/BuiltinAttributes.h:12,\r\n                 from /home/runner/work/circt/circt/include/circt/Dialect/FIRRTL/FIRRTLDialect.h:17,\r\n                 from /home/runner/work/circt/circt/include/circt/Dialect/FIRRTL/FIRRTLOps.h:16,\r\n                 from /home/runner/work/circt/circt/lib/Dialect/FIRRTL/FIRRTLOps.cpp:13:\r\n/home/runner/work/circt/circt/llvm/install/include/llvm/ADT/DenseMap.h: In function \u2018mlir::LogicalResult verifyMemOp(circt::firrtl::MemOp)\u2019:\r\n/home/runner/work/circt/circt/llvm/install/include/llvm/ADT/DenseMap.h:1165:18: warning: \u2018*((void*)(& portNamesSet)+16).llvm::SmallDenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, 8, llvm::DenseMapInfo<mlir::Attribute>, llvm::detail::DenseSetPair<mlir::Attribute> >::LargeRep::NumBuckets\u2019 may be used uninitialized in this function [-Wmaybe-uninitialized]\r\n     return Small ? InlineBuckets : getLargeRep()->NumBuckets;\r\n            ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/home/runner/work/circt/circt/llvm/install/include/llvm/ADT/DenseMap.h:1156:18: warning: \u2018*((void*)(& portNamesSet)+16).llvm::SmallDenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, 8, llvm::DenseMapInfo<mlir::Attribute>, llvm::detail::DenseSetPair<mlir::Attribute> >::LargeRep::Buckets\u2019 may be used uninitialized in this function [-Wmaybe-uninitialized]\r\n     return Small ? getInlineBuckets() : getLargeRep()->Buckets;\r\n            ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n```\r\n\r\n3. Possibly uninitialized value in `firrtl::parseType()`\r\n```\r\n/home/runner/work/circt/circt/lib/Dialect/FIRRTL/FIRRTLTypes.cpp: In function \u2018mlir::ParseResult parseType(circt::firrtl::FIRRTLType&, mlir::DialectAsmParser&)\u2019:\r\n/home/runner/work/circt/circt/lib/Dialect/FIRRTL/FIRRTLTypes.cpp:148:35: warning: \u2018fieldIntName\u2019 may be used uninitialized in this function [-Wmaybe-uninitialized]\r\n             nameStr = llvm::utostr(fieldIntName);\r\n```\r\n\r\n4. Possibly uninitialized value in `handshake::executeHandshakeFunction()`\r\n\r\n```\r\n[ 75%] Building CXX object lib/Dialect/LLHD/Simulator/CMakeFiles/obj.CIRCTLLHDSimEngine.dir/Engine.cpp.o\r\n/home/runner/work/circt/circt/tools/handshake-runner/Simulation.cpp: In function \u2018void executeHandshakeFunction(circt::handshake::FuncOp&, llvm::DenseMap<mlir::Value, llvm::Any>&, llvm::DenseMap<mlir::Value, double>&, std::vector<llvm::Any>&, std::vector<double>&, std::vector<std::vector<llvm::Any> >&, std::vector<double>&)\u2019:\r\n/home/runner/work/circt/circt/tools/handshake-runner/Simulation.cpp:568:27: warning: \u2018time\u2019 may be used uninitialized in this function [-Wmaybe-uninitialized]\r\n       timeMap[out] = time + 1;\r\n```\r\n\r\n\r\n\r\n5. Control reaches end of `handshake::getFIRRTLType`\r\n\r\n```\r\n[ 84%] Building CXX object lib/Conversion/HandshakeToFIRRTL/CMakeFiles/obj.CIRCTHandshakeToFIRRTL.dir/HandshakeToFIRRTL.cpp.o\r\n/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp: In lambda function:\r\n/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp:62:7: warning: control reaches end of non-void function [-Wreturn-type]\r\n       })\r\n```\r\n\r\n6. Control reaches end of `handshake::StdExprBuilder::visitStdExpr()`\r\n\r\n```\r\n/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp: In member function \u2018bool {anonymous}::StdExprBuilder::visitStdExpr(mlir::CmpIOp)\u2019:\r\n/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp:633:1: warning: control reaches end of non-void function [-Wreturn-type]\r\n }\r\n```\r\n \r\n7. `ESIRTLBuilder::declareCosimEndpoint()` defined but not used\r\n```\r\n/home/runner/work/circt/circt/lib/Dialect/ESI/ESIPasses.cpp:190:19: warning: \u2018circt::rtl::RTLModuleExternOp {anonymous}::ESIRTLBuilder::declareCosimEndpoint()\u2019 defined but not used [-Wunused-function]\r\n RTLModuleExternOp ESIRTLBuilder::declareCosimEndpoint() {\r\n                   ^~~~~~~~~~~~~\r\n[ 89%] Built target obj.CIRCTFIRRTLTransforms\r\n```\r\n\r\n8. `FIRParser::parseGetLocation(mlir::Location&)` defined but not used \r\n\r\n```\r\n/home/runner/work/circt/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:268:13: warning: \u2018mlir::ParseResult {anonymous}::FIRParser::parseGetLocation(mlir::Location&)\u2019 defined but not used [-Wunused-function]\r\n ParseResult FIRParser::parseGetLocation(Location &loc) {\r\n             ^~~~~~~~~\r\n/home/runner/work/circt/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:263:13: warning: \u2018mlir::ParseResult {anonymous}::FIRParser::parseGetLocation(llvm::SMLoc&)\u2019 defined but not used [-Wunused-function]\r\n ParseResult FIRParser::parseGetLocation(SMLoc &loc) {\r\n             ^~~~~~~~~\r\nIn file included from /home/runner/work/circt/circt/include/circt/Dialect/SV/SVOps.h:43:0,\r\n                 from /home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:19:\r\n/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc: In static member function \u2018static char circt::sv::CaseZOp::getLetter(circt::sv::CaseZOp::PatternBit, bool)\u2019:\r\n/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc:609:5: warning: control reaches end of non-void function [-Wreturn-type]\r\n     }\r\n```\r\n\r\n9. Various function in Export verilog not used\r\n\r\n```\r\n/home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilogFIRRTL.cpp:961:13: warning: \u2018{anonymous}::SubExprInfo {anonymous}::ExprEmitter::emitUnary(mlir::Operation*, const char*, bool)\u2019 defined but not used [-Wunused-function]\r\n SubExprInfo ExprEmitter::emitUnary(Operation *op, const char *syntax,\r\n             ^~~~~~~~~~~\r\n/home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilogFIRRTL.cpp:940:13: warning: \u2018{anonymous}::SubExprInfo {anonymous}::ExprEmitter::emitVariadic(mlir::Operation*, {anonymous}::VerilogPrecedence, const char*)\u2019 defined but not used [-Wunused-function]\r\n SubExprInfo ExprEmitter::emitVariadic(Operation *op, VerilogPrecedence prec,\r\n             ^~~~~~~~~~~\r\n/home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilogFIRRTL.cpp:875:13: warning: \u2018{anonymous}::SubExprInfo {anonymous}::ExprEmitter::emitBinary(mlir::Operation*, {anonymous}::VerilogPrecedence, const char*, bool)\u2019 defined but not used [-Wunused-function]\r\n SubExprInfo ExprEmitter::emitBinary(Operation *op, VerilogPrecedence prec,\r\n             ^~~~~~~~~~~\r\n```\r\n\r\n9.  Control reaches end of firtool's `processBuffer()`\r\n\r\n```\r\n/home/runner/work/circt/circt/tools/firtool/firtool.cpp: In function \u2018mlir::LogicalResult processBuffer(std::unique_ptr<llvm::MemoryBuffer>, llvm::raw_ostream&)\u2019:\r\n/home/runner/work/circt/circt/tools/firtool/firtool.cpp:173:1: warning: control reaches end of non-void function [-Wreturn-type]\r\n };\r\n```", "code_snippet_01": "In file included from /home/runner/work/circt/circt/include/circt/Dialect/SV/SVOps.h:43:0,\r\n                 from /home/runner/work/circt/circt/lib/Dialect/SV/SVOps.cpp:13:\r\n/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc: In static member function \u2018static char circt::sv::CaseZOp::getLetter(circt::sv::CaseZOp::PatternBit, bool)\u2019:\r\n/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc:609:5: warning: control reaches end of non-void function [-Wreturn-type]\r\n     }", "code_snippet_02": "In file included from /home/runner/work/circt/circt/llvm/install/include/mlir/Support/InterfaceSupport.h:17:0,\r\n                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/StorageUniquerSupport.h:16,\r\n                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/AttributeSupport.h:17,\r\n                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/Attributes.h:12,\r\n                 from /home/runner/work/circt/circt/llvm/install/include/mlir/IR/BuiltinAttributes.h:12,\r\n                 from /home/runner/work/circt/circt/include/circt/Dialect/FIRRTL/FIRRTLDialect.h:17,\r\n                 from /home/runner/work/circt/circt/include/circt/Dialect/FIRRTL/FIRRTLOps.h:16,\r\n                 from /home/runner/work/circt/circt/lib/Dialect/FIRRTL/FIRRTLOps.cpp:13:\r\n/home/runner/work/circt/circt/llvm/install/include/llvm/ADT/DenseMap.h: In function \u2018mlir::LogicalResult verifyMemOp(circt::firrtl::MemOp)\u2019:\r\n/home/runner/work/circt/circt/llvm/install/include/llvm/ADT/DenseMap.h:1165:18: warning: \u2018*((void*)(& portNamesSet)+16).llvm::SmallDenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, 8, llvm::DenseMapInfo<mlir::Attribute>, llvm::detail::DenseSetPair<mlir::Attribute> >::LargeRep::NumBuckets\u2019 may be used uninitialized in this function [-Wmaybe-uninitialized]\r\n     return Small ? InlineBuckets : getLargeRep()->NumBuckets;\r\n            ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/home/runner/work/circt/circt/llvm/install/include/llvm/ADT/DenseMap.h:1156:18: warning: \u2018*((void*)(& portNamesSet)+16).llvm::SmallDenseMap<mlir::Attribute, llvm::detail::DenseSetEmpty, 8, llvm::DenseMapInfo<mlir::Attribute>, llvm::detail::DenseSetPair<mlir::Attribute> >::LargeRep::Buckets\u2019 may be used uninitialized in this function [-Wmaybe-uninitialized]\r\n     return Small ? getInlineBuckets() : getLargeRep()->Buckets;\r\n            ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~", "code_snippet_03": "/home/runner/work/circt/circt/lib/Dialect/FIRRTL/FIRRTLTypes.cpp: In function \u2018mlir::ParseResult parseType(circt::firrtl::FIRRTLType&, mlir::DialectAsmParser&)\u2019:\r\n/home/runner/work/circt/circt/lib/Dialect/FIRRTL/FIRRTLTypes.cpp:148:35: warning: \u2018fieldIntName\u2019 may be used uninitialized in this function [-Wmaybe-uninitialized]\r\n             nameStr = llvm::utostr(fieldIntName);", "code_snippet_04": "[ 75%] Building CXX object lib/Dialect/LLHD/Simulator/CMakeFiles/obj.CIRCTLLHDSimEngine.dir/Engine.cpp.o\r\n/home/runner/work/circt/circt/tools/handshake-runner/Simulation.cpp: In function \u2018void executeHandshakeFunction(circt::handshake::FuncOp&, llvm::DenseMap<mlir::Value, llvm::Any>&, llvm::DenseMap<mlir::Value, double>&, std::vector<llvm::Any>&, std::vector<double>&, std::vector<std::vector<llvm::Any> >&, std::vector<double>&)\u2019:\r\n/home/runner/work/circt/circt/tools/handshake-runner/Simulation.cpp:568:27: warning: \u2018time\u2019 may be used uninitialized in this function [-Wmaybe-uninitialized]\r\n       timeMap[out] = time + 1;", "code_snippet_05": "[ 84%] Building CXX object lib/Conversion/HandshakeToFIRRTL/CMakeFiles/obj.CIRCTHandshakeToFIRRTL.dir/HandshakeToFIRRTL.cpp.o\r\n/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp: In lambda function:\r\n/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp:62:7: warning: control reaches end of non-void function [-Wreturn-type]\r\n       })", "code_snippet_06": "/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp: In member function \u2018bool {anonymous}::StdExprBuilder::visitStdExpr(mlir::CmpIOp)\u2019:\r\n/home/runner/work/circt/circt/lib/Conversion/HandshakeToFIRRTL/HandshakeToFIRRTL.cpp:633:1: warning: control reaches end of non-void function [-Wreturn-type]\r\n }", "code_snippet_07": "/home/runner/work/circt/circt/lib/Dialect/ESI/ESIPasses.cpp:190:19: warning: \u2018circt::rtl::RTLModuleExternOp {anonymous}::ESIRTLBuilder::declareCosimEndpoint()\u2019 defined but not used [-Wunused-function]\r\n RTLModuleExternOp ESIRTLBuilder::declareCosimEndpoint() {\r\n                   ^~~~~~~~~~~~~\r\n[ 89%] Built target obj.CIRCTFIRRTLTransforms", "code_snippet_08": "/home/runner/work/circt/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:268:13: warning: \u2018mlir::ParseResult {anonymous}::FIRParser::parseGetLocation(mlir::Location&)\u2019 defined but not used [-Wunused-function]\r\n ParseResult FIRParser::parseGetLocation(Location &loc) {\r\n             ^~~~~~~~~\r\n/home/runner/work/circt/circt/lib/Dialect/FIRRTL/Import/FIRParser.cpp:263:13: warning: \u2018mlir::ParseResult {anonymous}::FIRParser::parseGetLocation(llvm::SMLoc&)\u2019 defined but not used [-Wunused-function]\r\n ParseResult FIRParser::parseGetLocation(SMLoc &loc) {\r\n             ^~~~~~~~~\r\nIn file included from /home/runner/work/circt/circt/include/circt/Dialect/SV/SVOps.h:43:0,\r\n                 from /home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilog.cpp:19:\r\n/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc: In static member function \u2018static char circt::sv::CaseZOp::getLetter(circt::sv::CaseZOp::PatternBit, bool)\u2019:\r\n/home/runner/work/circt/circt/build_gcc/include/circt/Dialect/SV/SV.h.inc:609:5: warning: control reaches end of non-void function [-Wreturn-type]\r\n     }", "code_snippet_09": "/home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilogFIRRTL.cpp:961:13: warning: \u2018{anonymous}::SubExprInfo {anonymous}::ExprEmitter::emitUnary(mlir::Operation*, const char*, bool)\u2019 defined but not used [-Wunused-function]\r\n SubExprInfo ExprEmitter::emitUnary(Operation *op, const char *syntax,\r\n             ^~~~~~~~~~~\r\n/home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilogFIRRTL.cpp:940:13: warning: \u2018{anonymous}::SubExprInfo {anonymous}::ExprEmitter::emitVariadic(mlir::Operation*, {anonymous}::VerilogPrecedence, const char*)\u2019 defined but not used [-Wunused-function]\r\n SubExprInfo ExprEmitter::emitVariadic(Operation *op, VerilogPrecedence prec,\r\n             ^~~~~~~~~~~\r\n/home/runner/work/circt/circt/lib/Translation/ExportVerilog/ExportVerilogFIRRTL.cpp:875:13: warning: \u2018{anonymous}::SubExprInfo {anonymous}::ExprEmitter::emitBinary(mlir::Operation*, {anonymous}::VerilogPrecedence, const char*, bool)\u2019 defined but not used [-Wunused-function]\r\n SubExprInfo ExprEmitter::emitBinary(Operation *op, VerilogPrecedence prec,\r\n             ^~~~~~~~~~~", "code_snippet_10": "/home/runner/work/circt/circt/tools/firtool/firtool.cpp: In function \u2018mlir::LogicalResult processBuffer(std::unique_ptr<llvm::MemoryBuffer>, llvm::raw_ostream&)\u2019:\r\n/home/runner/work/circt/circt/tools/firtool/firtool.cpp:173:1: warning: control reaches end of non-void function [-Wreturn-type]\r\n };"}, {"number": 701, "title": "[FIRRTL] wire inside always block", "created_at": "2021-03-02T02:20:09Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_a: {inp_b: {inp_j: SInt<11>}, inp_f: SInt<19>}\r\n    reg _tmp6: UInt<25>, clock with: (reset => (reset, UInt<25>(0)))\r\n    _tmp6 <= and(inp_a.inp_b.inp_j, SInt<25>(12345))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:\r\n\r\n```verilog\r\n// skipped defines\r\nmodule top_mod(\r\n  input        clock, reset,\r\n  input [10:0] inp_a_inp_b_inp_j,\r\n  input [18:0] inp_a_inp_f);\r\n\r\n  reg [24:0] _tmp6;\t// a_top_mod.fir:6:5\r\n\r\n  always_ff @(posedge clock) begin\t// a_top_mod.fir:6:5\r\n    if (reset)\t// a_top_mod.fir:6:5\r\n      _tmp6 <= 25'h0;\t// a_top_mod.fir:6:{5,56}\r\n    else\t// a_top_mod.fir:6:5\r\n      wire [24:0] _tmp = {{14{inp_a_inp_b_inp_j[10]}}, inp_a_inp_b_inp_j};\t// a_top_mod.fir:7:14\r\n      _tmp6 <= _tmp & 25'h3039;\t// a_top_mod.fir:7:{11,14,37}\r\n  end // always_ff @(posedge)\r\n  `ifndef SYNTHESIS\t// a_top_mod.fir:6:5\r\n    initial begin\t// a_top_mod.fir:6:5\r\n      `INIT_RANDOM_PROLOG_\t// a_top_mod.fir:6:5\r\n      `ifdef RANDOMIZE_REG_INIT\t// a_top_mod.fir:6:5\r\n        if (~reset)\t// a_top_mod.fir:6:5\r\n          _tmp6 = `RANDOM;\t// a_top_mod.fir:6:5\r\n      `endif\r\n    end // initial\r\n  `endif\r\n  wire [24:0] _tmp = {{14{inp_a_inp_b_inp_j[10]}}, inp_a_inp_b_inp_j};\t// a_top_mod.fir:7:14\r\nendmodule\r\n```\r\n\r\nAn output Verilog has an error, declaring `wire` iside `always_ff` block.\r\n\r\n```verilog\r\n%Error: a_top_mod_new.sv:66:7: syntax error, unexpected wire\r\n   66 |       wire [24:0] _tmp = {{14{inp_a_inp_b_inp_j[10]}}, inp_a_inp_b_inp_j};  \r\n      |       ^~~~\r\n```", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_a: {inp_b: {inp_j: SInt<11>}, inp_f: SInt<19>}\r\n    reg _tmp6: UInt<25>, clock with: (reset => (reset, UInt<25>(0)))\r\n    _tmp6 <= and(inp_a.inp_b.inp_j, SInt<25>(12345))", "code_snippet_02": "// skipped defines\r\nmodule top_mod(\r\n  input        clock, reset,\r\n  input [10:0] inp_a_inp_b_inp_j,\r\n  input [18:0] inp_a_inp_f);\r\n\r\n  reg [24:0] _tmp6;\t// a_top_mod.fir:6:5\r\n\r\n  always_ff @(posedge clock) begin\t// a_top_mod.fir:6:5\r\n    if (reset)\t// a_top_mod.fir:6:5\r\n      _tmp6 <= 25'h0;\t// a_top_mod.fir:6:{5,56}\r\n    else\t// a_top_mod.fir:6:5\r\n      wire [24:0] _tmp = {{14{inp_a_inp_b_inp_j[10]}}, inp_a_inp_b_inp_j};\t// a_top_mod.fir:7:14\r\n      _tmp6 <= _tmp & 25'h3039;\t// a_top_mod.fir:7:{11,14,37}\r\n  end // always_ff @(posedge)\r\n  `ifndef SYNTHESIS\t// a_top_mod.fir:6:5\r\n    initial begin\t// a_top_mod.fir:6:5\r\n      `INIT_RANDOM_PROLOG_\t// a_top_mod.fir:6:5\r\n      `ifdef RANDOMIZE_REG_INIT\t// a_top_mod.fir:6:5\r\n        if (~reset)\t// a_top_mod.fir:6:5\r\n          _tmp6 = `RANDOM;\t// a_top_mod.fir:6:5\r\n      `endif\r\n    end // initial\r\n  `endif\r\n  wire [24:0] _tmp = {{14{inp_a_inp_b_inp_j[10]}}, inp_a_inp_b_inp_j};\t// a_top_mod.fir:7:14\r\nendmodule", "code_snippet_03": "%Error: a_top_mod_new.sv:66:7: syntax error, unexpected wire\r\n   66 |       wire [24:0] _tmp = {{14{inp_a_inp_b_inp_j[10]}}, inp_a_inp_b_inp_j};  \r\n      |       ^~~~"}, {"number": 699, "title": "[FIRRTL] RegReset may have reset values narrower than register", "created_at": "2021-03-01T22:05:54Z", "state": "closed", "labels": "bug", "body": "We aren't handling values narrower than the register being used for reset.  FIRRTL generates these.\r\n```\r\nmodule  {\r\n  firrtl.circuit \"AQS\" {\r\n    firrtl.module @AQS(%clock: !firrtl.clock, %reset: !firrtl.asyncreset) {\r\n      %c0_ui1 = firrtl.constant(0 : ui1) : !firrtl.uint<1>\r\n      %widx_widx_bin = firrtl.regreset %clock, %reset, %c0_ui1 {name = \"widx_widx_bin\"} : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.uint<4>\r\n    }\r\n  }\r\n}\r\n```", "code_snippet_01": "module  {\r\n  firrtl.circuit \"AQS\" {\r\n    firrtl.module @AQS(%clock: !firrtl.clock, %reset: !firrtl.asyncreset) {\r\n      %c0_ui1 = firrtl.constant(0 : ui1) : !firrtl.uint<1>\r\n      %widx_widx_bin = firrtl.regreset %clock, %reset, %c0_ui1 {name = \"widx_widx_bin\"} : (!firrtl.clock, !firrtl.asyncreset, !firrtl.uint<1>) -> !firrtl.uint<4>\r\n    }\r\n  }\r\n}"}, {"number": 690, "title": "module instance with analog port not lowered correctly", "created_at": "2021-02-26T23:16:43Z", "state": "closed", "labels": "bug, FIRRTL", "body": "lowerTypes(analog) -> integer for instances, but modules expecting an inout<integer>\r\ntest case:\r\n```\r\nmodule  {\r\n  firrtl.circuit \"foo\" {\r\n    firrtl.module @bar(%led_0: !firrtl.analog<1>) {\r\n    }\r\n    firrtl.module @foo() {\r\n      %fpga_led_0 = firrtl.instance @bar {name = \"fpga\", portNames = [\"led_0\"]} : !firrtl.analog<1>\r\n   }\r\n  }\r\n}\r\n```\r\nRunning it:\r\n```\r\nandrew@narya:~/src/examples$  ~/src/circt/build/bin/firtool --mlir-disable-threading --lower-to-rtl --enable-lower-types bug.mlir\r\nbug.mlir:6:21: error: 'rtl.instance' op #0 operand type must be '!rtl.inout<i1>', but got 'i1'\r\n      %fpga_led_0 = firrtl.instance @bar {name = \"fpga\", portNames = [\"led_0\"]} : !firrtl.analog<1>\r\n                    ^\r\nbug.mlir:6:21: note: see current operation: \"rtl.instance\"(%0) {instanceName = \"fpga\", moduleName = @bar} : (i1) -> ()\r\nbug.mlir:3:5: note: original module declared here\r\n    firrtl.module @bar(%led_0: !firrtl.analog<1>) {\r\n    ^\r\n```", "code_snippet_01": "module  {\r\n  firrtl.circuit \"foo\" {\r\n    firrtl.module @bar(%led_0: !firrtl.analog<1>) {\r\n    }\r\n    firrtl.module @foo() {\r\n      %fpga_led_0 = firrtl.instance @bar {name = \"fpga\", portNames = [\"led_0\"]} : !firrtl.analog<1>\r\n   }\r\n  }\r\n}", "code_snippet_02": "andrew@narya:~/src/examples$  ~/src/circt/build/bin/firtool --mlir-disable-threading --lower-to-rtl --enable-lower-types bug.mlir\r\nbug.mlir:6:21: error: 'rtl.instance' op #0 operand type must be '!rtl.inout<i1>', but got 'i1'\r\n      %fpga_led_0 = firrtl.instance @bar {name = \"fpga\", portNames = [\"led_0\"]} : !firrtl.analog<1>\r\n                    ^\r\nbug.mlir:6:21: note: see current operation: \"rtl.instance\"(%0) {instanceName = \"fpga\", moduleName = @bar} : (i1) -> ()\r\nbug.mlir:3:5: note: original module declared here\r\n    firrtl.module @bar(%led_0: !firrtl.analog<1>) {\r\n    ^"}, {"number": 682, "title": "Handle Registers in LowerTypes", "created_at": "2021-02-25T20:55:07Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Aggregate *registers* are currently not being lowering in FIRRTL Dialect's type lowering pass. I think this is a straightforward addition of a visitor for wire ops in the pass.\r\n\r\nConsider:\r\n```scala\r\ncircuit Bar :\r\n  module Bar:\r\n    input a: {a: UInt<1>}\r\n    input clk: Clock\r\n    output b: {a: UInt<1>}\r\n\r\n    reg x: {a: UInt<1>}, clk\r\n\r\n    x.a <= a.a\r\n    b.a <= x.a\r\n```\r\n\r\nThis is currently crashing when running:\r\n\r\n```bash\r\ncirct-translate -import-firrtl Bar.fir | circt-opt -pass-pipeline='firrtl.circuit(firrtl.module(firrtl-lower-types))'\r\n```\r\n\r\nWith:\r\n\r\n```\r\nAssertion failed: (entry && \"bundle lowering was not set\"), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 524.\r\n```\r\n\r\nThis is basically the same thing as #680, just split out to potentially expose more parallel work.", "code_snippet_01": "circuit Bar :\r\n  module Bar:\r\n    input a: {a: UInt<1>}\r\n    input clk: Clock\r\n    output b: {a: UInt<1>}\r\n\r\n    reg x: {a: UInt<1>}, clk\r\n\r\n    x.a <= a.a\r\n    b.a <= x.a", "code_snippet_02": "circt-translate -import-firrtl Bar.fir | circt-opt -pass-pipeline='firrtl.circuit(firrtl.module(firrtl-lower-types))'", "code_snippet_03": "Assertion failed: (entry && \"bundle lowering was not set\"), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 524."}, {"number": 681, "title": "module names with keywords aren't renamed in export", "created_at": "2021-02-25T20:45:02Z", "state": "closed", "labels": "bug, good first issue", "body": "for example, rtl-dialect.mlir has a module \"inout\" which isn't allowed."}, {"number": 680, "title": "Handle wires in LowerTypes", "created_at": "2021-02-25T20:41:34Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Aggregate wires are currently not being lowering in FIRRTL Dialect's type lowering pass. I think this is a straightforward addition of a visitor for wire ops in the pass.\r\n\r\nConsider:\r\n```scala\r\ncircuit Foo :\r\n  module Foo:\r\n    input a: {a: UInt<1>}\r\n    output b: {a: UInt<1>}\r\n\r\n    wire x: {a: UInt<1>}\r\n\r\n    x.a <= a.a\r\n    b.a <= x.a\r\n```\r\n\r\nThis is currently crashing when running:\r\n\r\n```bash\r\ncirct-translate -import-firrtl Foo.fir | circt-opt -pass-pipeline='firrtl.circuit(firrtl.module(firrtl-lower-types))'\r\n```\r\n\r\nWith:\r\n\r\n```\r\nAssertion failed: (entry && \"bundle lowering was not set\"), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 524.\r\n```", "code_snippet_01": "circuit Foo :\r\n  module Foo:\r\n    input a: {a: UInt<1>}\r\n    output b: {a: UInt<1>}\r\n\r\n    wire x: {a: UInt<1>}\r\n\r\n    x.a <= a.a\r\n    b.a <= x.a", "code_snippet_02": "circt-translate -import-firrtl Foo.fir | circt-opt -pass-pipeline='firrtl.circuit(firrtl.module(firrtl-lower-types))'", "code_snippet_03": "Assertion failed: (entry && \"bundle lowering was not set\"), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 524."}, {"number": 679, "title": "[FIRRTL] (cat / gt) mismatch", "created_at": "2021-02-25T20:09:00Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 4046\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_h: SInt<0>\r\n    input inp_e: UInt<11>\r\n    output tmp15: UInt<1>\r\n    reg tmp6: UInt<28>, clock\r\n    reg _tmp10: UInt<1>, clock with: (reset => (reset, UInt<1>(0)))\r\n    tmp6 <= cat(SInt<28>(\"h-6de5f19\"), inp_h)\r\n    _tmp10 <= gt(UInt<11>(0), tmp6)\r\n    tmp15 <= _tmp10\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:\r\n\r\n```verilog\r\n// skipped defines\r\nmodule top_mod(\r\n  input         clock, reset,\r\n  input  [10:0] inp_e,\r\n  output        tmp15);\r\n\r\n  reg [27:0] tmp6;\t// a_top_mod.fir:9:5\r\n  reg        _tmp10;\t// a_top_mod.fir:10:5\r\n// skipped ifdefs\r\n  always_ff @(posedge clock)\t// a_top_mod.fir:11:10\r\n    tmp6 <= 28'h921A0E7;\t// a_top_mod.fir:11:{10,17}\r\n  always_ff @(posedge clock) begin\t// a_top_mod.fir:12:12\r\n    if (reset)\t// a_top_mod.fir:12:12\r\n      _tmp10 <= 1'h0;\t// a_top_mod.fir:10:5, :12:15\r\n    else\t// a_top_mod.fir:12:12\r\n      _tmp10 <= 1'h0;\t// a_top_mod.fir:12:{12,15}\r\n  end // always_ff @(posedge)\r\n  assign tmp15 = _tmp10;\t// a_top_mod.fir:3:3\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input         clock,\r\n  input         reset,\r\n  input  [10:0] inp_e,\r\n  output        tmp15\r\n);\r\n// skipped ifdefs\r\n  reg  _tmp10;\r\n  assign tmp15 = _tmp10;\r\n  always @(posedge clock) begin\r\n    if (reset) begin\r\n      _tmp10 <= 1'h0;\r\n    end else begin\r\n      _tmp10 <= 1'h1;\r\n    end\r\n  end\r\n// skipped ifdefs\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nyosys 0\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 1\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 2\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n\r\nLooks like `_tmp10` optimized to the different constant?\r\n", "code_snippet_01": "; seed: 4046\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_h: SInt<0>\r\n    input inp_e: UInt<11>\r\n    output tmp15: UInt<1>\r\n    reg tmp6: UInt<28>, clock\r\n    reg _tmp10: UInt<1>, clock with: (reset => (reset, UInt<1>(0)))\r\n    tmp6 <= cat(SInt<28>(\"h-6de5f19\"), inp_h)\r\n    _tmp10 <= gt(UInt<11>(0), tmp6)\r\n    tmp15 <= _tmp10", "code_snippet_02": "// skipped defines\r\nmodule top_mod(\r\n  input         clock, reset,\r\n  input  [10:0] inp_e,\r\n  output        tmp15);\r\n\r\n  reg [27:0] tmp6;\t// a_top_mod.fir:9:5\r\n  reg        _tmp10;\t// a_top_mod.fir:10:5\r\n// skipped ifdefs\r\n  always_ff @(posedge clock)\t// a_top_mod.fir:11:10\r\n    tmp6 <= 28'h921A0E7;\t// a_top_mod.fir:11:{10,17}\r\n  always_ff @(posedge clock) begin\t// a_top_mod.fir:12:12\r\n    if (reset)\t// a_top_mod.fir:12:12\r\n      _tmp10 <= 1'h0;\t// a_top_mod.fir:10:5, :12:15\r\n    else\t// a_top_mod.fir:12:12\r\n      _tmp10 <= 1'h0;\t// a_top_mod.fir:12:{12,15}\r\n  end // always_ff @(posedge)\r\n  assign tmp15 = _tmp10;\t// a_top_mod.fir:3:3\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input         clock,\r\n  input         reset,\r\n  input  [10:0] inp_e,\r\n  output        tmp15\r\n);\r\n// skipped ifdefs\r\n  reg  _tmp10;\r\n  assign tmp15 = _tmp10;\r\n  always @(posedge clock) begin\r\n    if (reset) begin\r\n      _tmp10 <= 1'h0;\r\n    end else begin\r\n      _tmp10 <= 1'h1;\r\n    end\r\n  end\r\n// skipped ifdefs\r\nendmodule", "code_snippet_04": "yosys 0\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 1\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 2\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 678, "title": "[FIRRTL] (div / reg / add) mismatch", "created_at": "2021-02-25T19:37:30Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 3727\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    output tmp22: SInt<8>\r\n    output _tmp30: UInt<1>\r\n    input tmp6: SInt<1>\r\n    wire tmp7: UInt<1>\r\n    reg _tmp17: UInt<7>, clock\r\n    reg tmp21: UInt<1>, clock with: (reset => (reset, UInt<1>(0)))\r\n    tmp7 <= UInt<1>(0)\r\n    _tmp17 <= div(UInt<7>(\"b1101111\"), tmp7)\r\n    tmp21 <= orr(_tmp17)\r\n    tmp22 <= add(tmp6, asSInt(_tmp17))\r\n    _tmp30 <= tmp21\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:\r\n\r\n```verilog\r\n// skipped defines\r\nmodule top_mod(\r\n  input        clock, reset, tmp6,\r\n  output [7:0] tmp22,\r\n  output       _tmp30);\r\n\r\n  wire       tmp7;\t// a_top_mod.fir:9:5\r\n  reg  [6:0] _tmp17;\t// a_top_mod.fir:10:5\r\n  reg        tmp21;\t// a_top_mod.fir:11:5\r\n\r\n// skipped ifdefs\r\n  assign tmp7 = 1'h0;\t// a_top_mod.fir:11:55, :12:10\r\n  always_ff @(posedge clock)\t// a_top_mod.fir:13:12\r\n    _tmp17 <= 7'h6F / {6'h0, tmp7};\t// a_top_mod.fir:13:{12,15,19}\r\n  wire [6:0] _T = _tmp17;\t// a_top_mod.fir:14:14\r\n  always_ff @(posedge clock) begin\t// a_top_mod.fir:14:11\r\n    if (reset)\t// a_top_mod.fir:14:11\r\n      tmp21 <= 1'h0;\t// a_top_mod.fir:11:{5,55}\r\n    else\t// a_top_mod.fir:14:11\r\n      tmp21 <= |_T;\t// a_top_mod.fir:14:{11,14}\r\n  end // always_ff @(posedge)\r\n  assign tmp22 = {8{tmp6}} + {{1{_T[6]}}, _T};\t// a_top_mod.fir:3:3, :15:14\r\n  assign _tmp30 = tmp21;\t// a_top_mod.fir:3:3\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input        clock,\r\n  input        reset,\r\n  output [7:0] tmp22,\r\n  output       _tmp30,\r\n  input        tmp6\r\n);\r\n// skipped ifdefs\r\n  reg [6:0] _tmp17;\r\n  reg  tmp21;\r\n  wire [6:0] _GEN_0 = {7{tmp6}};\r\n  assign tmp22 = $signed(_GEN_0) + $signed(_tmp17);\r\n  assign _tmp30 = tmp21;\r\n  always @(posedge clock) begin\r\n    _tmp17 <= 7'h6f / 1'h0;\r\n    if (reset) begin\r\n      tmp21 <= 1'h0;\r\n    end else begin\r\n      tmp21 <= |_tmp17;\r\n    end\r\n  end\r\n// skipped ifdefs\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nyosys 0\r\nERROR: Found 9 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 1\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "; seed: 3727\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    output tmp22: SInt<8>\r\n    output _tmp30: UInt<1>\r\n    input tmp6: SInt<1>\r\n    wire tmp7: UInt<1>\r\n    reg _tmp17: UInt<7>, clock\r\n    reg tmp21: UInt<1>, clock with: (reset => (reset, UInt<1>(0)))\r\n    tmp7 <= UInt<1>(0)\r\n    _tmp17 <= div(UInt<7>(\"b1101111\"), tmp7)\r\n    tmp21 <= orr(_tmp17)\r\n    tmp22 <= add(tmp6, asSInt(_tmp17))\r\n    _tmp30 <= tmp21", "code_snippet_02": "// skipped defines\r\nmodule top_mod(\r\n  input        clock, reset, tmp6,\r\n  output [7:0] tmp22,\r\n  output       _tmp30);\r\n\r\n  wire       tmp7;\t// a_top_mod.fir:9:5\r\n  reg  [6:0] _tmp17;\t// a_top_mod.fir:10:5\r\n  reg        tmp21;\t// a_top_mod.fir:11:5\r\n\r\n// skipped ifdefs\r\n  assign tmp7 = 1'h0;\t// a_top_mod.fir:11:55, :12:10\r\n  always_ff @(posedge clock)\t// a_top_mod.fir:13:12\r\n    _tmp17 <= 7'h6F / {6'h0, tmp7};\t// a_top_mod.fir:13:{12,15,19}\r\n  wire [6:0] _T = _tmp17;\t// a_top_mod.fir:14:14\r\n  always_ff @(posedge clock) begin\t// a_top_mod.fir:14:11\r\n    if (reset)\t// a_top_mod.fir:14:11\r\n      tmp21 <= 1'h0;\t// a_top_mod.fir:11:{5,55}\r\n    else\t// a_top_mod.fir:14:11\r\n      tmp21 <= |_T;\t// a_top_mod.fir:14:{11,14}\r\n  end // always_ff @(posedge)\r\n  assign tmp22 = {8{tmp6}} + {{1{_T[6]}}, _T};\t// a_top_mod.fir:3:3, :15:14\r\n  assign _tmp30 = tmp21;\t// a_top_mod.fir:3:3\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input        clock,\r\n  input        reset,\r\n  output [7:0] tmp22,\r\n  output       _tmp30,\r\n  input        tmp6\r\n);\r\n// skipped ifdefs\r\n  reg [6:0] _tmp17;\r\n  reg  tmp21;\r\n  wire [6:0] _GEN_0 = {7{tmp6}};\r\n  assign tmp22 = $signed(_GEN_0) + $signed(_tmp17);\r\n  assign _tmp30 = tmp21;\r\n  always @(posedge clock) begin\r\n    _tmp17 <= 7'h6f / 1'h0;\r\n    if (reset) begin\r\n      tmp21 <= 1'h0;\r\n    end else begin\r\n      tmp21 <= |_tmp17;\r\n    end\r\n  end\r\n// skipped ifdefs\r\nendmodule", "code_snippet_04": "yosys 0\r\nERROR: Found 9 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 1\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 672, "title": "[FIRRTL] (rem / eq) mismatch", "created_at": "2021-02-25T06:55:18Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input tmp22: UInt<5>\r\n    output _tmp23: UInt<1>\r\n    wire tmp16: SInt<2>\r\n    tmp16 <= rem(SInt<2>(\"o-1\"), SInt<14>(\"o16271\"))\r\n    _tmp23 <= eq(tmp22, asUInt(tmp16))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:\r\n\r\n```verilog\r\n// skipped defines\r\nmodule top_mod(\r\n  input  [4:0] tmp22,\r\n  output       _tmp23);\r\n\r\n  wire [1:0] tmp16;\t// a_top_mod.fir:6:5\r\n\r\n  wire [13:0] _T = -14'sh1 % 14'sh1CB9;\t// a_top_mod.fir:7:{14,34}\r\n  assign tmp16 = _T[1:0];\t// a_top_mod.fir:7:{11,14}\r\n  assign _tmp23 = tmp22 == {3'h0, tmp16};\t// a_top_mod.fir:3:3, :8:15\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [4:0] tmp22,\r\n  output       _tmp23\r\n);\r\n  wire [13:0] _GEN_0 = -14'sh1 % 14'sh1cb9;\r\n  wire [13:0] _GEN_1 = _GEN_0;\r\n  assign _tmp23 = tmp22 == _GEN_1;\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nyosys 0\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 1\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 2\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 3\r\nERROR: Called with -verify and proof did fail!\r\nyosys 4\r\nERROR: Called with -verify and proof did fail!\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input tmp22: UInt<5>\r\n    output _tmp23: UInt<1>\r\n    wire tmp16: SInt<2>\r\n    tmp16 <= rem(SInt<2>(\"o-1\"), SInt<14>(\"o16271\"))\r\n    _tmp23 <= eq(tmp22, asUInt(tmp16))", "code_snippet_02": "// skipped defines\r\nmodule top_mod(\r\n  input  [4:0] tmp22,\r\n  output       _tmp23);\r\n\r\n  wire [1:0] tmp16;\t// a_top_mod.fir:6:5\r\n\r\n  wire [13:0] _T = -14'sh1 % 14'sh1CB9;\t// a_top_mod.fir:7:{14,34}\r\n  assign tmp16 = _T[1:0];\t// a_top_mod.fir:7:{11,14}\r\n  assign _tmp23 = tmp22 == {3'h0, tmp16};\t// a_top_mod.fir:3:3, :8:15\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [4:0] tmp22,\r\n  output       _tmp23\r\n);\r\n  wire [13:0] _GEN_0 = -14'sh1 % 14'sh1cb9;\r\n  wire [13:0] _GEN_1 = _GEN_0;\r\n  assign _tmp23 = tmp22 == _GEN_1;\r\nendmodule", "code_snippet_04": "yosys 0\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 1\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 2\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 3\r\nERROR: Called with -verify and proof did fail!\r\nyosys 4\r\nERROR: Called with -verify and proof did fail!"}, {"number": 671, "title": "[FIRRTL] (rem / mux) mismatch", "created_at": "2021-02-25T05:17:47Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input tmp13: SInt<11>\r\n    output tmp28: UInt<26>\r\n    input _tmp24: UInt<1>\r\n    input tmp25: UInt<26>\r\n    wire tmp18: SInt<11>\r\n    tmp18 <= rem(tmp13, asSInt(UInt<24>(9972122)))\r\n    tmp28 <= mux(tail(asUInt(tmp18), 10), tmp25, _tmp24)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types` produces this Verilog:\r\n\r\n```verilog\r\n// skipped defines\r\nmodule top_mod(\r\n  input  [10:0] tmp13,\r\n  input         _tmp24,\r\n  input  [25:0] tmp25,\r\n  output [25:0] tmp28);\r\n\r\n  wire [10:0] tmp18;\t// a_top_mod.fir:7:5\r\n\r\n  wire [23:0] _T = $signed({{13{tmp13[10]}}, tmp13}) % -24'sh67D666;\t// a_top_mod.fir:8:{14,25}\r\n  assign tmp18 = _T[10:0];\t// a_top_mod.fir:8:{11,14}\r\n  wire [10:0] _T_0 = tmp18;\t// a_top_mod.fir:9:18\r\n  assign tmp28 = _T_0[0] ? tmp25 : {25'h0, _tmp24};\t// a_top_mod.fir:2:3, :9:{14,18}\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT --dont-fold div` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [10:0] tmp13,\r\n  output [25:0] tmp28,\r\n  input         _tmp24,\r\n  input  [25:0] tmp25\r\n);\r\n  wire [23:0] _GEN_0 = {{13{tmp13[10]}},tmp13};\r\n  wire [23:0] _GEN_1 = $signed(_GEN_0) % -24'sh67d666;\r\n  assign tmp28 = _GEN_1[13:0] ? tmp25 : {{25'd0}, _tmp24};\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nyosys 0\r\nERROR: Found 26 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 1\r\nERROR: Found 26 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 2\r\nERROR: Found 26 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 3\r\nERROR: Called with -verify and proof did fail!\r\nyosys 4\r\nERROR: Called with -verify and proof did fail!\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input tmp13: SInt<11>\r\n    output tmp28: UInt<26>\r\n    input _tmp24: UInt<1>\r\n    input tmp25: UInt<26>\r\n    wire tmp18: SInt<11>\r\n    tmp18 <= rem(tmp13, asSInt(UInt<24>(9972122)))\r\n    tmp28 <= mux(tail(asUInt(tmp18), 10), tmp25, _tmp24)", "code_snippet_02": "// skipped defines\r\nmodule top_mod(\r\n  input  [10:0] tmp13,\r\n  input         _tmp24,\r\n  input  [25:0] tmp25,\r\n  output [25:0] tmp28);\r\n\r\n  wire [10:0] tmp18;\t// a_top_mod.fir:7:5\r\n\r\n  wire [23:0] _T = $signed({{13{tmp13[10]}}, tmp13}) % -24'sh67D666;\t// a_top_mod.fir:8:{14,25}\r\n  assign tmp18 = _T[10:0];\t// a_top_mod.fir:8:{11,14}\r\n  wire [10:0] _T_0 = tmp18;\t// a_top_mod.fir:9:18\r\n  assign tmp28 = _T_0[0] ? tmp25 : {25'h0, _tmp24};\t// a_top_mod.fir:2:3, :9:{14,18}\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [10:0] tmp13,\r\n  output [25:0] tmp28,\r\n  input         _tmp24,\r\n  input  [25:0] tmp25\r\n);\r\n  wire [23:0] _GEN_0 = {{13{tmp13[10]}},tmp13};\r\n  wire [23:0] _GEN_1 = $signed(_GEN_0) % -24'sh67d666;\r\n  assign tmp28 = _GEN_1[13:0] ? tmp25 : {{25'd0}, _tmp24};\r\nendmodule", "code_snippet_04": "yosys 0\r\nERROR: Found 26 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 1\r\nERROR: Found 26 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 2\r\nERROR: Found 26 unproven $equiv cells in 'equiv_status -assert'.\r\nyosys 3\r\nERROR: Called with -verify and proof did fail!\r\nyosys 4\r\nERROR: Called with -verify and proof did fail!"}, {"number": 669, "title": "MemOp with readwrite ports not lowered", "created_at": "2021-02-24T22:31:11Z", "state": "closed", "labels": "bug, FIRRTL", "body": "from firtool:\r\n```\r\nfoo.mlir:1759866:79: error: 'firrtl.mem' op readwrite ports should be lowered into separate read and write ports by previous passes\r\n```", "code_snippet_01": "foo.mlir:1759866:79: error: 'firrtl.mem' op readwrite ports should be lowered into separate read and write ports by previous passes"}, {"number": 668, "title": "ExportVerilog not splitting line for long variadic ops", "created_at": "2021-02-24T22:17:37Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Not splitting single expressions which are long.\r\n```\r\n    %3844 = comb.or %3233, %3234, %3235, %3236, %3237, %3238, %3240, %3241, %3242, %3243, %3244, %3245, %3246, %3247, %3248, %3249, %3250, %3251, %3252, %3253, %3254, %3255, %3256, %3257, %3258, %3259, %3260, %3261, %3263, %3264, %3265, %3267, %3268, %3269, %3270, %3271, %3272, %3273, %3274, %3275, %3276, %3277, %3278, %3279, %3280, %3281, %3282, %3283, %3284, %3285, %3286, %3288, %3290, %3291, %3292, %3293, %3294, %3295, %3296, %3297, %3298, %3299, %3300, %3301, %3302, %3303, %3304, %3305, %3306, %3307, %3308, %3309, %3310, %3311, %3312, %3313, %3314, %3315, %3316, %3317, %3319, %3320, %3321, %3322, %3323, %3324, %3325, %3326, %3327, %3328, %3329, %3330, %3331, %3332, %3333, %3334, %3335, %3336, %3338, %3339, %3340, %3341, %3342, %3343, %3344, %3345, %3346, %3347, %3349, %3350, %3351, %3352, %3353, %3354, %3355, %3356, %3357, %3358, %3359, %3360, %3362, %3363, %3364, %3365, %3366, %3367, %3368, %3369, %3370, %3371, %3372, %3373, %3374, %3375, %3376, %3377, %3378, %3379, %3380, %3381, %3382, %3383, %3384, %3385, %3386, %3387, %3388, %3390, %3391, %3392, %3393, %3394, %3395, %3396, %3397, %3398, %3399, %3400, %3401, %3402, %3403, %3404, %3405, %3406, %3407, %3408, %3409, %3411, %3412, %3413, %3414, %3415, %3416, %3417, %3418, %3419, %3420, %3421, %3422, %3423, %3424, %3425, %3426, %3427, %3428, %3429, %3430, %3431, %3432, %3433, %3434, %3435, %3436, %3437, %3438, %3439, %3440, %3441, %3442, %3444, %3446, %3447, %3448, %3449, %3450, %3451, %3452, %3453, %3455, %3456, %3457, %3458, %3459, %3460, %3461, %3462, %3463, %3464, %3465, %3466, %3467, %3468, %3469, %3470, %3471, %3472, %3473, %3474, %3475, %3476, %3477, %3478, %3479, %3480, %3481, %3482, %3483, %3484, %3485, %3486, %3487, %3488, %3489, %3490, %3491, %3492, %3493, %3494, %3495, %3496, %3497, %3498, %3499, %3500, %3501, %3502, %3503, %3504, %3505, %3506, %3507, %3508, %3509, %3510, %3511, %3512, %3513, %3514, %3515, %3516, %3517, %3518, %3519, %3520, %3521, %3522, %3523, %3524, %3525, %3526, %3527, %3528, %3529, %3530, %3531, %3532, %3533, %3534, %3535, %3536, %3537, %3538, %3539, %3540, %3541, %3542, %3543, %3544, %3545, %3546, %3547, %3548, %3549, %3550, %3551, %3552, %3553, %3554, %3555, %3556, %3557, %3558, %3559, %3560, %3561, %3562, %3563, %3564, %3565, %3566, %3567, %3568, %3569, %3570, %3571, %3572, %3573, %3574, %3575, %3576, %3577, %3578, %3579, %3580, %3581, %3583, %3584, %3585, %3586, %3588, %3589, %3590, %3591, %3592, %3593, %3594, %3595, %3596, %3597, %3598, %3599, %3600, %3601, %3602, %3603, %3604, %3605, %3606, %3607, %3608, %3609, %3610, %3611, %3612, %3613, %3614, %3615, %3616, %3617, %3618, %3619, %3620, %3621, %3622, %3623, %3624, %3625, %3626, %3627, %3628, %3629, %3630, %3631, %3632, %3633, %3634, %3635, %3636, %3637, %3638, %3639, %3640, %3641, %3642, %3643, %3644, %3645, %3646, %3647, %3648, %3649, %3650, %3651, %3652, %3653, %3654, %3655, %3656, %3657, %3658, %3659, %3660, %3661, %3662, %3663, %3664, %3665, %3666, %3667, %3668, %3669, %3670, %3671, %3672, %3673, %3674, %3675, %3676, %3677, %3678, %3679, %3680, %3681, %3682, %3683, %3684, %3685, %3686, %3687, %3688, %3689, %3690, %3691, %3692, %3693, %3694, %3695, %3696, %3697, %3698, %3699, %3700, %3701, %3702, %3703, %3704, %3705, %3706, %3707, %3708, %3709, %3710, %3711, %3712, %3713, %3714, %3715, %3716, %3717, %3718, %3719, %3720, %3721, %3722, %3723, %3724, %3725, %3726, %3727, %3728, %3729, %3730, %3731, %3732, %3733, %3734, %3735, %3736, %3737, %3738, %3739, %3740, %3741, %3742, %3743, %3744, %3745, %3746, %3747, %3748, %3749, %3750, %3751, %3752, %3753, %3754, %3755, %3756, %3757, %3758, %3759, %3760, %3761, %3762, %3763, %3764, %3765, %3766, %3767, %3768, %3769, %3770, %3771, %3772, %3773, %3774, %3775, %3776, %3777, %3778, %3779, %3780, %3781, %3782, %3783, %3784, %3785, %3786, %3787, %3788, %3789, %3790, %3791, %3792, %3793, %3794, %3795, %3796, %3797, %3798, %3799, %3800, %3801, %3802, %3803, %3804, %3805, %3806, %3807, %3808, %3809, %3810, %3811, %3812, %3813, %3814, %3815, %3816, %3817, %3818, %3819, %3820, %3821, %3822, %3823, %3824, %3825, %3826, %3827, %3828, %3829, %3830, %3831, %3832, %3833, %3834, %3835, %3836, %3837, %3838, %3840, %3841, %3842, %3843 : i1\r\n```\r\nMakes something like:\r\n\r\n```\r\n  wire _T_361 = _T_180 ? _T_181 == 64'h63\r\n| _T_181 == 64'h1063\r\n| _T_181 == 64'h4063\r\n| _T_181 == 64'h6063\r\n| _T_181 == 64'h5063\r\n| _T_181 == 64'h7063\r\n| _T_182 == 64'h6F\r\n| _T_181 == 64'h67\r\n| _T_181 == 64'h3\r\n| _T_181 == 64'h4003\r\n| _T_181 == 64'h1003\r\n| _T_181 == 64'h5003\r\n| _T_181 == 64'h2003\r\n| _T_181 == 64'h6003\r\n| _T_181 == 64'h3003\r\n| _T_181 == 64'h23\r\n| _T_181 == 64'h1023\r\n| _T_181 == 64'h2023\r\n| _T_181 == 64'h3023\r\n| _T_182 == 64'h37\r\n| _T_182 == 64'h17\r\n| _T_181 == 64'h13\r\n| _T_181 == 64'h2013\r\n| _T_181 == 64'h3013\r\n| _T_181 == 64'h7013\r\n| _T_181 == 64'h6013\r\n| _T_181 == 64'h4013\r\n| _T_181 == 64'h1B\r\n| _T_183 == 64'h101B\r\n| _T_183 == 64'h501B\r\n| _T_183 == 64'h4000501B\r\n| _T_184 == 64'h1013\r\n| _T_184 == 64'h5013\r\n| _T_184 == 64'h40005013\r\n| _T_183 == 64'h33\r\n| _T_183 == 64'h40000033\r\n| _T_183 == 64'h2033\r\n| _T_183 == 64'h3033\r\n| _T_183 == 64'h7033\r\n| _T_183 == 64'h6033\r\n| _T_183 == 64'h4033\r\n| _T_183 == 64'h1033\r\n| _T_183 == 64'h5033\r\n| _T_183 == 64'h40005033\r\n| _T_183 == 64'h3B\r\n| _T_183 == 64'h4000003B\r\n| _T_183 == 64'h103B\r\n| _T_183 == 64'h503B\r\n| _T_183 == 64'h4000503B\r\n| _T_181 == 64'hF\r\n| _T_181 == 64'h100F\r\n| (io_fetch_bits_data & 64'hFE007FFF) == 64'h12000073\r\n| _T_185 == 64'hFC000073\r\n| _T_185 == 64'hFC200073\r\n| _T_181 == 64'h5073\r\n| _T_181 == 64'h6073\r\n| _T_181 == 64'h7073\r\n| _T_185 == 64'h73\r\n| _T_185 == 64'h100073\r\n| _T_185 == 64'h30200073\r\n| _T_185 == 64'h10500073\r\n| _T_185 == 64'h30500073\r\n| _T_181 == 64'h1073\r\n| _T_181 == 64'h2073\r\n| _T_181 == 64'h3073\r\n| _T_185 == 64'h10200073\r\n| _T_185 == 64'h7B200073\r\n| _T_183 == 64'h2000033\r\n| _T_183 == 64'h2001033\r\n| _T_183 == 64'h2003033\r\n| _T_183 == 64'h2002033\r\n| _T_183 == 64'h200003B\r\n| _T_183 == 64'h2004033\r\n| _T_183 == 64'h2005033\r\n| _T_183 == 64'h2006033\r\n| _T_183 == 64'h2007033\r\n| _T_183 == 64'h200403B\r\n| _T_183 == 64'h200503B\r\n| _T_183 == 64'h200603B\r\n| _T_183 == 64'h200703B\r\n| _T_186 == 64'h202F\r\n| _T_186 == 64'h6000202F\r\n| _T_186 == 64'h4000202F\r\n| _T_186 == 64'h2000202F\r\n| _T_186 == 64'h8000202F\r\n| _T_186 == 64'hA000202F\r\n| _T_186 == 64'hC000202F\r\n| _T_186 == 64'hE000202F\r\n| _T_186 == 64'h800202F\r\n| _T_186 == 64'h302F\r\n| _T_186 == 64'h6000302F\r\n| _T_186 == 64'h4000302F\r\n| _T_186 == 64'h2000302F\r\n| _T_186 == 64'h8000302F\r\n| _T_186 == 64'hA000302F\r\n| _T_186 == 64'hC000302F\r\n| _T_186 == 64'hE000302F\r\n| _T_186 == 64'h800302F\r\n| _T_187 == 64'h1000202F\r\n| _T_186 == 64'h1800202F\r\n| _T_187 == 64'h1000302F\r\n| _T_186 == 64'h1800302F\r\n| _T_181 == 64'h1027\r\n| _T_181 == 64'h2027\r\n| _T_181 == 64'h3027\r\n| _T_181 == 64'h1007\r\n| _T_181 == 64'h2007\r\n| _T_181 == 64'h3007\r\n| _T_188 == 64'h4000043\r\n| _T_188 == 64'h4000047\r\n| _T_188 == 64'h400004B\r\n| _T_188 == 64'h400004F\r\n| _T_188 == 64'h43\r\n| _T_188 == 64'h47\r\n| _T_188 == 64'h4B\r\n| _T_188 == 64'h4F\r\n| _T_188 == 64'h2000043\r\n| _T_188 == 64'h2000047\r\n| _T_188 == 64'h200004B\r\n| _T_188 == 64'h200004F\r\n| _T_189 == 64'h4000053\r\n| _T_189 == 64'hC000053\r\n| _T_189 == 64'h14000053\r\n| _T_189 == 64'h1C000053\r\n| _T_183 == 64'h24000053\r\n| _T_183 == 64'h24001053\r\n| _T_183 == 64'h24002053\r\n| _T_183 == 64'h2C000053\r\n| _T_183 == 64'h2C001053\r\n| _T_189 == 64'h53\r\n| _T_189 == 64'h8000053\r\n| _T_189 == 64'h10000053\r\n| _T_189 == 64'h18000053\r\n| _T_183 == 64'h20000053\r\n| _T_183 == 64'h20001053\r\n| _T_183 == 64'h20002053\r\n| _T_183 == 64'h28000053\r\n| _T_183 == 64'h28001053\r\n| _T_189 == 64'h2000053\r\n| _T_189 == 64'hA000053\r\n| _T_189 == 64'h12000053\r\n| _T_189 == 64'h1A000053\r\n| _T_183 == 64'h22000053\r\n| _T_183 == 64'h22001053\r\n| _T_183 == 64'h22002053\r\n| _T_183 == 64'h2A000053\r\n| _T_183 == 64'h2A001053\r\n| _T_190 == 64'h5C000053\r\n| _T_190 == 64'h44000053\r\n| _T_190 == 64'h40200053\r\n| _T_190 == 64'h58000053\r\n| _T_190 == 64'h5A000053\r\n| _T_190 == 64'h40100053\r\n| _T_190 == 64'h42000053\r\n| _T_190 == 64'h44100053\r\n| _T_190 == 64'h42200053\r\n| _T_183 == 64'hA4002053\r\n| _T_183 == 64'hA4001053\r\n| _T_183 == 64'hA4000053\r\n| _T_183 == 64'hA0002053\r\n| _T_183 == 64'hA0001053\r\n| _T_183 == 64'hA0000053\r\n| _T_183 == 64'hA2002053\r\n| _T_183 == 64'hA2001053\r\n| _T_183 == 64'hA2000053\r\n| _T_190 == 64'hC4000053\r\n| _T_190 == 64'hC4100053\r\n| _T_191 == 64'hE4001053\r\n| _T_190 == 64'hC4200053\r\n| _T_190 == 64'hC4300053\r\n| _T_190 == 64'hC0000053\r\n| _T_190 == 64'hC0100053\r\n| _T_191 == 64'hE0001053\r\n| _T_190 == 64'hC0200053\r\n| _T_190 == 64'hC0300053\r\n| _T_190 == 64'hC2000053\r\n| _T_190 == 64'hC2100053\r\n| _T_191 == 64'hE2001053\r\n| _T_190 == 64'hC2200053\r\n| _T_190 == 64'hC2300053\r\n| _T_191 == 64'hE4000053\r\n| _T_191 == 64'hE0000053\r\n| _T_191 == 64'hE2000053\r\n| _T_191 == 64'hF4000053\r\n| _T_191 == 64'hF0000053\r\n| _T_191 == 64'hF2000053\r\n| _T_190 == 64'hD4000053\r\n| _T_190 == 64'hD4100053\r\n| _T_190 == 64'hD4200053\r\n| _T_190 == 64'hD4300053\r\n| _T_190 == 64'hD0000053\r\n| _T_190 == 64'hD0100053\r\n| _T_190 == 64'hD0200053\r\n| _T_190 == 64'hD0300053\r\n| _T_190 == 64'hD2000053\r\n| _T_190 == 64'hD2100053\r\n| _T_190 == 64'hD2200053\r\n| _T_190 == 64'hD2300053\r\n| _T_183 == 64'h80007057\r\n| (io_fetch_bits_data & 64'h8000707F) == 64'h7057\r\n| _T_192 == 64'h7\r\n| _T_192 == 64'h5007\r\n| _T_192 == 64'h6007\r\n| _T_192 == 64'h7007\r\n| _T_192 == 64'h1000007\r\n| _T_192 == 64'h1005007\r\n| _T_192 == 64'h1006007\r\n| _T_192 == 64'h1007007\r\n| _T_193 == 64'hC000007\r\n| _T_193 == 64'hC005007\r\n| _T_193 == 64'hC006007\r\n| _T_191 == 64'h2800007\r\n| _T_191 == 64'h2805007\r\n| _T_191 == 64'h2806007\r\n| _T_191 == 64'h2807007\r\n| _T_191 == 64'h22800007\r\n| _T_191 == 64'h22805007\r\n| _T_191 == 64'h22806007\r\n| _T_191 == 64'h22807007\r\n| _T_191 == 64'h62800007\r\n| _T_191 == 64'h62805007\r\n| _T_191 == 64'h62806007\r\n| _T_191 == 64'h62807007\r\n| _T_191 == 64'hE2800007\r\n| _T_191 == 64'hE2805007\r\n| _T_191 == 64'hE2806007\r\n| _T_191 == 64'hE2807007\r\n| _T_193 == 64'hC007007\r\n| _T_192 == 64'h27\r\n| _T_192 == 64'h5027\r\n| _T_192 == 64'h6027\r\n| _T_192 == 64'h7027\r\n| _T_193 == 64'hC000027\r\n| _T_193 == 64'hC005027\r\n| _T_193 == 64'hC006027\r\n| _T_184 == 64'h4000027\r\n| _T_184 == 64'h4005027\r\n| _T_184 == 64'h4006027\r\n| _T_191 == 64'h2800027\r\n| _T_191 == 64'h22800027\r\n| _T_191 == 64'h62800027\r\n| _T_191 == 64'hE2800027\r\n| _T_193 == 64'hC007027\r\n| _T_184 == 64'h4007027\r\n| _T_186 == 64'h800002F\r\n| _T_186 == 64'h2F\r\n| _T_186 == 64'h2000002F\r\n| _T_186 == 64'h6000002F\r\n| _T_186 == 64'h4000002F\r\n| _T_186 == 64'h8000002F\r\n| _T_186 == 64'hA000002F\r\n| _T_186 == 64'hC000002F\r\n| _T_186 == 64'hE000002F\r\n| _T_186 == 64'h800502F\r\n| _T_186 == 64'h502F\r\n| _T_186 == 64'h2000502F\r\n| _T_186 == 64'h6000502F\r\n| _T_186 == 64'h4000502F\r\n| _T_186 == 64'h8000502F\r\n| _T_186 == 64'hA000502F\r\n| _T_186 == 64'hC000502F\r\n| _T_186 == 64'hE000502F\r\n| _T_186 == 64'h800602F\r\n| _T_186 == 64'h602F\r\n| _T_186 == 64'h2000602F\r\n| _T_186 == 64'h6000602F\r\n| _T_186 == 64'h4000602F\r\n| _T_186 == 64'h8000602F\r\n| _T_186 == 64'hA000602F\r\n| _T_186 == 64'hC000602F\r\n| _T_186 == 64'hE000602F\r\n| _T_186 == 64'h800702F\r\n| _T_186 == 64'h702F\r\n| _T_186 == 64'h2000702F\r\n| _T_186 == 64'h6000702F\r\n| _T_186 == 64'h4000702F\r\n| _T_186 == 64'h8000702F\r\n| _T_186 == 64'hA000702F\r\n| _T_186 == 64'hC000702F\r\n| _T_186 == 64'hE000702F\r\n| _T_193 == 64'h8000007\r\n| _T_193 == 64'h8005007\r\n| _T_193 == 64'h8006007\r\n| _T_193 == 64'h8007007\r\n| _T_193 == 64'h8000027\r\n| _T_193 == 64'h8005027\r\n| _T_193 == 64'h8006027\r\n| _T_193 == 64'h8007027\r\n| _T_184 == 64'h2057\r\n| _T_184 == 64'hC4000057\r\n| _T_184 == 64'hC0000057\r\n| _T_184 == 64'h4002057\r\n| _T_184 == 64'h8002057\r\n| _T_184 == 64'hC002057\r\n| _T_184 == 64'h10002057\r\n| _T_184 == 64'h14002057\r\n| _T_184 == 64'h18002057\r\n| _T_184 == 64'h1C002057\r\n| _T_184 == 64'h57\r\n| _T_184 == 64'h8000057\r\n| _T_183 == 64'h40000057\r\n| _T_184 == 64'h44000057\r\n| _T_183 == 64'h48000057\r\n| _T_184 == 64'h4C000057\r\n| _T_184 == 64'h94000057\r\n| _T_184 == 64'hA0000057\r\n| _T_184 == 64'hA4000057\r\n| _T_184 == 64'hB0000057\r\n| _T_184 == 64'hB4000057\r\n| _T_184 == 64'h24000057\r\n| _T_184 == 64'h28000057\r\n| _T_184 == 64'h2C000057\r\n| _T_184 == 64'h60000057\r\n| _T_184 == 64'h64000057\r\n| _T_184 == 64'h6C000057\r\n| _T_184 == 64'h68000057\r\n| _T_184 == 64'h70000057\r\n| _T_184 == 64'h74000057\r\n| _T_184 == 64'h10000057\r\n| _T_184 == 64'h14000057\r\n| _T_184 == 64'h18000057\r\n| _T_184 == 64'h1C000057\r\n| _T_184 == 64'h30000057\r\n| _T_184 == 64'h38000057\r\n| _T_183 == 64'h5E002057\r\n| _T_183 == 64'h5C000057\r\n| _T_191 == 64'h5E000057\r\n| _T_184 == 64'h60002057\r\n| _T_184 == 64'h64002057\r\n| _T_184 == 64'h68002057\r\n| _T_184 == 64'h6C002057\r\n| _T_184 == 64'h70002057\r\n| _T_184 == 64'h74002057\r\n| _T_184 == 64'h78002057\r\n| _T_184 == 64'h7C002057\r\n| _T_194 == 64'h5000A057\r\n| _T_194 == 64'h50012057\r\n| _T_194 == 64'h5001A057\r\n| _T_194 == 64'h50082057\r\n| (io_fetch_bits_data & 64'hFDFFF07F) == 64'h5008A057\r\n| _T_194 == 64'h48032057\r\n| _T_194 == 64'h4803A057\r\n| _T_194 == 64'h48022057\r\n| _T_194 == 64'h4802A057\r\n| _T_194 == 64'h48012057\r\n| _T_194 == 64'h4801A057\r\n| _T_184 == 64'hC4002057\r\n| _T_184 == 64'hC0002057\r\n| _T_184 == 64'hCC002057\r\n| _T_184 == 64'hC8002057\r\n| _T_184 == 64'hD4002057\r\n| _T_184 == 64'hD0002057\r\n| _T_184 == 64'hDC002057\r\n| _T_184 == 64'hD8002057\r\n| _T_184 == 64'hEC002057\r\n| _T_184 == 64'hE0002057\r\n| _T_184 == 64'hE8002057\r\n| _T_184 == 64'hF0002057\r\n| _T_184 == 64'hF4002057\r\n| _T_184 == 64'hFC002057\r\n| _T_184 == 64'h94002057\r\n| _T_184 == 64'h9C002057\r\n| _T_184 == 64'h90002057\r\n| _T_184 == 64'h98002057\r\n| _T_184 == 64'h84002057\r\n| _T_184 == 64'h80002057\r\n| _T_184 == 64'h8C002057\r\n| _T_184 == 64'h88002057\r\n| _T_184 == 64'hA4002057\r\n| _T_184 == 64'hAC002057\r\n| _T_184 == 64'hB4002057\r\n| _T_184 == 64'hBC002057\r\n| _T_184 == 64'h24002057\r\n| _T_184 == 64'h2C002057\r\n| _T_184 == 64'h20002057\r\n| _T_184 == 64'h28002057\r\n| _T_184 == 64'h84000057\r\n| _T_184 == 64'h8C000057\r\n| _T_184 == 64'h80000057\r\n| _T_184 == 64'h88000057\r\n| _T_184 == 64'h9C000057\r\n| _T_184 == 64'hA8000057\r\n| _T_184 == 64'hAC000057\r\n| _T_184 == 64'hBC000057\r\n| _T_184 == 64'hB8000057\r\n| _T_184 == 64'h4001057\r\n| _T_184 == 64'hC4001057\r\n| _T_184 == 64'hC001057\r\n| _T_184 == 64'hCC001057\r\n| _T_184 == 64'h14001057\r\n| _T_184 == 64'h1C001057\r\n| _T_194 == 64'h4C081057\r\n| _T_184 == 64'h10001057\r\n| _T_184 == 64'h18001057\r\n| _T_184 == 64'h60001057\r\n| _T_184 == 64'h64001057\r\n| _T_184 == 64'h6C001057\r\n| _T_184 == 64'h70001057\r\n| _T_194 == 64'h48011057\r\n| _T_194 == 64'h48019057\r\n| _T_194 == 64'h48091057\r\n| _T_194 == 64'h48099057\r\n| _T_194 == 64'h480B1057\r\n| _T_194 == 64'h480B9057\r\n| _T_194 == 64'h48081057\r\n| _T_194 == 64'h48089057\r\n| _T_194 == 64'h48051057\r\n| _T_194 == 64'h48059057\r\n| _T_194 == 64'h48071057\r\n| _T_194 == 64'h48079057\r\n| _T_194 == 64'h48041057\r\n| _T_194 == 64'h48049057\r\n| _T_194 == 64'h48031057\r\n| _T_194 == 64'h48039057\r\n| _T_194 == 64'h48001057\r\n| _T_194 == 64'h48009057\r\n| _T_184 == 64'h90001057\r\n| _T_184 == 64'h1057\r\n| _T_184 == 64'h8001057\r\n| _T_194 == 64'h4C001057\r\n| _T_184 == 64'h80001057\r\n| _T_194 == 64'h4C021057\r\n| _T_194 == 64'h4C029057\r\n| _T_184 == 64'hB0001057\r\n| _T_184 == 64'hB4001057\r\n| _T_184 == 64'hB8001057\r\n| _T_184 == 64'hBC001057\r\n| _T_184 == 64'hA0001057\r\n| _T_184 == 64'hA4001057\r\n| _T_184 == 64'hA8001057\r\n| _T_184 == 64'hAC001057\r\n| _T_184 == 64'h20001057\r\n| _T_184 == 64'h24001057\r\n| _T_184 == 64'h28001057\r\n| _T_194 == 64'h480A1057\r\n| _T_194 == 64'h480A9057\r\n| _T_194 == 64'h48061057\r\n| _T_184 == 64'hC0001057\r\n| _T_184 == 64'hC8001057\r\n| _T_184 == 64'hE0001057\r\n| _T_184 == 64'hD0001057\r\n| _T_184 == 64'hD8001057\r\n| _T_184 == 64'hF0001057\r\n| _T_184 == 64'hF4001057\r\n| _T_184 == 64'hF8001057\r\n| _T_184 == 64'hFC001057\r\n| _T_184 == 64'h3057\r\n| _T_183 == 64'h40003057\r\n| _T_184 == 64'h44003057\r\n| _T_184 == 64'hC003057\r\n| _T_184 == 64'h94003057\r\n| _T_184 == 64'hA0003057\r\n| _T_184 == 64'hA4003057\r\n| _T_184 == 64'hB0003057\r\n| _T_184 == 64'hB4003057\r\n| _T_184 == 64'h24003057\r\n| _T_184 == 64'h28003057\r\n| _T_184 == 64'h2C003057\r\n| _T_183 == 64'h9E003057\r\n| _T_184 == 64'h38003057\r\n| _T_184 == 64'h3C003057\r\n| _T_184 == 64'h60003057\r\n| _T_184 == 64'h64003057\r\n| _T_184 == 64'h70003057\r\n| _T_184 == 64'h74003057\r\n| _T_184 == 64'h78003057\r\n| _T_184 == 64'h7C003057\r\n| _T_184 == 64'h30003057\r\n| _T_183 == 64'h5C003057\r\n| _T_191 == 64'h5E003057\r\n| _T_184 == 64'h84003057\r\n| _T_184 == 64'h80003057\r\n| _T_184 == 64'hA8003057\r\n| _T_184 == 64'hAC003057\r\n| _T_184 == 64'hBC003057\r\n| _T_184 == 64'hB8003057\r\n| _T_184 == 64'h4057\r\n| _T_184 == 64'h8004057\r\n| _T_183 == 64'h40004057\r\n| _T_184 == 64'h44004057\r\n| _T_183 == 64'h48004057\r\n| _T_184 == 64'h4C004057\r\n| _T_184 == 64'hC004057\r\n| _T_184 == 64'h94004057\r\n| _T_184 == 64'hA0004057\r\n| _T_184 == 64'hA4004057\r\n| _T_184 == 64'hB0004057\r\n| _T_184 == 64'hB4004057\r\n| _T_184 == 64'h24004057\r\n| _T_184 == 64'h28004057\r\n| _T_184 == 64'h2C004057\r\n| _T_184 == 64'h38004057\r\n| _T_184 == 64'h3C004057\r\n| _T_184 == 64'h38006057\r\n| _T_184 == 64'h3C006057\r\n| _T_184 == 64'h60004057\r\n| _T_184 == 64'h64004057\r\n| _T_184 == 64'h6C004057\r\n| _T_184 == 64'h68004057\r\n| _T_184 == 64'h70004057\r\n| _T_184 == 64'h74004057\r\n| _T_184 == 64'h78004057\r\n| _T_184 == 64'h7C004057\r\n| _T_184 == 64'h10004057\r\n| _T_184 == 64'h14004057\r\n| _T_184 == 64'h18004057\r\n| _T_184 == 64'h1C004057\r\n| _T_184 == 64'h30004057\r\n| _T_183 == 64'h5C004057\r\n| _T_191 == 64'h5E004057\r\n| _T_184 == 64'hC4006057\r\n| _T_184 == 64'hC0006057\r\n| _T_184 == 64'hCC006057\r\n| _T_184 == 64'hC8006057\r\n| _T_184 == 64'hD4006057\r\n| _T_184 == 64'hD0006057\r\n| _T_184 == 64'hDC006057\r\n| _T_184 == 64'hD8006057\r\n| _T_184 == 64'hEC006057\r\n| _T_184 == 64'hE0006057\r\n| _T_184 == 64'hE8006057\r\n| _T_184 == 64'hF0006057\r\n| _T_184 == 64'hF4006057\r\n| _T_184 == 64'hFC006057\r\n| _T_184 == 64'hF8006057\r\n| _T_184 == 64'h94006057\r\n| _T_184 == 64'h9C006057\r\n| _T_184 == 64'h90006057\r\n| _T_184 == 64'h98006057\r\n| _T_184 == 64'h84006057\r\n| _T_184 == 64'h80006057\r\n| _T_184 == 64'h8C006057\r\n| _T_184 == 64'h88006057\r\n| _T_184 == 64'hA4006057\r\n| _T_184 == 64'hAC006057\r\n| _T_184 == 64'hB4006057\r\n| _T_184 == 64'hBC006057\r\n| _T_191 == 64'h42006057\r\n| _T_184 == 64'h24006057\r\n| _T_184 == 64'h2C006057\r\n| _T_184 == 64'h20006057\r\n| _T_184 == 64'h28006057\r\n| _T_184 == 64'h84004057\r\n| _T_184 == 64'h8C004057\r\n| _T_184 == 64'h80004057\r\n| _T_184 == 64'h88004057\r\n| _T_184 == 64'h9C004057\r\n| _T_184 == 64'hA8004057\r\n| _T_184 == 64'hAC004057\r\n| _T_184 == 64'hBC004057\r\n| _T_184 == 64'hB8004057\r\n| _T_184 == 64'h38005057\r\n| _T_184 == 64'h3C005057\r\n| _T_184 == 64'h20005057\r\n| _T_184 == 64'h24005057\r\n| _T_184 == 64'h28005057\r\n| _T_184 == 64'h10005057\r\n| _T_184 == 64'h18005057\r\n| _T_184 == 64'h60005057\r\n| _T_184 == 64'h64005057\r\n| _T_184 == 64'h6C005057\r\n| _T_184 == 64'h70005057\r\n| _T_184 == 64'h74005057\r\n| _T_184 == 64'h7C005057\r\n| _T_183 == 64'h5C005057\r\n| _T_191 == 64'h5E005057\r\n| _T_184 == 64'h90005057\r\n| _T_184 == 64'h5057\r\n| _T_184 == 64'h8005057\r\n| _T_184 == 64'h9C005057\r\n| _T_184 == 64'h80005057\r\n| _T_184 == 64'h84005057\r\n| _T_184 == 64'hB0005057\r\n| _T_184 == 64'hB4005057\r\n| _T_184 == 64'hB8005057\r\n| _T_184 == 64'hBC005057\r\n| _T_184 == 64'hA0005057\r\n| _T_184 == 64'hA4005057\r\n| _T_184 == 64'hA8005057\r\n| _T_184 == 64'hAC005057\r\n| _T_191 == 64'h42005057\r\n| _T_184 == 64'hC0005057\r\n| _T_184 == 64'hC8005057\r\n| _T_184 == 64'hE0005057\r\n| _T_184 == 64'hD0005057\r\n| _T_184 == 64'hD8005057\r\n| _T_184 == 64'hF0005057\r\n| _T_184 == 64'hF4005057\r\n| _T_184 == 64'hF8005057\r\n| _T_184 == 64'hFC005057\r\n| _T_195 == 64'h42002057\r\n| _T_194 == 64'h40082057\r\n| _T_194 == 64'h4008A057\r\n| _T_195 == 64'h42001057 : _T_180 ? _T_343 : _T_345 ? _T_343 : _T_344 ? ((_T_249 ? 1'h1 : _T_248 ? 1'h1 : _T_247 ? 1'h1 : _T_246 ? 1'h1 : _T_245 ? |{_T_223, _T_207} : _T_244 ? 1'h1 : _T_243 ? _T_209 : 1'h1) == 1'h0 ? 1'h0 : _T_277 == 32'h63\r\n| _T_277 == 32'h1063\r\n| _T_277 == 32'h4063\r\n| _T_277 == 32'h6063\r\n| _T_277 == 32'h5063\r\n| _T_277 == 32'h7063\r\n| _T_278 == 32'h6F\r\n| _T_277 == 32'h67\r\n| _T_277 == 32'h3\r\n| _T_277 == 32'h4003\r\n| _T_277 == 32'h1003\r\n| _T_277 == 32'h5003\r\n| _T_277 == 32'h2003\r\n| _T_277 == 32'h6003\r\n| _T_277 == 32'h3003\r\n| _T_277 == 32'h23\r\n| _T_277 == 32'h1023\r\n| _T_277 == 32'h2023\r\n| _T_277 == 32'h3023\r\n| _T_278 == 32'h37\r\n| _T_278 == 32'h17\r\n| _T_277 == 32'h13\r\n| _T_277 == 32'h2013\r\n| _T_277 == 32'h3013\r\n| _T_277 == 32'h7013\r\n| _T_277 == 32'h6013\r\n| _T_277 == 32'h4013\r\n| _T_277 == 32'h1B\r\n| _T_279 == 32'h101B\r\n| _T_279 == 32'h501B\r\n| _T_279 == 32'h4000501B\r\n| _T_280 == 32'h1013\r\n| _T_280 == 32'h5013\r\n| _T_280 == 32'h40005013\r\n| _T_279 == 32'h33\r\n| _T_279 == 32'h40000033\r\n| _T_279 == 32'h2033\r\n| _T_279 == 32'h3033\r\n| _T_279 == 32'h7033\r\n| _T_279 == 32'h6033\r\n| _T_279 == 32'h4033\r\n| _T_279 == 32'h1033\r\n| _T_279 == 32'h5033\r\n| _T_279 == 32'h40005033\r\n| _T_279 == 32'h3B\r\n| _T_279 == 32'h4000003B\r\n| _T_279 == 32'h103B\r\n| _T_279 == 32'h503B\r\n| _T_279 == 32'h4000503B\r\n| _T_277 == 32'hF\r\n| _T_277 == 32'h100F\r\n| (_T_276 & 32'hFE007FFF) == 32'h12000073\r\n| _T_276 == 32'hFC000073\r\n| _T_276 == 32'hFC200073\r\n| _T_277 == 32'h5073\r\n| _T_277 == 32'h6073\r\n| _T_277 == 32'h7073\r\n| _T_276 == 32'h73\r\n| _T_276 == 32'h100073\r\n| _T_276 == 32'h30200073\r\n| _T_276 == 32'h10500073\r\n| _T_276 == 32'h30500073\r\n| _T_277 == 32'h1073\r\n| _T_277 == 32'h2073\r\n| _T_277 == 32'h3073\r\n| _T_276 == 32'h10200073\r\n| _T_276 == 32'h7B200073\r\n| _T_279 == 32'h2000033\r\n| _T_279 == 32'h2001033\r\n| _T_279 == 32'h2003033\r\n| _T_279 == 32'h2002033\r\n| _T_279 == 32'h200003B\r\n| _T_279 == 32'h2004033\r\n| _T_279 == 32'h2005033\r\n| _T_279 == 32'h2006033\r\n| _T_279 == 32'h2007033\r\n| _T_279 == 32'h200403B\r\n| _T_279 == 32'h200503B\r\n| _T_279 == 32'h200603B\r\n| _T_279 == 32'h200703B\r\n| _T_281 == 32'h202F\r\n| _T_281 == 32'h6000202F\r\n| _T_281 == 32'h4000202F\r\n| _T_281 == 32'h2000202F\r\n| _T_281 == 32'h8000202F\r\n| _T_281 == 32'hA000202F\r\n| _T_281 == 32'hC000202F\r\n| _T_281 == 32'hE000202F\r\n| _T_281 == 32'h800202F\r\n| _T_281 == 32'h302F\r\n| _T_281 == 32'h6000302F\r\n| _T_281 == 32'h4000302F\r\n| _T_281 == 32'h2000302F\r\n| _T_281 == 32'h8000302F\r\n| _T_281 == 32'hA000302F\r\n| _T_281 == 32'hC000302F\r\n| _T_281 == 32'hE000302F\r\n| _T_281 == 32'h800302F\r\n| _T_282 == 32'h1000202F\r\n| _T_281 == 32'h1800202F\r\n| _T_282 == 32'h1000302F\r\n| _T_281 == 32'h1800302F\r\n| _T_277 == 32'h1027\r\n| _T_277 == 32'h2027\r\n| _T_277 == 32'h3027\r\n| _T_277 == 32'h1007\r\n| _T_277 == 32'h2007\r\n| _T_277 == 32'h3007\r\n| _T_283 == 32'h4000043\r\n| _T_283 == 32'h4000047\r\n| _T_283 == 32'h400004B\r\n| _T_283 == 32'h400004F\r\n| _T_283 == 32'h43\r\n| _T_283 == 32'h47\r\n| _T_283 == 32'h4B\r\n| _T_283 == 32'h4F\r\n| _T_283 == 32'h2000043\r\n| _T_283 == 32'h2000047\r\n| _T_283 == 32'h200004B\r\n| _T_283 == 32'h200004F\r\n| _T_284 == 32'h4000053\r\n| _T_284 == 32'hC000053\r\n| _T_284 == 32'h14000053\r\n| _T_284 == 32'h1C000053\r\n| _T_279 == 32'h24000053\r\n| _T_279 == 32'h24001053\r\n| _T_279 == 32'h24002053\r\n| _T_279 == 32'h2C000053\r\n| _T_279 == 32'h2C001053\r\n| _T_284 == 32'h53\r\n| _T_284 == 32'h8000053\r\n| _T_284 == 32'h10000053\r\n| _T_284 == 32'h18000053\r\n| _T_279 == 32'h20000053\r\n| _T_279 == 32'h20001053\r\n| _T_279 == 32'h20002053\r\n| _T_279 == 32'h28000053\r\n| _T_279 == 32'h28001053\r\n| _T_284 == 32'h2000053\r\n| _T_284 == 32'hA000053\r\n| _T_284 == 32'h12000053\r\n| _T_284 == 32'h1A000053\r\n| _T_279 == 32'h22000053\r\n| _T_279 == 32'h22001053\r\n| _T_279 == 32'h22002053\r\n| _T_279 == 32'h2A000053\r\n| _T_279 == 32'h2A001053\r\n| _T_285 == 32'h5C000053\r\n| _T_285 == 32'h44000053\r\n| _T_285 == 32'h40200053\r\n| _T_285 == 32'h58000053\r\n| _T_285 == 32'h5A000053\r\n| _T_285 == 32'h40100053\r\n| _T_285 == 32'h42000053\r\n| _T_285 == 32'h44100053\r\n| _T_285 == 32'h42200053\r\n| _T_279 == 32'hA4002053\r\n| _T_279 == 32'hA4001053\r\n| _T_279 == 32'hA4000053\r\n| _T_279 == 32'hA0002053\r\n| _T_279 == 32'hA0001053\r\n| _T_279 == 32'hA0000053\r\n| _T_279 == 32'hA2002053\r\n| _T_279 == 32'hA2001053\r\n| _T_279 == 32'hA2000053\r\n| _T_285 == 32'hC4000053\r\n| _T_285 == 32'hC4100053\r\n| _T_286 == 32'hE4001053\r\n| _T_285 == 32'hC4200053\r\n| _T_285 == 32'hC4300053\r\n| _T_285 == 32'hC0000053\r\n| _T_285 == 32'hC0100053\r\n| _T_286 == 32'hE0001053\r\n| _T_285 == 32'hC0200053\r\n| _T_285 == 32'hC0300053\r\n| _T_285 == 32'hC2000053\r\n| _T_285 == 32'hC2100053\r\n| _T_286 == 32'hE2001053\r\n| _T_285 == 32'hC2200053\r\n| _T_285 == 32'hC2300053\r\n| _T_286 == 32'hE4000053\r\n| _T_286 == 32'hE0000053\r\n| _T_286 == 32'hE2000053\r\n| _T_286 == 32'hF4000053\r\n| _T_286 == 32'hF0000053\r\n| _T_286 == 32'hF2000053\r\n| _T_285 == 32'hD4000053\r\n| _T_285 == 32'hD4100053\r\n| _T_285 == 32'hD4200053\r\n| _T_285 == 32'hD4300053\r\n| _T_285 == 32'hD0000053\r\n| _T_285 == 32'hD0100053\r\n| _T_285 == 32'hD0200053\r\n| _T_285 == 32'hD0300053\r\n| _T_285 == 32'hD2000053\r\n| _T_285 == 32'hD2100053\r\n| _T_285 == 32'hD2200053\r\n| _T_285 == 32'hD2300053\r\n| _T_279 == 32'h80007057\r\n| (_T_276 & 32'h8000707F) == 32'h7057\r\n| _T_287 == 32'h7\r\n| _T_287 == 32'h5007\r\n| _T_287 == 32'h6007\r\n| _T_287 == 32'h7007\r\n| _T_287 == 32'h1000007\r\n| _T_287 == 32'h1005007\r\n| _T_287 == 32'h1006007\r\n| _T_287 == 32'h1007007\r\n| _T_288 == 32'hC000007\r\n| _T_288 == 32'hC005007\r\n| _T_288 == 32'hC006007\r\n| _T_286 == 32'h2800007\r\n| _T_286 == 32'h2805007\r\n| _T_286 == 32'h2806007\r\n| _T_286 == 32'h2807007\r\n| _T_286 == 32'h22800007\r\n| _T_286 == 32'h22805007\r\n| _T_286 == 32'h22806007\r\n| _T_286 == 32'h22807007\r\n| _T_286 == 32'h62800007\r\n| _T_286 == 32'h62805007\r\n| _T_286 == 32'h62806007\r\n| _T_286 == 32'h62807007\r\n| _T_286 == 32'hE2800007\r\n| _T_286 == 32'hE2805007\r\n| _T_286 == 32'hE2806007\r\n| _T_286 == 32'hE2807007\r\n| _T_288 == 32'hC007007\r\n| _T_287 == 32'h27\r\n| _T_287 == 32'h5027\r\n| _T_287 == 32'h6027\r\n| _T_287 == 32'h7027\r\n| _T_288 == 32'hC000027\r\n| _T_288 == 32'hC005027\r\n| _T_288 == 32'hC006027\r\n| _T_280 == 32'h4000027\r\n| _T_280 == 32'h4005027\r\n| _T_280 == 32'h4006027\r\n| _T_286 == 32'h2800027\r\n| _T_286 == 32'h22800027\r\n| _T_286 == 32'h62800027\r\n| _T_286 == 32'hE2800027\r\n| _T_288 == 32'hC007027\r\n| _T_280 == 32'h4007027\r\n| _T_281 == 32'h800002F\r\n| _T_281 == 32'h2F\r\n| _T_281 == 32'h2000002F\r\n| _T_281 == 32'h6000002F\r\n| _T_281 == 32'h4000002F\r\n| _T_281 == 32'h8000002F\r\n| _T_281 == 32'hA000002F\r\n| _T_281 == 32'hC000002F\r\n| _T_281 == 32'hE000002F\r\n| _T_281 == 32'h800502F\r\n| _T_281 == 32'h502F\r\n| _T_281 == 32'h2000502F\r\n| _T_281 == 32'h6000502F\r\n| _T_281 == 32'h4000502F\r\n| _T_281 == 32'h8000502F\r\n| _T_281 == 32'hA000502F\r\n| _T_281 == 32'hC000502F\r\n| _T_281 == 32'hE000502F\r\n| _T_281 == 32'h800602F\r\n| _T_281 == 32'h602F\r\n| _T_281 == 32'h2000602F\r\n| _T_281 == 32'h6000602F\r\n| _T_281 == 32'h4000602F\r\n| _T_281 == 32'h8000602F\r\n| _T_281 == 32'hA000602F\r\n| _T_281 == 32'hC000602F\r\n| _T_281 == 32'hE000602F\r\n| _T_281 == 32'h800702F\r\n| _T_281 == 32'h702F\r\n| _T_281 == 32'h2000702F\r\n| _T_281 == 32'h6000702F\r\n| _T_281 == 32'h4000702F\r\n| _T_281 == 32'h8000702F\r\n| _T_281 == 32'hA000702F\r\n| _T_281 == 32'hC000702F\r\n| _T_281 == 32'hE000702F\r\n| _T_288 == 32'h8000007\r\n| _T_288 == 32'h8005007\r\n| _T_288 == 32'h8006007\r\n| _T_288 == 32'h8007007\r\n| _T_288 == 32'h8000027\r\n| _T_288 == 32'h8005027\r\n| _T_288 == 32'h8006027\r\n| _T_288 == 32'h8007027\r\n| _T_280 == 32'h2057\r\n| _T_280 == 32'hC4000057\r\n| _T_280 == 32'hC0000057\r\n| _T_280 == 32'h4002057\r\n| _T_280 == 32'h8002057\r\n| _T_280 == 32'hC002057\r\n| _T_280 == 32'h10002057\r\n| _T_280 == 32'h14002057\r\n| _T_280 == 32'h18002057\r\n| _T_280 == 32'h1C002057\r\n| _T_280 == 32'h57\r\n| _T_280 == 32'h8000057\r\n| _T_279 == 32'h40000057\r\n| _T_280 == 32'h44000057\r\n| _T_279 == 32'h48000057\r\n| _T_280 == 32'h4C000057\r\n| _T_280 == 32'h94000057\r\n| _T_280 == 32'hA0000057\r\n| _T_280 == 32'hA4000057\r\n| _T_280 == 32'hB0000057\r\n| _T_280 == 32'hB4000057\r\n| _T_280 == 32'h24000057\r\n| _T_280 == 32'h28000057\r\n| _T_280 == 32'h2C000057\r\n| _T_280 == 32'h60000057\r\n| _T_280 == 32'h64000057\r\n| _T_280 == 32'h6C000057\r\n| _T_280 == 32'h68000057\r\n| _T_280 == 32'h70000057\r\n| _T_280 == 32'h74000057\r\n| _T_280 == 32'h10000057\r\n| _T_280 == 32'h14000057\r\n| _T_280 == 32'h18000057\r\n| _T_280 == 32'h1C000057\r\n| _T_280 == 32'h30000057\r\n| _T_280 == 32'h38000057\r\n| _T_279 == 32'h5E002057\r\n| _T_279 == 32'h5C000057\r\n| _T_286 == 32'h5E000057\r\n| _T_280 == 32'h60002057\r\n| _T_280 == 32'h64002057\r\n| _T_280 == 32'h68002057\r\n| _T_280 == 32'h6C002057\r\n| _T_280 == 32'h70002057\r\n| _T_280 == 32'h74002057\r\n| _T_280 == 32'h78002057\r\n| _T_280 == 32'h7C002057\r\n| _T_289 == 32'h5000A057\r\n| _T_289 == 32'h50012057\r\n| _T_289 == 32'h5001A057\r\n| _T_289 == 32'h50082057\r\n| (_T_276 & 32'hFDFFF07F) == 32'h5008A057\r\n| _T_289 == 32'h48032057\r\n| _T_289 == 32'h4803A057\r\n| _T_289 == 32'h48022057\r\n| _T_289 == 32'h4802A057\r\n| _T_289 == 32'h48012057\r\n| _T_289 == 32'h4801A057\r\n| _T_280 == 32'hC4002057\r\n| _T_280 == 32'hC0002057\r\n| _T_280 == 32'hCC002057\r\n| _T_280 == 32'hC8002057\r\n| _T_280 == 32'hD4002057\r\n| _T_280 == 32'hD0002057\r\n| _T_280 == 32'hDC002057\r\n| _T_280 == 32'hD8002057\r\n| _T_280 == 32'hEC002057\r\n| _T_280 == 32'hE0002057\r\n| _T_280 == 32'hE8002057\r\n| _T_280 == 32'hF0002057\r\n| _T_280 == 32'hF4002057\r\n| _T_280 == 32'hFC002057\r\n| _T_280 == 32'h94002057\r\n| _T_280 == 32'h9C002057\r\n| _T_280 == 32'h90002057\r\n| _T_280 == 32'h98002057\r\n| _T_280 == 32'h84002057\r\n| _T_280 == 32'h80002057\r\n| _T_280 == 32'h8C002057\r\n| _T_280 == 32'h88002057\r\n| _T_280 == 32'hA4002057\r\n| _T_280 == 32'hAC002057\r\n| _T_280 == 32'hB4002057\r\n| _T_280 == 32'hBC002057\r\n| _T_280 == 32'h24002057\r\n| _T_280 == 32'h2C002057\r\n| _T_280 == 32'h20002057\r\n| _T_280 == 32'h28002057\r\n| _T_280 == 32'h84000057\r\n| _T_280 == 32'h8C000057\r\n| _T_280 == 32'h80000057\r\n| _T_280 == 32'h88000057\r\n| _T_280 == 32'h9C000057\r\n| _T_280 == 32'hA8000057\r\n| _T_280 == 32'hAC000057\r\n| _T_280 == 32'hBC000057\r\n| _T_280 == 32'hB8000057\r\n| _T_280 == 32'h4001057\r\n| _T_280 == 32'hC4001057\r\n| _T_280 == 32'hC001057\r\n| _T_280 == 32'hCC001057\r\n| _T_280 == 32'h14001057\r\n| _T_280 == 32'h1C001057\r\n| _T_289 == 32'h4C081057\r\n| _T_280 == 32'h10001057\r\n| _T_280 == 32'h18001057\r\n| _T_280 == 32'h60001057\r\n| _T_280 == 32'h64001057\r\n| _T_280 == 32'h6C001057\r\n| _T_280 == 32'h70001057\r\n| _T_289 == 32'h48011057\r\n| _T_289 == 32'h48019057\r\n| _T_289 == 32'h48091057\r\n| _T_289 == 32'h48099057\r\n| _T_289 == 32'h480B1057\r\n| _T_289 == 32'h480B9057\r\n| _T_289 == 32'h48081057\r\n| _T_289 == 32'h48089057\r\n| _T_289 == 32'h48051057\r\n| _T_289 == 32'h48059057\r\n| _T_289 == 32'h48071057\r\n| _T_289 == 32'h48079057\r\n| _T_289 == 32'h48041057\r\n| _T_289 == 32'h48049057\r\n| _T_289 == 32'h48031057\r\n| _T_289 == 32'h48039057\r\n| _T_289 == 32'h48001057\r\n| _T_289 == 32'h48009057\r\n| _T_280 == 32'h90001057\r\n| _T_280 == 32'h1057\r\n| _T_280 == 32'h8001057\r\n| _T_289 == 32'h4C001057\r\n| _T_280 == 32'h80001057\r\n| _T_289 == 32'h4C021057\r\n| _T_289 == 32'h4C029057\r\n| _T_280 == 32'hB0001057\r\n| _T_280 == 32'hB4001057\r\n| _T_280 == 32'hB8001057\r\n| _T_280 == 32'hBC001057\r\n| _T_280 == 32'hA0001057\r\n| _T_280 == 32'hA4001057\r\n| _T_280 == 32'hA8001057\r\n| _T_280 == 32'hAC001057\r\n| _T_280 == 32'h20001057\r\n| _T_280 == 32'h24001057\r\n| _T_280 == 32'h28001057\r\n| _T_289 == 32'h480A1057\r\n| _T_289 == 32'h480A9057\r\n| _T_289 == 32'h48061057\r\n| _T_280 == 32'hC0001057\r\n| _T_280 == 32'hC8001057\r\n| _T_280 == 32'hE0001057\r\n| _T_280 == 32'hD0001057\r\n| _T_280 == 32'hD8001057\r\n| _T_280 == 32'hF0001057\r\n| _T_280 == 32'hF4001057\r\n| _T_280 == 32'hF8001057\r\n| _T_280 == 32'hFC001057\r\n| _T_280 == 32'h3057\r\n| _T_279 == 32'h40003057\r\n| _T_280 == 32'h44003057\r\n| _T_280 == 32'hC003057\r\n| _T_280 == 32'h94003057\r\n| _T_280 == 32'hA0003057\r\n| _T_280 == 32'hA4003057\r\n| _T_280 == 32'hB0003057\r\n| _T_280 == 32'hB4003057\r\n| _T_280 == 32'h24003057\r\n| _T_280 == 32'h28003057\r\n| _T_280 == 32'h2C003057\r\n| _T_279 == 32'h9E003057\r\n| _T_280 == 32'h38003057\r\n| _T_280 == 32'h3C003057\r\n| _T_280 == 32'h60003057\r\n| _T_280 == 32'h64003057\r\n| _T_280 == 32'h70003057\r\n| _T_280 == 32'h74003057\r\n| _T_280 == 32'h78003057\r\n| _T_280 == 32'h7C003057\r\n| _T_280 == 32'h30003057\r\n| _T_279 == 32'h5C003057\r\n| _T_286 == 32'h5E003057\r\n| _T_280 == 32'h84003057\r\n| _T_280 == 32'h80003057\r\n| _T_280 == 32'hA8003057\r\n| _T_280 == 32'hAC003057\r\n| _T_280 == 32'hBC003057\r\n| _T_280 == 32'hB8003057\r\n| _T_280 == 32'h4057\r\n| _T_280 == 32'h8004057\r\n| _T_279 == 32'h40004057\r\n| _T_280 == 32'h44004057\r\n| _T_279 == 32'h48004057\r\n| _T_280 == 32'h4C004057\r\n| _T_280 == 32'hC004057\r\n| _T_280 == 32'h94004057\r\n| _T_280 == 32'hA0004057\r\n| _T_280 == 32'hA4004057\r\n| _T_280 == 32'hB0004057\r\n| _T_280 == 32'hB4004057\r\n| _T_280 == 32'h24004057\r\n| _T_280 == 32'h28004057\r\n| _T_280 == 32'h2C004057\r\n| _T_280 == 32'h38004057\r\n| _T_280 == 32'h3C004057\r\n| _T_280 == 32'h38006057\r\n| _T_280 == 32'h3C006057\r\n| _T_280 == 32'h60004057\r\n| _T_280 == 32'h64004057\r\n| _T_280 == 32'h6C004057\r\n| _T_280 == 32'h68004057\r\n| _T_280 == 32'h70004057\r\n| _T_280 == 32'h74004057\r\n| _T_280 == 32'h78004057\r\n| _T_280 == 32'h7C004057\r\n| _T_280 == 32'h10004057\r\n| _T_280 == 32'h14004057\r\n| _T_280 == 32'h18004057\r\n| _T_280 == 32'h1C004057\r\n| _T_280 == 32'h30004057\r\n| _T_279 == 32'h5C004057\r\n| _T_286 == 32'h5E004057\r\n| _T_280 == 32'hC4006057\r\n| _T_280 == 32'hC0006057\r\n| _T_280 == 32'hCC006057\r\n| _T_280 == 32'hC8006057\r\n| _T_280 == 32'hD4006057\r\n| _T_280 == 32'hD0006057\r\n| _T_280 == 32'hDC006057\r\n| _T_280 == 32'hD8006057\r\n| _T_280 == 32'hEC006057\r\n| _T_280 == 32'hE0006057\r\n| _T_280 == 32'hE8006057\r\n| _T_280 == 32'hF0006057\r\n| _T_280 == 32'hF4006057\r\n| _T_280 == 32'hFC006057\r\n| _T_280 == 32'hF8006057\r\n| _T_280 == 32'h94006057\r\n| _T_280 == 32'h9C006057\r\n| _T_280 == 32'h90006057\r\n| _T_280 == 32'h98006057\r\n| _T_280 == 32'h84006057\r\n| _T_280 == 32'h80006057\r\n| _T_280 == 32'h8C006057\r\n| _T_280 == 32'h88006057\r\n| _T_280 == 32'hA4006057\r\n| _T_280 == 32'hAC006057\r\n| _T_280 == 32'hB4006057\r\n| _T_280 == 32'hBC006057\r\n| _T_286 == 32'h42006057\r\n| _T_280 == 32'h24006057\r\n| _T_280 == 32'h2C006057\r\n| _T_280 == 32'h20006057\r\n| _T_280 == 32'h28006057\r\n| _T_280 == 32'h84004057\r\n| _T_280 == 32'h8C004057\r\n| _T_280 == 32'h80004057\r\n| _T_280 == 32'h88004057\r\n| _T_280 == 32'h9C004057\r\n| _T_280 == 32'hA8004057\r\n| _T_280 == 32'hAC004057\r\n| _T_280 == 32'hBC004057\r\n| _T_280 == 32'hB8004057\r\n| _T_280 == 32'h38005057\r\n| _T_280 == 32'h3C005057\r\n| _T_280 == 32'h20005057\r\n| _T_280 == 32'h24005057\r\n| _T_280 == 32'h28005057\r\n| _T_280 == 32'h10005057\r\n| _T_280 == 32'h18005057\r\n| _T_280 == 32'h60005057\r\n| _T_280 == 32'h64005057\r\n| _T_280 == 32'h6C005057\r\n| _T_280 == 32'h70005057\r\n| _T_280 == 32'h74005057\r\n| _T_280 == 32'h7C005057\r\n| _T_279 == 32'h5C005057\r\n| _T_286 == 32'h5E005057\r\n| _T_280 == 32'h90005057\r\n| _T_280 == 32'h5057\r\n| _T_280 == 32'h8005057\r\n| _T_280 == 32'h9C005057\r\n| _T_280 == 32'h80005057\r\n| _T_280 == 32'h84005057\r\n| _T_280 == 32'hB0005057\r\n| _T_280 == 32'hB4005057\r\n| _T_280 == 32'hB8005057\r\n| _T_280 == 32'hBC005057\r\n| _T_280 == 32'hA0005057\r\n| _T_280 == 32'hA4005057\r\n| _T_280 == 32'hA8005057\r\n| _T_280 == 32'hAC005057\r\n| _T_286 == 32'h42005057\r\n| _T_280 == 32'hC0005057\r\n| _T_280 == 32'hC8005057\r\n| _T_280 == 32'hE0005057\r\n| _T_280 == 32'hD0005057\r\n| _T_280 == 32'hD8005057\r\n| _T_280 == 32'hF0005057\r\n| _T_280 == 32'hF4005057\r\n| _T_280 == 32'hF8005057\r\n| _T_280 == 32'hFC005057\r\n| _T_290 == 32'h42002057\r\n| _T_289 == 32'h40082057\r\n| _T_289 == 32'h4008A057\r\n| _T_290 == 32'h42001057) : (_T_249 ? 1'h1 : _T_248 ? 1'h1 : _T_247 ? 1'h1 : _T_246 ? 1'h1 : _T_245 ? 1'h1 : _T_244 ? 1'h1 : _T_243 ? 1'h1 : |io_fetch_bits_data[12:5]) == 1'h0 ? 1'h0 : _T_251 == 32'h63\r\n| _T_251 == 32'h1063\r\n| _T_251 == 32'h4063\r\n| _T_251 == 32'h6063\r\n| _T_251 == 32'h5063\r\n| _T_251 == 32'h7063\r\n| _T_252 == 32'h6F\r\n| _T_251 == 32'h67\r\n| _T_251 == 32'h3\r\n| _T_251 == 32'h4003\r\n| _T_251 == 32'h1003\r\n| _T_251 == 32'h5003\r\n| _T_251 == 32'h2003\r\n| _T_251 == 32'h6003\r\n| _T_251 == 32'h3003\r\n| _T_251 == 32'h23\r\n| _T_251 == 32'h1023\r\n| _T_251 == 32'h2023\r\n| _T_251 == 32'h3023\r\n| _T_252 == 32'h37\r\n| _T_252 == 32'h17\r\n| _T_251 == 32'h13\r\n| _T_251 == 32'h2013\r\n| _T_251 == 32'h3013\r\n| _T_251 == 32'h7013\r\n| _T_251 == 32'h6013\r\n| _T_251 == 32'h4013\r\n| _T_251 == 32'h1B\r\n| _T_253 == 32'h101B\r\n| _T_253 == 32'h501B\r\n| _T_253 == 32'h4000501B\r\n| _T_254 == 32'h1013\r\n| _T_254 == 32'h5013\r\n| _T_254 == 32'h40005013\r\n| _T_253 == 32'h33\r\n| _T_253 == 32'h40000033\r\n| _T_253 == 32'h2033\r\n| _T_253 == 32'h3033\r\n| _T_253 == 32'h7033\r\n| _T_253 == 32'h6033\r\n| _T_253 == 32'h4033\r\n| _T_253 == 32'h1033\r\n| _T_253 == 32'h5033\r\n| _T_253 == 32'h40005033\r\n| _T_253 == 32'h3B\r\n| _T_253 == 32'h4000003B\r\n| _T_253 == 32'h103B\r\n| _T_253 == 32'h503B\r\n| _T_253 == 32'h4000503B\r\n| _T_251 == 32'hF\r\n| _T_251 == 32'h100F\r\n| (_T_250 & 32'hFE007FFF) == 32'h12000073\r\n| _T_250 == 32'hFC000073\r\n| _T_250 == 32'hFC200073\r\n| _T_251 == 32'h5073\r\n| _T_251 == 32'h6073\r\n| _T_251 == 32'h7073\r\n| _T_250 == 32'h73\r\n| _T_250 == 32'h100073\r\n| _T_250 == 32'h30200073\r\n| _T_250 == 32'h10500073\r\n| _T_250 == 32'h30500073\r\n| _T_251 == 32'h1073\r\n| _T_251 == 32'h2073\r\n| _T_251 == 32'h3073\r\n| _T_250 == 32'h10200073\r\n| _T_250 == 32'h7B200073\r\n| _T_253 == 32'h2000033\r\n| _T_253 == 32'h2001033\r\n| _T_253 == 32'h2003033\r\n| _T_253 == 32'h2002033\r\n| _T_253 == 32'h200003B\r\n| _T_253 == 32'h2004033\r\n| _T_253 == 32'h2005033\r\n| _T_253 == 32'h2006033\r\n| _T_253 == 32'h2007033\r\n| _T_253 == 32'h200403B\r\n| _T_253 == 32'h200503B\r\n| _T_253 == 32'h200603B\r\n| _T_253 == 32'h200703B\r\n| _T_255 == 32'h202F\r\n| _T_255 == 32'h6000202F\r\n| _T_255 == 32'h4000202F\r\n| _T_255 == 32'h2000202F\r\n| _T_255 == 32'h8000202F\r\n| _T_255 == 32'hA000202F\r\n| _T_255 == 32'hC000202F\r\n| _T_255 == 32'hE000202F\r\n| _T_255 == 32'h800202F\r\n| _T_255 == 32'h302F\r\n| _T_255 == 32'h6000302F\r\n| _T_255 == 32'h4000302F\r\n| _T_255 == 32'h2000302F\r\n| _T_255 == 32'h8000302F\r\n| _T_255 == 32'hA000302F\r\n| _T_255 == 32'hC000302F\r\n| _T_255 == 32'hE000302F\r\n| _T_255 == 32'h800302F\r\n| _T_256 == 32'h1000202F\r\n| _T_255 == 32'h1800202F\r\n| _T_256 == 32'h1000302F\r\n| _T_255 == 32'h1800302F\r\n| _T_251 == 32'h1027\r\n| _T_251 == 32'h2027\r\n| _T_251 == 32'h3027\r\n| _T_251 == 32'h1007\r\n| _T_251 == 32'h2007\r\n| _T_251 == 32'h3007\r\n| _T_257 == 32'h4000043\r\n| _T_257 == 32'h4000047\r\n| _T_257 == 32'h400004B\r\n| _T_257 == 32'h400004F\r\n| _T_257 == 32'h43\r\n| _T_257 == 32'h47\r\n| _T_257 == 32'h4B\r\n| _T_257 == 32'h4F\r\n| _T_257 == 32'h2000043\r\n| _T_257 == 32'h2000047\r\n| _T_257 == 32'h200004B\r\n| _T_257 == 32'h200004F\r\n| _T_258 == 32'h4000053\r\n| _T_258 == 32'hC000053\r\n| _T_258 == 32'h14000053\r\n| _T_258 == 32'h1C000053\r\n| _T_253 == 32'h24000053\r\n| _T_253 == 32'h24001053\r\n| _T_253 == 32'h24002053\r\n| _T_253 == 32'h2C000053\r\n| _T_253 == 32'h2C001053\r\n| _T_258 == 32'h53\r\n| _T_258 == 32'h8000053\r\n| _T_258 == 32'h10000053\r\n| _T_258 == 32'h18000053\r\n| _T_253 == 32'h20000053\r\n| _T_253 == 32'h20001053\r\n| _T_253 == 32'h20002053\r\n| _T_253 == 32'h28000053\r\n| _T_253 == 32'h28001053\r\n| _T_258 == 32'h2000053\r\n| _T_258 == 32'hA000053\r\n| _T_258 == 32'h12000053\r\n| _T_258 == 32'h1A000053\r\n| _T_253 == 32'h22000053\r\n| _T_253 == 32'h22001053\r\n| _T_253 == 32'h22002053\r\n| _T_253 == 32'h2A000053\r\n| _T_253 == 32'h2A001053\r\n| _T_259 == 32'h5C000053\r\n| _T_259 == 32'h44000053\r\n| _T_259 == 32'h40200053\r\n| _T_259 == 32'h58000053\r\n| _T_259 == 32'h5A000053\r\n| _T_259 == 32'h40100053\r\n| _T_259 == 32'h42000053\r\n| _T_259 == 32'h44100053\r\n| _T_259 == 32'h42200053\r\n| _T_253 == 32'hA4002053\r\n| _T_253 == 32'hA4001053\r\n| _T_253 == 32'hA4000053\r\n| _T_253 == 32'hA0002053\r\n| _T_253 == 32'hA0001053\r\n| _T_253 == 32'hA0000053\r\n| _T_253 == 32'hA2002053\r\n| _T_253 == 32'hA2001053\r\n| _T_253 == 32'hA2000053\r\n| _T_259 == 32'hC4000053\r\n| _T_259 == 32'hC4100053\r\n| _T_260 == 32'hE4001053\r\n| _T_259 == 32'hC4200053\r\n| _T_259 == 32'hC4300053\r\n| _T_259 == 32'hC0000053\r\n| _T_259 == 32'hC0100053\r\n| _T_260 == 32'hE0001053\r\n| _T_259 == 32'hC0200053\r\n| _T_259 == 32'hC0300053\r\n| _T_259 == 32'hC2000053\r\n| _T_259 == 32'hC2100053\r\n| _T_260 == 32'hE2001053\r\n| _T_259 == 32'hC2200053\r\n| _T_259 == 32'hC2300053\r\n| _T_260 == 32'hE4000053\r\n| _T_260 == 32'hE0000053\r\n| _T_260 == 32'hE2000053\r\n| _T_260 == 32'hF4000053\r\n| _T_260 == 32'hF0000053\r\n| _T_260 == 32'hF2000053\r\n| _T_259 == 32'hD4000053\r\n| _T_259 == 32'hD4100053\r\n| _T_259 == 32'hD4200053\r\n| _T_259 == 32'hD4300053\r\n| _T_259 == 32'hD0000053\r\n| _T_259 == 32'hD0100053\r\n| _T_259 == 32'hD0200053\r\n| _T_259 == 32'hD0300053\r\n| _T_259 == 32'hD2000053\r\n| _T_259 == 32'hD2100053\r\n| _T_259 == 32'hD2200053\r\n| _T_259 == 32'hD2300053\r\n| _T_253 == 32'h80007057\r\n| (_T_250 & 32'h8000707F) == 32'h7057\r\n| _T_261 == 32'h7\r\n| _T_261 == 32'h5007\r\n| _T_261 == 32'h6007\r\n| _T_261 == 32'h7007\r\n| _T_261 == 32'h1000007\r\n| _T_261 == 32'h1005007\r\n| _T_261 == 32'h1006007\r\n| _T_261 == 32'h1007007\r\n| _T_262 == 32'hC000007\r\n| _T_262 == 32'hC005007\r\n| _T_262 == 32'hC006007\r\n| _T_260 == 32'h2800007\r\n| _T_260 == 32'h2805007\r\n| _T_260 == 32'h2806007\r\n| _T_260 == 32'h2807007\r\n| _T_260 == 32'h22800007\r\n| _T_260 == 32'h22805007\r\n| _T_260 == 32'h22806007\r\n| _T_260 == 32'h22807007\r\n| _T_260 == 32'h62800007\r\n| _T_260 == 32'h62805007\r\n| _T_260 == 32'h62806007\r\n| _T_260 == 32'h62807007\r\n| _T_260 == 32'hE2800007\r\n| _T_260 == 32'hE2805007\r\n| _T_260 == 32'hE2806007\r\n| _T_260 == 32'hE2807007\r\n| _T_262 == 32'hC007007\r\n| _T_261 == 32'h27\r\n| _T_261 == 32'h5027\r\n| _T_261 == 32'h6027\r\n| _T_261 == 32'h7027\r\n| _T_262 == 32'hC000027\r\n| _T_262 == 32'hC005027\r\n| _T_262 == 32'hC006027\r\n| _T_254 == 32'h4000027\r\n| _T_254 == 32'h4005027\r\n| _T_254 == 32'h4006027\r\n| _T_260 == 32'h2800027\r\n| _T_260 == 32'h22800027\r\n| _T_260 == 32'h62800027\r\n| _T_260 == 32'hE2800027\r\n| _T_262 == 32'hC007027\r\n| _T_254 == 32'h4007027\r\n| _T_255 == 32'h800002F\r\n| _T_255 == 32'h2F\r\n| _T_255 == 32'h2000002F\r\n| _T_255 == 32'h6000002F\r\n| _T_255 == 32'h4000002F\r\n| _T_255 == 32'h8000002F\r\n| _T_255 == 32'hA000002F\r\n| _T_255 == 32'hC000002F\r\n| _T_255 == 32'hE000002F\r\n| _T_255 == 32'h800502F\r\n| _T_255 == 32'h502F\r\n| _T_255 == 32'h2000502F\r\n| _T_255 == 32'h6000502F\r\n| _T_255 == 32'h4000502F\r\n| _T_255 == 32'h8000502F\r\n| _T_255 == 32'hA000502F\r\n| _T_255 == 32'hC000502F\r\n| _T_255 == 32'hE000502F\r\n| _T_255 == 32'h800602F\r\n| _T_255 == 32'h602F\r\n| _T_255 == 32'h2000602F\r\n| _T_255 == 32'h6000602F\r\n| _T_255 == 32'h4000602F\r\n| _T_255 == 32'h8000602F\r\n| _T_255 == 32'hA000602F\r\n| _T_255 == 32'hC000602F\r\n| _T_255 == 32'hE000602F\r\n| _T_255 == 32'h800702F\r\n| _T_255 == 32'h702F\r\n| _T_255 == 32'h2000702F\r\n| _T_255 == 32'h6000702F\r\n| _T_255 == 32'h4000702F\r\n| _T_255 == 32'h8000702F\r\n| _T_255 == 32'hA000702F\r\n| _T_255 == 32'hC000702F\r\n| _T_255 == 32'hE000702F\r\n| _T_262 == 32'h8000007\r\n| _T_262 == 32'h8005007\r\n| _T_262 == 32'h8006007\r\n| _T_262 == 32'h8007007\r\n| _T_262 == 32'h8000027\r\n| _T_262 == 32'h8005027\r\n| _T_262 == 32'h8006027\r\n| _T_262 == 32'h8007027\r\n| _T_254 == 32'h2057\r\n| _T_254 == 32'hC4000057\r\n| _T_254 == 32'hC0000057\r\n| _T_254 == 32'h4002057\r\n| _T_254 == 32'h8002057\r\n| _T_254 == 32'hC002057\r\n| _T_254 == 32'h10002057\r\n| _T_254 == 32'h14002057\r\n| _T_254 == 32'h18002057\r\n| _T_254 == 32'h1C002057\r\n| _T_254 == 32'h57\r\n| _T_254 == 32'h8000057\r\n| _T_253 == 32'h40000057\r\n| _T_254 == 32'h44000057\r\n| _T_253 == 32'h48000057\r\n| _T_254 == 32'h4C000057\r\n| _T_254 == 32'h94000057\r\n| _T_254 == 32'hA0000057\r\n| _T_254 == 32'hA4000057\r\n| _T_254 == 32'hB0000057\r\n| _T_254 == 32'hB4000057\r\n| _T_254 == 32'h24000057\r\n| _T_254 == 32'h28000057\r\n| _T_254 == 32'h2C000057\r\n| _T_254 == 32'h60000057\r\n| _T_254 == 32'h64000057\r\n| _T_254 == 32'h6C000057\r\n| _T_254 == 32'h68000057\r\n| _T_254 == 32'h70000057\r\n| _T_254 == 32'h74000057\r\n| _T_254 == 32'h10000057\r\n| _T_254 == 32'h14000057\r\n| _T_254 == 32'h18000057\r\n| _T_254 == 32'h1C000057\r\n| _T_254 == 32'h30000057\r\n| _T_254 == 32'h38000057\r\n| _T_253 == 32'h5E002057\r\n| _T_253 == 32'h5C000057\r\n| _T_260 == 32'h5E000057\r\n| _T_254 == 32'h60002057\r\n| _T_254 == 32'h64002057\r\n| _T_254 == 32'h68002057\r\n| _T_254 == 32'h6C002057\r\n| _T_254 == 32'h70002057\r\n| _T_254 == 32'h74002057\r\n| _T_254 == 32'h78002057\r\n| _T_254 == 32'h7C002057\r\n| _T_263 == 32'h5000A057\r\n| _T_263 == 32'h50012057\r\n| _T_263 == 32'h5001A057\r\n| _T_263 == 32'h50082057\r\n| (_T_250 & 32'hFDFFF07F) == 32'h5008A057\r\n| _T_263 == 32'h48032057\r\n| _T_263 == 32'h4803A057\r\n| _T_263 == 32'h48022057\r\n| _T_263 == 32'h4802A057\r\n| _T_263 == 32'h48012057\r\n| _T_263 == 32'h4801A057\r\n| _T_254 == 32'hC4002057\r\n| _T_254 == 32'hC0002057\r\n| _T_254 == 32'hCC002057\r\n| _T_254 == 32'hC8002057\r\n| _T_254 == 32'hD4002057\r\n| _T_254 == 32'hD0002057\r\n| _T_254 == 32'hDC002057\r\n| _T_254 == 32'hD8002057\r\n| _T_254 == 32'hEC002057\r\n| _T_254 == 32'hE0002057\r\n| _T_254 == 32'hE8002057\r\n| _T_254 == 32'hF0002057\r\n| _T_254 == 32'hF4002057\r\n| _T_254 == 32'hFC002057\r\n| _T_254 == 32'h94002057\r\n| _T_254 == 32'h9C002057\r\n| _T_254 == 32'h90002057\r\n| _T_254 == 32'h98002057\r\n| _T_254 == 32'h84002057\r\n| _T_254 == 32'h80002057\r\n| _T_254 == 32'h8C002057\r\n| _T_254 == 32'h88002057\r\n| _T_254 == 32'hA4002057\r\n| _T_254 == 32'hAC002057\r\n| _T_254 == 32'hB4002057\r\n| _T_254 == 32'hBC002057\r\n| _T_254 == 32'h24002057\r\n| _T_254 == 32'h2C002057\r\n| _T_254 == 32'h20002057\r\n| _T_254 == 32'h28002057\r\n| _T_254 == 32'h84000057\r\n| _T_254 == 32'h8C000057\r\n| _T_254 == 32'h80000057\r\n| _T_254 == 32'h88000057\r\n| _T_254 == 32'h9C000057\r\n| _T_254 == 32'hA8000057\r\n| _T_254 == 32'hAC000057\r\n| _T_254 == 32'hBC000057\r\n| _T_254 == 32'hB8000057\r\n| _T_254 == 32'h4001057\r\n| _T_254 == 32'hC4001057\r\n| _T_254 == 32'hC001057\r\n| _T_254 == 32'hCC001057\r\n| _T_254 == 32'h14001057\r\n| _T_254 == 32'h1C001057\r\n| _T_263 == 32'h4C081057\r\n| _T_254 == 32'h10001057\r\n| _T_254 == 32'h18001057\r\n| _T_254 == 32'h60001057\r\n| _T_254 == 32'h64001057\r\n| _T_254 == 32'h6C001057\r\n| _T_254 == 32'h70001057\r\n| _T_263 == 32'h48011057\r\n| _T_263 == 32'h48019057\r\n| _T_263 == 32'h48091057\r\n| _T_263 == 32'h48099057\r\n| _T_263 == 32'h480B1057\r\n| _T_263 == 32'h480B9057\r\n| _T_263 == 32'h48081057\r\n| _T_263 == 32'h48089057\r\n| _T_263 == 32'h48051057\r\n| _T_263 == 32'h48059057\r\n| _T_263 == 32'h48071057\r\n| _T_263 == 32'h48079057\r\n| _T_263 == 32'h48041057\r\n| _T_263 == 32'h48049057\r\n| _T_263 == 32'h48031057\r\n| _T_263 == 32'h48039057\r\n| _T_263 == 32'h48001057\r\n| _T_263 == 32'h48009057\r\n| _T_254 == 32'h90001057\r\n| _T_254 == 32'h1057\r\n| _T_254 == 32'h8001057\r\n| _T_263 == 32'h4C001057\r\n| _T_254 == 32'h80001057\r\n| _T_263 == 32'h4C021057\r\n| _T_263 == 32'h4C029057\r\n| _T_254 == 32'hB0001057\r\n| _T_254 == 32'hB4001057\r\n| _T_254 == 32'hB8001057\r\n| _T_254 == 32'hBC001057\r\n| _T_254 == 32'hA0001057\r\n| _T_254 == 32'hA4001057\r\n| _T_254 == 32'hA8001057\r\n| _T_254 == 32'hAC001057\r\n| _T_254 == 32'h20001057\r\n| _T_254 == 32'h24001057\r\n| _T_254 == 32'h28001057\r\n| _T_263 == 32'h480A1057\r\n| _T_263 == 32'h480A9057\r\n| _T_263 == 32'h48061057\r\n| _T_254 == 32'hC0001057\r\n| _T_254 == 32'hC8001057\r\n| _T_254 == 32'hE0001057\r\n| _T_254 == 32'hD0001057\r\n| _T_254 == 32'hD8001057\r\n| _T_254 == 32'hF0001057\r\n| _T_254 == 32'hF4001057\r\n| _T_254 == 32'hF8001057\r\n| _T_254 == 32'hFC001057\r\n| _T_254 == 32'h3057\r\n| _T_253 == 32'h40003057\r\n| _T_254 == 32'h44003057\r\n| _T_254 == 32'hC003057\r\n| _T_254 == 32'h94003057\r\n| _T_254 == 32'hA0003057\r\n| _T_254 == 32'hA4003057\r\n| _T_254 == 32'hB0003057\r\n| _T_254 == 32'hB4003057\r\n| _T_254 == 32'h24003057\r\n| _T_254 == 32'h28003057\r\n| _T_254 == 32'h2C003057\r\n| _T_253 == 32'h9E003057\r\n| _T_254 == 32'h38003057\r\n| _T_254 == 32'h3C003057\r\n| _T_254 == 32'h60003057\r\n| _T_254 == 32'h64003057\r\n| _T_254 == 32'h70003057\r\n| _T_254 == 32'h74003057\r\n| _T_254 == 32'h78003057\r\n| _T_254 == 32'h7C003057\r\n| _T_254 == 32'h30003057\r\n| _T_253 == 32'h5C003057\r\n| _T_260 == 32'h5E003057\r\n| _T_254 == 32'h84003057\r\n| _T_254 == 32'h80003057\r\n| _T_254 == 32'hA8003057\r\n| _T_254 == 32'hAC003057\r\n| _T_254 == 32'hBC003057\r\n| _T_254 == 32'hB8003057\r\n| _T_254 == 32'h4057\r\n| _T_254 == 32'h8004057\r\n| _T_253 == 32'h40004057\r\n| _T_254 == 32'h44004057\r\n| _T_253 == 32'h48004057\r\n| _T_254 == 32'h4C004057\r\n| _T_254 == 32'hC004057\r\n| _T_254 == 32'h94004057\r\n| _T_254 == 32'hA0004057\r\n| _T_254 == 32'hA4004057\r\n| _T_254 == 32'hB0004057\r\n| _T_254 == 32'hB4004057\r\n| _T_254 == 32'h24004057\r\n| _T_254 == 32'h28004057\r\n| _T_254 == 32'h2C004057\r\n| _T_254 == 32'h38004057\r\n| _T_254 == 32'h3C004057\r\n| _T_254 == 32'h38006057\r\n| _T_254 == 32'h3C006057\r\n| _T_254 == 32'h60004057\r\n| _T_254 == 32'h64004057\r\n| _T_254 == 32'h6C004057\r\n| _T_254 == 32'h68004057\r\n| _T_254 == 32'h70004057\r\n| _T_254 == 32'h74004057\r\n| _T_254 == 32'h78004057\r\n| _T_254 == 32'h7C004057\r\n| _T_254 == 32'h10004057\r\n| _T_254 == 32'h14004057\r\n| _T_254 == 32'h18004057\r\n| _T_254 == 32'h1C004057\r\n| _T_254 == 32'h30004057\r\n| _T_253 == 32'h5C004057\r\n| _T_260 == 32'h5E004057\r\n| _T_254 == 32'hC4006057\r\n| _T_254 == 32'hC0006057\r\n| _T_254 == 32'hCC006057\r\n| _T_254 == 32'hC8006057\r\n| _T_254 == 32'hD4006057\r\n| _T_254 == 32'hD0006057\r\n| _T_254 == 32'hDC006057\r\n| _T_254 == 32'hD8006057\r\n| _T_254 == 32'hEC006057\r\n| _T_254 == 32'hE0006057\r\n| _T_254 == 32'hE8006057\r\n| _T_254 == 32'hF0006057\r\n| _T_254 == 32'hF4006057\r\n| _T_254 == 32'hFC006057\r\n| _T_254 == 32'hF8006057\r\n| _T_254 == 32'h94006057\r\n| _T_254 == 32'h9C006057\r\n| _T_254 == 32'h90006057\r\n| _T_254 == 32'h98006057\r\n| _T_254 == 32'h84006057\r\n| _T_254 == 32'h80006057\r\n| _T_254 == 32'h8C006057\r\n| _T_254 == 32'h88006057\r\n| _T_254 == 32'hA4006057\r\n| _T_254 == 32'hAC006057\r\n| _T_254 == 32'hB4006057\r\n| _T_254 == 32'hBC006057\r\n| _T_260 == 32'h42006057\r\n| _T_254 == 32'h24006057\r\n| _T_254 == 32'h2C006057\r\n| _T_254 == 32'h20006057\r\n| _T_254 == 32'h28006057\r\n| _T_254 == 32'h84004057\r\n| _T_254 == 32'h8C004057\r\n| _T_254 == 32'h80004057\r\n| _T_254 == 32'h88004057\r\n| _T_254 == 32'h9C004057\r\n| _T_254 == 32'hA8004057\r\n| _T_254 == 32'hAC004057\r\n| _T_254 == 32'hBC004057\r\n| _T_254 == 32'hB8004057\r\n| _T_254 == 32'h38005057\r\n| _T_254 == 32'h3C005057\r\n| _T_254 == 32'h20005057\r\n| _T_254 == 32'h24005057\r\n| _T_254 == 32'h28005057\r\n| _T_254 == 32'h10005057\r\n| _T_254 == 32'h18005057\r\n| _T_254 == 32'h60005057\r\n| _T_254 == 32'h64005057\r\n| _T_254 == 32'h6C005057\r\n| _T_254 == 32'h70005057\r\n| _T_254 == 32'h74005057\r\n| _T_254 == 32'h7C005057\r\n| _T_253 == 32'h5C005057\r\n| _T_260 == 32'h5E005057\r\n| _T_254 == 32'h90005057\r\n| _T_254 == 32'h5057\r\n| _T_254 == 32'h8005057\r\n| _T_254 == 32'h9C005057\r\n| _T_254 == 32'h80005057\r\n| _T_254 == 32'h84005057\r\n| _T_254 == 32'hB0005057\r\n| _T_254 == 32'hB4005057\r\n| _T_254 == 32'hB8005057\r\n| _T_254 == 32'hBC005057\r\n| _T_254 == 32'hA0005057\r\n| _T_254 == 32'hA4005057\r\n| _T_254 == 32'hA8005057\r\n| _T_254 == 32'hAC005057\r\n| _T_260 == 32'h42005057\r\n| _T_254 == 32'hC0005057\r\n| _T_254 == 32'hC8005057\r\n| _T_254 == 32'hE0005057\r\n| _T_254 == 32'hD0005057\r\n| _T_254 == 32'hD8005057\r\n| _T_254 == 32'hF0005057\r\n| _T_254 == 32'hF4005057\r\n| _T_254 == 32'hF8005057\r\n| _T_254 == 32'hFC005057\r\n| _T_264 == 32'h42002057\r\n| _T_263 == 32'h40082057\r\n| _T_263 == 32'h4008A057\r\n| _T_264 == 32'h42001057;\t// foo.lo.fir.mlir:493257:17, :493315:27, :493318:27, :493319:27, :493351:27, :493352:27, :493353:27, :493354:27, :493360:27, :493361:27, :493362:27, :493363:27, :493427:27, :493428:27, :493429:27, :493430:27, :493431:27, :493432:27, :493433:27, :493434:27, :493435:27, :493436:27, :493437:27, :493439:27, :493440:27, :493441:27, :493442:27, :493443:27, :493444:27, :493445:27, :493446:27, :493447:27, :493448:27, :493449:27, :493450:27, :493451:27, :493452:27, :493453:27, :493454:27, :493455:27, :493456:27, :493457:27, :493458:27, :493459:27, :493460:27, :493461:27, :493462:27, :493463:27, :493464:27, :493465:27, :493466:27, :493467:27, :493468:27, :493469:27, :493470:27, :493471:27, :493498:27, :493499:27, :493500:27, :493501:27, :493516:27, :493524:27, :493525:27, :493526:27, :493527:27, :493533:27, :493534:27, :493535:27, :493536:27, :493542:27, :493543:27, :493544:27, :493545:27, :493551:27, :493552:27, :493553:27, :493554:27, :493564:27, :493565:27, :493579:27, :493580:27, :493581:27, :493582:27, :493583:27, :493615:27, :493623:27, :493624:27, :493625:27, :493626:27, :493627:27, :493628:27, :493629:27, :493630:27, :493631:27, :493632:27, :493633:27, :493634:27, :493635:27, :493636:27, :493637:27, :493638:27, :493639:27, :493640:27, :493641:27, :493642:27, :493643:27, :493644:27, :493645:27, :493646:27, :493647:27, :493648:27, :493653:27, :493654:27, :493655:27, :493656:27, :493657:27, :493658:27, :493659:27, :493660:27, :493661:27, :493663:27, :493665:27, :493693:27, :493697:27, :493700:27, :493701:27, :493702:27, :493703:27, :493704:27, :493705:27, :493706:27, :493707:27, :493714:27, :493715:27, :493716:27, :493717:27, :493718:27, :493719:27, :493720:27, :493721:27, :493722:27, :493727:27, :493728:27, :493729:27, :493730:27, :493731:27, :493735:27, :493747:27, :493748:27, :493749:27, :493750:27, :493751:27, :493752:27, :493760:27, :493761:27, :493762:27, :493763:27, :493764:27, :493787:27, :493788:27, :493789:27, :493790:27, :493791:27, :493792:27, :493793:27, :493794:27, :493795:27, :493796:27, :493797:27, :493798:27, :493799:27, :493800:27, :493801:27, :493802:27, :493803:27, :493804:27, :493805:27, :493806:27, :493807:27, :493808:27, :493809:27, :493810:27, :493811:27, :493812:27, :493813:27, :493819:27, :493820:27, :493821:27, :493822:27, :493823:27, :493824:27, :493825:27, :493826:27, :493827:27, :493843:27, :493846:27, :493847:27, :493848:27, :493849:27, :493850:27, :493851:27, :493852:27, :493853:27, :493854:27, :493855:27, :493856:27, :493858:27, :493859:27, :493860:27, :493861:27, :493862:27, :493863:27, :493864:27, :493865:27, :493866:27, :494059:13, :498312:15, :498315:15, :498318:15, :498321:15, :498324:15, :498327:15, :498331:15, :498334:15, :498337:15, :498340:15, :498343:15, :498346:15, :498349:15, :498352:15, :498355:15, :498358:15, :498361:15, :498364:15, :498367:15, :498370:15, :498373:15, :498376:15, :498379:15, :498382:15, :498385:15, :498388:15, :498391:15, :498394:15, :498398:15, :498401:15, :498404:15, :498408:15, :498411:15, :498414:15, :498417:15, :498420:15, :498423:15, :498426:15, :498429:15, :498432:15, :498435:15, :498438:15, :498441:15, :498444:15, :498447:15, :498450:15, :498453:15, :498456:15, :498459:15, :498462:15, :498465:15, :498469:15, :498478:15, :498481:15, :498484:15, :498487:15, :498490:15, :498493:15, :498496:15, :498499:15, :498502:15, :498505:15, :498508:15, :498511:15, :498514:15, :498517:15, :498520:15, :498523:15, :498526:15, :498529:15, :498532:15, :498535:15, :498538:15, :498541:15, :498544:15, :498547:15, :498550:15, :498553:15, :498557:15, :498560:15, :498563:15, :498566:15, :498581:15, :498584:15, :498587:15, :498590:15, :498593:15, :498608:15, :498612:15, :498615:15, :498618:15, :498621:15, :498624:15, :498627:15, :498630:15, :498633:15, :498636:15, :498639:15, :498643:15, :498646:15, :498649:15, :498652:15, :498655:15, :498658:15, :498661:15, :498664:15, :498667:15, :498670:15, :498673:15, :498676:15, :498680:15, :498683:15, :498686:15, :498689:15, :498692:15, :498695:15, :498698:15, :498701:15, :498704:15, :498707:15, :498710:15, :498713:15, :498716:15, :498719:15, :498722:15, :498725:15, :498728:15, :498731:15, :498734:15, :498737:15, :498740:15, :498743:15, :498746:15, :498749:15, :498752:15, :498755:15, :498758:15, :498762:15, :498765:15, :498768:15, :498771:15, :498774:15, :498777:15, :498780:15, :498783:15, :498786:15, :498920:15, :498924:15, :498927:15, :498930:15, :498933:15, :498936:15, :498939:15, :498942:15, :498945:15, :498949:15, :498952:15, :498955:15, :498958:15, :498961:15, :498964:15, :498967:15, :498970:15, :498973:15, :498976:15, :498979:15, :498982:15, :498985:15, :498988:15, :498991:15, :499006:15, :499009:15, :499012:15, :499015:15, :499018:15, :499021:15, :499024:15, :499027:15, :499030:15, :499033:15, :499036:15, :499039:15, :499042:15, :499045:15, :499051:15, :499054:15, :499057:15, :499060:15, :499063:15, :499066:15, :499069:15, :499084:15, :499087:15, :499090:15, :499093:15, :499096:15, :499111:15, :499114:15, :499117:15, :499120:15, :499123:15, :499138:15, :499141:15, :499144:15, :499147:15, :499150:15, :499165:15, :499168:15, :499171:15, :499174:15, :499177:15, :499180:15, :499183:15, :499186:15, :499189:15, :499198:15, :499201:15, :499204:15, :499207:15, :499210:15, :499213:15, :499216:15, :499219:15, :499222:15, :499225:15, :499228:15, :499231:15, :499234:15, :499252:15, :499255:15, :499258:15, :499261:15, :499264:15, :499267:15, :499270:15, :499273:15, :499276:15, :499279:15, :499282:15, :499285:15, :499288:15, :499291:15, :499294:15, :499297:15, :499300:15, :499303:15, :499306:15, :499309:15, :499312:15, :499315:15, :499318:15, :499321:15, :499324:15, :499327:15, :499331:15, :499334:15, :499337:15, :499340:15, :499344:15, :499347:15, :499350:15, :499353:15, :499356:15, :499359:15, :499362:15, :499443:15, :499446:15, :499449:15, :499452:15, :499482:15, :499488:15, :499494:15, :499497:15, :499500:15, :499503:15, :499506:15, :499509:15, :499512:15, :499515:15, :499518:15, :499521:15, :499524:15, :499527:15, :499530:15, :499533:15, :499536:15, :499539:15, :499542:15, :499545:15, :499548:15, :499551:15, :499554:15, :499557:15, :499560:15, :499563:15, :499566:15, :499569:15, :499572:15, :499578:15, :499581:15, :499584:15, :499590:15, :499593:15, :499620:15, :499623:15, :499626:15, :499629:15, :499632:15, :499635:15, :499665:15, :499668:15, :499671:15, :499674:15, :499692:15, :499695:15, :499698:15, :499704:15, :499707:15, :499710:15, :499713:15, :499716:15, :499719:15, :499722:15, :499725:15, :499728:15, :499731:15, :499734:15, :499755:15, :499758:15, :499761:15, :499764:15, :499767:15, :499770:15, :499773:15, :499791:15, :499794:15, :499797:15, :499800:15, :499803:15, :499806:15, :499809:15, :499812:15, :499815:15, :499818:15, :499821:15, :499824:15, :499827:15, :499830:15, :499833:15, :499836:15, :499839:15, :499842:15, :499845:15, :499848:15, :499851:15, :499854:15, :499938:15, :499941:15, :499944:15, :499947:15, :499950:15, :499980:15, :499983:15, :499986:15, :499989:15, :499992:15, :499995:15, :499998:15, :500001:15, :500004:15, :500007:15, :500010:15, :500013:15, :500016:15, :500019:15, :500022:15, :500028:15, :500031:15, :500067:15, :500098:15, :500101:15, :500104:15, :500107:15, :508678:15, :508681:15, :508684:15, :508687:15, :508690:15, :508693:15, :508697:15, :508700:15, :508703:15, :508706:15, :508709:15, :508712:15, :508715:15, :508718:15, :508721:15, :508724:15, :508727:15, :508730:15, :508733:15, :508736:15, :508739:15, :508742:15, :508745:15, :508748:15, :508751:15, :508754:15, :508757:15, :508760:15, :508764:15, :508767:15, :508770:15, :508774:15, :508777:15, :508780:15, :508783:15, :508786:15, :508789:15, :508792:15, :508795:15, :508798:15, :508801:15, :508804:15, :508807:15, :508810:15, :508813:15, :508816:15, :508819:15, :508822:15, :508825:15, :508828:15, :508831:15, :508833:15, :508835:15, :508839:15, :508842:15, :508845:15, :508848:15, :508851:15, :508854:15, :508857:15, :508860:15, :508863:15, :508866:15, :508869:15, :508872:15, :508875:15, :508878:15, :508881:15, :508884:15, :508887:15, :508890:15, :508893:15, :508896:15, :508899:15, :508902:15, :508905:15, :508908:15, :508911:15, :508914:15, :508917:15, :508920:15, :508924:15, :508927:15, :508930:15, :508933:15, :508936:15, :508939:15, :508942:15, :508945:15, :508948:15, :508951:15, :508954:15, :508957:15, :508960:15, :508963:15, :508966:15, :508969:15, :508972:15, :508975:15, :508979:15, :508982:15, :508985:15, :508988:15, :508991:15, :508994:15, :508997:15, :509000:15, :509003:15, :509006:15, :509010:15, :509013:15, :509016:15, :509019:15, :509022:15, :509025:15, :509028:15, :509031:15, :509034:15, :509037:15, :509040:15, :509043:15, :509047:15, :509050:15, :509053:15, :509056:15, :509059:15, :509062:15, :509065:15, :509068:15, :509071:15, :509074:15, :509077:15, :509080:15, :509083:15, :509086:15, :509089:15, :509092:15, :509095:15, :509098:15, :509101:15, :509104:15, :509107:15, :509110:15, :509113:15, :509116:15, :509119:15, :509122:15, :509125:15, :509129:15, :509132:15, :509135:15, :509138:15, :509141:15, :509144:15, :509147:15, :509150:15, :509153:15, :509156:15, :509159:15, :509162:15, :509165:15, :509168:15, :509171:15, :509174:15, :509177:15, :509180:15, :509183:15, :509186:15, :509190:15, :509193:15, :509196:15, :509199:15, :509202:15, :509205:15, :509208:15, :509211:15, :509214:15, :509217:15, :509220:15, :509223:15, :509226:15, :509229:15, :509232:15, :509235:15, :509238:15, :509241:15, :509244:15, :509247:15, :509250:15, :509253:15, :509256:15, :509259:15, :509262:15, :509265:15, :509268:15, :509271:15, :509274:15, :509277:15, :509280:15, :509283:15, :509285:15, :509287:15, :509291:15, :509294:15, :509297:15, :509300:15, :509303:15, :509306:15, :509309:15, :509312:15, :509316:15, :509319:15, :509322:15, :509325:15, :509328:15, :509331:15, :509334:15, :509337:15, :509340:15, :509343:15, :509346:15, :509349:15, :509352:15, :509355:15, :509358:15, :509361:15, :509364:15, :509367:15, :509370:15, :509373:15, :509376:15, :509379:15, :509382:15, :509385:15, :509388:15, :509391:15, :509394:15, :509397:15, :509400:15, :509403:15, :509406:15, :509409:15, :509412:15, :509415:15, :509418:15, :509421:15, :509424:15, :509427:15, :509430:15, :509433:15, :509436:15, :509439:15, :509442:15, :509445:15, :509448:15, :509451:15, :509454:15, :509457:15, :509460:15, :509463:15, :509466:15, :509469:15, :509472:15, :509475:15, :509478:15, :509481:15, :509484:15, :509487:15, :509490:15, :509493:15, :509496:15, :509499:15, :509502:15, :509505:15, :509508:15, :509511:15, :509514:15, :509517:15, :509520:15, :509523:15, :509526:15, :509529:15, :509532:15, :509535:15, :509538:15, :509541:15, :509544:15, :509547:15, :509550:15, :509553:15, :509556:15, :509559:15, :509562:15, :509565:15, :509568:15, :509571:15, :509574:15, :509577:15, :509580:15, :509583:15, :509586:15, :509589:15, :509592:15, :509595:15, :509598:15, :509601:15, :509604:15, :509607:15, :509610:15, :509613:15, :509616:15, :509619:15, :509622:15, :509625:15, :509628:15, :509631:15, :509634:15, :509637:15, :509640:15, :509643:15, :509646:15, :509649:15, :509652:15, :509655:15, :509658:15, :509661:15, :509664:15, :509667:15, :509670:15, :509673:15, :509676:15, :509679:15, :509682:15, :509685:15, :509688:15, :509691:15, :509694:15, :509698:15, :509701:15, :509704:15, :509707:15, :509709:15, :509711:15, :509714:15, :509717:15, :509720:15, :509723:15, :509726:15, :509729:15, :509732:15, :509735:15, :509738:15, :509741:15, :509744:15, :509747:15, :509750:15, :509753:15, :509756:15, :509759:15, :509762:15, :509765:15, :509768:15, :509771:15, :509774:15, :509777:15, :509780:15, :509783:15, :509786:15, :509789:15, :509792:15, :509795:15, :509798:15, :509801:15, :509804:15, :509807:15, :509810:15, :509813:15, :509816:15, :509819:15, :509822:15, :509825:15, :509828:15, :509831:15, :509834:15, :509837:15, :509840:15, :509843:15, :509846:15, :509849:15, :509852:15, :509855:15, :509858:15, :509861:15, :509864:15, :509867:15, :509870:15, :509873:15, :509876:15, :509879:15, :509882:15, :509885:15, :509888:15, :509891:15, :509894:15, :509897:15, :509900:15, :509903:15, :509906:15, :509909:15, :509912:15, :509915:15, :509918:15, :509921:15, :509924:15, :509927:15, :509930:15, :509933:15, :509936:15, :509939:15, :509942:15, :509945:15, :509948:15, :509951:15, :509954:15, :509957:15, :509960:15, :509963:15, :509966:15, :509969:15, :509972:15, :509975:15, :509978:15, :509981:15, :509984:15, :509987:15, :509990:15, :509993:15, :509996:15, :509999:15, :510002:15, :510005:15, :510008:15, :510011:15, :510014:15, :510017:15, :510020:15, :510023:15, :510026:15, :510029:15, :510032:15, :510035:15, :510038:15, :510041:15, :510044:15, :510047:15, :510050:15, :510053:15, :510056:15, :510059:15, :510062:15, :510065:15, :510068:15, :510071:15, :510074:15, :510077:15, :510080:15, :510083:15, :510086:15, :510089:15, :510092:15, :510095:15, :510098:15, :510101:15, :510104:15, :510107:15, :510110:15, :510113:15, :510116:15, :510119:15, :510122:15, :510125:15, :510128:15, :510131:15, :510134:15, :510137:15, :510140:15, :510143:15, :510146:15, :510149:15, :510152:15, :510155:15, :510158:15, :510161:15, :510164:15, :510167:15, :510170:15, :510173:15, :510176:15, :510179:15, :510182:15, :510185:15, :510188:15, :510191:15, :510194:15, :510197:15, :510200:15, :510203:15, :510206:15, :510209:15, :510212:15, :510215:15, :510218:15, :510221:15, :510224:15, :510227:15, :510230:15, :510233:15, :510236:15, :510239:15, :510242:15, :510245:15, :510248:15, :510251:15, :510254:15, :510257:15, :510260:15, :510263:15, :510266:15, :510269:15, :510272:15, :510275:15, :510278:15, :510281:15, :510284:15, :510287:15, :510290:15, :510293:15, :510296:15, :510299:15, :510302:15, :510305:15, :510308:15, :510311:15, :510314:15, :510317:15, :510320:15, :510323:15, :510326:15, :510329:15, :510332:15, :510335:15, :510338:15, :510341:15, :510344:15, :510347:15, :510350:15, :510353:15, :510356:15, :510359:15, :510362:15, :510365:15, :510368:15, :510371:15, :510374:15, :510377:15, :510380:15, :510383:15, :510386:15, :510389:15, :510392:15, :510395:15, :510398:15, :510401:15, :510404:15, :510407:15, :510410:15, :510413:15, :510416:15, :510419:15, :510422:15, :510425:15, :510428:15, :510431:15, :510434:15, :510437:15, :510440:15, :510443:15, :510446:15, :510449:15, :510452:15, :510455:15, :510458:15, :510461:15, :510465:15, :510468:15, :510471:15, :510474:15, :511660:15, :511839:15, :511841:15, :512083:15, :512138:15, :512908:15, :512911:15, :512914:15, :512917:15, :512920:15, :512923:15, :512927:15, :512930:15, :512933:15, :512936:15, :512939:15, :512942:15, :512945:15, :512948:15, :512951:15, :512954:15, :512957:15, :512960:15, :512963:15, :512966:15, :512969:15, :512972:15, :512975:15, :512978:15, :512981:15, :512984:15, :512987:15, :512990:15, :512994:15, :512997:15, :513000:15, :513004:15, :513007:15, :513010:15, :513013:15, :513016:15, :513019:15, :513022:15, :513025:15, :513028:15, :513031:15, :513034:15, :513037:15, :513040:15, :513043:15, :513046:15, :513049:15, :513052:15, :513055:15, :513058:15, :513061:15, :513063:15, :513065:15, :513068:15, :513071:15, :513074:15, :513077:15, :513080:15, :513083:15, :513086:15, :513089:15, :513092:15, :513095:15, :513098:15, :513101:15, :513104:15, :513107:15, :513110:15, :513113:15, :513116:15, :513119:15, :513122:15, :513125:15, :513128:15, :513131:15, :513134:15, :513137:15, :513140:15, :513143:15, :513146:15, :513149:15, :513153:15, :513156:15, :513159:15, :513162:15, :513165:15, :513168:15, :513171:15, :513174:15, :513177:15, :513180:15, :513183:15, :513186:15, :513189:15, :513192:15, :513195:15, :513198:15, :513201:15, :513204:15, :513208:15, :513211:15, :513214:15, :513217:15, :513220:15, :513223:15, :513226:15, :513229:15, :513232:15, :513235:15, :513239:15, :513242:15, :513245:15, :513248:15, :513251:15, :513254:15, :513257:15, :513260:15, :513263:15, :513266:15, :513269:15, :513272:15, :513276:15, :513279:15, :513282:15, :513285:15, :513288:15, :513291:15, :513294:15, :513297:15, :513300:15, :513303:15, :513306:15, :513309:15, :513312:15, :513315:15, :513318:15, :513321:15, :513324:15, :513327:15, :513330:15, :513333:15, :513336:15, :513339:15, :513342:15, :513345:15, :513348:15, :513351:15, :513354:15, :513358:15, :513361:15, :513364:15, :513367:15, :513370:15, :513373:15, :513376:15, :513379:15, :513382:15, :513385:15, :513388:15, :513391:15, :513394:15, :513397:15, :513400:15, :513403:15, :513406:15, :513409:15, :513412:15, :513415:15, :513419:15, :513422:15, :513425:15, :513428:15, :513431:15, :513434:15, :513437:15, :513440:15, :513443:15, :513446:15, :513449:15, :513452:15, :513455:15, :513458:15, :513461:15, :513464:15, :513467:15, :513470:15, :513473:15, :513476:15, :513479:15, :513482:15, :513485:15, :513488:15, :513491:15, :513494:15, :513497:15, :513500:15, :513503:15, :513506:15, :513509:15, :513512:15, :513514:15, :513516:15, :513520:15, :513523:15, :513526:15, :513529:15, :513532:15, :513535:15, :513538:15, :513541:15, :513545:15, :513548:15, :513551:15, :513554:15, :513557:15, :513560:15, :513563:15, :513566:15, :513569:15, :513572:15, :513575:15, :513578:15, :513581:15, :513584:15, :513587:15, :513590:15, :513593:15, :513596:15, :513599:15, :513602:15, :513605:15, :513608:15, :513611:15, :513614:15, :513617:15, :513620:15, :513623:15, :513626:15, :513629:15, :513632:15, :513635:15, :513638:15, :513641:15, :513644:15, :513647:15, :513650:15, :513653:15, :513656:15, :513659:15, :513662:15, :513665:15, :513668:15, :513671:15, :513674:15, :513677:15, :513680:15, :513683:15, :513686:15, :513689:15, :513692:15, :513695:15, :513698:15, :513701:15, :513704:15, :513707:15, :513710:15, :513713:15, :513716:15, :513719:15, :513722:15, :513725:15, :513728:15, :513731:15, :513734:15, :513737:15, :513740:15, :513743:15, :513746:15, :513749:15, :513752:15, :513755:15, :513758:15, :513761:15, :513764:15, :513767:15, :513770:15, :513773:15, :513776:15, :513779:15, :513782:15, :513785:15, :513788:15, :513791:15, :513794:15, :513797:15, :513800:15, :513803:15, :513806:15, :513809:15, :513812:15, :513815:15, :513818:15, :513821:15, :513824:15, :513827:15, :513830:15, :513833:15, :513836:15, :513839:15, :513842:15, :513845:15, :513848:15, :513851:15, :513854:15, :513857:15, :513860:15, :513863:15, :513866:15, :513869:15, :513872:15, :513875:15, :513878:15, :513881:15, :513884:15, :513887:15, :513890:15, :513893:15, :513896:15, :513899:15, :513902:15, :513905:15, :513908:15, :513911:15, :513914:15, :513917:15, :513920:15, :513923:15, :513927:15, :513930:15, :513933:15, :513936:15, :513938:15, :513940:15, :513943:15, :513946:15, :513949:15, :513952:15, :513955:15, :513958:15, :513961:15, :513964:15, :513967:15, :513970:15, :513973:15, :513976:15, :513979:15, :513982:15, :513985:15, :513988:15, :513991:15, :513994:15, :513997:15, :514000:15, :514003:15, :514006:15, :514009:15, :514012:15, :514015:15, :514018:15, :514021:15, :514024:15, :514027:15, :514030:15, :514033:15, :514036:15, :514039:15, :514042:15, :514045:15, :514048:15, :514051:15, :514054:15, :514057:15, :514060:15, :514063:15, :514066:15, :514069:15, :514072:15, :514075:15, :514078:15, :514081:15, :514084:15, :514087:15, :514090:15, :514093:15, :514096:15, :514099:15, :514102:15, :514105:15, :514108:15, :514111:15, :514114:15, :514117:15, :514120:15, :514123:15, :514126:15, :514129:15, :514132:15, :514135:15, :514138:15, :514141:15, :514144:15, :514147:15, :514150:15, :514153:15, :514156:15, :514159:15, :514162:15, :514165:15, :514168:15, :514171:15, :514174:15, :514177:15, :514180:15, :514183:15, :514186:15, :514189:15, :514192:15, :514195:15, :514198:15, :514201:15, :514204:15, :514207:15, :514210:15, :514213:15, :514216:15, :514219:15, :514222:15, :514225:15, :514228:15, :514231:15, :514234:15, :514237:15, :514240:15, :514243:15, :514246:15, :514249:15, :514252:15, :514255:15, :514258:15, :514261:15, :514264:15, :514267:15, :514270:15, :514273:15, :514276:15, :514279:15, :514282:15, :514285:15, :514288:15, :514291:15, :514294:15, :514297:15, :514300:15, :514303:15, :514306:15, :514309:15, :514312:15, :514315:15, :514318:15, :514321:15, :514324:15, :514327:15, :514330:15, :514333:15, :514336:15, :514339:15, :514342:15, :514345:15, :514348:15, :514351:15, :514354:15, :514357:15, :514360:15, :514363:15, :514366:15, :514369:15, :514372:15, :514375:15, :514378:15, :514381:15, :514384:15, :514387:15, :514390:15, :514393:15, :514396:15, :514399:15, :514402:15, :514405:15, :514408:15, :514411:15, :514414:15, :514417:15, :514420:15, :514423:15, :514426:15, :514429:15, :514432:15, :514435:15, :514438:15, :514441:15, :514444:15, :514447:15, :514450:15, :514453:15, :514456:15, :514459:15, :514462:15, :514465:15, :514468:15, :514471:15, :514474:15, :514477:15, :514480:15, :514483:15, :514486:15, :514489:15, :514492:15, :514495:15, :514498:15, :514501:15, :514504:15, :514507:15, :514510:15, :514513:15, :514516:15, :514519:15, :514522:15, :514525:15, :514528:15, :514531:15, :514534:15, :514537:15, :514540:15, :514543:15, :514546:15, :514549:15, :514552:15, :514555:15, :514558:15, :514561:15, :514564:15, :514567:15, :514570:15, :514573:15, :514576:15, :514579:15, :514582:15, :514585:15, :514588:15, :514591:15, :514594:15, :514597:15, :514600:15, :514603:15, :514606:15, :514609:15, :514612:15, :514615:15, :514618:15, :514621:15, :514624:15, :514627:15, :514630:15, :514633:15, :514636:15, :514639:15, :514642:15, :514645:15, :514648:15, :514651:15, :514654:15, :514657:15, :514660:15, :514663:15, :514666:15, :514669:15, :514672:15, :514675:15, :514678:15, :514681:15, :514684:15, :514687:15, :514690:15, :514694:15, :514697:15, :514700:15, :514703:15, :515889:15, :516241:15, :516245:15, :516249:15, :516253:15, :516257:15, :516261:15, :516265:15, :516267:15, :516269:15, :516303:15, :516306:15, :516309:15, :516312:15, :516315:15, :516318:15, :516322:15, :516325:15, :516328:15, :516331:15, :516334:15, :516337:15, :516340:15, :516343:15, :516346:15, :516349:15, :516352:15, :516355:15, :516358:15, :516361:15, :516364:15, :516367:15, :516370:15, :516373:15, :516376:15, :516379:15, :516382:15, :516385:15, :516389:15, :516392:15, :516395:15, :516399:15, :516402:15, :516405:15, :516408:15, :516411:15, :516414:15, :516417:15, :516420:15, :516423:15, :516426:15, :516429:15, :516432:15, :516435:15, :516438:15, :516441:15, :516444:15, :516447:15, :516450:15, :516453:15, :516456:15, :516458:15, :516460:15, :516463:15, :516466:15, :516469:15, :516472:15, :516475:15, :516478:15, :516481:15, :516484:15, :516487:15, :516490:15, :516493:15, :516496:15, :516499:15, :516502:15, :516505:15, :516508:15, :516511:15, :516514:15, :516517:15, :516520:15, :516523:15, :516526:15, :516529:15, :516532:15, :516535:15, :516538:15, :516541:15, :516544:15, :516548:15, :516551:15, :516554:15, :516557:15, :516560:15, :516563:15, :516566:15, :516569:15, :516572:15, :516575:15, :516578:15, :516581:15, :516584:15, :516587:15, :516590:15, :516593:15, :516596:15, :516599:15, :516603:15, :516606:15, :516609:15, :516612:15, :516615:15, :516618:15, :516621:15, :516624:15, :516627:15, :516630:15, :516634:15, :516637:15, :516640:15, :516643:15, :516646:15, :516649:15, :516652:15, :516655:15, :516658:15, :516661:15, :516664:15, :516667:15, :516671:15, :516674:15, :516677:15, :516680:15, :516683:15, :516686:15, :516689:15, :516692:15, :516695:15, :516698:15, :516701:15, :516704:15, :516707:15, :516710:15, :516713:15, :516716:15, :516719:15, :516722:15, :516725:15, :516728:15, :516731:15, :516734:15, :516737:15, :516740:15, :516743:15, :516746:15, :516749:15, :516753:15, :516756:15, :516759:15, :516762:15, :516765:15, :516768:15, :516771:15, :516774:15, :516777:15, :516780:15, :516783:15, :516786:15, :516789:15, :516792:15, :516795:15, :516798:15, :516801:15, :516804:15, :516807:15, :516810:15, :516814:15, :516817:15, :516820:15, :516823:15, :516826:15, :516829:15, :516832:15, :516835:15, :516838:15, :516841:15, :516844:15, :516847:15, :516850:15, :516853:15, :516856:15, :516859:15, :516862:15, :516865:15, :516868:15, :516871:15, :516874:15, :516877:15, :516880:15, :516883:15, :516886:15, :516889:15, :516892:15, :516895:15, :516898:15, :516901:15, :516904:15, :516907:15, :516909:15, :516911:15, :516915:15, :516918:15, :516921:15, :516924:15, :516927:15, :516930:15, :516933:15, :516936:15, :516940:15, :516943:15, :516946:15, :516949:15, :516952:15, :516955:15, :516958:15, :516961:15, :516964:15, :516967:15, :516970:15, :516973:15, :516976:15, :516979:15, :516982:15, :516985:15, :516988:15, :516991:15, :516994:15, :516997:15, :517000:15, :517003:15, :517006:15, :517009:15, :517012:15, :517015:15, :517018:15, :517021:15, :517024:15, :517027:15, :517030:15, :517033:15, :517036:15, :517039:15, :517042:15, :517045:15, :517048:15, :517051:15, :517054:15, :517057:15, :517060:15, :517063:15, :517066:15, :517069:15, :517072:15, :517075:15, :517078:15, :517081:15, :517084:15, :517087:15, :517090:15, :517093:15, :517096:15, :517099:15, :517102:15, :517105:15, :517108:15, :517111:15, :517114:15, :517117:15, :517120:15, :517123:15, :517126:15, :517129:15, :517132:15, :517135:15, :517138:15, :517141:15, :517144:15, :517147:15, :517150:15, :517153:15, :517156:15, :517159:15, :517162:15, :517165:15, :517168:15, :517171:15, :517174:15, :517177:15, :517180:15, :517183:15, :517186:15, :517189:15, :517192:15, :517195:15, :517198:15, :517201:15, :517204:15, :517207:15, :517210:15, :517213:15, :517216:15, :517219:15, :517222:15, :517225:15, :517228:15, :517231:15, :517234:15, :517237:15, :517240:15, :517243:15, :517246:15, :517249:15, :517252:15, :517255:15, :517258:15, :517261:15, :517264:15, :517267:15, :517270:15, :517273:15, :517276:15, :517279:15, :517282:15, :517285:15, :517288:15, :517291:15, :517294:15, :517297:15, :517300:15, :517303:15, :517306:15, :517309:15, :517312:15, :517315:15, :517318:15, :517322:15, :517325:15, :517328:15, :517331:15, :517333:15, :517335:15, :517338:15, :517341:15, :517344:15, :517347:15, :517350:15, :517353:15, :517356:15, :517359:15, :517362:15, :517365:15, :517368:15, :517371:15, :517374:15, :517377:15, :517380:15, :517383:15, :517386:15, :517389:15, :517392:15, :517395:15, :517398:15, :517401:15, :517404:15, :517407:15, :517410:15, :517413:15, :517416:15, :517419:15, :517422:15, :517425:15, :517428:15, :517431:15, :517434:15, :517437:15, :517440:15, :517443:15, :517446:15, :517449:15, :517452:15, :517455:15, :517458:15, :517461:15, :517464:15, :517467:15, :517470:15, :517473:15, :517476:15, :517479:15, :517482:15, :517485:15, :517488:15, :517491:15, :517494:15, :517497:15, :517500:15, :517503:15, :517506:15, :517509:15, :517512:15, :517515:15, :517518:15, :517521:15, :517524:15, :517527:15, :517530:15, :517533:15, :517536:15, :517539:15, :517542:15, :517545:15, :517548:15, :517551:15, :517554:15, :517557:15, :517560:15, :517563:15, :517566:15, :517569:15, :517572:15, :517575:15, :517578:15, :517581:15, :517584:15, :517587:15, :517590:15, :517593:15, :517596:15, :517599:15, :517602:15, :517605:15, :517608:15, :517611:15, :517614:15, :517617:15, :517620:15, :517623:15, :517626:15, :517629:15, :517632:15, :517635:15, :517638:15, :517641:15, :517644:15, :517647:15, :517650:15, :517653:15, :517656:15, :517659:15, :517662:15, :517665:15, :517668:15, :517671:15, :517674:15, :517677:15, :517680:15, :517683:15, :517686:15, :517689:15, :517692:15, :517695:15, :517698:15, :517701:15, :517704:15, :517707:15, :517710:15, :517713:15, :517716:15, :517719:15, :517722:15, :517725:15, :517728:15, :517731:15, :517734:15, :517737:15, :517740:15, :517743:15, :517746:15, :517749:15, :517752:15, :517755:15, :517758:15, :517761:15, :517764:15, :517767:15, :517770:15, :517773:15, :517776:15, :517779:15, :517782:15, :517785:15, :517788:15, :517791:15, :517794:15, :517797:15, :517800:15, :517803:15, :517806:15, :517809:15, :517812:15, :517815:15, :517818:15, :517821:15, :517824:15, :517827:15, :517830:15, :517833:15, :517836:15, :517839:15, :517842:15, :517845:15, :517848:15, :517851:15, :517854:15, :517857:15, :517860:15, :517863:15, :517866:15, :517869:15, :517872:15, :517875:15, :517878:15, :517881:15, :517884:15, :517887:15, :517890:15, :517893:15, :517896:15, :517899:15, :517902:15, :517905:15, :517908:15, :517911:15, :517914:15, :517917:15, :517920:15, :517923:15, :517926:15, :517929:15, :517932:15, :517935:15, :517938:15, :517941:15, :517944:15, :517947:15, :517950:15, :517953:15, :517956:15, :517959:15, :517962:15, :517965:15, :517968:15, :517971:15, :517974:15, :517977:15, :517980:15, :517983:15, :517986:15, :517989:15, :517992:15, :517995:15, :517998:15, :518001:15, :518004:15, :518007:15, :518010:15, :518013:15, :518016:15, :518019:15, :518022:15, :518025:15, :518028:15, :518031:15, :518034:15, :518037:15, :518040:15, :518043:15, :518046:15, :518049:15, :518052:15, :518055:15, :518058:15, :518061:15, :518064:15, :518067:15, :518070:15, :518073:15, :518076:15, :518079:15, :518082:15, :518085:15, :518089:15, :518092:15, :518095:15, :518098:15, :519284:16, :519636:16, :519640:16, :519644:16, :519648:16, :519652:16, :519656:16, :519660:16, :519662:16, :519664:16, :523111:16, :523158:16, :523184:16, :523238:16\r\n```", "code_snippet_01": "%3844 = comb.or %3233, %3234, %3235, %3236, %3237, %3238, %3240, %3241, %3242, %3243, %3244, %3245, %3246, %3247, %3248, %3249, %3250, %3251, %3252, %3253, %3254, %3255, %3256, %3257, %3258, %3259, %3260, %3261, %3263, %3264, %3265, %3267, %3268, %3269, %3270, %3271, %3272, %3273, %3274, %3275, %3276, %3277, %3278, %3279, %3280, %3281, %3282, %3283, %3284, %3285, %3286, %3288, %3290, %3291, %3292, %3293, %3294, %3295, %3296, %3297, %3298, %3299, %3300, %3301, %3302, %3303, %3304, %3305, %3306, %3307, %3308, %3309, %3310, %3311, %3312, %3313, %3314, %3315, %3316, %3317, %3319, %3320, %3321, %3322, %3323, %3324, %3325, %3326, %3327, %3328, %3329, %3330, %3331, %3332, %3333, %3334, %3335, %3336, %3338, %3339, %3340, %3341, %3342, %3343, %3344, %3345, %3346, %3347, %3349, %3350, %3351, %3352, %3353, %3354, %3355, %3356, %3357, %3358, %3359, %3360, %3362, %3363, %3364, %3365, %3366, %3367, %3368, %3369, %3370, %3371, %3372, %3373, %3374, %3375, %3376, %3377, %3378, %3379, %3380, %3381, %3382, %3383, %3384, %3385, %3386, %3387, %3388, %3390, %3391, %3392, %3393, %3394, %3395, %3396, %3397, %3398, %3399, %3400, %3401, %3402, %3403, %3404, %3405, %3406, %3407, %3408, %3409, %3411, %3412, %3413, %3414, %3415, %3416, %3417, %3418, %3419, %3420, %3421, %3422, %3423, %3424, %3425, %3426, %3427, %3428, %3429, %3430, %3431, %3432, %3433, %3434, %3435, %3436, %3437, %3438, %3439, %3440, %3441, %3442, %3444, %3446, %3447, %3448, %3449, %3450, %3451, %3452, %3453, %3455, %3456, %3457, %3458, %3459, %3460, %3461, %3462, %3463, %3464, %3465, %3466, %3467, %3468, %3469, %3470, %3471, %3472, %3473, %3474, %3475, %3476, %3477, %3478, %3479, %3480, %3481, %3482, %3483, %3484, %3485, %3486, %3487, %3488, %3489, %3490, %3491, %3492, %3493, %3494, %3495, %3496, %3497, %3498, %3499, %3500, %3501, %3502, %3503, %3504, %3505, %3506, %3507, %3508, %3509, %3510, %3511, %3512, %3513, %3514, %3515, %3516, %3517, %3518, %3519, %3520, %3521, %3522, %3523, %3524, %3525, %3526, %3527, %3528, %3529, %3530, %3531, %3532, %3533, %3534, %3535, %3536, %3537, %3538, %3539, %3540, %3541, %3542, %3543, %3544, %3545, %3546, %3547, %3548, %3549, %3550, %3551, %3552, %3553, %3554, %3555, %3556, %3557, %3558, %3559, %3560, %3561, %3562, %3563, %3564, %3565, %3566, %3567, %3568, %3569, %3570, %3571, %3572, %3573, %3574, %3575, %3576, %3577, %3578, %3579, %3580, %3581, %3583, %3584, %3585, %3586, %3588, %3589, %3590, %3591, %3592, %3593, %3594, %3595, %3596, %3597, %3598, %3599, %3600, %3601, %3602, %3603, %3604, %3605, %3606, %3607, %3608, %3609, %3610, %3611, %3612, %3613, %3614, %3615, %3616, %3617, %3618, %3619, %3620, %3621, %3622, %3623, %3624, %3625, %3626, %3627, %3628, %3629, %3630, %3631, %3632, %3633, %3634, %3635, %3636, %3637, %3638, %3639, %3640, %3641, %3642, %3643, %3644, %3645, %3646, %3647, %3648, %3649, %3650, %3651, %3652, %3653, %3654, %3655, %3656, %3657, %3658, %3659, %3660, %3661, %3662, %3663, %3664, %3665, %3666, %3667, %3668, %3669, %3670, %3671, %3672, %3673, %3674, %3675, %3676, %3677, %3678, %3679, %3680, %3681, %3682, %3683, %3684, %3685, %3686, %3687, %3688, %3689, %3690, %3691, %3692, %3693, %3694, %3695, %3696, %3697, %3698, %3699, %3700, %3701, %3702, %3703, %3704, %3705, %3706, %3707, %3708, %3709, %3710, %3711, %3712, %3713, %3714, %3715, %3716, %3717, %3718, %3719, %3720, %3721, %3722, %3723, %3724, %3725, %3726, %3727, %3728, %3729, %3730, %3731, %3732, %3733, %3734, %3735, %3736, %3737, %3738, %3739, %3740, %3741, %3742, %3743, %3744, %3745, %3746, %3747, %3748, %3749, %3750, %3751, %3752, %3753, %3754, %3755, %3756, %3757, %3758, %3759, %3760, %3761, %3762, %3763, %3764, %3765, %3766, %3767, %3768, %3769, %3770, %3771, %3772, %3773, %3774, %3775, %3776, %3777, %3778, %3779, %3780, %3781, %3782, %3783, %3784, %3785, %3786, %3787, %3788, %3789, %3790, %3791, %3792, %3793, %3794, %3795, %3796, %3797, %3798, %3799, %3800, %3801, %3802, %3803, %3804, %3805, %3806, %3807, %3808, %3809, %3810, %3811, %3812, %3813, %3814, %3815, %3816, %3817, %3818, %3819, %3820, %3821, %3822, %3823, %3824, %3825, %3826, %3827, %3828, %3829, %3830, %3831, %3832, %3833, %3834, %3835, %3836, %3837, %3838, %3840, %3841, %3842, %3843 : i1", "code_snippet_02": "wire _T_361 = _T_180 ? _T_181 == 64'h63\r\n| _T_181 == 64'h1063\r\n| _T_181 == 64'h4063\r\n| _T_181 == 64'h6063\r\n| _T_181 == 64'h5063\r\n| _T_181 == 64'h7063\r\n| _T_182 == 64'h6F\r\n| _T_181 == 64'h67\r\n| _T_181 == 64'h3\r\n| _T_181 == 64'h4003\r\n| _T_181 == 64'h1003\r\n| _T_181 == 64'h5003\r\n| _T_181 == 64'h2003\r\n| _T_181 == 64'h6003\r\n| _T_181 == 64'h3003\r\n| _T_181 == 64'h23\r\n| _T_181 == 64'h1023\r\n| _T_181 == 64'h2023\r\n| _T_181 == 64'h3023\r\n| _T_182 == 64'h37\r\n| _T_182 == 64'h17\r\n| _T_181 == 64'h13\r\n| _T_181 == 64'h2013\r\n| _T_181 == 64'h3013\r\n| _T_181 == 64'h7013\r\n| _T_181 == 64'h6013\r\n| _T_181 == 64'h4013\r\n| _T_181 == 64'h1B\r\n| _T_183 == 64'h101B\r\n| _T_183 == 64'h501B\r\n| _T_183 == 64'h4000501B\r\n| _T_184 == 64'h1013\r\n| _T_184 == 64'h5013\r\n| _T_184 == 64'h40005013\r\n| _T_183 == 64'h33\r\n| _T_183 == 64'h40000033\r\n| _T_183 == 64'h2033\r\n| _T_183 == 64'h3033\r\n| _T_183 == 64'h7033\r\n| _T_183 == 64'h6033\r\n| _T_183 == 64'h4033\r\n| _T_183 == 64'h1033\r\n| _T_183 == 64'h5033\r\n| _T_183 == 64'h40005033\r\n| _T_183 == 64'h3B\r\n| _T_183 == 64'h4000003B\r\n| _T_183 == 64'h103B\r\n| _T_183 == 64'h503B\r\n| _T_183 == 64'h4000503B\r\n| _T_181 == 64'hF\r\n| _T_181 == 64'h100F\r\n| (io_fetch_bits_data & 64'hFE007FFF) == 64'h12000073\r\n| _T_185 == 64'hFC000073\r\n| _T_185 == 64'hFC200073\r\n| _T_181 == 64'h5073\r\n| _T_181 == 64'h6073\r\n| _T_181 == 64'h7073\r\n| _T_185 == 64'h73\r\n| _T_185 == 64'h100073\r\n| _T_185 == 64'h30200073\r\n| _T_185 == 64'h10500073\r\n| _T_185 == 64'h30500073\r\n| _T_181 == 64'h1073\r\n| _T_181 == 64'h2073\r\n| _T_181 == 64'h3073\r\n| _T_185 == 64'h10200073\r\n| _T_185 == 64'h7B200073\r\n| _T_183 == 64'h2000033\r\n| _T_183 == 64'h2001033\r\n| _T_183 == 64'h2003033\r\n| _T_183 == 64'h2002033\r\n| _T_183 == 64'h200003B\r\n| _T_183 == 64'h2004033\r\n| _T_183 == 64'h2005033\r\n| _T_183 == 64'h2006033\r\n| _T_183 == 64'h2007033\r\n| _T_183 == 64'h200403B\r\n| _T_183 == 64'h200503B\r\n| _T_183 == 64'h200603B\r\n| _T_183 == 64'h200703B\r\n| _T_186 == 64'h202F\r\n| _T_186 == 64'h6000202F\r\n| _T_186 == 64'h4000202F\r\n| _T_186 == 64'h2000202F\r\n| _T_186 == 64'h8000202F\r\n| _T_186 == 64'hA000202F\r\n| _T_186 == 64'hC000202F\r\n| _T_186 == 64'hE000202F\r\n| _T_186 == 64'h800202F\r\n| _T_186 == 64'h302F\r\n| _T_186 == 64'h6000302F\r\n| _T_186 == 64'h4000302F\r\n| _T_186 == 64'h2000302F\r\n| _T_186 == 64'h8000302F\r\n| _T_186 == 64'hA000302F\r\n| _T_186 == 64'hC000302F\r\n| _T_186 == 64'hE000302F\r\n| _T_186 == 64'h800302F\r\n| _T_187 == 64'h1000202F\r\n| _T_186 == 64'h1800202F\r\n| _T_187 == 64'h1000302F\r\n| _T_186 == 64'h1800302F\r\n| _T_181 == 64'h1027\r\n| _T_181 == 64'h2027\r\n| _T_181 == 64'h3027\r\n| _T_181 == 64'h1007\r\n| _T_181 == 64'h2007\r\n| _T_181 == 64'h3007\r\n| _T_188 == 64'h4000043\r\n| _T_188 == 64'h4000047\r\n| _T_188 == 64'h400004B\r\n| _T_188 == 64'h400004F\r\n| _T_188 == 64'h43\r\n| _T_188 == 64'h47\r\n| _T_188 == 64'h4B\r\n| _T_188 == 64'h4F\r\n| _T_188 == 64'h2000043\r\n| _T_188 == 64'h2000047\r\n| _T_188 == 64'h200004B\r\n| _T_188 == 64'h200004F\r\n| _T_189 == 64'h4000053\r\n| _T_189 == 64'hC000053\r\n| _T_189 == 64'h14000053\r\n| _T_189 == 64'h1C000053\r\n| _T_183 == 64'h24000053\r\n| _T_183 == 64'h24001053\r\n| _T_183 == 64'h24002053\r\n| _T_183 == 64'h2C000053\r\n| _T_183 == 64'h2C001053\r\n| _T_189 == 64'h53\r\n| _T_189 == 64'h8000053\r\n| _T_189 == 64'h10000053\r\n| _T_189 == 64'h18000053\r\n| _T_183 == 64'h20000053\r\n| _T_183 == 64'h20001053\r\n| _T_183 == 64'h20002053\r\n| _T_183 == 64'h28000053\r\n| _T_183 == 64'h28001053\r\n| _T_189 == 64'h2000053\r\n| _T_189 == 64'hA000053\r\n| _T_189 == 64'h12000053\r\n| _T_189 == 64'h1A000053\r\n| _T_183 == 64'h22000053\r\n| _T_183 == 64'h22001053\r\n| _T_183 == 64'h22002053\r\n| _T_183 == 64'h2A000053\r\n| _T_183 == 64'h2A001053\r\n| _T_190 == 64'h5C000053\r\n| _T_190 == 64'h44000053\r\n| _T_190 == 64'h40200053\r\n| _T_190 == 64'h58000053\r\n| _T_190 == 64'h5A000053\r\n| _T_190 == 64'h40100053\r\n| _T_190 == 64'h42000053\r\n| _T_190 == 64'h44100053\r\n| _T_190 == 64'h42200053\r\n| _T_183 == 64'hA4002053\r\n| _T_183 == 64'hA4001053\r\n| _T_183 == 64'hA4000053\r\n| _T_183 == 64'hA0002053\r\n| _T_183 == 64'hA0001053\r\n| _T_183 == 64'hA0000053\r\n| _T_183 == 64'hA2002053\r\n| _T_183 == 64'hA2001053\r\n| _T_183 == 64'hA2000053\r\n| _T_190 == 64'hC4000053\r\n| _T_190 == 64'hC4100053\r\n| _T_191 == 64'hE4001053\r\n| _T_190 == 64'hC4200053\r\n| _T_190 == 64'hC4300053\r\n| _T_190 == 64'hC0000053\r\n| _T_190 == 64'hC0100053\r\n| _T_191 == 64'hE0001053\r\n| _T_190 == 64'hC0200053\r\n| _T_190 == 64'hC0300053\r\n| _T_190 == 64'hC2000053\r\n| _T_190 == 64'hC2100053\r\n| _T_191 == 64'hE2001053\r\n| _T_190 == 64'hC2200053\r\n| _T_190 == 64'hC2300053\r\n| _T_191 == 64'hE4000053\r\n| _T_191 == 64'hE0000053\r\n| _T_191 == 64'hE2000053\r\n| _T_191 == 64'hF4000053\r\n| _T_191 == 64'hF0000053\r\n| _T_191 == 64'hF2000053\r\n| _T_190 == 64'hD4000053\r\n| _T_190 == 64'hD4100053\r\n| _T_190 == 64'hD4200053\r\n| _T_190 == 64'hD4300053\r\n| _T_190 == 64'hD0000053\r\n| _T_190 == 64'hD0100053\r\n| _T_190 == 64'hD0200053\r\n| _T_190 == 64'hD0300053\r\n| _T_190 == 64'hD2000053\r\n| _T_190 == 64'hD2100053\r\n| _T_190 == 64'hD2200053\r\n| _T_190 == 64'hD2300053\r\n| _T_183 == 64'h80007057\r\n| (io_fetch_bits_data & 64'h8000707F) == 64'h7057\r\n| _T_192 == 64'h7\r\n| _T_192 == 64'h5007\r\n| _T_192 == 64'h6007\r\n| _T_192 == 64'h7007\r\n| _T_192 == 64'h1000007\r\n| _T_192 == 64'h1005007\r\n| _T_192 == 64'h1006007\r\n| _T_192 == 64'h1007007\r\n| _T_193 == 64'hC000007\r\n| _T_193 == 64'hC005007\r\n| _T_193 == 64'hC006007\r\n| _T_191 == 64'h2800007\r\n| _T_191 == 64'h2805007\r\n| _T_191 == 64'h2806007\r\n| _T_191 == 64'h2807007\r\n| _T_191 == 64'h22800007\r\n| _T_191 == 64'h22805007\r\n| _T_191 == 64'h22806007\r\n| _T_191 == 64'h22807007\r\n| _T_191 == 64'h62800007\r\n| _T_191 == 64'h62805007\r\n| _T_191 == 64'h62806007\r\n| _T_191 == 64'h62807007\r\n| _T_191 == 64'hE2800007\r\n| _T_191 == 64'hE2805007\r\n| _T_191 == 64'hE2806007\r\n| _T_191 == 64'hE2807007\r\n| _T_193 == 64'hC007007\r\n| _T_192 == 64'h27\r\n| _T_192 == 64'h5027\r\n| _T_192 == 64'h6027\r\n| _T_192 == 64'h7027\r\n| _T_193 == 64'hC000027\r\n| _T_193 == 64'hC005027\r\n| _T_193 == 64'hC006027\r\n| _T_184 == 64'h4000027\r\n| _T_184 == 64'h4005027\r\n| _T_184 == 64'h4006027\r\n| _T_191 == 64'h2800027\r\n| _T_191 == 64'h22800027\r\n| _T_191 == 64'h62800027\r\n| _T_191 == 64'hE2800027\r\n| _T_193 == 64'hC007027\r\n| _T_184 == 64'h4007027\r\n| _T_186 == 64'h800002F\r\n| _T_186 == 64'h2F\r\n| _T_186 == 64'h2000002F\r\n| _T_186 == 64'h6000002F\r\n| _T_186 == 64'h4000002F\r\n| _T_186 == 64'h8000002F\r\n| _T_186 == 64'hA000002F\r\n| _T_186 == 64'hC000002F\r\n| _T_186 == 64'hE000002F\r\n| _T_186 == 64'h800502F\r\n| _T_186 == 64'h502F\r\n| _T_186 == 64'h2000502F\r\n| _T_186 == 64'h6000502F\r\n| _T_186 == 64'h4000502F\r\n| _T_186 == 64'h8000502F\r\n| _T_186 == 64'hA000502F\r\n| _T_186 == 64'hC000502F\r\n| _T_186 == 64'hE000502F\r\n| _T_186 == 64'h800602F\r\n| _T_186 == 64'h602F\r\n| _T_186 == 64'h2000602F\r\n| _T_186 == 64'h6000602F\r\n| _T_186 == 64'h4000602F\r\n| _T_186 == 64'h8000602F\r\n| _T_186 == 64'hA000602F\r\n| _T_186 == 64'hC000602F\r\n| _T_186 == 64'hE000602F\r\n| _T_186 == 64'h800702F\r\n| _T_186 == 64'h702F\r\n| _T_186 == 64'h2000702F\r\n| _T_186 == 64'h6000702F\r\n| _T_186 == 64'h4000702F\r\n| _T_186 == 64'h8000702F\r\n| _T_186 == 64'hA000702F\r\n| _T_186 == 64'hC000702F\r\n| _T_186 == 64'hE000702F\r\n| _T_193 == 64'h8000007\r\n| _T_193 == 64'h8005007\r\n| _T_193 == 64'h8006007\r\n| _T_193 == 64'h8007007\r\n| _T_193 == 64'h8000027\r\n| _T_193 == 64'h8005027\r\n| _T_193 == 64'h8006027\r\n| _T_193 == 64'h8007027\r\n| _T_184 == 64'h2057\r\n| _T_184 == 64'hC4000057\r\n| _T_184 == 64'hC0000057\r\n| _T_184 == 64'h4002057\r\n| _T_184 == 64'h8002057\r\n| _T_184 == 64'hC002057\r\n| _T_184 == 64'h10002057\r\n| _T_184 == 64'h14002057\r\n| _T_184 == 64'h18002057\r\n| _T_184 == 64'h1C002057\r\n| _T_184 == 64'h57\r\n| _T_184 == 64'h8000057\r\n| _T_183 == 64'h40000057\r\n| _T_184 == 64'h44000057\r\n| _T_183 == 64'h48000057\r\n| _T_184 == 64'h4C000057\r\n| _T_184 == 64'h94000057\r\n| _T_184 == 64'hA0000057\r\n| _T_184 == 64'hA4000057\r\n| _T_184 == 64'hB0000057\r\n| _T_184 == 64'hB4000057\r\n| _T_184 == 64'h24000057\r\n| _T_184 == 64'h28000057\r\n| _T_184 == 64'h2C000057\r\n| _T_184 == 64'h60000057\r\n| _T_184 == 64'h64000057\r\n| _T_184 == 64'h6C000057\r\n| _T_184 == 64'h68000057\r\n| _T_184 == 64'h70000057\r\n| _T_184 == 64'h74000057\r\n| _T_184 == 64'h10000057\r\n| _T_184 == 64'h14000057\r\n| _T_184 == 64'h18000057\r\n| _T_184 == 64'h1C000057\r\n| _T_184 == 64'h30000057\r\n| _T_184 == 64'h38000057\r\n| _T_183 == 64'h5E002057\r\n| _T_183 == 64'h5C000057\r\n| _T_191 == 64'h5E000057\r\n| _T_184 == 64'h60002057\r\n| _T_184 == 64'h64002057\r\n| _T_184 == 64'h68002057\r\n| _T_184 == 64'h6C002057\r\n| _T_184 == 64'h70002057\r\n| _T_184 == 64'h74002057\r\n| _T_184 == 64'h78002057\r\n| _T_184 == 64'h7C002057\r\n| _T_194 == 64'h5000A057\r\n| _T_194 == 64'h50012057\r\n| _T_194 == 64'h5001A057\r\n| _T_194 == 64'h50082057\r\n| (io_fetch_bits_data & 64'hFDFFF07F) == 64'h5008A057\r\n| _T_194 == 64'h48032057\r\n| _T_194 == 64'h4803A057\r\n| _T_194 == 64'h48022057\r\n| _T_194 == 64'h4802A057\r\n| _T_194 == 64'h48012057\r\n| _T_194 == 64'h4801A057\r\n| _T_184 == 64'hC4002057\r\n| _T_184 == 64'hC0002057\r\n| _T_184 == 64'hCC002057\r\n| _T_184 == 64'hC8002057\r\n| _T_184 == 64'hD4002057\r\n| _T_184 == 64'hD0002057\r\n| _T_184 == 64'hDC002057\r\n| _T_184 == 64'hD8002057\r\n| _T_184 == 64'hEC002057\r\n| _T_184 == 64'hE0002057\r\n| _T_184 == 64'hE8002057\r\n| _T_184 == 64'hF0002057\r\n| _T_184 == 64'hF4002057\r\n| _T_184 == 64'hFC002057\r\n| _T_184 == 64'h94002057\r\n| _T_184 == 64'h9C002057\r\n| _T_184 == 64'h90002057\r\n| _T_184 == 64'h98002057\r\n| _T_184 == 64'h84002057\r\n| _T_184 == 64'h80002057\r\n| _T_184 == 64'h8C002057\r\n| _T_184 == 64'h88002057\r\n| _T_184 == 64'hA4002057\r\n| _T_184 == 64'hAC002057\r\n| _T_184 == 64'hB4002057\r\n| _T_184 == 64'hBC002057\r\n| _T_184 == 64'h24002057\r\n| _T_184 == 64'h2C002057\r\n| _T_184 == 64'h20002057\r\n| _T_184 == 64'h28002057\r\n| _T_184 == 64'h84000057\r\n| _T_184 == 64'h8C000057\r\n| _T_184 == 64'h80000057\r\n| _T_184 == 64'h88000057\r\n| _T_184 == 64'h9C000057\r\n| _T_184 == 64'hA8000057\r\n| _T_184 == 64'hAC000057\r\n| _T_184 == 64'hBC000057\r\n| _T_184 == 64'hB8000057\r\n| _T_184 == 64'h4001057\r\n| _T_184 == 64'hC4001057\r\n| _T_184 == 64'hC001057\r\n| _T_184 == 64'hCC001057\r\n| _T_184 == 64'h14001057\r\n| _T_184 == 64'h1C001057\r\n| _T_194 == 64'h4C081057\r\n| _T_184 == 64'h10001057\r\n| _T_184 == 64'h18001057\r\n| _T_184 == 64'h60001057\r\n| _T_184 == 64'h64001057\r\n| _T_184 == 64'h6C001057\r\n| _T_184 == 64'h70001057\r\n| _T_194 == 64'h48011057\r\n| _T_194 == 64'h48019057\r\n| _T_194 == 64'h48091057\r\n| _T_194 == 64'h48099057\r\n| _T_194 == 64'h480B1057\r\n| _T_194 == 64'h480B9057\r\n| _T_194 == 64'h48081057\r\n| _T_194 == 64'h48089057\r\n| _T_194 == 64'h48051057\r\n| _T_194 == 64'h48059057\r\n| _T_194 == 64'h48071057\r\n| _T_194 == 64'h48079057\r\n| _T_194 == 64'h48041057\r\n| _T_194 == 64'h48049057\r\n| _T_194 == 64'h48031057\r\n| _T_194 == 64'h48039057\r\n| _T_194 == 64'h48001057\r\n| _T_194 == 64'h48009057\r\n| _T_184 == 64'h90001057\r\n| _T_184 == 64'h1057\r\n| _T_184 == 64'h8001057\r\n| _T_194 == 64'h4C001057\r\n| _T_184 == 64'h80001057\r\n| _T_194 == 64'h4C021057\r\n| _T_194 == 64'h4C029057\r\n| _T_184 == 64'hB0001057\r\n| _T_184 == 64'hB4001057\r\n| _T_184 == 64'hB8001057\r\n| _T_184 == 64'hBC001057\r\n| _T_184 == 64'hA0001057\r\n| _T_184 == 64'hA4001057\r\n| _T_184 == 64'hA8001057\r\n| _T_184 == 64'hAC001057\r\n| _T_184 == 64'h20001057\r\n| _T_184 == 64'h24001057\r\n| _T_184 == 64'h28001057\r\n| _T_194 == 64'h480A1057\r\n| _T_194 == 64'h480A9057\r\n| _T_194 == 64'h48061057\r\n| _T_184 == 64'hC0001057\r\n| _T_184 == 64'hC8001057\r\n| _T_184 == 64'hE0001057\r\n| _T_184 == 64'hD0001057\r\n| _T_184 == 64'hD8001057\r\n| _T_184 == 64'hF0001057\r\n| _T_184 == 64'hF4001057\r\n| _T_184 == 64'hF8001057\r\n| _T_184 == 64'hFC001057\r\n| _T_184 == 64'h3057\r\n| _T_183 == 64'h40003057\r\n| _T_184 == 64'h44003057\r\n| _T_184 == 64'hC003057\r\n| _T_184 == 64'h94003057\r\n| _T_184 == 64'hA0003057\r\n| _T_184 == 64'hA4003057\r\n| _T_184 == 64'hB0003057\r\n| _T_184 == 64'hB4003057\r\n| _T_184 == 64'h24003057\r\n| _T_184 == 64'h28003057\r\n| _T_184 == 64'h2C003057\r\n| _T_183 == 64'h9E003057\r\n| _T_184 == 64'h38003057\r\n| _T_184 == 64'h3C003057\r\n| _T_184 == 64'h60003057\r\n| _T_184 == 64'h64003057\r\n| _T_184 == 64'h70003057\r\n| _T_184 == 64'h74003057\r\n| _T_184 == 64'h78003057\r\n| _T_184 == 64'h7C003057\r\n| _T_184 == 64'h30003057\r\n| _T_183 == 64'h5C003057\r\n| _T_191 == 64'h5E003057\r\n| _T_184 == 64'h84003057\r\n| _T_184 == 64'h80003057\r\n| _T_184 == 64'hA8003057\r\n| _T_184 == 64'hAC003057\r\n| _T_184 == 64'hBC003057\r\n| _T_184 == 64'hB8003057\r\n| _T_184 == 64'h4057\r\n| _T_184 == 64'h8004057\r\n| _T_183 == 64'h40004057\r\n| _T_184 == 64'h44004057\r\n| _T_183 == 64'h48004057\r\n| _T_184 == 64'h4C004057\r\n| _T_184 == 64'hC004057\r\n| _T_184 == 64'h94004057\r\n| _T_184 == 64'hA0004057\r\n| _T_184 == 64'hA4004057\r\n| _T_184 == 64'hB0004057\r\n| _T_184 == 64'hB4004057\r\n| _T_184 == 64'h24004057\r\n| _T_184 == 64'h28004057\r\n| _T_184 == 64'h2C004057\r\n| _T_184 == 64'h38004057\r\n| _T_184 == 64'h3C004057\r\n| _T_184 == 64'h38006057\r\n| _T_184 == 64'h3C006057\r\n| _T_184 == 64'h60004057\r\n| _T_184 == 64'h64004057\r\n| _T_184 == 64'h6C004057\r\n| _T_184 == 64'h68004057\r\n| _T_184 == 64'h70004057\r\n| _T_184 == 64'h74004057\r\n| _T_184 == 64'h78004057\r\n| _T_184 == 64'h7C004057\r\n| _T_184 == 64'h10004057\r\n| _T_184 == 64'h14004057\r\n| _T_184 == 64'h18004057\r\n| _T_184 == 64'h1C004057\r\n| _T_184 == 64'h30004057\r\n| _T_183 == 64'h5C004057\r\n| _T_191 == 64'h5E004057\r\n| _T_184 == 64'hC4006057\r\n| _T_184 == 64'hC0006057\r\n| _T_184 == 64'hCC006057\r\n| _T_184 == 64'hC8006057\r\n| _T_184 == 64'hD4006057\r\n| _T_184 == 64'hD0006057\r\n| _T_184 == 64'hDC006057\r\n| _T_184 == 64'hD8006057\r\n| _T_184 == 64'hEC006057\r\n| _T_184 == 64'hE0006057\r\n| _T_184 == 64'hE8006057\r\n| _T_184 == 64'hF0006057\r\n| _T_184 == 64'hF4006057\r\n| _T_184 == 64'hFC006057\r\n| _T_184 == 64'hF8006057\r\n| _T_184 == 64'h94006057\r\n| _T_184 == 64'h9C006057\r\n| _T_184 == 64'h90006057\r\n| _T_184 == 64'h98006057\r\n| _T_184 == 64'h84006057\r\n| _T_184 == 64'h80006057\r\n| _T_184 == 64'h8C006057\r\n| _T_184 == 64'h88006057\r\n| _T_184 == 64'hA4006057\r\n| _T_184 == 64'hAC006057\r\n| _T_184 == 64'hB4006057\r\n| _T_184 == 64'hBC006057\r\n| _T_191 == 64'h42006057\r\n| _T_184 == 64'h24006057\r\n| _T_184 == 64'h2C006057\r\n| _T_184 == 64'h20006057\r\n| _T_184 == 64'h28006057\r\n| _T_184 == 64'h84004057\r\n| _T_184 == 64'h8C004057\r\n| _T_184 == 64'h80004057\r\n| _T_184 == 64'h88004057\r\n| _T_184 == 64'h9C004057\r\n| _T_184 == 64'hA8004057\r\n| _T_184 == 64'hAC004057\r\n| _T_184 == 64'hBC004057\r\n| _T_184 == 64'hB8004057\r\n| _T_184 == 64'h38005057\r\n| _T_184 == 64'h3C005057\r\n| _T_184 == 64'h20005057\r\n| _T_184 == 64'h24005057\r\n| _T_184 == 64'h28005057\r\n| _T_184 == 64'h10005057\r\n| _T_184 == 64'h18005057\r\n| _T_184 == 64'h60005057\r\n| _T_184 == 64'h64005057\r\n| _T_184 == 64'h6C005057\r\n| _T_184 == 64'h70005057\r\n| _T_184 == 64'h74005057\r\n| _T_184 == 64'h7C005057\r\n| _T_183 == 64'h5C005057\r\n| _T_191 == 64'h5E005057\r\n| _T_184 == 64'h90005057\r\n| _T_184 == 64'h5057\r\n| _T_184 == 64'h8005057\r\n| _T_184 == 64'h9C005057\r\n| _T_184 == 64'h80005057\r\n| _T_184 == 64'h84005057\r\n| _T_184 == 64'hB0005057\r\n| _T_184 == 64'hB4005057\r\n| _T_184 == 64'hB8005057\r\n| _T_184 == 64'hBC005057\r\n| _T_184 == 64'hA0005057\r\n| _T_184 == 64'hA4005057\r\n| _T_184 == 64'hA8005057\r\n| _T_184 == 64'hAC005057\r\n| _T_191 == 64'h42005057\r\n| _T_184 == 64'hC0005057\r\n| _T_184 == 64'hC8005057\r\n| _T_184 == 64'hE0005057\r\n| _T_184 == 64'hD0005057\r\n| _T_184 == 64'hD8005057\r\n| _T_184 == 64'hF0005057\r\n| _T_184 == 64'hF4005057\r\n| _T_184 == 64'hF8005057\r\n| _T_184 == 64'hFC005057\r\n| _T_195 == 64'h42002057\r\n| _T_194 == 64'h40082057\r\n| _T_194 == 64'h4008A057\r\n| _T_195 == 64'h42001057 : _T_180 ? _T_343 : _T_345 ? _T_343 : _T_344 ? ((_T_249 ? 1'h1 : _T_248 ? 1'h1 : _T_247 ? 1'h1 : _T_246 ? 1'h1 : _T_245 ? |{_T_223, _T_207} : _T_244 ? 1'h1 : _T_243 ? _T_209 : 1'h1) == 1'h0 ? 1'h0 : _T_277 == 32'h63\r\n| _T_277 == 32'h1063\r\n| _T_277 == 32'h4063\r\n| _T_277 == 32'h6063\r\n| _T_277 == 32'h5063\r\n| _T_277 == 32'h7063\r\n| _T_278 == 32'h6F\r\n| _T_277 == 32'h67\r\n| _T_277 == 32'h3\r\n| _T_277 == 32'h4003\r\n| _T_277 == 32'h1003\r\n| _T_277 == 32'h5003\r\n| _T_277 == 32'h2003\r\n| _T_277 == 32'h6003\r\n| _T_277 == 32'h3003\r\n| _T_277 == 32'h23\r\n| _T_277 == 32'h1023\r\n| _T_277 == 32'h2023\r\n| _T_277 == 32'h3023\r\n| _T_278 == 32'h37\r\n| _T_278 == 32'h17\r\n| _T_277 == 32'h13\r\n| _T_277 == 32'h2013\r\n| _T_277 == 32'h3013\r\n| _T_277 == 32'h7013\r\n| _T_277 == 32'h6013\r\n| _T_277 == 32'h4013\r\n| _T_277 == 32'h1B\r\n| _T_279 == 32'h101B\r\n| _T_279 == 32'h501B\r\n| _T_279 == 32'h4000501B\r\n| _T_280 == 32'h1013\r\n| _T_280 == 32'h5013\r\n| _T_280 == 32'h40005013\r\n| _T_279 == 32'h33\r\n| _T_279 == 32'h40000033\r\n| _T_279 == 32'h2033\r\n| _T_279 == 32'h3033\r\n| _T_279 == 32'h7033\r\n| _T_279 == 32'h6033\r\n| _T_279 == 32'h4033\r\n| _T_279 == 32'h1033\r\n| _T_279 == 32'h5033\r\n| _T_279 == 32'h40005033\r\n| _T_279 == 32'h3B\r\n| _T_279 == 32'h4000003B\r\n| _T_279 == 32'h103B\r\n| _T_279 == 32'h503B\r\n| _T_279 == 32'h4000503B\r\n| _T_277 == 32'hF\r\n| _T_277 == 32'h100F\r\n| (_T_276 & 32'hFE007FFF) == 32'h12000073\r\n| _T_276 == 32'hFC000073\r\n| _T_276 == 32'hFC200073\r\n| _T_277 == 32'h5073\r\n| _T_277 == 32'h6073\r\n| _T_277 == 32'h7073\r\n| _T_276 == 32'h73\r\n| _T_276 == 32'h100073\r\n| _T_276 == 32'h30200073\r\n| _T_276 == 32'h10500073\r\n| _T_276 == 32'h30500073\r\n| _T_277 == 32'h1073\r\n| _T_277 == 32'h2073\r\n| _T_277 == 32'h3073\r\n| _T_276 == 32'h10200073\r\n| _T_276 == 32'h7B200073\r\n| _T_279 == 32'h2000033\r\n| _T_279 == 32'h2001033\r\n| _T_279 == 32'h2003033\r\n| _T_279 == 32'h2002033\r\n| _T_279 == 32'h200003B\r\n| _T_279 == 32'h2004033\r\n| _T_279 == 32'h2005033\r\n| _T_279 == 32'h2006033\r\n| _T_279 == 32'h2007033\r\n| _T_279 == 32'h200403B\r\n| _T_279 == 32'h200503B\r\n| _T_279 == 32'h200603B\r\n| _T_279 == 32'h200703B\r\n| _T_281 == 32'h202F\r\n| _T_281 == 32'h6000202F\r\n| _T_281 == 32'h4000202F\r\n| _T_281 == 32'h2000202F\r\n| _T_281 == 32'h8000202F\r\n| _T_281 == 32'hA000202F\r\n| _T_281 == 32'hC000202F\r\n| _T_281 == 32'hE000202F\r\n| _T_281 == 32'h800202F\r\n| _T_281 == 32'h302F\r\n| _T_281 == 32'h6000302F\r\n| _T_281 == 32'h4000302F\r\n| _T_281 == 32'h2000302F\r\n| _T_281 == 32'h8000302F\r\n| _T_281 == 32'hA000302F\r\n| _T_281 == 32'hC000302F\r\n| _T_281 == 32'hE000302F\r\n| _T_281 == 32'h800302F\r\n| _T_282 == 32'h1000202F\r\n| _T_281 == 32'h1800202F\r\n| _T_282 == 32'h1000302F\r\n| _T_281 == 32'h1800302F\r\n| _T_277 == 32'h1027\r\n| _T_277 == 32'h2027\r\n| _T_277 == 32'h3027\r\n| _T_277 == 32'h1007\r\n| _T_277 == 32'h2007\r\n| _T_277 == 32'h3007\r\n| _T_283 == 32'h4000043\r\n| _T_283 == 32'h4000047\r\n| _T_283 == 32'h400004B\r\n| _T_283 == 32'h400004F\r\n| _T_283 == 32'h43\r\n| _T_283 == 32'h47\r\n| _T_283 == 32'h4B\r\n| _T_283 == 32'h4F\r\n| _T_283 == 32'h2000043\r\n| _T_283 == 32'h2000047\r\n| _T_283 == 32'h200004B\r\n| _T_283 == 32'h200004F\r\n| _T_284 == 32'h4000053\r\n| _T_284 == 32'hC000053\r\n| _T_284 == 32'h14000053\r\n| _T_284 == 32'h1C000053\r\n| _T_279 == 32'h24000053\r\n| _T_279 == 32'h24001053\r\n| _T_279 == 32'h24002053\r\n| _T_279 == 32'h2C000053\r\n| _T_279 == 32'h2C001053\r\n| _T_284 == 32'h53\r\n| _T_284 == 32'h8000053\r\n| _T_284 == 32'h10000053\r\n| _T_284 == 32'h18000053\r\n| _T_279 == 32'h20000053\r\n| _T_279 == 32'h20001053\r\n| _T_279 == 32'h20002053\r\n| _T_279 == 32'h28000053\r\n| _T_279 == 32'h28001053\r\n| _T_284 == 32'h2000053\r\n| _T_284 == 32'hA000053\r\n| _T_284 == 32'h12000053\r\n| _T_284 == 32'h1A000053\r\n| _T_279 == 32'h22000053\r\n| _T_279 == 32'h22001053\r\n| _T_279 == 32'h22002053\r\n| _T_279 == 32'h2A000053\r\n| _T_279 == 32'h2A001053\r\n| _T_285 == 32'h5C000053\r\n| _T_285 == 32'h44000053\r\n| _T_285 == 32'h40200053\r\n| _T_285 == 32'h58000053\r\n| _T_285 == 32'h5A000053\r\n| _T_285 == 32'h40100053\r\n| _T_285 == 32'h42000053\r\n| _T_285 == 32'h44100053\r\n| _T_285 == 32'h42200053\r\n| _T_279 == 32'hA4002053\r\n| _T_279 == 32'hA4001053\r\n| _T_279 == 32'hA4000053\r\n| _T_279 == 32'hA0002053\r\n| _T_279 == 32'hA0001053\r\n| _T_279 == 32'hA0000053\r\n| _T_279 == 32'hA2002053\r\n| _T_279 == 32'hA2001053\r\n| _T_279 == 32'hA2000053\r\n| _T_285 == 32'hC4000053\r\n| _T_285 == 32'hC4100053\r\n| _T_286 == 32'hE4001053\r\n| _T_285 == 32'hC4200053\r\n| _T_285 == 32'hC4300053\r\n| _T_285 == 32'hC0000053\r\n| _T_285 == 32'hC0100053\r\n| _T_286 == 32'hE0001053\r\n| _T_285 == 32'hC0200053\r\n| _T_285 == 32'hC0300053\r\n| _T_285 == 32'hC2000053\r\n| _T_285 == 32'hC2100053\r\n| _T_286 == 32'hE2001053\r\n| _T_285 == 32'hC2200053\r\n| _T_285 == 32'hC2300053\r\n| _T_286 == 32'hE4000053\r\n| _T_286 == 32'hE0000053\r\n| _T_286 == 32'hE2000053\r\n| _T_286 == 32'hF4000053\r\n| _T_286 == 32'hF0000053\r\n| _T_286 == 32'hF2000053\r\n| _T_285 == 32'hD4000053\r\n| _T_285 == 32'hD4100053\r\n| _T_285 == 32'hD4200053\r\n| _T_285 == 32'hD4300053\r\n| _T_285 == 32'hD0000053\r\n| _T_285 == 32'hD0100053\r\n| _T_285 == 32'hD0200053\r\n| _T_285 == 32'hD0300053\r\n| _T_285 == 32'hD2000053\r\n| _T_285 == 32'hD2100053\r\n| _T_285 == 32'hD2200053\r\n| _T_285 == 32'hD2300053\r\n| _T_279 == 32'h80007057\r\n| (_T_276 & 32'h8000707F) == 32'h7057\r\n| _T_287 == 32'h7\r\n| _T_287 == 32'h5007\r\n| _T_287 == 32'h6007\r\n| _T_287 == 32'h7007\r\n| _T_287 == 32'h1000007\r\n| _T_287 == 32'h1005007\r\n| _T_287 == 32'h1006007\r\n| _T_287 == 32'h1007007\r\n| _T_288 == 32'hC000007\r\n| _T_288 == 32'hC005007\r\n| _T_288 == 32'hC006007\r\n| _T_286 == 32'h2800007\r\n| _T_286 == 32'h2805007\r\n| _T_286 == 32'h2806007\r\n| _T_286 == 32'h2807007\r\n| _T_286 == 32'h22800007\r\n| _T_286 == 32'h22805007\r\n| _T_286 == 32'h22806007\r\n| _T_286 == 32'h22807007\r\n| _T_286 == 32'h62800007\r\n| _T_286 == 32'h62805007\r\n| _T_286 == 32'h62806007\r\n| _T_286 == 32'h62807007\r\n| _T_286 == 32'hE2800007\r\n| _T_286 == 32'hE2805007\r\n| _T_286 == 32'hE2806007\r\n| _T_286 == 32'hE2807007\r\n| _T_288 == 32'hC007007\r\n| _T_287 == 32'h27\r\n| _T_287 == 32'h5027\r\n| _T_287 == 32'h6027\r\n| _T_287 == 32'h7027\r\n| _T_288 == 32'hC000027\r\n| _T_288 == 32'hC005027\r\n| _T_288 == 32'hC006027\r\n| _T_280 == 32'h4000027\r\n| _T_280 == 32'h4005027\r\n| _T_280 == 32'h4006027\r\n| _T_286 == 32'h2800027\r\n| _T_286 == 32'h22800027\r\n| _T_286 == 32'h62800027\r\n| _T_286 == 32'hE2800027\r\n| _T_288 == 32'hC007027\r\n| _T_280 == 32'h4007027\r\n| _T_281 == 32'h800002F\r\n| _T_281 == 32'h2F\r\n| _T_281 == 32'h2000002F\r\n| _T_281 == 32'h6000002F\r\n| _T_281 == 32'h4000002F\r\n| _T_281 == 32'h8000002F\r\n| _T_281 == 32'hA000002F\r\n| _T_281 == 32'hC000002F\r\n| _T_281 == 32'hE000002F\r\n| _T_281 == 32'h800502F\r\n| _T_281 == 32'h502F\r\n| _T_281 == 32'h2000502F\r\n| _T_281 == 32'h6000502F\r\n| _T_281 == 32'h4000502F\r\n| _T_281 == 32'h8000502F\r\n| _T_281 == 32'hA000502F\r\n| _T_281 == 32'hC000502F\r\n| _T_281 == 32'hE000502F\r\n| _T_281 == 32'h800602F\r\n| _T_281 == 32'h602F\r\n| _T_281 == 32'h2000602F\r\n| _T_281 == 32'h6000602F\r\n| _T_281 == 32'h4000602F\r\n| _T_281 == 32'h8000602F\r\n| _T_281 == 32'hA000602F\r\n| _T_281 == 32'hC000602F\r\n| _T_281 == 32'hE000602F\r\n| _T_281 == 32'h800702F\r\n| _T_281 == 32'h702F\r\n| _T_281 == 32'h2000702F\r\n| _T_281 == 32'h6000702F\r\n| _T_281 == 32'h4000702F\r\n| _T_281 == 32'h8000702F\r\n| _T_281 == 32'hA000702F\r\n| _T_281 == 32'hC000702F\r\n| _T_281 == 32'hE000702F\r\n| _T_288 == 32'h8000007\r\n| _T_288 == 32'h8005007\r\n| _T_288 == 32'h8006007\r\n| _T_288 == 32'h8007007\r\n| _T_288 == 32'h8000027\r\n| _T_288 == 32'h8005027\r\n| _T_288 == 32'h8006027\r\n| _T_288 == 32'h8007027\r\n| _T_280 == 32'h2057\r\n| _T_280 == 32'hC4000057\r\n| _T_280 == 32'hC0000057\r\n| _T_280 == 32'h4002057\r\n| _T_280 == 32'h8002057\r\n| _T_280 == 32'hC002057\r\n| _T_280 == 32'h10002057\r\n| _T_280 == 32'h14002057\r\n| _T_280 == 32'h18002057\r\n| _T_280 == 32'h1C002057\r\n| _T_280 == 32'h57\r\n| _T_280 == 32'h8000057\r\n| _T_279 == 32'h40000057\r\n| _T_280 == 32'h44000057\r\n| _T_279 == 32'h48000057\r\n| _T_280 == 32'h4C000057\r\n| _T_280 == 32'h94000057\r\n| _T_280 == 32'hA0000057\r\n| _T_280 == 32'hA4000057\r\n| _T_280 == 32'hB0000057\r\n| _T_280 == 32'hB4000057\r\n| _T_280 == 32'h24000057\r\n| _T_280 == 32'h28000057\r\n| _T_280 == 32'h2C000057\r\n| _T_280 == 32'h60000057\r\n| _T_280 == 32'h64000057\r\n| _T_280 == 32'h6C000057\r\n| _T_280 == 32'h68000057\r\n| _T_280 == 32'h70000057\r\n| _T_280 == 32'h74000057\r\n| _T_280 == 32'h10000057\r\n| _T_280 == 32'h14000057\r\n| _T_280 == 32'h18000057\r\n| _T_280 == 32'h1C000057\r\n| _T_280 == 32'h30000057\r\n| _T_280 == 32'h38000057\r\n| _T_279 == 32'h5E002057\r\n| _T_279 == 32'h5C000057\r\n| _T_286 == 32'h5E000057\r\n| _T_280 == 32'h60002057\r\n| _T_280 == 32'h64002057\r\n| _T_280 == 32'h68002057\r\n| _T_280 == 32'h6C002057\r\n| _T_280 == 32'h70002057\r\n| _T_280 == 32'h74002057\r\n| _T_280 == 32'h78002057\r\n| _T_280 == 32'h7C002057\r\n| _T_289 == 32'h5000A057\r\n| _T_289 == 32'h50012057\r\n| _T_289 == 32'h5001A057\r\n| _T_289 == 32'h50082057\r\n| (_T_276 & 32'hFDFFF07F) == 32'h5008A057\r\n| _T_289 == 32'h48032057\r\n| _T_289 == 32'h4803A057\r\n| _T_289 == 32'h48022057\r\n| _T_289 == 32'h4802A057\r\n| _T_289 == 32'h48012057\r\n| _T_289 == 32'h4801A057\r\n| _T_280 == 32'hC4002057\r\n| _T_280 == 32'hC0002057\r\n| _T_280 == 32'hCC002057\r\n| _T_280 == 32'hC8002057\r\n| _T_280 == 32'hD4002057\r\n| _T_280 == 32'hD0002057\r\n| _T_280 == 32'hDC002057\r\n| _T_280 == 32'hD8002057\r\n| _T_280 == 32'hEC002057\r\n| _T_280 == 32'hE0002057\r\n| _T_280 == 32'hE8002057\r\n| _T_280 == 32'hF0002057\r\n| _T_280 == 32'hF4002057\r\n| _T_280 == 32'hFC002057\r\n| _T_280 == 32'h94002057\r\n| _T_280 == 32'h9C002057\r\n| _T_280 == 32'h90002057\r\n| _T_280 == 32'h98002057\r\n| _T_280 == 32'h84002057\r\n| _T_280 == 32'h80002057\r\n| _T_280 == 32'h8C002057\r\n| _T_280 == 32'h88002057\r\n| _T_280 == 32'hA4002057\r\n| _T_280 == 32'hAC002057\r\n| _T_280 == 32'hB4002057\r\n| _T_280 == 32'hBC002057\r\n| _T_280 == 32'h24002057\r\n| _T_280 == 32'h2C002057\r\n| _T_280 == 32'h20002057\r\n| _T_280 == 32'h28002057\r\n| _T_280 == 32'h84000057\r\n| _T_280 == 32'h8C000057\r\n| _T_280 == 32'h80000057\r\n| _T_280 == 32'h88000057\r\n| _T_280 == 32'h9C000057\r\n| _T_280 == 32'hA8000057\r\n| _T_280 == 32'hAC000057\r\n| _T_280 == 32'hBC000057\r\n| _T_280 == 32'hB8000057\r\n| _T_280 == 32'h4001057\r\n| _T_280 == 32'hC4001057\r\n| _T_280 == 32'hC001057\r\n| _T_280 == 32'hCC001057\r\n| _T_280 == 32'h14001057\r\n| _T_280 == 32'h1C001057\r\n| _T_289 == 32'h4C081057\r\n| _T_280 == 32'h10001057\r\n| _T_280 == 32'h18001057\r\n| _T_280 == 32'h60001057\r\n| _T_280 == 32'h64001057\r\n| _T_280 == 32'h6C001057\r\n| _T_280 == 32'h70001057\r\n| _T_289 == 32'h48011057\r\n| _T_289 == 32'h48019057\r\n| _T_289 == 32'h48091057\r\n| _T_289 == 32'h48099057\r\n| _T_289 == 32'h480B1057\r\n| _T_289 == 32'h480B9057\r\n| _T_289 == 32'h48081057\r\n| _T_289 == 32'h48089057\r\n| _T_289 == 32'h48051057\r\n| _T_289 == 32'h48059057\r\n| _T_289 == 32'h48071057\r\n| _T_289 == 32'h48079057\r\n| _T_289 == 32'h48041057\r\n| _T_289 == 32'h48049057\r\n| _T_289 == 32'h48031057\r\n| _T_289 == 32'h48039057\r\n| _T_289 == 32'h48001057\r\n| _T_289 == 32'h48009057\r\n| _T_280 == 32'h90001057\r\n| _T_280 == 32'h1057\r\n| _T_280 == 32'h8001057\r\n| _T_289 == 32'h4C001057\r\n| _T_280 == 32'h80001057\r\n| _T_289 == 32'h4C021057\r\n| _T_289 == 32'h4C029057\r\n| _T_280 == 32'hB0001057\r\n| _T_280 == 32'hB4001057\r\n| _T_280 == 32'hB8001057\r\n| _T_280 == 32'hBC001057\r\n| _T_280 == 32'hA0001057\r\n| _T_280 == 32'hA4001057\r\n| _T_280 == 32'hA8001057\r\n| _T_280 == 32'hAC001057\r\n| _T_280 == 32'h20001057\r\n| _T_280 == 32'h24001057\r\n| _T_280 == 32'h28001057\r\n| _T_289 == 32'h480A1057\r\n| _T_289 == 32'h480A9057\r\n| _T_289 == 32'h48061057\r\n| _T_280 == 32'hC0001057\r\n| _T_280 == 32'hC8001057\r\n| _T_280 == 32'hE0001057\r\n| _T_280 == 32'hD0001057\r\n| _T_280 == 32'hD8001057\r\n| _T_280 == 32'hF0001057\r\n| _T_280 == 32'hF4001057\r\n| _T_280 == 32'hF8001057\r\n| _T_280 == 32'hFC001057\r\n| _T_280 == 32'h3057\r\n| _T_279 == 32'h40003057\r\n| _T_280 == 32'h44003057\r\n| _T_280 == 32'hC003057\r\n| _T_280 == 32'h94003057\r\n| _T_280 == 32'hA0003057\r\n| _T_280 == 32'hA4003057\r\n| _T_280 == 32'hB0003057\r\n| _T_280 == 32'hB4003057\r\n| _T_280 == 32'h24003057\r\n| _T_280 == 32'h28003057\r\n| _T_280 == 32'h2C003057\r\n| _T_279 == 32'h9E003057\r\n| _T_280 == 32'h38003057\r\n| _T_280 == 32'h3C003057\r\n| _T_280 == 32'h60003057\r\n| _T_280 == 32'h64003057\r\n| _T_280 == 32'h70003057\r\n| _T_280 == 32'h74003057\r\n| _T_280 == 32'h78003057\r\n| _T_280 == 32'h7C003057\r\n| _T_280 == 32'h30003057\r\n| _T_279 == 32'h5C003057\r\n| _T_286 == 32'h5E003057\r\n| _T_280 == 32'h84003057\r\n| _T_280 == 32'h80003057\r\n| _T_280 == 32'hA8003057\r\n| _T_280 == 32'hAC003057\r\n| _T_280 == 32'hBC003057\r\n| _T_280 == 32'hB8003057\r\n| _T_280 == 32'h4057\r\n| _T_280 == 32'h8004057\r\n| _T_279 == 32'h40004057\r\n| _T_280 == 32'h44004057\r\n| _T_279 == 32'h48004057\r\n| _T_280 == 32'h4C004057\r\n| _T_280 == 32'hC004057\r\n| _T_280 == 32'h94004057\r\n| _T_280 == 32'hA0004057\r\n| _T_280 == 32'hA4004057\r\n| _T_280 == 32'hB0004057\r\n| _T_280 == 32'hB4004057\r\n| _T_280 == 32'h24004057\r\n| _T_280 == 32'h28004057\r\n| _T_280 == 32'h2C004057\r\n| _T_280 == 32'h38004057\r\n| _T_280 == 32'h3C004057\r\n| _T_280 == 32'h38006057\r\n| _T_280 == 32'h3C006057\r\n| _T_280 == 32'h60004057\r\n| _T_280 == 32'h64004057\r\n| _T_280 == 32'h6C004057\r\n| _T_280 == 32'h68004057\r\n| _T_280 == 32'h70004057\r\n| _T_280 == 32'h74004057\r\n| _T_280 == 32'h78004057\r\n| _T_280 == 32'h7C004057\r\n| _T_280 == 32'h10004057\r\n| _T_280 == 32'h14004057\r\n| _T_280 == 32'h18004057\r\n| _T_280 == 32'h1C004057\r\n| _T_280 == 32'h30004057\r\n| _T_279 == 32'h5C004057\r\n| _T_286 == 32'h5E004057\r\n| _T_280 == 32'hC4006057\r\n| _T_280 == 32'hC0006057\r\n| _T_280 == 32'hCC006057\r\n| _T_280 == 32'hC8006057\r\n| _T_280 == 32'hD4006057\r\n| _T_280 == 32'hD0006057\r\n| _T_280 == 32'hDC006057\r\n| _T_280 == 32'hD8006057\r\n| _T_280 == 32'hEC006057\r\n| _T_280 == 32'hE0006057\r\n| _T_280 == 32'hE8006057\r\n| _T_280 == 32'hF0006057\r\n| _T_280 == 32'hF4006057\r\n| _T_280 == 32'hFC006057\r\n| _T_280 == 32'hF8006057\r\n| _T_280 == 32'h94006057\r\n| _T_280 == 32'h9C006057\r\n| _T_280 == 32'h90006057\r\n| _T_280 == 32'h98006057\r\n| _T_280 == 32'h84006057\r\n| _T_280 == 32'h80006057\r\n| _T_280 == 32'h8C006057\r\n| _T_280 == 32'h88006057\r\n| _T_280 == 32'hA4006057\r\n| _T_280 == 32'hAC006057\r\n| _T_280 == 32'hB4006057\r\n| _T_280 == 32'hBC006057\r\n| _T_286 == 32'h42006057\r\n| _T_280 == 32'h24006057\r\n| _T_280 == 32'h2C006057\r\n| _T_280 == 32'h20006057\r\n| _T_280 == 32'h28006057\r\n| _T_280 == 32'h84004057\r\n| _T_280 == 32'h8C004057\r\n| _T_280 == 32'h80004057\r\n| _T_280 == 32'h88004057\r\n| _T_280 == 32'h9C004057\r\n| _T_280 == 32'hA8004057\r\n| _T_280 == 32'hAC004057\r\n| _T_280 == 32'hBC004057\r\n| _T_280 == 32'hB8004057\r\n| _T_280 == 32'h38005057\r\n| _T_280 == 32'h3C005057\r\n| _T_280 == 32'h20005057\r\n| _T_280 == 32'h24005057\r\n| _T_280 == 32'h28005057\r\n| _T_280 == 32'h10005057\r\n| _T_280 == 32'h18005057\r\n| _T_280 == 32'h60005057\r\n| _T_280 == 32'h64005057\r\n| _T_280 == 32'h6C005057\r\n| _T_280 == 32'h70005057\r\n| _T_280 == 32'h74005057\r\n| _T_280 == 32'h7C005057\r\n| _T_279 == 32'h5C005057\r\n| _T_286 == 32'h5E005057\r\n| _T_280 == 32'h90005057\r\n| _T_280 == 32'h5057\r\n| _T_280 == 32'h8005057\r\n| _T_280 == 32'h9C005057\r\n| _T_280 == 32'h80005057\r\n| _T_280 == 32'h84005057\r\n| _T_280 == 32'hB0005057\r\n| _T_280 == 32'hB4005057\r\n| _T_280 == 32'hB8005057\r\n| _T_280 == 32'hBC005057\r\n| _T_280 == 32'hA0005057\r\n| _T_280 == 32'hA4005057\r\n| _T_280 == 32'hA8005057\r\n| _T_280 == 32'hAC005057\r\n| _T_286 == 32'h42005057\r\n| _T_280 == 32'hC0005057\r\n| _T_280 == 32'hC8005057\r\n| _T_280 == 32'hE0005057\r\n| _T_280 == 32'hD0005057\r\n| _T_280 == 32'hD8005057\r\n| _T_280 == 32'hF0005057\r\n| _T_280 == 32'hF4005057\r\n| _T_280 == 32'hF8005057\r\n| _T_280 == 32'hFC005057\r\n| _T_290 == 32'h42002057\r\n| _T_289 == 32'h40082057\r\n| _T_289 == 32'h4008A057\r\n| _T_290 == 32'h42001057) : (_T_249 ? 1'h1 : _T_248 ? 1'h1 : _T_247 ? 1'h1 : _T_246 ? 1'h1 : _T_245 ? 1'h1 : _T_244 ? 1'h1 : _T_243 ? 1'h1 : |io_fetch_bits_data[12:5]) == 1'h0 ? 1'h0 : _T_251 == 32'h63\r\n| _T_251 == 32'h1063\r\n| _T_251 == 32'h4063\r\n| _T_251 == 32'h6063\r\n| _T_251 == 32'h5063\r\n| _T_251 == 32'h7063\r\n| _T_252 == 32'h6F\r\n| _T_251 == 32'h67\r\n| _T_251 == 32'h3\r\n| _T_251 == 32'h4003\r\n| _T_251 == 32'h1003\r\n| _T_251 == 32'h5003\r\n| _T_251 == 32'h2003\r\n| _T_251 == 32'h6003\r\n| _T_251 == 32'h3003\r\n| _T_251 == 32'h23\r\n| _T_251 == 32'h1023\r\n| _T_251 == 32'h2023\r\n| _T_251 == 32'h3023\r\n| _T_252 == 32'h37\r\n| _T_252 == 32'h17\r\n| _T_251 == 32'h13\r\n| _T_251 == 32'h2013\r\n| _T_251 == 32'h3013\r\n| _T_251 == 32'h7013\r\n| _T_251 == 32'h6013\r\n| _T_251 == 32'h4013\r\n| _T_251 == 32'h1B\r\n| _T_253 == 32'h101B\r\n| _T_253 == 32'h501B\r\n| _T_253 == 32'h4000501B\r\n| _T_254 == 32'h1013\r\n| _T_254 == 32'h5013\r\n| _T_254 == 32'h40005013\r\n| _T_253 == 32'h33\r\n| _T_253 == 32'h40000033\r\n| _T_253 == 32'h2033\r\n| _T_253 == 32'h3033\r\n| _T_253 == 32'h7033\r\n| _T_253 == 32'h6033\r\n| _T_253 == 32'h4033\r\n| _T_253 == 32'h1033\r\n| _T_253 == 32'h5033\r\n| _T_253 == 32'h40005033\r\n| _T_253 == 32'h3B\r\n| _T_253 == 32'h4000003B\r\n| _T_253 == 32'h103B\r\n| _T_253 == 32'h503B\r\n| _T_253 == 32'h4000503B\r\n| _T_251 == 32'hF\r\n| _T_251 == 32'h100F\r\n| (_T_250 & 32'hFE007FFF) == 32'h12000073\r\n| _T_250 == 32'hFC000073\r\n| _T_250 == 32'hFC200073\r\n| _T_251 == 32'h5073\r\n| _T_251 == 32'h6073\r\n| _T_251 == 32'h7073\r\n| _T_250 == 32'h73\r\n| _T_250 == 32'h100073\r\n| _T_250 == 32'h30200073\r\n| _T_250 == 32'h10500073\r\n| _T_250 == 32'h30500073\r\n| _T_251 == 32'h1073\r\n| _T_251 == 32'h2073\r\n| _T_251 == 32'h3073\r\n| _T_250 == 32'h10200073\r\n| _T_250 == 32'h7B200073\r\n| _T_253 == 32'h2000033\r\n| _T_253 == 32'h2001033\r\n| _T_253 == 32'h2003033\r\n| _T_253 == 32'h2002033\r\n| _T_253 == 32'h200003B\r\n| _T_253 == 32'h2004033\r\n| _T_253 == 32'h2005033\r\n| _T_253 == 32'h2006033\r\n| _T_253 == 32'h2007033\r\n| _T_253 == 32'h200403B\r\n| _T_253 == 32'h200503B\r\n| _T_253 == 32'h200603B\r\n| _T_253 == 32'h200703B\r\n| _T_255 == 32'h202F\r\n| _T_255 == 32'h6000202F\r\n| _T_255 == 32'h4000202F\r\n| _T_255 == 32'h2000202F\r\n| _T_255 == 32'h8000202F\r\n| _T_255 == 32'hA000202F\r\n| _T_255 == 32'hC000202F\r\n| _T_255 == 32'hE000202F\r\n| _T_255 == 32'h800202F\r\n| _T_255 == 32'h302F\r\n| _T_255 == 32'h6000302F\r\n| _T_255 == 32'h4000302F\r\n| _T_255 == 32'h2000302F\r\n| _T_255 == 32'h8000302F\r\n| _T_255 == 32'hA000302F\r\n| _T_255 == 32'hC000302F\r\n| _T_255 == 32'hE000302F\r\n| _T_255 == 32'h800302F\r\n| _T_256 == 32'h1000202F\r\n| _T_255 == 32'h1800202F\r\n| _T_256 == 32'h1000302F\r\n| _T_255 == 32'h1800302F\r\n| _T_251 == 32'h1027\r\n| _T_251 == 32'h2027\r\n| _T_251 == 32'h3027\r\n| _T_251 == 32'h1007\r\n| _T_251 == 32'h2007\r\n| _T_251 == 32'h3007\r\n| _T_257 == 32'h4000043\r\n| _T_257 == 32'h4000047\r\n| _T_257 == 32'h400004B\r\n| _T_257 == 32'h400004F\r\n| _T_257 == 32'h43\r\n| _T_257 == 32'h47\r\n| _T_257 == 32'h4B\r\n| _T_257 == 32'h4F\r\n| _T_257 == 32'h2000043\r\n| _T_257 == 32'h2000047\r\n| _T_257 == 32'h200004B\r\n| _T_257 == 32'h200004F\r\n| _T_258 == 32'h4000053\r\n| _T_258 == 32'hC000053\r\n| _T_258 == 32'h14000053\r\n| _T_258 == 32'h1C000053\r\n| _T_253 == 32'h24000053\r\n| _T_253 == 32'h24001053\r\n| _T_253 == 32'h24002053\r\n| _T_253 == 32'h2C000053\r\n| _T_253 == 32'h2C001053\r\n| _T_258 == 32'h53\r\n| _T_258 == 32'h8000053\r\n| _T_258 == 32'h10000053\r\n| _T_258 == 32'h18000053\r\n| _T_253 == 32'h20000053\r\n| _T_253 == 32'h20001053\r\n| _T_253 == 32'h20002053\r\n| _T_253 == 32'h28000053\r\n| _T_253 == 32'h28001053\r\n| _T_258 == 32'h2000053\r\n| _T_258 == 32'hA000053\r\n| _T_258 == 32'h12000053\r\n| _T_258 == 32'h1A000053\r\n| _T_253 == 32'h22000053\r\n| _T_253 == 32'h22001053\r\n| _T_253 == 32'h22002053\r\n| _T_253 == 32'h2A000053\r\n| _T_253 == 32'h2A001053\r\n| _T_259 == 32'h5C000053\r\n| _T_259 == 32'h44000053\r\n| _T_259 == 32'h40200053\r\n| _T_259 == 32'h58000053\r\n| _T_259 == 32'h5A000053\r\n| _T_259 == 32'h40100053\r\n| _T_259 == 32'h42000053\r\n| _T_259 == 32'h44100053\r\n| _T_259 == 32'h42200053\r\n| _T_253 == 32'hA4002053\r\n| _T_253 == 32'hA4001053\r\n| _T_253 == 32'hA4000053\r\n| _T_253 == 32'hA0002053\r\n| _T_253 == 32'hA0001053\r\n| _T_253 == 32'hA0000053\r\n| _T_253 == 32'hA2002053\r\n| _T_253 == 32'hA2001053\r\n| _T_253 == 32'hA2000053\r\n| _T_259 == 32'hC4000053\r\n| _T_259 == 32'hC4100053\r\n| _T_260 == 32'hE4001053\r\n| _T_259 == 32'hC4200053\r\n| _T_259 == 32'hC4300053\r\n| _T_259 == 32'hC0000053\r\n| _T_259 == 32'hC0100053\r\n| _T_260 == 32'hE0001053\r\n| _T_259 == 32'hC0200053\r\n| _T_259 == 32'hC0300053\r\n| _T_259 == 32'hC2000053\r\n| _T_259 == 32'hC2100053\r\n| _T_260 == 32'hE2001053\r\n| _T_259 == 32'hC2200053\r\n| _T_259 == 32'hC2300053\r\n| _T_260 == 32'hE4000053\r\n| _T_260 == 32'hE0000053\r\n| _T_260 == 32'hE2000053\r\n| _T_260 == 32'hF4000053\r\n| _T_260 == 32'hF0000053\r\n| _T_260 == 32'hF2000053\r\n| _T_259 == 32'hD4000053\r\n| _T_259 == 32'hD4100053\r\n| _T_259 == 32'hD4200053\r\n| _T_259 == 32'hD4300053\r\n| _T_259 == 32'hD0000053\r\n| _T_259 == 32'hD0100053\r\n| _T_259 == 32'hD0200053\r\n| _T_259 == 32'hD0300053\r\n| _T_259 == 32'hD2000053\r\n| _T_259 == 32'hD2100053\r\n| _T_259 == 32'hD2200053\r\n| _T_259 == 32'hD2300053\r\n| _T_253 == 32'h80007057\r\n| (_T_250 & 32'h8000707F) == 32'h7057\r\n| _T_261 == 32'h7\r\n| _T_261 == 32'h5007\r\n| _T_261 == 32'h6007\r\n| _T_261 == 32'h7007\r\n| _T_261 == 32'h1000007\r\n| _T_261 == 32'h1005007\r\n| _T_261 == 32'h1006007\r\n| _T_261 == 32'h1007007\r\n| _T_262 == 32'hC000007\r\n| _T_262 == 32'hC005007\r\n| _T_262 == 32'hC006007\r\n| _T_260 == 32'h2800007\r\n| _T_260 == 32'h2805007\r\n| _T_260 == 32'h2806007\r\n| _T_260 == 32'h2807007\r\n| _T_260 == 32'h22800007\r\n| _T_260 == 32'h22805007\r\n| _T_260 == 32'h22806007\r\n| _T_260 == 32'h22807007\r\n| _T_260 == 32'h62800007\r\n| _T_260 == 32'h62805007\r\n| _T_260 == 32'h62806007\r\n| _T_260 == 32'h62807007\r\n| _T_260 == 32'hE2800007\r\n| _T_260 == 32'hE2805007\r\n| _T_260 == 32'hE2806007\r\n| _T_260 == 32'hE2807007\r\n| _T_262 == 32'hC007007\r\n| _T_261 == 32'h27\r\n| _T_261 == 32'h5027\r\n| _T_261 == 32'h6027\r\n| _T_261 == 32'h7027\r\n| _T_262 == 32'hC000027\r\n| _T_262 == 32'hC005027\r\n| _T_262 == 32'hC006027\r\n| _T_254 == 32'h4000027\r\n| _T_254 == 32'h4005027\r\n| _T_254 == 32'h4006027\r\n| _T_260 == 32'h2800027\r\n| _T_260 == 32'h22800027\r\n| _T_260 == 32'h62800027\r\n| _T_260 == 32'hE2800027\r\n| _T_262 == 32'hC007027\r\n| _T_254 == 32'h4007027\r\n| _T_255 == 32'h800002F\r\n| _T_255 == 32'h2F\r\n| _T_255 == 32'h2000002F\r\n| _T_255 == 32'h6000002F\r\n| _T_255 == 32'h4000002F\r\n| _T_255 == 32'h8000002F\r\n| _T_255 == 32'hA000002F\r\n| _T_255 == 32'hC000002F\r\n| _T_255 == 32'hE000002F\r\n| _T_255 == 32'h800502F\r\n| _T_255 == 32'h502F\r\n| _T_255 == 32'h2000502F\r\n| _T_255 == 32'h6000502F\r\n| _T_255 == 32'h4000502F\r\n| _T_255 == 32'h8000502F\r\n| _T_255 == 32'hA000502F\r\n| _T_255 == 32'hC000502F\r\n| _T_255 == 32'hE000502F\r\n| _T_255 == 32'h800602F\r\n| _T_255 == 32'h602F\r\n| _T_255 == 32'h2000602F\r\n| _T_255 == 32'h6000602F\r\n| _T_255 == 32'h4000602F\r\n| _T_255 == 32'h8000602F\r\n| _T_255 == 32'hA000602F\r\n| _T_255 == 32'hC000602F\r\n| _T_255 == 32'hE000602F\r\n| _T_255 == 32'h800702F\r\n| _T_255 == 32'h702F\r\n| _T_255 == 32'h2000702F\r\n| _T_255 == 32'h6000702F\r\n| _T_255 == 32'h4000702F\r\n| _T_255 == 32'h8000702F\r\n| _T_255 == 32'hA000702F\r\n| _T_255 == 32'hC000702F\r\n| _T_255 == 32'hE000702F\r\n| _T_262 == 32'h8000007\r\n| _T_262 == 32'h8005007\r\n| _T_262 == 32'h8006007\r\n| _T_262 == 32'h8007007\r\n| _T_262 == 32'h8000027\r\n| _T_262 == 32'h8005027\r\n| _T_262 == 32'h8006027\r\n| _T_262 == 32'h8007027\r\n| _T_254 == 32'h2057\r\n| _T_254 == 32'hC4000057\r\n| _T_254 == 32'hC0000057\r\n| _T_254 == 32'h4002057\r\n| _T_254 == 32'h8002057\r\n| _T_254 == 32'hC002057\r\n| _T_254 == 32'h10002057\r\n| _T_254 == 32'h14002057\r\n| _T_254 == 32'h18002057\r\n| _T_254 == 32'h1C002057\r\n| _T_254 == 32'h57\r\n| _T_254 == 32'h8000057\r\n| _T_253 == 32'h40000057\r\n| _T_254 == 32'h44000057\r\n| _T_253 == 32'h48000057\r\n| _T_254 == 32'h4C000057\r\n| _T_254 == 32'h94000057\r\n| _T_254 == 32'hA0000057\r\n| _T_254 == 32'hA4000057\r\n| _T_254 == 32'hB0000057\r\n| _T_254 == 32'hB4000057\r\n| _T_254 == 32'h24000057\r\n| _T_254 == 32'h28000057\r\n| _T_254 == 32'h2C000057\r\n| _T_254 == 32'h60000057\r\n| _T_254 == 32'h64000057\r\n| _T_254 == 32'h6C000057\r\n| _T_254 == 32'h68000057\r\n| _T_254 == 32'h70000057\r\n| _T_254 == 32'h74000057\r\n| _T_254 == 32'h10000057\r\n| _T_254 == 32'h14000057\r\n| _T_254 == 32'h18000057\r\n| _T_254 == 32'h1C000057\r\n| _T_254 == 32'h30000057\r\n| _T_254 == 32'h38000057\r\n| _T_253 == 32'h5E002057\r\n| _T_253 == 32'h5C000057\r\n| _T_260 == 32'h5E000057\r\n| _T_254 == 32'h60002057\r\n| _T_254 == 32'h64002057\r\n| _T_254 == 32'h68002057\r\n| _T_254 == 32'h6C002057\r\n| _T_254 == 32'h70002057\r\n| _T_254 == 32'h74002057\r\n| _T_254 == 32'h78002057\r\n| _T_254 == 32'h7C002057\r\n| _T_263 == 32'h5000A057\r\n| _T_263 == 32'h50012057\r\n| _T_263 == 32'h5001A057\r\n| _T_263 == 32'h50082057\r\n| (_T_250 & 32'hFDFFF07F) == 32'h5008A057\r\n| _T_263 == 32'h48032057\r\n| _T_263 == 32'h4803A057\r\n| _T_263 == 32'h48022057\r\n| _T_263 == 32'h4802A057\r\n| _T_263 == 32'h48012057\r\n| _T_263 == 32'h4801A057\r\n| _T_254 == 32'hC4002057\r\n| _T_254 == 32'hC0002057\r\n| _T_254 == 32'hCC002057\r\n| _T_254 == 32'hC8002057\r\n| _T_254 == 32'hD4002057\r\n| _T_254 == 32'hD0002057\r\n| _T_254 == 32'hDC002057\r\n| _T_254 == 32'hD8002057\r\n| _T_254 == 32'hEC002057\r\n| _T_254 == 32'hE0002057\r\n| _T_254 == 32'hE8002057\r\n| _T_254 == 32'hF0002057\r\n| _T_254 == 32'hF4002057\r\n| _T_254 == 32'hFC002057\r\n| _T_254 == 32'h94002057\r\n| _T_254 == 32'h9C002057\r\n| _T_254 == 32'h90002057\r\n| _T_254 == 32'h98002057\r\n| _T_254 == 32'h84002057\r\n| _T_254 == 32'h80002057\r\n| _T_254 == 32'h8C002057\r\n| _T_254 == 32'h88002057\r\n| _T_254 == 32'hA4002057\r\n| _T_254 == 32'hAC002057\r\n| _T_254 == 32'hB4002057\r\n| _T_254 == 32'hBC002057\r\n| _T_254 == 32'h24002057\r\n| _T_254 == 32'h2C002057\r\n| _T_254 == 32'h20002057\r\n| _T_254 == 32'h28002057\r\n| _T_254 == 32'h84000057\r\n| _T_254 == 32'h8C000057\r\n| _T_254 == 32'h80000057\r\n| _T_254 == 32'h88000057\r\n| _T_254 == 32'h9C000057\r\n| _T_254 == 32'hA8000057\r\n| _T_254 == 32'hAC000057\r\n| _T_254 == 32'hBC000057\r\n| _T_254 == 32'hB8000057\r\n| _T_254 == 32'h4001057\r\n| _T_254 == 32'hC4001057\r\n| _T_254 == 32'hC001057\r\n| _T_254 == 32'hCC001057\r\n| _T_254 == 32'h14001057\r\n| _T_254 == 32'h1C001057\r\n| _T_263 == 32'h4C081057\r\n| _T_254 == 32'h10001057\r\n| _T_254 == 32'h18001057\r\n| _T_254 == 32'h60001057\r\n| _T_254 == 32'h64001057\r\n| _T_254 == 32'h6C001057\r\n| _T_254 == 32'h70001057\r\n| _T_263 == 32'h48011057\r\n| _T_263 == 32'h48019057\r\n| _T_263 == 32'h48091057\r\n| _T_263 == 32'h48099057\r\n| _T_263 == 32'h480B1057\r\n| _T_263 == 32'h480B9057\r\n| _T_263 == 32'h48081057\r\n| _T_263 == 32'h48089057\r\n| _T_263 == 32'h48051057\r\n| _T_263 == 32'h48059057\r\n| _T_263 == 32'h48071057\r\n| _T_263 == 32'h48079057\r\n| _T_263 == 32'h48041057\r\n| _T_263 == 32'h48049057\r\n| _T_263 == 32'h48031057\r\n| _T_263 == 32'h48039057\r\n| _T_263 == 32'h48001057\r\n| _T_263 == 32'h48009057\r\n| _T_254 == 32'h90001057\r\n| _T_254 == 32'h1057\r\n| _T_254 == 32'h8001057\r\n| _T_263 == 32'h4C001057\r\n| _T_254 == 32'h80001057\r\n| _T_263 == 32'h4C021057\r\n| _T_263 == 32'h4C029057\r\n| _T_254 == 32'hB0001057\r\n| _T_254 == 32'hB4001057\r\n| _T_254 == 32'hB8001057\r\n| _T_254 == 32'hBC001057\r\n| _T_254 == 32'hA0001057\r\n| _T_254 == 32'hA4001057\r\n| _T_254 == 32'hA8001057\r\n| _T_254 == 32'hAC001057\r\n| _T_254 == 32'h20001057\r\n| _T_254 == 32'h24001057\r\n| _T_254 == 32'h28001057\r\n| _T_263 == 32'h480A1057\r\n| _T_263 == 32'h480A9057\r\n| _T_263 == 32'h48061057\r\n| _T_254 == 32'hC0001057\r\n| _T_254 == 32'hC8001057\r\n| _T_254 == 32'hE0001057\r\n| _T_254 == 32'hD0001057\r\n| _T_254 == 32'hD8001057\r\n| _T_254 == 32'hF0001057\r\n| _T_254 == 32'hF4001057\r\n| _T_254 == 32'hF8001057\r\n| _T_254 == 32'hFC001057\r\n| _T_254 == 32'h3057\r\n| _T_253 == 32'h40003057\r\n| _T_254 == 32'h44003057\r\n| _T_254 == 32'hC003057\r\n| _T_254 == 32'h94003057\r\n| _T_254 == 32'hA0003057\r\n| _T_254 == 32'hA4003057\r\n| _T_254 == 32'hB0003057\r\n| _T_254 == 32'hB4003057\r\n| _T_254 == 32'h24003057\r\n| _T_254 == 32'h28003057\r\n| _T_254 == 32'h2C003057\r\n| _T_253 == 32'h9E003057\r\n| _T_254 == 32'h38003057\r\n| _T_254 == 32'h3C003057\r\n| _T_254 == 32'h60003057\r\n| _T_254 == 32'h64003057\r\n| _T_254 == 32'h70003057\r\n| _T_254 == 32'h74003057\r\n| _T_254 == 32'h78003057\r\n| _T_254 == 32'h7C003057\r\n| _T_254 == 32'h30003057\r\n| _T_253 == 32'h5C003057\r\n| _T_260 == 32'h5E003057\r\n| _T_254 == 32'h84003057\r\n| _T_254 == 32'h80003057\r\n| _T_254 == 32'hA8003057\r\n| _T_254 == 32'hAC003057\r\n| _T_254 == 32'hBC003057\r\n| _T_254 == 32'hB8003057\r\n| _T_254 == 32'h4057\r\n| _T_254 == 32'h8004057\r\n| _T_253 == 32'h40004057\r\n| _T_254 == 32'h44004057\r\n| _T_253 == 32'h48004057\r\n| _T_254 == 32'h4C004057\r\n| _T_254 == 32'hC004057\r\n| _T_254 == 32'h94004057\r\n| _T_254 == 32'hA0004057\r\n| _T_254 == 32'hA4004057\r\n| _T_254 == 32'hB0004057\r\n| _T_254 == 32'hB4004057\r\n| _T_254 == 32'h24004057\r\n| _T_254 == 32'h28004057\r\n| _T_254 == 32'h2C004057\r\n| _T_254 == 32'h38004057\r\n| _T_254 == 32'h3C004057\r\n| _T_254 == 32'h38006057\r\n| _T_254 == 32'h3C006057\r\n| _T_254 == 32'h60004057\r\n| _T_254 == 32'h64004057\r\n| _T_254 == 32'h6C004057\r\n| _T_254 == 32'h68004057\r\n| _T_254 == 32'h70004057\r\n| _T_254 == 32'h74004057\r\n| _T_254 == 32'h78004057\r\n| _T_254 == 32'h7C004057\r\n| _T_254 == 32'h10004057\r\n| _T_254 == 32'h14004057\r\n| _T_254 == 32'h18004057\r\n| _T_254 == 32'h1C004057\r\n| _T_254 == 32'h30004057\r\n| _T_253 == 32'h5C004057\r\n| _T_260 == 32'h5E004057\r\n| _T_254 == 32'hC4006057\r\n| _T_254 == 32'hC0006057\r\n| _T_254 == 32'hCC006057\r\n| _T_254 == 32'hC8006057\r\n| _T_254 == 32'hD4006057\r\n| _T_254 == 32'hD0006057\r\n| _T_254 == 32'hDC006057\r\n| _T_254 == 32'hD8006057\r\n| _T_254 == 32'hEC006057\r\n| _T_254 == 32'hE0006057\r\n| _T_254 == 32'hE8006057\r\n| _T_254 == 32'hF0006057\r\n| _T_254 == 32'hF4006057\r\n| _T_254 == 32'hFC006057\r\n| _T_254 == 32'hF8006057\r\n| _T_254 == 32'h94006057\r\n| _T_254 == 32'h9C006057\r\n| _T_254 == 32'h90006057\r\n| _T_254 == 32'h98006057\r\n| _T_254 == 32'h84006057\r\n| _T_254 == 32'h80006057\r\n| _T_254 == 32'h8C006057\r\n| _T_254 == 32'h88006057\r\n| _T_254 == 32'hA4006057\r\n| _T_254 == 32'hAC006057\r\n| _T_254 == 32'hB4006057\r\n| _T_254 == 32'hBC006057\r\n| _T_260 == 32'h42006057\r\n| _T_254 == 32'h24006057\r\n| _T_254 == 32'h2C006057\r\n| _T_254 == 32'h20006057\r\n| _T_254 == 32'h28006057\r\n| _T_254 == 32'h84004057\r\n| _T_254 == 32'h8C004057\r\n| _T_254 == 32'h80004057\r\n| _T_254 == 32'h88004057\r\n| _T_254 == 32'h9C004057\r\n| _T_254 == 32'hA8004057\r\n| _T_254 == 32'hAC004057\r\n| _T_254 == 32'hBC004057\r\n| _T_254 == 32'hB8004057\r\n| _T_254 == 32'h38005057\r\n| _T_254 == 32'h3C005057\r\n| _T_254 == 32'h20005057\r\n| _T_254 == 32'h24005057\r\n| _T_254 == 32'h28005057\r\n| _T_254 == 32'h10005057\r\n| _T_254 == 32'h18005057\r\n| _T_254 == 32'h60005057\r\n| _T_254 == 32'h64005057\r\n| _T_254 == 32'h6C005057\r\n| _T_254 == 32'h70005057\r\n| _T_254 == 32'h74005057\r\n| _T_254 == 32'h7C005057\r\n| _T_253 == 32'h5C005057\r\n| _T_260 == 32'h5E005057\r\n| _T_254 == 32'h90005057\r\n| _T_254 == 32'h5057\r\n| _T_254 == 32'h8005057\r\n| _T_254 == 32'h9C005057\r\n| _T_254 == 32'h80005057\r\n| _T_254 == 32'h84005057\r\n| _T_254 == 32'hB0005057\r\n| _T_254 == 32'hB4005057\r\n| _T_254 == 32'hB8005057\r\n| _T_254 == 32'hBC005057\r\n| _T_254 == 32'hA0005057\r\n| _T_254 == 32'hA4005057\r\n| _T_254 == 32'hA8005057\r\n| _T_254 == 32'hAC005057\r\n| _T_260 == 32'h42005057\r\n| _T_254 == 32'hC0005057\r\n| _T_254 == 32'hC8005057\r\n| _T_254 == 32'hE0005057\r\n| _T_254 == 32'hD0005057\r\n| _T_254 == 32'hD8005057\r\n| _T_254 == 32'hF0005057\r\n| _T_254 == 32'hF4005057\r\n| _T_254 == 32'hF8005057\r\n| _T_254 == 32'hFC005057\r\n| _T_264 == 32'h42002057\r\n| _T_263 == 32'h40082057\r\n| _T_263 == 32'h4008A057\r\n| _T_264 == 32'h42001057;\t// foo.lo.fir.mlir:493257:17, :493315:27, :493318:27, :493319:27, :493351:27, :493352:27, :493353:27, :493354:27, :493360:27, :493361:27, :493362:27, :493363:27, :493427:27, :493428:27, :493429:27, :493430:27, :493431:27, :493432:27, :493433:27, :493434:27, :493435:27, :493436:27, :493437:27, :493439:27, :493440:27, :493441:27, :493442:27, :493443:27, :493444:27, :493445:27, :493446:27, :493447:27, :493448:27, :493449:27, :493450:27, :493451:27, :493452:27, :493453:27, :493454:27, :493455:27, :493456:27, :493457:27, :493458:27, :493459:27, :493460:27, :493461:27, :493462:27, :493463:27, :493464:27, :493465:27, :493466:27, :493467:27, :493468:27, :493469:27, :493470:27, :493471:27, :493498:27, :493499:27, :493500:27, :493501:27, :493516:27, :493524:27, :493525:27, :493526:27, :493527:27, :493533:27, :493534:27, :493535:27, :493536:27, :493542:27, :493543:27, :493544:27, :493545:27, :493551:27, :493552:27, :493553:27, :493554:27, :493564:27, :493565:27, :493579:27, :493580:27, :493581:27, :493582:27, :493583:27, :493615:27, :493623:27, :493624:27, :493625:27, :493626:27, :493627:27, :493628:27, :493629:27, :493630:27, :493631:27, :493632:27, :493633:27, :493634:27, :493635:27, :493636:27, :493637:27, :493638:27, :493639:27, :493640:27, :493641:27, :493642:27, :493643:27, :493644:27, :493645:27, :493646:27, :493647:27, :493648:27, :493653:27, :493654:27, :493655:27, :493656:27, :493657:27, :493658:27, :493659:27, :493660:27, :493661:27, :493663:27, :493665:27, :493693:27, :493697:27, :493700:27, :493701:27, :493702:27, :493703:27, :493704:27, :493705:27, :493706:27, :493707:27, :493714:27, :493715:27, :493716:27, :493717:27, :493718:27, :493719:27, :493720:27, :493721:27, :493722:27, :493727:27, :493728:27, :493729:27, :493730:27, :493731:27, :493735:27, :493747:27, :493748:27, :493749:27, :493750:27, :493751:27, :493752:27, :493760:27, :493761:27, :493762:27, :493763:27, :493764:27, :493787:27, :493788:27, :493789:27, :493790:27, :493791:27, :493792:27, :493793:27, :493794:27, :493795:27, :493796:27, :493797:27, :493798:27, :493799:27, :493800:27, :493801:27, :493802:27, :493803:27, :493804:27, :493805:27, :493806:27, :493807:27, :493808:27, :493809:27, :493810:27, :493811:27, :493812:27, :493813:27, :493819:27, :493820:27, :493821:27, :493822:27, :493823:27, :493824:27, :493825:27, :493826:27, :493827:27, :493843:27, :493846:27, :493847:27, :493848:27, :493849:27, :493850:27, :493851:27, :493852:27, :493853:27, :493854:27, :493855:27, :493856:27, :493858:27, :493859:27, :493860:27, :493861:27, :493862:27, :493863:27, :493864:27, :493865:27, :493866:27, :494059:13, :498312:15, :498315:15, :498318:15, :498321:15, :498324:15, :498327:15, :498331:15, :498334:15, :498337:15, :498340:15, :498343:15, :498346:15, :498349:15, :498352:15, :498355:15, :498358:15, :498361:15, :498364:15, :498367:15, :498370:15, :498373:15, :498376:15, :498379:15, :498382:15, :498385:15, :498388:15, :498391:15, :498394:15, :498398:15, :498401:15, :498404:15, :498408:15, :498411:15, :498414:15, :498417:15, :498420:15, :498423:15, :498426:15, :498429:15, :498432:15, :498435:15, :498438:15, :498441:15, :498444:15, :498447:15, :498450:15, :498453:15, :498456:15, :498459:15, :498462:15, :498465:15, :498469:15, :498478:15, :498481:15, :498484:15, :498487:15, :498490:15, :498493:15, :498496:15, :498499:15, :498502:15, :498505:15, :498508:15, :498511:15, :498514:15, :498517:15, :498520:15, :498523:15, :498526:15, :498529:15, :498532:15, :498535:15, :498538:15, :498541:15, :498544:15, :498547:15, :498550:15, :498553:15, :498557:15, :498560:15, :498563:15, :498566:15, :498581:15, :498584:15, :498587:15, :498590:15, :498593:15, :498608:15, :498612:15, :498615:15, :498618:15, :498621:15, :498624:15, :498627:15, :498630:15, :498633:15, :498636:15, :498639:15, :498643:15, :498646:15, :498649:15, :498652:15, :498655:15, :498658:15, :498661:15, :498664:15, :498667:15, :498670:15, :498673:15, :498676:15, :498680:15, :498683:15, :498686:15, :498689:15, :498692:15, :498695:15, :498698:15, :498701:15, :498704:15, :498707:15, :498710:15, :498713:15, :498716:15, :498719:15, :498722:15, :498725:15, :498728:15, :498731:15, :498734:15, :498737:15, :498740:15, :498743:15, :498746:15, :498749:15, :498752:15, :498755:15, :498758:15, :498762:15, :498765:15, :498768:15, :498771:15, :498774:15, :498777:15, :498780:15, :498783:15, :498786:15, :498920:15, :498924:15, :498927:15, :498930:15, :498933:15, :498936:15, :498939:15, :498942:15, :498945:15, :498949:15, :498952:15, :498955:15, :498958:15, :498961:15, :498964:15, :498967:15, :498970:15, :498973:15, :498976:15, :498979:15, :498982:15, :498985:15, :498988:15, :498991:15, :499006:15, :499009:15, :499012:15, :499015:15, :499018:15, :499021:15, :499024:15, :499027:15, :499030:15, :499033:15, :499036:15, :499039:15, :499042:15, :499045:15, :499051:15, :499054:15, :499057:15, :499060:15, :499063:15, :499066:15, :499069:15, :499084:15, :499087:15, :499090:15, :499093:15, :499096:15, :499111:15, :499114:15, :499117:15, :499120:15, :499123:15, :499138:15, :499141:15, :499144:15, :499147:15, :499150:15, :499165:15, :499168:15, :499171:15, :499174:15, :499177:15, :499180:15, :499183:15, :499186:15, :499189:15, :499198:15, :499201:15, :499204:15, :499207:15, :499210:15, :499213:15, :499216:15, :499219:15, :499222:15, :499225:15, :499228:15, :499231:15, :499234:15, :499252:15, :499255:15, :499258:15, :499261:15, :499264:15, :499267:15, :499270:15, :499273:15, :499276:15, :499279:15, :499282:15, :499285:15, :499288:15, :499291:15, :499294:15, :499297:15, :499300:15, :499303:15, :499306:15, :499309:15, :499312:15, :499315:15, :499318:15, :499321:15, :499324:15, :499327:15, :499331:15, :499334:15, :499337:15, :499340:15, :499344:15, :499347:15, :499350:15, :499353:15, :499356:15, :499359:15, :499362:15, :499443:15, :499446:15, :499449:15, :499452:15, :499482:15, :499488:15, :499494:15, :499497:15, :499500:15, :499503:15, :499506:15, :499509:15, :499512:15, :499515:15, :499518:15, :499521:15, :499524:15, :499527:15, :499530:15, :499533:15, :499536:15, :499539:15, :499542:15, :499545:15, :499548:15, :499551:15, :499554:15, :499557:15, :499560:15, :499563:15, :499566:15, :499569:15, :499572:15, :499578:15, :499581:15, :499584:15, :499590:15, :499593:15, :499620:15, :499623:15, :499626:15, :499629:15, :499632:15, :499635:15, :499665:15, :499668:15, :499671:15, :499674:15, :499692:15, :499695:15, :499698:15, :499704:15, :499707:15, :499710:15, :499713:15, :499716:15, :499719:15, :499722:15, :499725:15, :499728:15, :499731:15, :499734:15, :499755:15, :499758:15, :499761:15, :499764:15, :499767:15, :499770:15, :499773:15, :499791:15, :499794:15, :499797:15, :499800:15, :499803:15, :499806:15, :499809:15, :499812:15, :499815:15, :499818:15, :499821:15, :499824:15, :499827:15, :499830:15, :499833:15, :499836:15, :499839:15, :499842:15, :499845:15, :499848:15, :499851:15, :499854:15, :499938:15, :499941:15, :499944:15, :499947:15, :499950:15, :499980:15, :499983:15, :499986:15, :499989:15, :499992:15, :499995:15, :499998:15, :500001:15, :500004:15, :500007:15, :500010:15, :500013:15, :500016:15, :500019:15, :500022:15, :500028:15, :500031:15, :500067:15, :500098:15, :500101:15, :500104:15, :500107:15, :508678:15, :508681:15, :508684:15, :508687:15, :508690:15, :508693:15, :508697:15, :508700:15, :508703:15, :508706:15, :508709:15, :508712:15, :508715:15, :508718:15, :508721:15, :508724:15, :508727:15, :508730:15, :508733:15, :508736:15, :508739:15, :508742:15, :508745:15, :508748:15, :508751:15, :508754:15, :508757:15, :508760:15, :508764:15, :508767:15, :508770:15, :508774:15, :508777:15, :508780:15, :508783:15, :508786:15, :508789:15, :508792:15, :508795:15, :508798:15, :508801:15, :508804:15, :508807:15, :508810:15, :508813:15, :508816:15, :508819:15, :508822:15, :508825:15, :508828:15, :508831:15, :508833:15, :508835:15, :508839:15, :508842:15, :508845:15, :508848:15, :508851:15, :508854:15, :508857:15, :508860:15, :508863:15, :508866:15, :508869:15, :508872:15, :508875:15, :508878:15, :508881:15, :508884:15, :508887:15, :508890:15, :508893:15, :508896:15, :508899:15, :508902:15, :508905:15, :508908:15, :508911:15, :508914:15, :508917:15, :508920:15, :508924:15, :508927:15, :508930:15, :508933:15, :508936:15, :508939:15, :508942:15, :508945:15, :508948:15, :508951:15, :508954:15, :508957:15, :508960:15, :508963:15, :508966:15, :508969:15, :508972:15, :508975:15, :508979:15, :508982:15, :508985:15, :508988:15, :508991:15, :508994:15, :508997:15, :509000:15, :509003:15, :509006:15, :509010:15, :509013:15, :509016:15, :509019:15, :509022:15, :509025:15, :509028:15, :509031:15, :509034:15, :509037:15, :509040:15, :509043:15, :509047:15, :509050:15, :509053:15, :509056:15, :509059:15, :509062:15, :509065:15, :509068:15, :509071:15, :509074:15, :509077:15, :509080:15, :509083:15, :509086:15, :509089:15, :509092:15, :509095:15, :509098:15, :509101:15, :509104:15, :509107:15, :509110:15, :509113:15, :509116:15, :509119:15, :509122:15, :509125:15, :509129:15, :509132:15, :509135:15, :509138:15, :509141:15, :509144:15, :509147:15, :509150:15, :509153:15, :509156:15, :509159:15, :509162:15, :509165:15, :509168:15, :509171:15, :509174:15, :509177:15, :509180:15, :509183:15, :509186:15, :509190:15, :509193:15, :509196:15, :509199:15, :509202:15, :509205:15, :509208:15, :509211:15, :509214:15, :509217:15, :509220:15, :509223:15, :509226:15, :509229:15, :509232:15, :509235:15, :509238:15, :509241:15, :509244:15, :509247:15, :509250:15, :509253:15, :509256:15, :509259:15, :509262:15, :509265:15, :509268:15, :509271:15, :509274:15, :509277:15, :509280:15, :509283:15, :509285:15, :509287:15, :509291:15, :509294:15, :509297:15, :509300:15, :509303:15, :509306:15, :509309:15, :509312:15, :509316:15, :509319:15, :509322:15, :509325:15, :509328:15, :509331:15, :509334:15, :509337:15, :509340:15, :509343:15, :509346:15, :509349:15, :509352:15, :509355:15, :509358:15, :509361:15, :509364:15, :509367:15, :509370:15, :509373:15, :509376:15, :509379:15, :509382:15, :509385:15, :509388:15, :509391:15, :509394:15, :509397:15, :509400:15, :509403:15, :509406:15, :509409:15, :509412:15, :509415:15, :509418:15, :509421:15, :509424:15, :509427:15, :509430:15, :509433:15, :509436:15, :509439:15, :509442:15, :509445:15, :509448:15, :509451:15, :509454:15, :509457:15, :509460:15, :509463:15, :509466:15, :509469:15, :509472:15, :509475:15, :509478:15, :509481:15, :509484:15, :509487:15, :509490:15, :509493:15, :509496:15, :509499:15, :509502:15, :509505:15, :509508:15, :509511:15, :509514:15, :509517:15, :509520:15, :509523:15, :509526:15, :509529:15, :509532:15, :509535:15, :509538:15, :509541:15, :509544:15, :509547:15, :509550:15, :509553:15, :509556:15, :509559:15, :509562:15, :509565:15, :509568:15, :509571:15, :509574:15, :509577:15, :509580:15, :509583:15, :509586:15, :509589:15, :509592:15, :509595:15, :509598:15, :509601:15, :509604:15, :509607:15, :509610:15, :509613:15, :509616:15, :509619:15, :509622:15, :509625:15, :509628:15, :509631:15, :509634:15, :509637:15, :509640:15, :509643:15, :509646:15, :509649:15, :509652:15, :509655:15, :509658:15, :509661:15, :509664:15, :509667:15, :509670:15, :509673:15, :509676:15, :509679:15, :509682:15, :509685:15, :509688:15, :509691:15, :509694:15, :509698:15, :509701:15, :509704:15, :509707:15, :509709:15, :509711:15, :509714:15, :509717:15, :509720:15, :509723:15, :509726:15, :509729:15, :509732:15, :509735:15, :509738:15, :509741:15, :509744:15, :509747:15, :509750:15, :509753:15, :509756:15, :509759:15, :509762:15, :509765:15, :509768:15, :509771:15, :509774:15, :509777:15, :509780:15, :509783:15, :509786:15, :509789:15, :509792:15, :509795:15, :509798:15, :509801:15, :509804:15, :509807:15, :509810:15, :509813:15, :509816:15, :509819:15, :509822:15, :509825:15, :509828:15, :509831:15, :509834:15, :509837:15, :509840:15, :509843:15, :509846:15, :509849:15, :509852:15, :509855:15, :509858:15, :509861:15, :509864:15, :509867:15, :509870:15, :509873:15, :509876:15, :509879:15, :509882:15, :509885:15, :509888:15, :509891:15, :509894:15, :509897:15, :509900:15, :509903:15, :509906:15, :509909:15, :509912:15, :509915:15, :509918:15, :509921:15, :509924:15, :509927:15, :509930:15, :509933:15, :509936:15, :509939:15, :509942:15, :509945:15, :509948:15, :509951:15, :509954:15, :509957:15, :509960:15, :509963:15, :509966:15, :509969:15, :509972:15, :509975:15, :509978:15, :509981:15, :509984:15, :509987:15, :509990:15, :509993:15, :509996:15, :509999:15, :510002:15, :510005:15, :510008:15, :510011:15, :510014:15, :510017:15, :510020:15, :510023:15, :510026:15, :510029:15, :510032:15, :510035:15, :510038:15, :510041:15, :510044:15, :510047:15, :510050:15, :510053:15, :510056:15, :510059:15, :510062:15, :510065:15, :510068:15, :510071:15, :510074:15, :510077:15, :510080:15, :510083:15, :510086:15, :510089:15, :510092:15, :510095:15, :510098:15, :510101:15, :510104:15, :510107:15, :510110:15, :510113:15, :510116:15, :510119:15, :510122:15, :510125:15, :510128:15, :510131:15, :510134:15, :510137:15, :510140:15, :510143:15, :510146:15, :510149:15, :510152:15, :510155:15, :510158:15, :510161:15, :510164:15, :510167:15, :510170:15, :510173:15, :510176:15, :510179:15, :510182:15, :510185:15, :510188:15, :510191:15, :510194:15, :510197:15, :510200:15, :510203:15, :510206:15, :510209:15, :510212:15, :510215:15, :510218:15, :510221:15, :510224:15, :510227:15, :510230:15, :510233:15, :510236:15, :510239:15, :510242:15, :510245:15, :510248:15, :510251:15, :510254:15, :510257:15, :510260:15, :510263:15, :510266:15, :510269:15, :510272:15, :510275:15, :510278:15, :510281:15, :510284:15, :510287:15, :510290:15, :510293:15, :510296:15, :510299:15, :510302:15, :510305:15, :510308:15, :510311:15, :510314:15, :510317:15, :510320:15, :510323:15, :510326:15, :510329:15, :510332:15, :510335:15, :510338:15, :510341:15, :510344:15, :510347:15, :510350:15, :510353:15, :510356:15, :510359:15, :510362:15, :510365:15, :510368:15, :510371:15, :510374:15, :510377:15, :510380:15, :510383:15, :510386:15, :510389:15, :510392:15, :510395:15, :510398:15, :510401:15, :510404:15, :510407:15, :510410:15, :510413:15, :510416:15, :510419:15, :510422:15, :510425:15, :510428:15, :510431:15, :510434:15, :510437:15, :510440:15, :510443:15, :510446:15, :510449:15, :510452:15, :510455:15, :510458:15, :510461:15, :510465:15, :510468:15, :510471:15, :510474:15, :511660:15, :511839:15, :511841:15, :512083:15, :512138:15, :512908:15, :512911:15, :512914:15, :512917:15, :512920:15, :512923:15, :512927:15, :512930:15, :512933:15, :512936:15, :512939:15, :512942:15, :512945:15, :512948:15, :512951:15, :512954:15, :512957:15, :512960:15, :512963:15, :512966:15, :512969:15, :512972:15, :512975:15, :512978:15, :512981:15, :512984:15, :512987:15, :512990:15, :512994:15, :512997:15, :513000:15, :513004:15, :513007:15, :513010:15, :513013:15, :513016:15, :513019:15, :513022:15, :513025:15, :513028:15, :513031:15, :513034:15, :513037:15, :513040:15, :513043:15, :513046:15, :513049:15, :513052:15, :513055:15, :513058:15, :513061:15, :513063:15, :513065:15, :513068:15, :513071:15, :513074:15, :513077:15, :513080:15, :513083:15, :513086:15, :513089:15, :513092:15, :513095:15, :513098:15, :513101:15, :513104:15, :513107:15, :513110:15, :513113:15, :513116:15, :513119:15, :513122:15, :513125:15, :513128:15, :513131:15, :513134:15, :513137:15, :513140:15, :513143:15, :513146:15, :513149:15, :513153:15, :513156:15, :513159:15, :513162:15, :513165:15, :513168:15, :513171:15, :513174:15, :513177:15, :513180:15, :513183:15, :513186:15, :513189:15, :513192:15, :513195:15, :513198:15, :513201:15, :513204:15, :513208:15, :513211:15, :513214:15, :513217:15, :513220:15, :513223:15, :513226:15, :513229:15, :513232:15, :513235:15, :513239:15, :513242:15, :513245:15, :513248:15, :513251:15, :513254:15, :513257:15, :513260:15, :513263:15, :513266:15, :513269:15, :513272:15, :513276:15, :513279:15, :513282:15, :513285:15, :513288:15, :513291:15, :513294:15, :513297:15, :513300:15, :513303:15, :513306:15, :513309:15, :513312:15, :513315:15, :513318:15, :513321:15, :513324:15, :513327:15, :513330:15, :513333:15, :513336:15, :513339:15, :513342:15, :513345:15, :513348:15, :513351:15, :513354:15, :513358:15, :513361:15, :513364:15, :513367:15, :513370:15, :513373:15, :513376:15, :513379:15, :513382:15, :513385:15, :513388:15, :513391:15, :513394:15, :513397:15, :513400:15, :513403:15, :513406:15, :513409:15, :513412:15, :513415:15, :513419:15, :513422:15, :513425:15, :513428:15, :513431:15, :513434:15, :513437:15, :513440:15, :513443:15, :513446:15, :513449:15, :513452:15, :513455:15, :513458:15, :513461:15, :513464:15, :513467:15, :513470:15, :513473:15, :513476:15, :513479:15, :513482:15, :513485:15, :513488:15, :513491:15, :513494:15, :513497:15, :513500:15, :513503:15, :513506:15, :513509:15, :513512:15, :513514:15, :513516:15, :513520:15, :513523:15, :513526:15, :513529:15, :513532:15, :513535:15, :513538:15, :513541:15, :513545:15, :513548:15, :513551:15, :513554:15, :513557:15, :513560:15, :513563:15, :513566:15, :513569:15, :513572:15, :513575:15, :513578:15, :513581:15, :513584:15, :513587:15, :513590:15, :513593:15, :513596:15, :513599:15, :513602:15, :513605:15, :513608:15, :513611:15, :513614:15, :513617:15, :513620:15, :513623:15, :513626:15, :513629:15, :513632:15, :513635:15, :513638:15, :513641:15, :513644:15, :513647:15, :513650:15, :513653:15, :513656:15, :513659:15, :513662:15, :513665:15, :513668:15, :513671:15, :513674:15, :513677:15, :513680:15, :513683:15, :513686:15, :513689:15, :513692:15, :513695:15, :513698:15, :513701:15, :513704:15, :513707:15, :513710:15, :513713:15, :513716:15, :513719:15, :513722:15, :513725:15, :513728:15, :513731:15, :513734:15, :513737:15, :513740:15, :513743:15, :513746:15, :513749:15, :513752:15, :513755:15, :513758:15, :513761:15, :513764:15, :513767:15, :513770:15, :513773:15, :513776:15, :513779:15, :513782:15, :513785:15, :513788:15, :513791:15, :513794:15, :513797:15, :513800:15, :513803:15, :513806:15, :513809:15, :513812:15, :513815:15, :513818:15, :513821:15, :513824:15, :513827:15, :513830:15, :513833:15, :513836:15, :513839:15, :513842:15, :513845:15, :513848:15, :513851:15, :513854:15, :513857:15, :513860:15, :513863:15, :513866:15, :513869:15, :513872:15, :513875:15, :513878:15, :513881:15, :513884:15, :513887:15, :513890:15, :513893:15, :513896:15, :513899:15, :513902:15, :513905:15, :513908:15, :513911:15, :513914:15, :513917:15, :513920:15, :513923:15, :513927:15, :513930:15, :513933:15, :513936:15, :513938:15, :513940:15, :513943:15, :513946:15, :513949:15, :513952:15, :513955:15, :513958:15, :513961:15, :513964:15, :513967:15, :513970:15, :513973:15, :513976:15, :513979:15, :513982:15, :513985:15, :513988:15, :513991:15, :513994:15, :513997:15, :514000:15, :514003:15, :514006:15, :514009:15, :514012:15, :514015:15, :514018:15, :514021:15, :514024:15, :514027:15, :514030:15, :514033:15, :514036:15, :514039:15, :514042:15, :514045:15, :514048:15, :514051:15, :514054:15, :514057:15, :514060:15, :514063:15, :514066:15, :514069:15, :514072:15, :514075:15, :514078:15, :514081:15, :514084:15, :514087:15, :514090:15, :514093:15, :514096:15, :514099:15, :514102:15, :514105:15, :514108:15, :514111:15, :514114:15, :514117:15, :514120:15, :514123:15, :514126:15, :514129:15, :514132:15, :514135:15, :514138:15, :514141:15, :514144:15, :514147:15, :514150:15, :514153:15, :514156:15, :514159:15, :514162:15, :514165:15, :514168:15, :514171:15, :514174:15, :514177:15, :514180:15, :514183:15, :514186:15, :514189:15, :514192:15, :514195:15, :514198:15, :514201:15, :514204:15, :514207:15, :514210:15, :514213:15, :514216:15, :514219:15, :514222:15, :514225:15, :514228:15, :514231:15, :514234:15, :514237:15, :514240:15, :514243:15, :514246:15, :514249:15, :514252:15, :514255:15, :514258:15, :514261:15, :514264:15, :514267:15, :514270:15, :514273:15, :514276:15, :514279:15, :514282:15, :514285:15, :514288:15, :514291:15, :514294:15, :514297:15, :514300:15, :514303:15, :514306:15, :514309:15, :514312:15, :514315:15, :514318:15, :514321:15, :514324:15, :514327:15, :514330:15, :514333:15, :514336:15, :514339:15, :514342:15, :514345:15, :514348:15, :514351:15, :514354:15, :514357:15, :514360:15, :514363:15, :514366:15, :514369:15, :514372:15, :514375:15, :514378:15, :514381:15, :514384:15, :514387:15, :514390:15, :514393:15, :514396:15, :514399:15, :514402:15, :514405:15, :514408:15, :514411:15, :514414:15, :514417:15, :514420:15, :514423:15, :514426:15, :514429:15, :514432:15, :514435:15, :514438:15, :514441:15, :514444:15, :514447:15, :514450:15, :514453:15, :514456:15, :514459:15, :514462:15, :514465:15, :514468:15, :514471:15, :514474:15, :514477:15, :514480:15, :514483:15, :514486:15, :514489:15, :514492:15, :514495:15, :514498:15, :514501:15, :514504:15, :514507:15, :514510:15, :514513:15, :514516:15, :514519:15, :514522:15, :514525:15, :514528:15, :514531:15, :514534:15, :514537:15, :514540:15, :514543:15, :514546:15, :514549:15, :514552:15, :514555:15, :514558:15, :514561:15, :514564:15, :514567:15, :514570:15, :514573:15, :514576:15, :514579:15, :514582:15, :514585:15, :514588:15, :514591:15, :514594:15, :514597:15, :514600:15, :514603:15, :514606:15, :514609:15, :514612:15, :514615:15, :514618:15, :514621:15, :514624:15, :514627:15, :514630:15, :514633:15, :514636:15, :514639:15, :514642:15, :514645:15, :514648:15, :514651:15, :514654:15, :514657:15, :514660:15, :514663:15, :514666:15, :514669:15, :514672:15, :514675:15, :514678:15, :514681:15, :514684:15, :514687:15, :514690:15, :514694:15, :514697:15, :514700:15, :514703:15, :515889:15, :516241:15, :516245:15, :516249:15, :516253:15, :516257:15, :516261:15, :516265:15, :516267:15, :516269:15, :516303:15, :516306:15, :516309:15, :516312:15, :516315:15, :516318:15, :516322:15, :516325:15, :516328:15, :516331:15, :516334:15, :516337:15, :516340:15, :516343:15, :516346:15, :516349:15, :516352:15, :516355:15, :516358:15, :516361:15, :516364:15, :516367:15, :516370:15, :516373:15, :516376:15, :516379:15, :516382:15, :516385:15, :516389:15, :516392:15, :516395:15, :516399:15, :516402:15, :516405:15, :516408:15, :516411:15, :516414:15, :516417:15, :516420:15, :516423:15, :516426:15, :516429:15, :516432:15, :516435:15, :516438:15, :516441:15, :516444:15, :516447:15, :516450:15, :516453:15, :516456:15, :516458:15, :516460:15, :516463:15, :516466:15, :516469:15, :516472:15, :516475:15, :516478:15, :516481:15, :516484:15, :516487:15, :516490:15, :516493:15, :516496:15, :516499:15, :516502:15, :516505:15, :516508:15, :516511:15, :516514:15, :516517:15, :516520:15, :516523:15, :516526:15, :516529:15, :516532:15, :516535:15, :516538:15, :516541:15, :516544:15, :516548:15, :516551:15, :516554:15, :516557:15, :516560:15, :516563:15, :516566:15, :516569:15, :516572:15, :516575:15, :516578:15, :516581:15, :516584:15, :516587:15, :516590:15, :516593:15, :516596:15, :516599:15, :516603:15, :516606:15, :516609:15, :516612:15, :516615:15, :516618:15, :516621:15, :516624:15, :516627:15, :516630:15, :516634:15, :516637:15, :516640:15, :516643:15, :516646:15, :516649:15, :516652:15, :516655:15, :516658:15, :516661:15, :516664:15, :516667:15, :516671:15, :516674:15, :516677:15, :516680:15, :516683:15, :516686:15, :516689:15, :516692:15, :516695:15, :516698:15, :516701:15, :516704:15, :516707:15, :516710:15, :516713:15, :516716:15, :516719:15, :516722:15, :516725:15, :516728:15, :516731:15, :516734:15, :516737:15, :516740:15, :516743:15, :516746:15, :516749:15, :516753:15, :516756:15, :516759:15, :516762:15, :516765:15, :516768:15, :516771:15, :516774:15, :516777:15, :516780:15, :516783:15, :516786:15, :516789:15, :516792:15, :516795:15, :516798:15, :516801:15, :516804:15, :516807:15, :516810:15, :516814:15, :516817:15, :516820:15, :516823:15, :516826:15, :516829:15, :516832:15, :516835:15, :516838:15, :516841:15, :516844:15, :516847:15, :516850:15, :516853:15, :516856:15, :516859:15, :516862:15, :516865:15, :516868:15, :516871:15, :516874:15, :516877:15, :516880:15, :516883:15, :516886:15, :516889:15, :516892:15, :516895:15, :516898:15, :516901:15, :516904:15, :516907:15, :516909:15, :516911:15, :516915:15, :516918:15, :516921:15, :516924:15, :516927:15, :516930:15, :516933:15, :516936:15, :516940:15, :516943:15, :516946:15, :516949:15, :516952:15, :516955:15, :516958:15, :516961:15, :516964:15, :516967:15, :516970:15, :516973:15, :516976:15, :516979:15, :516982:15, :516985:15, :516988:15, :516991:15, :516994:15, :516997:15, :517000:15, :517003:15, :517006:15, :517009:15, :517012:15, :517015:15, :517018:15, :517021:15, :517024:15, :517027:15, :517030:15, :517033:15, :517036:15, :517039:15, :517042:15, :517045:15, :517048:15, :517051:15, :517054:15, :517057:15, :517060:15, :517063:15, :517066:15, :517069:15, :517072:15, :517075:15, :517078:15, :517081:15, :517084:15, :517087:15, :517090:15, :517093:15, :517096:15, :517099:15, :517102:15, :517105:15, :517108:15, :517111:15, :517114:15, :517117:15, :517120:15, :517123:15, :517126:15, :517129:15, :517132:15, :517135:15, :517138:15, :517141:15, :517144:15, :517147:15, :517150:15, :517153:15, :517156:15, :517159:15, :517162:15, :517165:15, :517168:15, :517171:15, :517174:15, :517177:15, :517180:15, :517183:15, :517186:15, :517189:15, :517192:15, :517195:15, :517198:15, :517201:15, :517204:15, :517207:15, :517210:15, :517213:15, :517216:15, :517219:15, :517222:15, :517225:15, :517228:15, :517231:15, :517234:15, :517237:15, :517240:15, :517243:15, :517246:15, :517249:15, :517252:15, :517255:15, :517258:15, :517261:15, :517264:15, :517267:15, :517270:15, :517273:15, :517276:15, :517279:15, :517282:15, :517285:15, :517288:15, :517291:15, :517294:15, :517297:15, :517300:15, :517303:15, :517306:15, :517309:15, :517312:15, :517315:15, :517318:15, :517322:15, :517325:15, :517328:15, :517331:15, :517333:15, :517335:15, :517338:15, :517341:15, :517344:15, :517347:15, :517350:15, :517353:15, :517356:15, :517359:15, :517362:15, :517365:15, :517368:15, :517371:15, :517374:15, :517377:15, :517380:15, :517383:15, :517386:15, :517389:15, :517392:15, :517395:15, :517398:15, :517401:15, :517404:15, :517407:15, :517410:15, :517413:15, :517416:15, :517419:15, :517422:15, :517425:15, :517428:15, :517431:15, :517434:15, :517437:15, :517440:15, :517443:15, :517446:15, :517449:15, :517452:15, :517455:15, :517458:15, :517461:15, :517464:15, :517467:15, :517470:15, :517473:15, :517476:15, :517479:15, :517482:15, :517485:15, :517488:15, :517491:15, :517494:15, :517497:15, :517500:15, :517503:15, :517506:15, :517509:15, :517512:15, :517515:15, :517518:15, :517521:15, :517524:15, :517527:15, :517530:15, :517533:15, :517536:15, :517539:15, :517542:15, :517545:15, :517548:15, :517551:15, :517554:15, :517557:15, :517560:15, :517563:15, :517566:15, :517569:15, :517572:15, :517575:15, :517578:15, :517581:15, :517584:15, :517587:15, :517590:15, :517593:15, :517596:15, :517599:15, :517602:15, :517605:15, :517608:15, :517611:15, :517614:15, :517617:15, :517620:15, :517623:15, :517626:15, :517629:15, :517632:15, :517635:15, :517638:15, :517641:15, :517644:15, :517647:15, :517650:15, :517653:15, :517656:15, :517659:15, :517662:15, :517665:15, :517668:15, :517671:15, :517674:15, :517677:15, :517680:15, :517683:15, :517686:15, :517689:15, :517692:15, :517695:15, :517698:15, :517701:15, :517704:15, :517707:15, :517710:15, :517713:15, :517716:15, :517719:15, :517722:15, :517725:15, :517728:15, :517731:15, :517734:15, :517737:15, :517740:15, :517743:15, :517746:15, :517749:15, :517752:15, :517755:15, :517758:15, :517761:15, :517764:15, :517767:15, :517770:15, :517773:15, :517776:15, :517779:15, :517782:15, :517785:15, :517788:15, :517791:15, :517794:15, :517797:15, :517800:15, :517803:15, :517806:15, :517809:15, :517812:15, :517815:15, :517818:15, :517821:15, :517824:15, :517827:15, :517830:15, :517833:15, :517836:15, :517839:15, :517842:15, :517845:15, :517848:15, :517851:15, :517854:15, :517857:15, :517860:15, :517863:15, :517866:15, :517869:15, :517872:15, :517875:15, :517878:15, :517881:15, :517884:15, :517887:15, :517890:15, :517893:15, :517896:15, :517899:15, :517902:15, :517905:15, :517908:15, :517911:15, :517914:15, :517917:15, :517920:15, :517923:15, :517926:15, :517929:15, :517932:15, :517935:15, :517938:15, :517941:15, :517944:15, :517947:15, :517950:15, :517953:15, :517956:15, :517959:15, :517962:15, :517965:15, :517968:15, :517971:15, :517974:15, :517977:15, :517980:15, :517983:15, :517986:15, :517989:15, :517992:15, :517995:15, :517998:15, :518001:15, :518004:15, :518007:15, :518010:15, :518013:15, :518016:15, :518019:15, :518022:15, :518025:15, :518028:15, :518031:15, :518034:15, :518037:15, :518040:15, :518043:15, :518046:15, :518049:15, :518052:15, :518055:15, :518058:15, :518061:15, :518064:15, :518067:15, :518070:15, :518073:15, :518076:15, :518079:15, :518082:15, :518085:15, :518089:15, :518092:15, :518095:15, :518098:15, :519284:16, :519636:16, :519640:16, :519644:16, :519648:16, :519652:16, :519656:16, :519660:16, :519662:16, :519664:16, :523111:16, :523158:16, :523184:16, :523238:16"}, {"number": 666, "title": "firrtl.printf losses order", "created_at": "2021-02-24T21:59:53Z", "state": "closed", "labels": "bug, FIRRTL", "body": "multiple printf in the same region are ordered in firrtl, hence they cannot be lowered to independent always blocks which have non-determinstic sideeffect order.\r\n\r\nFirrtl spec 5.14."}, {"number": 661, "title": "[LowerTypes] Multiple port memories cause segfault", "created_at": "2021-02-24T15:33:40Z", "state": "closed", "labels": "bug", "body": "memories with multiple ports are not lowered correctly.  This segfaults:\r\n```\r\nmodule  {\r\n  firrtl.circuit \"foo\" {\r\n    firrtl.module @foo(\r\n      %clock: !firrtl.clock\r\n      ) {\r\n      %head_MPORT_2, %head_MPORT_6 = firrtl.mem Undefined {depth = 20 : i64, name = \"head\", portNames = [\"MPORT_2\", \"MPORT_6\"], readLatency = 0 : i32, writeLatency = 1 : i32} \r\n      : !firrtl.flip< bundle<addr: uint<5>, en: uint<1>, clk: clock, data: uint<5>, mask: uint<1> > >,\r\n        !firrtl.flip< bundle<addr: uint<5>, en: uint<1>, clk: clock, data: uint<5>, mask: uint<1> > >\r\n      %127 = firrtl.subfield %head_MPORT_6(\"clk\") : (!firrtl.flip<bundle<addr: uint<5>, en: uint<1>, clk: clock, data: uint<5>, mask: uint<1>>>) -> !firrtl.flip<clock>\r\n    }\r\n  }\r\n}\r\n```", "code_snippet_01": "module  {\r\n  firrtl.circuit \"foo\" {\r\n    firrtl.module @foo(\r\n      %clock: !firrtl.clock\r\n      ) {\r\n      %head_MPORT_2, %head_MPORT_6 = firrtl.mem Undefined {depth = 20 : i64, name = \"head\", portNames = [\"MPORT_2\", \"MPORT_6\"], readLatency = 0 : i32, writeLatency = 1 : i32} \r\n      : !firrtl.flip< bundle<addr: uint<5>, en: uint<1>, clk: clock, data: uint<5>, mask: uint<1> > >,\r\n        !firrtl.flip< bundle<addr: uint<5>, en: uint<1>, clk: clock, data: uint<5>, mask: uint<1> > >\r\n      %127 = firrtl.subfield %head_MPORT_6(\"clk\") : (!firrtl.flip<bundle<addr: uint<5>, en: uint<1>, clk: clock, data: uint<5>, mask: uint<1>>>) -> !firrtl.flip<clock>\r\n    }\r\n  }\r\n}"}, {"number": 640, "title": "FIRRTLToRTL test fails with gcc 10.2 but not with clang 11", "created_at": "2021-02-22T20:53:56Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```\r\nFAIL: CIRCT :: Conversion/FIRRTLToRTL/lower-to-rtl.mlir (42 of 180)\r\n******************** TEST 'CIRCT :: Conversion/FIRRTLToRTL/lower-to-rtl.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 1';   /home/jodemme/circt/build/bin/circt-opt -lower-firrtl-to-rtl /home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir | /home/jodemme/circt/llvm/build/bin/FileCheck /home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir\r\n--\r\nExit Code: 1\r\n\r\nCommand Output (stderr):\r\n--\r\n/home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir:801:12: error: CHECK: expected string not found in input\r\n // CHECK: %[[mask:.+]] = sv.read_inout %[[mask_0]]\r\n           ^\r\n<stdin>:423:25: note: scanning from here\r\n %15 = sv.read_inout %9 : !rtl.inout<i1>\r\n                        ^\r\n<stdin>:423:25: note: with \"mask_0\" equal to \"11\"\r\n %15 = sv.read_inout %9 : !rtl.inout<i1>\r\n                        ^\r\n<stdin>:426:2: note: possible intended match here\r\n %17 = sv.read_inout %10 : !rtl.inout<i4>\r\n ^\r\n\r\nInput file: <stdin>\r\nCheck file: /home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir\r\n\r\n-dump-input=help explains the following input dump.\r\n\r\nInput was:\r\n<<<<<<\r\n             .\r\n             .\r\n             .\r\n           418:  sv.passign %12, %17 : i8\r\n           419:  }\r\n           420:  }\r\n           421:  sv.alwaysff(posedge %8) {\r\n           422:  %14 = sv.read_inout %11 : !rtl.inout<i1>\r\n           423:  %15 = sv.read_inout %9 : !rtl.inout<i1>\r\ncheck:801'0                             X~~~~~~~~~~~~~~~ error: no match found\r\ncheck:801'1                                              with \"mask_0\" equal to \"11\"\r\n           424:  %16 = comb.and %15, %14 : i1\r\ncheck:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n           425:  sv.if %16 {\r\ncheck:801'0     ~~~~~~~~~~~~\r\n           426:  %17 = sv.read_inout %10 : !rtl.inout<i4>\r\ncheck:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\ncheck:801'2      ?                                        possible intended match\r\n           427:  %18 = sv.array_index_inout %memory[%17] : !rtl.inout<uarray<16xi8>>, i4\r\ncheck:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n           428:  %19 = sv.read_inout %12 : !rtl.inout<i8>\r\ncheck:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n           429:  sv.passign %18, %19 : i8\r\ncheck:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~\r\n           430:  }\r\ncheck:801'0     ~~\r\n           431:  }\r\ncheck:801'0     ~~\r\n             .\r\n             .\r\n             .\r\n>>>>>>\r\n\r\n--\r\n\r\n********************\r\n********************\r\nFailed Tests (1):\r\n  CIRCT :: Conversion/FIRRTLToRTL/lower-to-rtl.mlir\r\n\r\n\r\nTesting Time: 1.54s\r\n  Passed: 179\r\n  Failed:   1\r\n```\r\n\r\nSeems like the two lines are reverse with gcc. I suspect the recent change to ExportVerilog may have some compiler specific behavior...?", "code_snippet_01": "FAIL: CIRCT :: Conversion/FIRRTLToRTL/lower-to-rtl.mlir (42 of 180)\r\n******************** TEST 'CIRCT :: Conversion/FIRRTLToRTL/lower-to-rtl.mlir' FAILED ********************\r\nScript:\r\n--\r\n: 'RUN: at line 1';   /home/jodemme/circt/build/bin/circt-opt -lower-firrtl-to-rtl /home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir | /home/jodemme/circt/llvm/build/bin/FileCheck /home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir\r\n--\r\nExit Code: 1\r\n\r\nCommand Output (stderr):\r\n--\r\n/home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir:801:12: error: CHECK: expected string not found in input\r\n // CHECK: %[[mask:.+]] = sv.read_inout %[[mask_0]]\r\n           ^\r\n<stdin>:423:25: note: scanning from here\r\n %15 = sv.read_inout %9 : !rtl.inout<i1>\r\n                        ^\r\n<stdin>:423:25: note: with \"mask_0\" equal to \"11\"\r\n %15 = sv.read_inout %9 : !rtl.inout<i1>\r\n                        ^\r\n<stdin>:426:2: note: possible intended match here\r\n %17 = sv.read_inout %10 : !rtl.inout<i4>\r\n ^\r\n\r\nInput file: <stdin>\r\nCheck file: /home/jodemme/circt/test/Conversion/FIRRTLToRTL/lower-to-rtl.mlir\r\n\r\n-dump-input=help explains the following input dump.\r\n\r\nInput was:\r\n<<<<<<\r\n             .\r\n             .\r\n             .\r\n           418:  sv.passign %12, %17 : i8\r\n           419:  }\r\n           420:  }\r\n           421:  sv.alwaysff(posedge %8) {\r\n           422:  %14 = sv.read_inout %11 : !rtl.inout<i1>\r\n           423:  %15 = sv.read_inout %9 : !rtl.inout<i1>\r\ncheck:801'0                             X~~~~~~~~~~~~~~~ error: no match found\r\ncheck:801'1                                              with \"mask_0\" equal to \"11\"\r\n           424:  %16 = comb.and %15, %14 : i1\r\ncheck:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n           425:  sv.if %16 {\r\ncheck:801'0     ~~~~~~~~~~~~\r\n           426:  %17 = sv.read_inout %10 : !rtl.inout<i4>\r\ncheck:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\ncheck:801'2      ?                                        possible intended match\r\n           427:  %18 = sv.array_index_inout %memory[%17] : !rtl.inout<uarray<16xi8>>, i4\r\ncheck:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n           428:  %19 = sv.read_inout %12 : !rtl.inout<i8>\r\ncheck:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n           429:  sv.passign %18, %19 : i8\r\ncheck:801'0     ~~~~~~~~~~~~~~~~~~~~~~~~~\r\n           430:  }\r\ncheck:801'0     ~~\r\n           431:  }\r\ncheck:801'0     ~~\r\n             .\r\n             .\r\n             .\r\n>>>>>>\r\n\r\n--\r\n\r\n********************\r\n********************\r\nFailed Tests (1):\r\n  CIRCT :: Conversion/FIRRTLToRTL/lower-to-rtl.mlir\r\n\r\n\r\nTesting Time: 1.54s\r\n  Passed: 179\r\n  Failed:   1"}, {"number": 617, "title": "[RTL] Instance should verify that its return types match the Module", "created_at": "2021-02-19T07:09:14Z", "state": "closed", "labels": "bug, good first issue, HW", "body": "RTL does not appear to be checking that the number of arguments returned by InstanceOp match the module it is referencing.  The following does not produce an error:\r\n\r\n```mlir\r\n// RUN: circt-opt ./test.mlir\r\n\r\nrtl.module @empty() -> () {\r\n  rtl.output\r\n}\r\n\r\nrtl.module @test() -> () {\r\n  // too many outputs\r\n  %0, %1, %3 = rtl.instance \"inline-me\" @mem() : () -> (i2, i2, i2)\r\n  rtl.output\r\n}\r\n```\r\n", "code_snippet_01": "// RUN: circt-opt ./test.mlir\r\n\r\nrtl.module @empty() -> () {\r\n  rtl.output\r\n}\r\n\r\nrtl.module @test() -> () {\r\n  // too many outputs\r\n  %0, %1, %3 = rtl.instance \"inline-me\" @mem() : () -> (i2, i2, i2)\r\n  rtl.output\r\n}"}, {"number": 593, "title": "[FIRRTL] circuit with instance (core dump)", "created_at": "2021-02-15T04:10:39Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module mod_2 :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_a: {inp_d: UInt<14>}\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    inst U0 of mod_2\r\n    U0 is invalid\r\n    U0.reset <= reset\r\n    U0.clock <= clock\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --enable-lower-types --verilog` gives an error:\r\n\r\n```mlir\r\nfirtool: ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:500: mlir::Value {anonymous}::FIRRTLTypesLowering::getBundleLowering(mlir::Value, llvm::StringRef): Assertion `entry && \"bundle lowering was not set\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.v\r\n1.      2.       #0 0x00000000004c54ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004c55a4 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004c35a4 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004c4f40 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f6f180221d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007f6f17aa9ae5 raise (/lib64/libc.so.6+0x3dae5)\r\n #6 0x00007f6f17a92864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f6f17a92749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f6f17aa2016 (/lib64/libc.so.6+0x36016)\r\n #9 0x00000000005b68be (anonymous namespace)::FIRRTLTypesLowering::getBundleLowering(mlir::Value, llvm::StringRef) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:500:3\r\n#10 0x00000000005b6a2f (anonymous namespace)::FIRRTLTypesLowering::getAllBundleLowerings(mlir::Value, llvm::SmallVectorImpl<mlir::Value>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:521:22\r\n#11 0x00000000005b62aa (anonymous namespace)::FIRRTLTypesLowering::visitStmt(circt::firrtl::ConnectOp) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:429:3\r\n#12 0x00000000005b84cf void circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::ConnectOp>(auto) const /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:161:13\r\n#13 0x00000000005b82af llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::ConnectOp, circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&>(void&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:159:18\r\n#14 0x00000000005b8029 llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::ConnectOp, circt::firrtl::DoneOp, circt::firrtl::MemoryPortOp, circt::firrtl::PartialConnectOp, circt::firrtl::PrintFOp, circt::firrtl::SkipOp, circt::firrtl::StopOp, circt::firrtl::WhenOp, circt::firrtl::AssertOp, circt::firrtl::AssumeOp, circt::firrtl::CoverOp, circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42\r\n#15 0x00000000005b7d8f llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::AttachOp, circt::firrtl::ConnectOp, circt::firrtl::DoneOp, circt::firrtl::MemoryPortOp, circt::firrtl::PartialConnectOp, circt::firrtl::PrintFOp, circt::firrtl::SkipOp, circt::firrtl::StopOp, circt::firrtl::WhenOp, circt::firrtl::AssertOp, circt::firrtl::AssumeOp, circt::firrtl::CoverOp, circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)>(circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3\r\n#16 0x00000000005b7bb2 circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:160:52\r\n#17 0x00000000005b79a1 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::visitInvalidExpr(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:267:49\r\n#18 0x00000000005b760c void circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)::operator()<mlir::Operation*>(auto) const /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:54:56\r\n#19 0x00000000005b7359 void llvm::TypeSwitch<mlir::Operation*, void>::Default<circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)>(auto&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:168:3\r\n#20 0x00000000005b7066 circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:55:10\r\n#21 0x00000000005b6d23 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:262:49\r\n#22 0x00000000005b4992 (anonymous namespace)::FIRRTLTypesLowering::runOnOperation() /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:145:39\r\n#23 0x0000000000988303 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:399:36\r\n#24 0x000000000098852f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:440:15\r\n#25 0x000000000098920a mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:68\r\n#26 0x000000000098c371 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7\r\n#27 0x000000000098c1c8 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:140:38\r\n#28 0x000000000098f0b0 llvm::SmallVector<mlir::OpPassManager, 1u>* std::__invoke_impl<void, void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()&>(std::__invoke_other, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)&&, void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()&...) /usr/include/c++/10/bits/invoke.h:60:67\r\n#29 0x000000000098e53c _ZSt10__invoke_rIvRZN4llvm8parallel6detail17parallel_for_eachIPNS0_11SmallVectorIN4mlir13OpPassManagerELj1EEEZNS5_6detail17OpToOpPassAdaptor23runOnOperationAsyncImplEbEUlNS0_15MutableArrayRefIS6_EEE_EEvT_SE_T0_EUlvE_JEENSt9enable_ifIXsrSt6__and_IJSt7is_voidISE_ESt14__is_invocableISF_JDpT1_EEEE5valueESE_E4typeEOSF_DpOSN_ /usr/include/c++/10/bits/invoke.h:155:5\r\n#30 0x000000000098d7c6 std::_Function_handler<void (), void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()>::_M_invoke(std::_Any_data const&) /usr/include/c++/10/bits/std_function.h:292:44\r\n#31 0x00000000007f618a std::function<void ()>::operator()() const /usr/include/c++/10/bits/std_function.h:622:71\r\n#32 0x0000000000af305c llvm::parallel::detail::TaskGroup::spawn(std::function<void ()>) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Parallel.cpp:166:1\r\n#33 0x000000000098c2b1 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:140:13\r\n#34 0x000000000098b837 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40\r\n#35 0x000000000098971f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:593:24\r\n#36 0x0000000000988c4b mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:518:1\r\n#37 0x00000000009882e4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:396:28\r\n#38 0x000000000098852f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:440:15\r\n#39 0x000000000098920a mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:68\r\n#40 0x000000000098c371 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7\r\n#41 0x000000000098c312 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:143:16\r\n#42 0x000000000098b837 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40\r\n#43 0x000000000098971f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:593:24\r\n#44 0x0000000000988c4b mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:518:1\r\n#45 0x00000000009882e4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:396:28\r\n#46 0x000000000098852f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:440:15\r\n#47 0x000000000098a58f mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:889:74\r\n#48 0x000000000040963c processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:143:13\r\n#49 0x0000000000409afb main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:197:13\r\n#50 0x00007f6f17a94152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#51 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 24: 10266 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2\r\n```\r\n\r\nCompiled with `firrtl-1.5.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input   clock,\r\n  input   reset\r\n);\r\nendmodule\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module mod_2 :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_a: {inp_d: UInt<14>}\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    inst U0 of mod_2\r\n    U0 is invalid\r\n    U0.reset <= reset\r\n    U0.clock <= clock", "code_snippet_02": "firtool: ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:500: mlir::Value {anonymous}::FIRRTLTypesLowering::getBundleLowering(mlir::Value, llvm::StringRef): Assertion `entry && \"bundle lowering was not set\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=a_top_mod_new.v\r\n1.      2.       #0 0x00000000004c54ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004c55a4 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004c35a4 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004c4f40 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f6f180221d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007f6f17aa9ae5 raise (/lib64/libc.so.6+0x3dae5)\r\n #6 0x00007f6f17a92864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f6f17a92749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f6f17aa2016 (/lib64/libc.so.6+0x36016)\r\n #9 0x00000000005b68be (anonymous namespace)::FIRRTLTypesLowering::getBundleLowering(mlir::Value, llvm::StringRef) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:500:3\r\n#10 0x00000000005b6a2f (anonymous namespace)::FIRRTLTypesLowering::getAllBundleLowerings(mlir::Value, llvm::SmallVectorImpl<mlir::Value>&) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:521:22\r\n#11 0x00000000005b62aa (anonymous namespace)::FIRRTLTypesLowering::visitStmt(circt::firrtl::ConnectOp) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:429:3\r\n#12 0x00000000005b84cf void circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::ConnectOp>(auto) const /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:161:13\r\n#13 0x00000000005b82af llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::ConnectOp, circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&>(void&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:159:18\r\n#14 0x00000000005b8029 llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::ConnectOp, circt::firrtl::DoneOp, circt::firrtl::MemoryPortOp, circt::firrtl::PartialConnectOp, circt::firrtl::PrintFOp, circt::firrtl::SkipOp, circt::firrtl::StopOp, circt::firrtl::WhenOp, circt::firrtl::AssertOp, circt::firrtl::AssumeOp, circt::firrtl::CoverOp, circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42\r\n#15 0x00000000005b7d8f llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::AttachOp, circt::firrtl::ConnectOp, circt::firrtl::DoneOp, circt::firrtl::MemoryPortOp, circt::firrtl::PartialConnectOp, circt::firrtl::PrintFOp, circt::firrtl::SkipOp, circt::firrtl::StopOp, circt::firrtl::WhenOp, circt::firrtl::AssertOp, circt::firrtl::AssumeOp, circt::firrtl::CoverOp, circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)>(circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*)::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3\r\n#16 0x00000000005b7bb2 circt::firrtl::StmtVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchStmtVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:160:52\r\n#17 0x00000000005b79a1 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::visitInvalidExpr(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:267:49\r\n#18 0x00000000005b760c void circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)::operator()<mlir::Operation*>(auto) const /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:54:56\r\n#19 0x00000000005b7359 void llvm::TypeSwitch<mlir::Operation*, void>::Default<circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda0'(auto)>(auto&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:168:3\r\n#20 0x00000000005b7066 circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:55:10\r\n#21 0x00000000005b6d23 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/FIRRTL/FIRRTLVisitors.h:262:49\r\n#22 0x00000000005b4992 (anonymous namespace)::FIRRTLTypesLowering::runOnOperation() /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp:145:39\r\n#23 0x0000000000988303 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:399:36\r\n#24 0x000000000098852f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:440:15\r\n#25 0x000000000098920a mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:68\r\n#26 0x000000000098c371 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7\r\n#27 0x000000000098c1c8 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()::operator()() const /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:140:38\r\n#28 0x000000000098f0b0 llvm::SmallVector<mlir::OpPassManager, 1u>* std::__invoke_impl<void, void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()&>(std::__invoke_other, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)&&, void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()&...) /usr/include/c++/10/bits/invoke.h:60:67\r\n#29 0x000000000098e53c _ZSt10__invoke_rIvRZN4llvm8parallel6detail17parallel_for_eachIPNS0_11SmallVectorIN4mlir13OpPassManagerELj1EEEZNS5_6detail17OpToOpPassAdaptor23runOnOperationAsyncImplEbEUlNS0_15MutableArrayRefIS6_EEE_EEvT_SE_T0_EUlvE_JEENSt9enable_ifIXsrSt6__and_IJSt7is_voidISE_ESt14__is_invocableISF_JDpT1_EEEE5valueESE_E4typeEOSF_DpOSN_ /usr/include/c++/10/bits/invoke.h:155:5\r\n#30 0x000000000098d7c6 std::_Function_handler<void (), void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>))::'lambda'()>::_M_invoke(std::_Any_data const&) /usr/include/c++/10/bits/std_function.h:292:44\r\n#31 0x00000000007f618a std::function<void ()>::operator()() const /usr/include/c++/10/bits/std_function.h:622:71\r\n#32 0x0000000000af305c llvm::parallel::detail::TaskGroup::spawn(std::function<void ()>) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Parallel.cpp:166:1\r\n#33 0x000000000098c2b1 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:140:13\r\n#34 0x000000000098b837 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40\r\n#35 0x000000000098971f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:593:24\r\n#36 0x0000000000988c4b mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:518:1\r\n#37 0x00000000009882e4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:396:28\r\n#38 0x000000000098852f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:440:15\r\n#39 0x000000000098920a mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:616:68\r\n#40 0x000000000098c371 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>) std::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /usr/include/c++/10/bits/stl_algo.h:3838:7\r\n#41 0x000000000098c312 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:143:16\r\n#42 0x000000000098b837 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(llvm::MutableArrayRef<mlir::OpPassManager>)) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/Support/Parallel.h:233:40\r\n#43 0x000000000098971f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:593:24\r\n#44 0x0000000000988c4b mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:518:1\r\n#45 0x00000000009882e4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:396:28\r\n#46 0x000000000098852f mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:440:15\r\n#47 0x000000000098a58f mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:889:74\r\n#48 0x000000000040963c processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:143:13\r\n#49 0x0000000000409afb main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:197:13\r\n#50 0x00007f6f17a94152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#51 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 24: 10266 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --enable-lower-types --verilog -o=$VFILE2", "code_snippet_03": "module top_mod(\r\n  input   clock,\r\n  input   reset\r\n);\r\nendmodule"}, {"number": 572, "title": "Assigning to constants!", "created_at": "2021-02-08T22:43:48Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "```\r\n  ; CHECK-LABEL: module IsInvalid(\r\n  ; CHECK-NEXT:    input a);\r\n  module IsInvalid :\r\n    output a: Analog<1>\r\n    a is invalid  @[Place.scala 101]\r\n```\r\nGenerates this awesome verilog:\r\n```\r\nmodule IsInvalid(\r\n  input a);\r\n\r\n\r\n  `ifndef SYNTHESIS\r\n    alias a = '0;       // Place.scala:101\r\n  `endif\r\n  `ifdef SYNTHESIS\r\n    assign '0 = a;      // Place.scala:101\r\n    assign a = '0;      // Place.scala:101\r\n  `endif // SYNTHESIS\r\nendmodule\r\n```\r\n", "code_snippet_01": "; CHECK-LABEL: module IsInvalid(\r\n  ; CHECK-NEXT:    input a);\r\n  module IsInvalid :\r\n    output a: Analog<1>\r\n    a is invalid  @[Place.scala 101]", "code_snippet_02": "module IsInvalid(\r\n  input a);\r\n\r\n\r\n  `ifndef SYNTHESIS\r\n    alias a = '0;       // Place.scala:101\r\n  `endif\r\n  `ifdef SYNTHESIS\r\n    assign '0 = a;      // Place.scala:101\r\n    assign a = '0;      // Place.scala:101\r\n  `endif // SYNTHESIS\r\nendmodule"}, {"number": 571, "title": "[Windows build] Fixing 'invalid' path error", "created_at": "2021-02-08T21:03:04Z", "state": "closed", "labels": "bug", "body": "Windows build was broken by #554's introduction of an \"invalid path\" so the [Windows build](https://github.com/llvm/circt/actions/runs/543081032) wasn't able checkout the repo. Apparently, Windows doesn't allow filenames with only 3 characters...?\r\n\r\nWorking build: https://github.com/llvm/circt/runs/1858162878?check_suite_focus=true"}, {"number": 570, "title": "Windows build warnings", "created_at": "2021-02-08T21:00:39Z", "state": "closed", "labels": "bug", "body": "```\r\ncl : command line warning D9002: ignoring unknown option '-fno-exceptions'\r\ncl : command line warning D9002: ignoring unknown option '-fno-rtti'\r\n```\r\n\r\nThe `cl` flag for this is different.", "code_snippet_01": "cl : command line warning D9002: ignoring unknown option '-fno-exceptions'\r\ncl : command line warning D9002: ignoring unknown option '-fno-rtti'"}, {"number": 564, "title": "[FIRRTL] Add CheckInitialization Support", "created_at": "2021-02-06T01:53:30Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module mod_0 :\r\n    input tmp1: UInt<5>\r\n    output tmp2: UInt<5>\r\n    tmp2 <= tmp1\r\n  module top_mod :\r\n    input tmp1: UInt<5>\r\n    output tmp2: UInt<5>\r\n    inst U0 of mod_0\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces legit Verilog, but:\r\n\r\nCompiled with `firrtl-1.5.0` produces this error:\r\n\r\n```python\r\nException in thread \"main\" firrtl.passes.PassExceptions: \r\nfirrtl.passes.CheckInitialization$RefNotInitializedException:  : [module top_mod]  Reference U0 is not fully initialized.\r\n   : U0.tmp1 <= VOID\r\nfirrtl.passes.CheckInitialization$RefNotInitializedException:  : [module top_mod]  Reference tmp2 is not fully initialized.\r\n   : tmp2 <= VOID\r\nfirrtl.passes.PassException: 2 errors detected!\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module mod_0 :\r\n    input tmp1: UInt<5>\r\n    output tmp2: UInt<5>\r\n    tmp2 <= tmp1\r\n  module top_mod :\r\n    input tmp1: UInt<5>\r\n    output tmp2: UInt<5>\r\n    inst U0 of mod_0", "code_snippet_02": "Exception in thread \"main\" firrtl.passes.PassExceptions: \r\nfirrtl.passes.CheckInitialization$RefNotInitializedException:  : [module top_mod]  Reference U0 is not fully initialized.\r\n   : U0.tmp1 <= VOID\r\nfirrtl.passes.CheckInitialization$RefNotInitializedException:  : [module top_mod]  Reference tmp2 is not fully initialized.\r\n   : tmp2 <= VOID\r\nfirrtl.passes.PassException: 2 errors detected!"}, {"number": 563, "title": "[FIRRTL] instance invalid bindings", "created_at": "2021-02-06T01:49:31Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module mod_0 :\r\n    input tmp1: UInt<5>\r\n    output tmp2: UInt<5>\r\n    tmp2 <= tmp1\r\n  module top_mod :\r\n    input tmp1: UInt<5>\r\n    output tmp2: UInt<5>\r\n    inst U0 of mod_0\r\n    U0 is invalid\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` gives an error:\r\n\r\n```mlir\r\na_top_mod.fir:10:8: error: expected '.' in field reference\r\n    U0 is invalid\r\n       ^\r\n```\r\n\r\nCompiled with `firrtl-1.5.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule mod_0(\r\n  input  [4:0] tmp1,\r\n  output [4:0] tmp2\r\n);\r\n  assign tmp2 = tmp1;\r\nendmodule\r\nmodule top_mod(\r\n  input  [4:0] tmp1,\r\n  output [4:0] tmp2\r\n);\r\n  wire [4:0] U0_tmp1;\r\n  wire [4:0] U0_tmp2;\r\n  mod_0 U0 (\r\n    .tmp1(U0_tmp1),\r\n    .tmp2(U0_tmp2)\r\n  );\r\n  assign tmp2 = U0_tmp2;\r\n  assign U0_tmp1 = tmp1;\r\nendmodule\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module mod_0 :\r\n    input tmp1: UInt<5>\r\n    output tmp2: UInt<5>\r\n    tmp2 <= tmp1\r\n  module top_mod :\r\n    input tmp1: UInt<5>\r\n    output tmp2: UInt<5>\r\n    inst U0 of mod_0\r\n    U0 is invalid", "code_snippet_02": "a_top_mod.fir:10:8: error: expected '.' in field reference\r\n    U0 is invalid\r\n       ^", "code_snippet_03": "module mod_0(\r\n  input  [4:0] tmp1,\r\n  output [4:0] tmp2\r\n);\r\n  assign tmp2 = tmp1;\r\nendmodule\r\nmodule top_mod(\r\n  input  [4:0] tmp1,\r\n  output [4:0] tmp2\r\n);\r\n  wire [4:0] U0_tmp1;\r\n  wire [4:0] U0_tmp2;\r\n  mod_0 U0 (\r\n    .tmp1(U0_tmp1),\r\n    .tmp2(U0_tmp2)\r\n  );\r\n  assign tmp2 = U0_tmp2;\r\n  assign U0_tmp1 = tmp1;\r\nendmodule"}, {"number": 559, "title": "[FIRRTL] Context Dependent Port Parsing", "created_at": "2021-02-04T21:42:55Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following circuit is currently valid, but fails parsing:\r\n\r\n```scala\r\ncircuit Tricky:\r\n  module Tricky:\r\n    input input: UInt<1>\r\n    output output: UInt<1>\r\n    output <= input\r\n```\r\n\r\n```bash\r\nfirtool Tricky.fir\r\n# Tricky.fir:5:12: error: expected port name\r\n#     output <= input\r\n```", "code_snippet_01": "circuit Tricky:\r\n  module Tricky:\r\n    input input: UInt<1>\r\n    output output: UInt<1>\r\n    output <= input", "code_snippet_02": "firtool Tricky.fir\r\n# Tricky.fir:5:12: error: expected port name\r\n#     output <= input"}, {"number": 550, "title": "[FIRRTL] Parsing Problem with Instance Named \"write\"", "created_at": "2021-02-03T21:16:34Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL text fails to parse:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Bar:\r\n    input a: Clock\r\n  module Foo:\r\n    input a: Clock\r\n\r\n    inst write of Bar\r\n    write.a <= a\r\n```\r\n\r\n```bash\r\nfirtool Foo.fir\r\n# Foo.fir:8:5: error: bundle value 'write' should only be used from subfield\r\n#     write.a <= a\r\n#     ^\r\n```\r\n\r\nHowever, changing the name of the instance to \"bar\" causes it to parse:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Bar:\r\n    input a: Clock\r\n  module Foo:\r\n    input a: Clock\r\n\r\n    inst bar of Bar\r\n    bar.a <= a\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Bar:\r\n    input a: Clock\r\n  module Foo:\r\n    input a: Clock\r\n\r\n    inst write of Bar\r\n    write.a <= a", "code_snippet_02": "firtool Foo.fir\r\n# Foo.fir:8:5: error: bundle value 'write' should only be used from subfield\r\n#     write.a <= a\r\n#     ^", "code_snippet_03": "circuit Foo:\r\n  module Bar:\r\n    input a: Clock\r\n  module Foo:\r\n    input a: Clock\r\n\r\n    inst bar of Bar\r\n    bar.a <= a"}, {"number": 534, "title": "HandshakeToFIRRTL should respect FIRRTL requiring classic SSA def-before-use", "created_at": "2021-01-29T18:39:15Z", "state": "closed", "labels": "bug, Handshake", "body": "The following psuedo-IR can be produced by HandshakeToFIRRTL, passes the verifier, but will crash the LowerTypes pass:\r\n\r\n```\r\n%0 = firrtl.instance ...\r\nfirrtl.connect %0, %1\r\n%1 = firrtl.instance ...\r\n```\r\n\r\nThe actual test case I have is quite complex, and I'm trying to reduce it to something we can realistically put in a unit test.\r\n\r\nThe ~solution~ quick fix seems pretty clear: instead of processing every operation in order in the LowerTypes `runOnOperation` function, just track the connects to process, and take a second pass to actually process them. I've implemented this already, and will share a PR once I've reduced a reasonable test case.", "code_snippet_01": "%0 = firrtl.instance ...\r\nfirrtl.connect %0, %1\r\n%1 = firrtl.instance ..."}, {"number": 525, "title": "Verilog emitter will output invalid or reserved names", "created_at": "2021-01-27T20:55:41Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "for example, a port name struct."}, {"number": 520, "title": "[FIRRTL] lower-types does not support external modules", "created_at": "2021-01-27T09:28:13Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The lower types pass flattens bundles returned from `firrtl.instance` operations.  When there is an instance of an `firrtl.extmodule`, the instance is flattened while the module declaration is not. The pass should be extended to flatten bundles in external module declarations\r\n\r\nTest Case:\r\n``` mlir\r\n// circt-opt -pass-pipeline='firrtl.circuit(firrtl.module(firrtl-lower-types))' ./external-module-lower-bundles.mlir\r\nmodule  {\r\n  firrtl.circuit \"Test\" {\r\n    firrtl.extmodule @ExternalModule(!firrtl.bundle<valid: uint<1>, ready: flip<uint<1>>, data: uint<64>> {firrtl.name = \"source\"})\r\n    firrtl.module @Test() {\r\n      %inst_source = firrtl.instance @ExternalModule {name = \"\", portNames = [\"source\"]} : !firrtl.bundle<valid: flip<uint<1>>, ready: uint<1>, data: flip<uint<64>>>\r\n    }\r\n  }\r\n}\r\n```\r\n```\r\n./external-module-lower-bundles.mlir:6:16: error: 'firrtl.instance' op has a wrong number of results; expected 1 but got 3\r\n    %sourceV = firrtl.instance @ExternalModule {name = \"\", portNames = [\"source\"]} : !firrtl.bundle<valid: flip<uint<1>>, ready: uint<1>, data: flip<uint<64>>>\r\n               ^\r\n./external-module-lower-bundles.mlir:6:16: note: see current operation: %inst_source_valid, %inst_source_ready, %inst_source_data = \"firrtl.instance\"() {moduleName = @ExternalModule, name = \"\", portNames = [\"source_valid\", \"source_ready\", \"source_data\"]} : () -> (!firrtl.flip<uint<1>>, !firrtl.uint<1>, !firrtl.flip<uint<64>>)\r\n./external-module-lower-bundles.mlir:3:3: note: original module declared here\r\n  firrtl.extmodule @ExternalModule(%source: !firrtl.bundle<valid: uint<1>, ready: flip<uint<1>>, data: uint<64>>)\r\n```\r\n", "code_snippet_01": "mlir\r\n// circt-opt -pass-pipeline='firrtl.circuit(firrtl.module(firrtl-lower-types))' ./external-module-lower-bundles.mlir\r\nmodule  {\r\n  firrtl.circuit \"Test\" {\r\n    firrtl.extmodule @ExternalModule(!firrtl.bundle<valid: uint<1>, ready: flip<uint<1>>, data: uint<64>> {firrtl.name = \"source\"})\r\n    firrtl.module @Test() {\r\n      %inst_source = firrtl.instance @ExternalModule {name = \"\", portNames = [\"source\"]} : !firrtl.bundle<valid: flip<uint<1>>, ready: uint<1>, data: flip<uint<64>>>\r\n    }\r\n  }\r\n}", "code_snippet_02": "./external-module-lower-bundles.mlir:6:16: error: 'firrtl.instance' op has a wrong number of results; expected 1 but got 3\r\n    %sourceV = firrtl.instance @ExternalModule {name = \"\", portNames = [\"source\"]} : !firrtl.bundle<valid: flip<uint<1>>, ready: uint<1>, data: flip<uint<64>>>\r\n               ^\r\n./external-module-lower-bundles.mlir:6:16: note: see current operation: %inst_source_valid, %inst_source_ready, %inst_source_data = \"firrtl.instance\"() {moduleName = @ExternalModule, name = \"\", portNames = [\"source_valid\", \"source_ready\", \"source_data\"]} : () -> (!firrtl.flip<uint<1>>, !firrtl.uint<1>, !firrtl.flip<uint<64>>)\r\n./external-module-lower-bundles.mlir:3:3: note: original module declared here\r\n  firrtl.extmodule @ExternalModule(%source: !firrtl.bundle<valid: uint<1>, ready: flip<uint<1>>, data: uint<64>>)"}, {"number": 516, "title": "[FIRRTL] (div) 0-width (core dump)", "created_at": "2021-01-26T23:49:54Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_0: UInt<0>\r\n    output tmp3: UInt<0>\r\n    tmp3 <= div(inp_0, inp_0)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --verilog` gives an error:\r\n\r\n```mlir\r\nfirtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:280: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && \"bitwidth too small\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v\r\n #0 0x00000000004c196b llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004c1a22 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004bfa22 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004c13be SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007fdbbd4691d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007fdbbcf28ae5 raise (/lib64/libc.so.6+0x3dae5)\r\n #6 0x00007fdbbcf11864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007fdbbcf11749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007fdbbcf21016 (/lib64/libc.so.6+0x36016)\r\n #9 0x000000000045c0ee llvm::APInt::APInt(unsigned int, unsigned long, bool) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:281:21\r\n#10 0x000000000064d587 mlir::IntegerAttr::get(mlir::Type, long) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/BuiltinAttributes.cpp:307:79\r\n#11 0x00000000007a4a92 circt::firrtl::DivPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/FIRRTLFolds.cpp:68:69\r\n#12 0x00000000007993ca mlir::LogicalResult mlir::Op<circt::firrtl::DivPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::IntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::DivPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1619:53\r\n#13 0x00000000006d8946 mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3\r\n#14 0x00000000006d1fb0 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30\r\n#15 0x00000000008a6ca3 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#16 0x00000000008a6602 mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#17 0x000000000088b3d1 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#18 0x000000000088b6fc mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#19 0x000000000088b5e8 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#20 0x0000000000746aea (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3\r\n#21 0x0000000000974a85 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36\r\n#22 0x0000000000974cb1 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15\r\n#23 0x0000000000976cc6 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:885:74\r\n#24 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13\r\n#25 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13\r\n#26 0x00007fdbbcf13152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#27 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 14: 11144 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=$VFILE2\r\n```\r\n\r\nCompiled with `firrtl-1.5.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n);\r\nendmodule\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_0: UInt<0>\r\n    output tmp3: UInt<0>\r\n    tmp3 <= div(inp_0, inp_0)", "code_snippet_02": "firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:280: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && \"bitwidth too small\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v\r\n #0 0x00000000004c196b llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004c1a22 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004bfa22 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004c13be SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007fdbbd4691d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007fdbbcf28ae5 raise (/lib64/libc.so.6+0x3dae5)\r\n #6 0x00007fdbbcf11864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007fdbbcf11749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007fdbbcf21016 (/lib64/libc.so.6+0x36016)\r\n #9 0x000000000045c0ee llvm::APInt::APInt(unsigned int, unsigned long, bool) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:281:21\r\n#10 0x000000000064d587 mlir::IntegerAttr::get(mlir::Type, long) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/BuiltinAttributes.cpp:307:79\r\n#11 0x00000000007a4a92 circt::firrtl::DivPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/FIRRTLFolds.cpp:68:69\r\n#12 0x00000000007993ca mlir::LogicalResult mlir::Op<circt::firrtl::DivPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::IntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::DivPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1619:53\r\n#13 0x00000000006d8946 mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3\r\n#14 0x00000000006d1fb0 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30\r\n#15 0x00000000008a6ca3 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#16 0x00000000008a6602 mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#17 0x000000000088b3d1 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#18 0x000000000088b6fc mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#19 0x000000000088b5e8 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#20 0x0000000000746aea (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3\r\n#21 0x0000000000974a85 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36\r\n#22 0x0000000000974cb1 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15\r\n#23 0x0000000000976cc6 mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:885:74\r\n#24 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13\r\n#25 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13\r\n#26 0x00007fdbbcf13152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#27 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 14: 11144 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=$VFILE2", "code_snippet_03": "module top_mod(\r\n);\r\nendmodule"}, {"number": 511, "title": "[FIRRTL] circuit with a register (core dump)", "created_at": "2021-01-26T04:16:43Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_0: UInt<1>\r\n    output tmp1: UInt<1>\r\n    reg _tmp2: UInt<1>, clock with: (reset => (reset, UInt<1>(0)))\r\n    _tmp2 <= inp_0\r\n    tmp1 <= _tmp2\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl --verilog` gives an error:\r\n\r\n```mlir\r\nfirtool: ../llvm/llvm/include/llvm/ADT/ilist_iterator.h:138: llvm::ilist_iterator<OptionsT, IsReverse, IsConst>::reference llvm::ilist_iterator<OptionsT, IsReverse, IsConst>::operator*() const [with OptionsT = llvm::ilist_detail::node_options<mlir::Block, true, false, void>; bool IsReverse = false; bool IsConst = false; llvm::ilist_iterator<OptionsT, IsReverse, IsConst>::reference = mlir::Block&]: Assertion `!NodePtr->isKnownSentinel()' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v\r\n #0 0x00000000004c196b llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004c1a22 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004bfa22 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004c13be SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f28169991d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007f2816458ae5 raise (/lib64/libc.so.6+0x3dae5)\r\n #6 0x00007f2816441864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f2816441749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f2816451016 (/lib64/libc.so.6+0x36016)\r\n #9 0x000000000040e32d llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Block, true, false, void>, false, false>::operator*() const /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/ilist_iterator.h:139:33\r\n#10 0x000000000040c8c0 llvm::simple_ilist<mlir::Block>::front() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/simple_ilist.h:138:40\r\n#11 0x000000000040bb0c mlir::Region::front() /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/Region.h:61:43\r\n#12 0x000000000050e3ac circt::sv::AlwaysFFOp::getResetBlock() /home/drom/work/github/llvm/circt/build/include/circt/Dialect/SV/SV.h.inc:243:58\r\n#13 0x0000000000502b4f (anonymous namespace)::ModuleEmitter::visitSV(circt::sv::AlwaysFFOp) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:1500:23\r\n#14 0x00000000005095f9 mlir::LogicalResult circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::sv::AlwaysFFOp>(auto) const /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/SV/SVVisitors.h:43:13\r\n#15 0x0000000000509275 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::sv::AlwaysFFOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(mlir::LogicalResult&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:116:22\r\n#16 0x0000000000508ed1 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42\r\n#17 0x0000000000508b33 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3\r\n#18 0x0000000000508681 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3\r\n#19 0x0000000000507c67 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::IfDefOp, circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3\r\n#20 0x00000000005074af llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::RegOp, circt::sv::IfDefOp, circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3\r\n#21 0x0000000000506bab llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::TextualValueOp, circt::sv::RegOp, circt::sv::IfDefOp, circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3\r\n#22 0x00000000005063d0 circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/SV/SVVisitors.h:42:52\r\n#23 0x0000000000504cd8 (anonymous namespace)::ModuleEmitter::emitOperation(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:1929:16\r\n#24 0x0000000000505757 (anonymous namespace)::ModuleEmitter::emitRTLModule(circt::rtl::RTLModuleOp) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:2058:40\r\n#25 0x0000000000505908 (anonymous namespace)::MLIRModuleEmitter::emit(mlir::ModuleOp) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:2084:7\r\n#26 0x0000000000505abd circt::exportVerilog(mlir::ModuleOp, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:2097:24\r\n#27 0x00000000004096f0 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:153:44\r\n#28 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13\r\n#29 0x00007f2816443152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#30 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 14: 29799 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=$VFILE2\r\n```\r\n\r\nCompiled with `firrtl-1.5.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input   clock,\r\n  input   reset,\r\n  input   inp_0,\r\n  output  tmp1\r\n);\r\n`ifdef RANDOMIZE_REG_INIT\r\n  reg [31:0] _RAND_0;\r\n`endif // RANDOMIZE_REG_INIT\r\n  reg  _tmp2;\r\n  assign tmp1 = _tmp2;\r\n  always @(posedge clock) begin\r\n    if (reset) begin\r\n      _tmp2 <= 1'h0;\r\n    end else begin\r\n      _tmp2 <= inp_0;\r\n    end\r\n  end\r\n// Register and memory initialization\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_INVALID_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_REG_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifndef RANDOM\r\n`define RANDOM $random\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  integer initvar;\r\n`endif\r\n`ifndef SYNTHESIS\r\n`ifdef FIRRTL_BEFORE_INITIAL\r\n`FIRRTL_BEFORE_INITIAL\r\n`endif\r\ninitial begin\r\n  `ifdef RANDOMIZE\r\n    `ifdef INIT_RANDOM\r\n      `INIT_RANDOM\r\n    `endif\r\n    `ifndef VERILATOR\r\n      `ifdef RANDOMIZE_DELAY\r\n        #`RANDOMIZE_DELAY begin end\r\n      `else\r\n        #0.002 begin end\r\n      `endif\r\n    `endif\r\n`ifdef RANDOMIZE_REG_INIT\r\n  _RAND_0 = {1{`RANDOM}};\r\n  _tmp2 = _RAND_0[0:0];\r\n`endif // RANDOMIZE_REG_INIT\r\n  `endif // RANDOMIZE\r\nend // initial\r\n`ifdef FIRRTL_AFTER_INITIAL\r\n`FIRRTL_AFTER_INITIAL\r\n`endif\r\n`endif // SYNTHESIS\r\nendmodule\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input clock: Clock\r\n    input reset: UInt<1>\r\n    input inp_0: UInt<1>\r\n    output tmp1: UInt<1>\r\n    reg _tmp2: UInt<1>, clock with: (reset => (reset, UInt<1>(0)))\r\n    _tmp2 <= inp_0\r\n    tmp1 <= _tmp2", "code_snippet_02": "firtool: ../llvm/llvm/include/llvm/ADT/ilist_iterator.h:138: llvm::ilist_iterator<OptionsT, IsReverse, IsConst>::reference llvm::ilist_iterator<OptionsT, IsReverse, IsConst>::operator*() const [with OptionsT = llvm::ilist_detail::node_options<mlir::Block, true, false, void>; bool IsReverse = false; bool IsConst = false; llvm::ilist_iterator<OptionsT, IsReverse, IsConst>::reference = mlir::Block&]: Assertion `!NodePtr->isKnownSentinel()' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v\r\n #0 0x00000000004c196b llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004c1a22 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004bfa22 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004c13be SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f28169991d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007f2816458ae5 raise (/lib64/libc.so.6+0x3dae5)\r\n #6 0x00007f2816441864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f2816441749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f2816451016 (/lib64/libc.so.6+0x36016)\r\n #9 0x000000000040e32d llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Block, true, false, void>, false, false>::operator*() const /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/ilist_iterator.h:139:33\r\n#10 0x000000000040c8c0 llvm::simple_ilist<mlir::Block>::front() /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/simple_ilist.h:138:40\r\n#11 0x000000000040bb0c mlir::Region::front() /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/Region.h:61:43\r\n#12 0x000000000050e3ac circt::sv::AlwaysFFOp::getResetBlock() /home/drom/work/github/llvm/circt/build/include/circt/Dialect/SV/SV.h.inc:243:58\r\n#13 0x0000000000502b4f (anonymous namespace)::ModuleEmitter::visitSV(circt::sv::AlwaysFFOp) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:1500:23\r\n#14 0x00000000005095f9 mlir::LogicalResult circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::sv::AlwaysFFOp>(auto) const /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/SV/SVVisitors.h:43:13\r\n#15 0x0000000000509275 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::sv::AlwaysFFOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(mlir::LogicalResult&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:116:22\r\n#16 0x0000000000508ed1 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:41:42\r\n#17 0x0000000000508b33 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3\r\n#18 0x0000000000508681 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3\r\n#19 0x0000000000507c67 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::IfDefOp, circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3\r\n#20 0x00000000005074af llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::RegOp, circt::sv::IfDefOp, circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3\r\n#21 0x0000000000506bab llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>, mlir::Operation*>::Case<circt::sv::TextualValueOp, circt::sv::RegOp, circt::sv::IfDefOp, circt::sv::IfOp, circt::sv::AlwaysOp, circt::sv::AlwaysFFOp, circt::sv::InitialOp, circt::sv::YieldOp, circt::sv::BPAssignOp, circt::sv::PAssignOp, circt::sv::AliasOp, circt::sv::FWriteOp, circt::sv::FatalOp, circt::sv::FinishOp, circt::sv::VerbatimOp, circt::sv::InterfaceOp, circt::sv::InterfaceSignalOp, circt::sv::InterfaceModportOp, circt::sv::InterfaceInstanceOp, circt::sv::GetModportOp, circt::sv::AssignInterfaceSignalOp, circt::sv::ReadInterfaceSignalOp, circt::sv::AssertOp, circt::sv::AssumeOp, circt::sv::CoverOp, circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)>(circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*)::'lambda'(auto)&&) /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/TypeSwitch.h:42:3\r\n#22 0x00000000005063d0 circt::sv::Visitor<(anonymous namespace)::ModuleEmitter, mlir::LogicalResult>::dispatchSVVisitor(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../include/circt/Dialect/SV/SVVisitors.h:42:52\r\n#23 0x0000000000504cd8 (anonymous namespace)::ModuleEmitter::emitOperation(mlir::Operation*) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:1929:16\r\n#24 0x0000000000505757 (anonymous namespace)::ModuleEmitter::emitRTLModule(circt::rtl::RTLModuleOp) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:2058:40\r\n#25 0x0000000000505908 (anonymous namespace)::MLIRModuleEmitter::emit(mlir::ModuleOp) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:2084:7\r\n#26 0x0000000000505abd circt::exportVerilog(mlir::ModuleOp, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../lib/Translation/ExportVerilog/ExportVerilog.cpp:2097:24\r\n#27 0x00000000004096f0 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:153:44\r\n#28 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13\r\n#29 0x00007f2816443152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#30 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\n./process1.sh: line 14: 29799 Aborted                 (core dumped) ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=$VFILE2", "code_snippet_03": "module top_mod(\r\n  input   clock,\r\n  input   reset,\r\n  input   inp_0,\r\n  output  tmp1\r\n);\r\n`ifdef RANDOMIZE_REG_INIT\r\n  reg [31:0] _RAND_0;\r\n`endif // RANDOMIZE_REG_INIT\r\n  reg  _tmp2;\r\n  assign tmp1 = _tmp2;\r\n  always @(posedge clock) begin\r\n    if (reset) begin\r\n      _tmp2 <= 1'h0;\r\n    end else begin\r\n      _tmp2 <= inp_0;\r\n    end\r\n  end\r\n// Register and memory initialization\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_INVALID_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_REG_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifndef RANDOM\r\n`define RANDOM $random\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  integer initvar;\r\n`endif\r\n`ifndef SYNTHESIS\r\n`ifdef FIRRTL_BEFORE_INITIAL\r\n`FIRRTL_BEFORE_INITIAL\r\n`endif\r\ninitial begin\r\n  `ifdef RANDOMIZE\r\n    `ifdef INIT_RANDOM\r\n      `INIT_RANDOM\r\n    `endif\r\n    `ifndef VERILATOR\r\n      `ifdef RANDOMIZE_DELAY\r\n        #`RANDOMIZE_DELAY begin end\r\n      `else\r\n        #0.002 begin end\r\n      `endif\r\n    `endif\r\n`ifdef RANDOMIZE_REG_INIT\r\n  _RAND_0 = {1{`RANDOM}};\r\n  _tmp2 = _RAND_0[0:0];\r\n`endif // RANDOMIZE_REG_INIT\r\n  `endif // RANDOMIZE\r\nend // initial\r\n`ifdef FIRRTL_AFTER_INITIAL\r\n`FIRRTL_AFTER_INITIAL\r\n`endif\r\n`endif // SYNTHESIS\r\nendmodule"}, {"number": 508, "title": "Sensitivity list for always* blocks could include expressions", "created_at": "2021-01-25T19:45:12Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "always* blocks should be emitted with names in the sensitivity list, not inline expressions.  Thus anything that might be in a sensitivity list must be output first to an assign statement and referenced by name.\r\nconsider:\r\n```\r\n%clk = %clk2+ %clk2\r\nalways posedge clk\r\n```\r\nwill output something like\r\n```\r\nalways @(posedge (clk2 + clk3)\r\n```\r\nwhich is wrong ", "code_snippet_01": "%clk = %clk2+ %clk2\r\nalways posedge clk", "code_snippet_02": "always @(posedge (clk2 + clk3)"}, {"number": 507, "title": "[FIRRTL] Lower Types Fails for Certain Nested Bundles", "created_at": "2021-01-25T18:28:47Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The `LowerTypes` pass has problems with nested aggregates. Consider the following example:\r\n\r\n```scala\r\ncircuit Foo :\r\n  module Foo :\r\n    input a: { b: {c: UInt<1>}}\r\n    output b: { b: {c: UInt<1>}}\r\n\r\n    b <= a\r\n```\r\n\r\n```bash\r\nfirtool -lower-to-rtl -enable-lower-types -verilog Foo.fir\r\n# Assertion failed: (entry && \"bundle lowering was not set\"), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 530.\r\n```\r\n\r\nI believe this is trying to find a lowering for the non-leaf types, but such a lowering was never recorded.", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input a: { b: {c: UInt<1>}}\r\n    output b: { b: {c: UInt<1>}}\r\n\r\n    b <= a", "code_snippet_02": "firtool -lower-to-rtl -enable-lower-types -verilog Foo.fir\r\n# Assertion failed: (entry && \"bundle lowering was not set\"), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 530."}, {"number": 492, "title": "[FIRRTL] Write Only Memory Causes Type Error", "created_at": "2021-01-21T02:12:24Z", "state": "closed", "labels": "bug, FIRRTL", "body": "If you try to create a memory that only has a writer, the type of the memory will be `FlipType` due to type canonicalization. However, this then fails the ODS requirement that a memory is a `BundleType`. I ran into this from a different direction when working on #479/#488 where this problem will always happen when returning a variadic `BundleType` (the write port will always be flipped).\r\n\r\nConsider:\r\n\r\n```\r\ncircuit Bar :\r\n  module Bar :\r\n    input clock: Clock\r\n    input wAddr: UInt<4>\r\n    input wEn: UInt<1>\r\n    input wMask: UInt<1>\r\n    input wData: UInt<8>\r\n\r\n    mem memory:\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      writer => w\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.w.clk <= clock\r\n    memory.w.en <= wEn\r\n    memory.w.addr <= wAddr\r\n    memory.w.mask <= wMask\r\n    memory.w.data <= wData\r\n```\r\n\r\nThis will fail with:\r\n\r\n```bash\r\nfirtool Bar.fir\r\n# Bar.fir:9:5: error: 'firrtl.mem' op result #0 must be BundleType, but got '!firrtl.flip<bundle<w: bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>>>'\r\n#     mem memory:\r\n#     ^\r\n# Bar.fir:9:5: note: see current operation: %memory = \"firrtl.mem\"() {depth = 16 : i64, name = \"memory\", readLatency = 0 : i32, ruw = 0 : i32, writeLatency = 1 : i32} : () -> !firrtl.flip<bundle<w: bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>>>\r\n```\r\n\r\nThe SFC will return an empty module:\r\n\r\n```\r\nmodule Bar(\r\n  input        clock,\r\n  input  [3:0] wAddr,\r\n  input        wEn,\r\n  input        wMask,\r\n  input  [7:0] wData\r\n);\r\nendmodule\r\n```\r\n\r\nI admit that intentional description of a memory hole is a weird one...", "code_snippet_01": "circuit Bar :\r\n  module Bar :\r\n    input clock: Clock\r\n    input wAddr: UInt<4>\r\n    input wEn: UInt<1>\r\n    input wMask: UInt<1>\r\n    input wData: UInt<8>\r\n\r\n    mem memory:\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      writer => w\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.w.clk <= clock\r\n    memory.w.en <= wEn\r\n    memory.w.addr <= wAddr\r\n    memory.w.mask <= wMask\r\n    memory.w.data <= wData", "code_snippet_02": "firtool Bar.fir\r\n# Bar.fir:9:5: error: 'firrtl.mem' op result #0 must be BundleType, but got '!firrtl.flip<bundle<w: bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>>>'\r\n#     mem memory:\r\n#     ^\r\n# Bar.fir:9:5: note: see current operation: %memory = \"firrtl.mem\"() {depth = 16 : i64, name = \"memory\", readLatency = 0 : i32, ruw = 0 : i32, writeLatency = 1 : i32} : () -> !firrtl.flip<bundle<w: bundle<addr: uint<4>, en: uint<1>, clk: clock, data: uint<8>, mask: uint<1>>>>", "code_snippet_03": "module Bar(\r\n  input        clock,\r\n  input  [3:0] wAddr,\r\n  input        wEn,\r\n  input        wMask,\r\n  input  [7:0] wData\r\n);\r\nendmodule"}, {"number": 480, "title": "[FIRRTL] Handle read-write memory ports", "created_at": "2021-01-18T18:43:37Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Currently, any read-write memory ports get dropped during conversion to RTL with an error (but no hard exit from `firtool`). These, as the error message suggests, should be split up into separate read and write ports sometime before conversion to RTL to align with how the SFC handles these. Alternatively, these could be directly lowered to some structure that more directly expressions a true read/write port.\r\n\r\nThe main question is whether this should be a new pass or if this should be handled during an existing pass/conversion.\r\n\r\n### Example\r\n\r\nConsider the following FIRRTL circuit:\r\n\r\n```\r\ncircuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    input rwMode: UInt<1>\r\n    input rwEn: UInt<1>\r\n    input rwAddr: UInt<1>\r\n    input rwMask: UInt<1>\r\n    input rwDataIn: UInt<8>\r\n    output rwDataOut: UInt<8>\r\n\r\n    mem memory:\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      readwriter => rw\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.rw.clk <= clock\r\n    memory.rw.wmode <= rwMode\r\n    memory.rw.en <= rwEn\r\n    memory.rw.addr <= rwAddr\r\n    memory.rw.wdata <= rwDataIn\r\n    memory.rw.wmask <= rwMask\r\n    rwDataOut <= memory.rw.rdata\r\n```\r\n\r\nThe SFC will, during the `VerilogMemDelays` pass, split this into separate read and write ports. After that, the circuit looks like:\r\n\r\n```\r\ncircuit Foo :\r\n  module Foo :\r\n    input clock : Clock\r\n    input rwMode : UInt<1>\r\n    input rwEn : UInt<1>\r\n    input rwAddr : UInt<1>\r\n    input rwMask : UInt<1>\r\n    input rwDataIn : UInt<8>\r\n    output rwDataOut : UInt<8>\r\n\r\n    mem memory :\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      read-latency => 0\r\n      write-latency => 1\r\n      reader => rw_r\r\n      writer => rw_w\r\n      read-under-write => undefined\r\n    rwDataOut <= memory.rw_r.data\r\n    memory.rw_r.en <= and(rwEn, not(rwMode))\r\n    memory.rw_r.addr <= pad(rwAddr, 4)\r\n    memory.rw_r.clk <= clock\r\n    memory.rw_w.en <= and(rwEn, rwMode)\r\n    memory.rw_w.addr <= pad(rwAddr, 4)\r\n    memory.rw_w.mask <= rwMask\r\n    memory.rw_w.data <= rwDataIn\r\n    memory.rw_w.clk <= clock\r\n```\r\n\r\nCurrently, if we run the original FIRRTL IR through `firtool`, the memory is just dropped.", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    input rwMode: UInt<1>\r\n    input rwEn: UInt<1>\r\n    input rwAddr: UInt<1>\r\n    input rwMask: UInt<1>\r\n    input rwDataIn: UInt<8>\r\n    output rwDataOut: UInt<8>\r\n\r\n    mem memory:\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      readwriter => rw\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.rw.clk <= clock\r\n    memory.rw.wmode <= rwMode\r\n    memory.rw.en <= rwEn\r\n    memory.rw.addr <= rwAddr\r\n    memory.rw.wdata <= rwDataIn\r\n    memory.rw.wmask <= rwMask\r\n    rwDataOut <= memory.rw.rdata", "code_snippet_02": "circuit Foo :\r\n  module Foo :\r\n    input clock : Clock\r\n    input rwMode : UInt<1>\r\n    input rwEn : UInt<1>\r\n    input rwAddr : UInt<1>\r\n    input rwMask : UInt<1>\r\n    input rwDataIn : UInt<8>\r\n    output rwDataOut : UInt<8>\r\n\r\n    mem memory :\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      read-latency => 0\r\n      write-latency => 1\r\n      reader => rw_r\r\n      writer => rw_w\r\n      read-under-write => undefined\r\n    rwDataOut <= memory.rw_r.data\r\n    memory.rw_r.en <= and(rwEn, not(rwMode))\r\n    memory.rw_r.addr <= pad(rwAddr, 4)\r\n    memory.rw_r.clk <= clock\r\n    memory.rw_w.en <= and(rwEn, rwMode)\r\n    memory.rw_w.addr <= pad(rwAddr, 4)\r\n    memory.rw_w.mask <= rwMask\r\n    memory.rw_w.data <= rwDataIn\r\n    memory.rw_w.clk <= clock"}, {"number": 478, "title": "[FIRRTL] LowerTypes with memories crashes LowerToRTL", "created_at": "2021-01-18T18:00:07Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Running a memory through `LowerTypes` followed by `LowerToRTL` causes a crash. (**edit**: Originally I thought this was related to memories with aggregate types, but it's actually _any_ memory.)\r\n\r\nE.g., the following will crash with `firtool -enable-lower-types -lower-to-rtl`:\r\n\r\n```\r\ncircuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    input readAddr: UInt<4>\r\n    input readEn: UInt<1>\r\n    output readData: UInt<8>\r\n\r\n    mem memory:\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      reader => r\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.r.clk <= clock\r\n    memory.r.en <= readEn\r\n    memory.r.addr <= readAddr\r\n    readData <= memory.r.data\r\n```\r\n\r\n```\r\nAssertion failed: (entry && \"bundle lowering was not set\"), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 400.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: firtool -lower-to-rtl -enable-lower-types Foo.fir\r\n1.\t2.\tStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x000000010957a16d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x000000010957a71b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x00000001095783bb llvm::sys::RunSignalHandlers() + 123\r\n3  firtool                  0x000000010957ca68 SignalHandler(int) + 232\r\n4  libsystem_platform.dylib 0x00007fff203aad7d _sigtramp + 29\r\n5  firtool                  0x0000000109e9dd70 llvm::ColorCategory + 211904\r\n6  libsystem_c.dylib        0x00007fff202b9720 abort + 120\r\n7  libsystem_c.dylib        0x00007fff202b89d6 err + 0\r\n8  firtool                  0x00000001096bfac3 (anonymous namespace)::FIRRTLTypesLowering::getBundleLowering(mlir::Value, llvm::StringRef) + 211\r\n9  firtool                  0x00000001096bf810 (anonymous namespace)::FIRRTLTypesLowering::visitExpr(circt::firrtl::SubfieldOp) + 384\r\n10 firtool                  0x00000001096bf67b void circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::SubfieldOp>(auto) const + 43\r\n11 firtool                  0x00000001096bf5c1 llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::SubfieldOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(void&&) + 113\r\n12 firtool                  0x00000001096bf445 llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::SubfieldOp, circt::firrtl::SubindexOp, circt::firrtl::SubaccessOp, circt::firrtl::AddPrimOp, circt::firrtl::SubPrimOp, circt::firrtl::MulPrimOp, circt::firrtl::DivPrimOp, circt::firrtl::RemPrimOp, circt::firrtl::AndPrimOp, circt::firrtl::OrPrimOp, circt::firrtl::XorPrimOp, circt::firrtl::LEQPrimOp, circt::firrtl::LTPrimOp, circt::firrtl::GEQPrimOp, circt::firrtl::GTPrimOp, circt::firrtl::EQPrimOp, circt::firrtl::NEQPrimOp, circt::firrtl::CatPrimOp, circt::firrtl::DShlPrimOp, circt::firrtl::DShlwPrimOp, circt::firrtl::DShrPrimOp, circt::firrtl::ValidIfPrimOp, circt::firrtl::AsSIntPrimOp, circt::firrtl::AsUIntPrimOp, circt::firrtl::AsAsyncResetPrimOp, circt::firrtl::AsClockPrimOp, circt::firrtl::CvtPrimOp, circt::firrtl::NegPrimOp, circt::firrtl::NotPrimOp, circt::firrtl::AndRPrimOp, circt::firrtl::OrRPrimOp, circt::firrtl::XorRPrimOp, circt::firrtl::BitsPrimOp, circt::firrtl::HeadPrimOp, circt::firrtl::InvalidValuePrimOp, circt::firrtl::MuxPrimOp, circt::firrtl::PadPrimOp, circt::firrtl::ShlPrimOp, circt::firrtl::ShrPrimOp, circt::firrtl::TailPrimOp, circt::firrtl::AsPassivePrimOp, circt::firrtl::AsNonPassivePrimOp, circt::firrtl::StdIntCastOp, circt::firrtl::AnalogInOutCastOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&) + 37\r\n13 firtool                  0x00000001096bf2e1 llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::ConstantOp, circt::firrtl::SubfieldOp, circt::firrtl::SubindexOp, circt::firrtl::SubaccessOp, circt::firrtl::AddPrimOp, circt::firrtl::SubPrimOp, circt::firrtl::MulPrimOp, circt::firrtl::DivPrimOp, circt::firrtl::RemPrimOp, circt::firrtl::AndPrimOp, circt::firrtl::OrPrimOp, circt::firrtl::XorPrimOp, circt::firrtl::LEQPrimOp, circt::firrtl::LTPrimOp, circt::firrtl::GEQPrimOp, circt::firrtl::GTPrimOp, circt::firrtl::EQPrimOp, circt::firrtl::NEQPrimOp, circt::firrtl::CatPrimOp, circt::firrtl::DShlPrimOp, circt::firrtl::DShlwPrimOp, circt::firrtl::DShrPrimOp, circt::firrtl::ValidIfPrimOp, circt::firrtl::AsSIntPrimOp, circt::firrtl::AsUIntPrimOp, circt::firrtl::AsAsyncResetPrimOp, circt::firrtl::AsClockPrimOp, circt::firrtl::CvtPrimOp, circt::firrtl::NegPrimOp, circt::firrtl::NotPrimOp, circt::firrtl::AndRPrimOp, circt::firrtl::OrRPrimOp, circt::firrtl::XorRPrimOp, circt::firrtl::BitsPrimOp, circt::firrtl::HeadPrimOp, circt::firrtl::InvalidValuePrimOp, circt::firrtl::MuxPrimOp, circt::firrtl::PadPrimOp, circt::firrtl::ShlPrimOp, circt::firrtl::ShrPrimOp, circt::firrtl::TailPrimOp, circt::firrtl::AsPassivePrimOp, circt::firrtl::AsNonPassivePrimOp, circt::firrtl::StdIntCastOp, circt::firrtl::AnalogInOutCastOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&&) + 49\r\n14 firtool                  0x00000001096bf25d circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*) + 61\r\n15 firtool                  0x00000001096bbd60 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchVisitor(mlir::Operation*) + 32\r\n16 firtool                  0x00000001096ba19e (anonymous namespace)::FIRRTLTypesLowering::runOnOperation() + 670\r\n17 firtool                  0x0000000109d4f7e5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 661\r\n18 firtool                  0x0000000109d4fef7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359\r\n19 firtool                  0x0000000109d67ccf mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const + 559\r\n20 firtool                  0x0000000109d66002 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8 std::__1::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 82\r\n21 firtool                  0x0000000109d65f73 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 499\r\n22 firtool                  0x0000000109d51734 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 180\r\n23 firtool                  0x0000000109d50d3f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 1279\r\n24 firtool                  0x0000000109d4fb2d mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) + 77\r\n25 firtool                  0x0000000109d4f7d0 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 640\r\n26 firtool                  0x0000000109d4fef7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359\r\n27 firtool                  0x0000000109d67ccf mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const + 559\r\n28 firtool                  0x0000000109d66002 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8 std::__1::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 82\r\n29 firtool                  0x0000000109d65f73 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 499\r\n30 firtool                  0x0000000109d51734 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 180\r\n31 firtool                  0x0000000109d50d3f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 1279\r\n32 firtool                  0x0000000109d4fb2d mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) + 77\r\n33 firtool                  0x0000000109d4f7d0 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 640\r\n34 firtool                  0x0000000109d4fef7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359\r\n35 firtool                  0x0000000109d526c1 mlir::PassManager::run(mlir::Operation*) + 657\r\n36 firtool                  0x00000001093ee356 processBuffer(std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) + 1238\r\n37 firtool                  0x00000001093edb01 main + 897\r\n38 libdyld.dylib            0x00007fff20381621 start + 1\r\n39 libdyld.dylib            0x0000000000000004 start + 18446603339975616996\r\n```", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    input readAddr: UInt<4>\r\n    input readEn: UInt<1>\r\n    output readData: UInt<8>\r\n\r\n    mem memory:\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      reader => r\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.r.clk <= clock\r\n    memory.r.en <= readEn\r\n    memory.r.addr <= readAddr\r\n    readData <= memory.r.data", "code_snippet_02": "Assertion failed: (entry && \"bundle lowering was not set\"), function getBundleLowering, file ../lib/Dialect/FIRRTL/Transforms/LowerTypes.cpp, line 400.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: firtool -lower-to-rtl -enable-lower-types Foo.fir\r\n1.\t2.\tStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x000000010957a16d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x000000010957a71b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x00000001095783bb llvm::sys::RunSignalHandlers() + 123\r\n3  firtool                  0x000000010957ca68 SignalHandler(int) + 232\r\n4  libsystem_platform.dylib 0x00007fff203aad7d _sigtramp + 29\r\n5  firtool                  0x0000000109e9dd70 llvm::ColorCategory + 211904\r\n6  libsystem_c.dylib        0x00007fff202b9720 abort + 120\r\n7  libsystem_c.dylib        0x00007fff202b89d6 err + 0\r\n8  firtool                  0x00000001096bfac3 (anonymous namespace)::FIRRTLTypesLowering::getBundleLowering(mlir::Value, llvm::StringRef) + 211\r\n9  firtool                  0x00000001096bf810 (anonymous namespace)::FIRRTLTypesLowering::visitExpr(circt::firrtl::SubfieldOp) + 384\r\n10 firtool                  0x00000001096bf67b void circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)::operator()<circt::firrtl::SubfieldOp>(auto) const + 43\r\n11 firtool                  0x00000001096bf5c1 llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::SubfieldOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(void&&) + 113\r\n12 firtool                  0x00000001096bf445 llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::SubfieldOp, circt::firrtl::SubindexOp, circt::firrtl::SubaccessOp, circt::firrtl::AddPrimOp, circt::firrtl::SubPrimOp, circt::firrtl::MulPrimOp, circt::firrtl::DivPrimOp, circt::firrtl::RemPrimOp, circt::firrtl::AndPrimOp, circt::firrtl::OrPrimOp, circt::firrtl::XorPrimOp, circt::firrtl::LEQPrimOp, circt::firrtl::LTPrimOp, circt::firrtl::GEQPrimOp, circt::firrtl::GTPrimOp, circt::firrtl::EQPrimOp, circt::firrtl::NEQPrimOp, circt::firrtl::CatPrimOp, circt::firrtl::DShlPrimOp, circt::firrtl::DShlwPrimOp, circt::firrtl::DShrPrimOp, circt::firrtl::ValidIfPrimOp, circt::firrtl::AsSIntPrimOp, circt::firrtl::AsUIntPrimOp, circt::firrtl::AsAsyncResetPrimOp, circt::firrtl::AsClockPrimOp, circt::firrtl::CvtPrimOp, circt::firrtl::NegPrimOp, circt::firrtl::NotPrimOp, circt::firrtl::AndRPrimOp, circt::firrtl::OrRPrimOp, circt::firrtl::XorRPrimOp, circt::firrtl::BitsPrimOp, circt::firrtl::HeadPrimOp, circt::firrtl::InvalidValuePrimOp, circt::firrtl::MuxPrimOp, circt::firrtl::PadPrimOp, circt::firrtl::ShlPrimOp, circt::firrtl::ShrPrimOp, circt::firrtl::TailPrimOp, circt::firrtl::AsPassivePrimOp, circt::firrtl::AsNonPassivePrimOp, circt::firrtl::StdIntCastOp, circt::firrtl::AnalogInOutCastOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&) + 37\r\n13 firtool                  0x00000001096bf2e1 llvm::TypeSwitch<mlir::Operation*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<mlir::Operation*, void>, mlir::Operation*>::Case<circt::firrtl::ConstantOp, circt::firrtl::SubfieldOp, circt::firrtl::SubindexOp, circt::firrtl::SubaccessOp, circt::firrtl::AddPrimOp, circt::firrtl::SubPrimOp, circt::firrtl::MulPrimOp, circt::firrtl::DivPrimOp, circt::firrtl::RemPrimOp, circt::firrtl::AndPrimOp, circt::firrtl::OrPrimOp, circt::firrtl::XorPrimOp, circt::firrtl::LEQPrimOp, circt::firrtl::LTPrimOp, circt::firrtl::GEQPrimOp, circt::firrtl::GTPrimOp, circt::firrtl::EQPrimOp, circt::firrtl::NEQPrimOp, circt::firrtl::CatPrimOp, circt::firrtl::DShlPrimOp, circt::firrtl::DShlwPrimOp, circt::firrtl::DShrPrimOp, circt::firrtl::ValidIfPrimOp, circt::firrtl::AsSIntPrimOp, circt::firrtl::AsUIntPrimOp, circt::firrtl::AsAsyncResetPrimOp, circt::firrtl::AsClockPrimOp, circt::firrtl::CvtPrimOp, circt::firrtl::NegPrimOp, circt::firrtl::NotPrimOp, circt::firrtl::AndRPrimOp, circt::firrtl::OrRPrimOp, circt::firrtl::XorRPrimOp, circt::firrtl::BitsPrimOp, circt::firrtl::HeadPrimOp, circt::firrtl::InvalidValuePrimOp, circt::firrtl::MuxPrimOp, circt::firrtl::PadPrimOp, circt::firrtl::ShlPrimOp, circt::firrtl::ShrPrimOp, circt::firrtl::TailPrimOp, circt::firrtl::AsPassivePrimOp, circt::firrtl::AsNonPassivePrimOp, circt::firrtl::StdIntCastOp, circt::firrtl::AnalogInOutCastOp, circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)>(circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*)::'lambda'(auto)&&) + 49\r\n14 firtool                  0x00000001096bf25d circt::firrtl::ExprVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchExprVisitor(mlir::Operation*) + 61\r\n15 firtool                  0x00000001096bbd60 circt::firrtl::FIRRTLVisitor<(anonymous namespace)::FIRRTLTypesLowering, void>::dispatchVisitor(mlir::Operation*) + 32\r\n16 firtool                  0x00000001096ba19e (anonymous namespace)::FIRRTLTypesLowering::runOnOperation() + 670\r\n17 firtool                  0x0000000109d4f7e5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 661\r\n18 firtool                  0x0000000109d4fef7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359\r\n19 firtool                  0x0000000109d67ccf mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const + 559\r\n20 firtool                  0x0000000109d66002 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8 std::__1::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 82\r\n21 firtool                  0x0000000109d65f73 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 499\r\n22 firtool                  0x0000000109d51734 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 180\r\n23 firtool                  0x0000000109d50d3f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 1279\r\n24 firtool                  0x0000000109d4fb2d mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) + 77\r\n25 firtool                  0x0000000109d4f7d0 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 640\r\n26 firtool                  0x0000000109d4fef7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359\r\n27 firtool                  0x0000000109d67ccf mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8::operator()(llvm::MutableArrayRef<mlir::OpPassManager>) const + 559\r\n28 firtool                  0x0000000109d66002 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8 std::__1::for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 82\r\n29 firtool                  0x0000000109d65f73 void llvm::parallel::detail::parallel_for_each<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 499\r\n30 firtool                  0x0000000109d51734 void llvm::parallelForEach<llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8>(llvm::SmallVector<mlir::OpPassManager, 1u>*, llvm::SmallVector<mlir::OpPassManager, 1u>*, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_8) + 180\r\n31 firtool                  0x0000000109d50d3f mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) + 1279\r\n32 firtool                  0x0000000109d4fb2d mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) + 77\r\n33 firtool                  0x0000000109d4f7d0 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) + 640\r\n34 firtool                  0x0000000109d4fef7 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::__1::unique_ptr<mlir::Pass, std::__1::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) + 359\r\n35 firtool                  0x0000000109d526c1 mlir::PassManager::run(mlir::Operation*) + 657\r\n36 firtool                  0x00000001093ee356 processBuffer(std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) + 1238\r\n37 firtool                  0x00000001093edb01 main + 897\r\n38 libdyld.dylib            0x00007fff20381621 start + 1\r\n39 libdyld.dylib            0x0000000000000004 start + 18446603339975616996"}, {"number": 477, "title": "[FIRRTL] Lower to RTL for Memories of Read Latency > 0, Write Latency > 1", "created_at": "2021-01-18T17:55:36Z", "state": "closed", "labels": "bug, enhancement, FIRRTL", "body": "Currently, RTL lowering from FIRRTL only handles \"combinational read memories\", i.e., FIRRTL memories with read latency == 0 and write latency == 1. This is mostly reasonable as \"sequential read memories\", i.e., FIRRTL memories with read latency == 1 and write latency == 1, are usually replaced with technology-specific macros generated by a memory compiler. However, this is not always the case---sometimes you want to simulate the sequential memory directly or you can rely on an FPGA toolchain to infer the sequential memory as BRAM.\r\n\r\nWe should support arbitrary, legal values of read and write latency in the same way that the Scala FIRRTL Compiler (SFC) handles these. Namely, add register delays of en/addr for read latency and en/addr/data for write latency.\r\n\r\nAt minimum, we should support sequential read memories and error on any read or write latency greater than 1.\r\n\r\n### Example\r\n\r\nThe following sequential memory:\r\n\r\n```\r\ncircuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    input readAddr: UInt<4>\r\n    input readEn: UInt<1>\r\n    output readData: UInt<8>\r\n\r\n    mem memory:\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      reader => r\r\n      read-latency => 1\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.r.clk <= clock\r\n    memory.r.en <= readEn\r\n    memory.r.addr <= readAddr\r\n    readData <= memory.r.data\r\n```\r\n\r\nEmits incorrectly as:\r\n\r\n```verilog\r\nmodule Foo(\r\n  input        clock,\r\n  input  [3:0] readAddr,\r\n  input        readEn,\r\n  output [7:0] readData);\r\n\r\n  reg  [7:0] memory[15:0];\t// Foo.fir:8:5\r\n  wire [3:0] memory_r_addr;\t// Foo.fir:8:5\r\n  wire [7:0] memory_r_data;\t// Foo.fir:8:5\r\n\r\n  assign memory_r_data = memory[memory_r_addr];\t// Foo.fir:8:5\r\n  assign memory_r_addr = readAddr;\t// Foo.fir:18:19\r\n  assign readData = memory_r_data;\t// Foo.fir:2:3\r\nendmodule\r\n```\r\n\r\n### Additional Info\r\n\r\nCurrently, the Scala FIRRTL Compiler (SFC) has an optional pass to replace sequential read memories with blackboxes to support the technology-specific path. However, the SFC will happily lower memories with any read/write latency the user specifies by just adding the necessary delay registers for the output.\r\n\r\nE.g., if the read latency is 8, you get a pipe of 8 registers on the read value.\r\n\r\nI'm not aware of any mechanism by which a Chisel user can emit a memory which isn't a combinational read or sequential read memory. Chisel provides two primitives for working with memories:\r\n\r\n1. [`Mem`](https://www.chisel-lang.org/api/latest/chisel3/Mem.html): combinational read (read latency 0, write latency 1)\r\n2. [`SyncReadMem`](https://www.chisel-lang.org/api/latest/chisel3/SyncReadMem.html): sequential read (read latency 1, write latency 1)\r\n\r\nWith this in mind, it may make sense to de-prioritize implementing generic support for arbitrary, legal read/write latencies.", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    input readAddr: UInt<4>\r\n    input readEn: UInt<1>\r\n    output readData: UInt<8>\r\n\r\n    mem memory:\r\n      data-type => UInt<8>\r\n      depth => 16\r\n      reader => r\r\n      read-latency => 1\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.r.clk <= clock\r\n    memory.r.en <= readEn\r\n    memory.r.addr <= readAddr\r\n    readData <= memory.r.data", "code_snippet_02": "module Foo(\r\n  input        clock,\r\n  input  [3:0] readAddr,\r\n  input        readEn,\r\n  output [7:0] readData);\r\n\r\n  reg  [7:0] memory[15:0];\t// Foo.fir:8:5\r\n  wire [3:0] memory_r_addr;\t// Foo.fir:8:5\r\n  wire [7:0] memory_r_data;\t// Foo.fir:8:5\r\n\r\n  assign memory_r_data = memory[memory_r_addr];\t// Foo.fir:8:5\r\n  assign memory_r_addr = readAddr;\t// Foo.fir:18:19\r\n  assign readData = memory_r_data;\t// Foo.fir:2:3\r\nendmodule"}, {"number": 471, "title": "[ExportVerilog] Zero width module ports which appear last in a port list cause syntax errors", "created_at": "2021-01-17T20:59:02Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "As [noted in the code](https://github.com/llvm/circt/blob/1606160e433d378d188f214090c4f2c473e78e70/lib/Translation/ExportVerilog/ExportVerilog.cpp#L1525) in a list of port assignments (in a module instantiation): if the last port is zero width, the previous port will end with a comma, which is a syntax error."}, {"number": 463, "title": "[FIRRTL][RTL][ExportVerilog] Instances with no names", "created_at": "2021-01-15T21:49:47Z", "state": "closed", "labels": "bug", "body": "I have a question regarding FIRRTL instances with no names, lowering to RTL, and exporting Verilog.\r\n\r\nHere's a really stripped down example. All that really matters is I am starting with a FIRRTL instance that has no name:\r\n\r\n```\r\nmodule  {                                                                                                                                                                                                          \r\n  firrtl.circuit \"top\" {                                                                                                                                                                                           \r\n    firrtl.module @sub() {}                                                                                                                                                                                        \r\n    firrtl.module @top() {                                                                                                                                                                                         \r\n      %0 = firrtl.instance @sub : !firrtl.bundle<>                                                                                                                                                                 \r\n    }                                                                                                                                                                                                              \r\n  }                                                                                                                                                                                                                \r\n}\r\n```\r\n\r\nThe `name` attribute is marked optional, and the lowering pass from Handshake to FIRRTL makes use of this to generate IR similar to the above.\r\n\r\nIf I use FIRRTL to directly export verilog (`firtool -format=mlir -verilog`), I get the following output:\r\n\r\n```\r\nmodule sub();                                                                                                                                                                                                      \r\nendmodule                                                                                                                                                                                                          \r\n                                                                                                                                                                                                                   \r\nmodule top();                                                                                                                                                                                                      \r\n  sub _T (\r\n  );                                                                                                                                                                                                               \r\nendmodule \r\n```\r\n\r\nBecause of how instances are handled in `ExportVerilogFIRRTL`, the instance goes through `addName`/`getName` and a unique name is generated.\r\n\r\nIf I try to lower to RTL first (`firtool -format=mlir -lower-to-rtl -verilog`), I get a helpful error that explains `'rtl.instance' op requires attribute 'instanceName'`.\r\n\r\nShould the LowerToRTL pass do something to generate names in this case? It's nice to be able to leave off the name for passes like Handshake that don't really care how the instances are identified.", "code_snippet_01": "module  {                                                                                                                                                                                                          \r\n  firrtl.circuit \"top\" {                                                                                                                                                                                           \r\n    firrtl.module @sub() {}                                                                                                                                                                                        \r\n    firrtl.module @top() {                                                                                                                                                                                         \r\n      %0 = firrtl.instance @sub : !firrtl.bundle<>                                                                                                                                                                 \r\n    }                                                                                                                                                                                                              \r\n  }                                                                                                                                                                                                                \r\n}", "code_snippet_02": "module sub();                                                                                                                                                                                                      \r\nendmodule                                                                                                                                                                                                          \r\n                                                                                                                                                                                                                   \r\nmodule top();                                                                                                                                                                                                      \r\n  sub _T (\r\n  );                                                                                                                                                                                                               \r\nendmodule"}, {"number": 446, "title": "[FIRRTL] (xor) 0-width result (core dump)", "created_at": "2021-01-13T02:23:56Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_1: SInt<0>\r\n    output tmp10: UInt<1>\r\n    tmp10 <= xor(inp_1, inp_1)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` gives an error:\r\n\r\n```mlir\r\nfirtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:280: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && \"bitwidth too small\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v\r\n #0 0x00000000004c16e3 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004c179a PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004bf7a0 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004c1136 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f76f9a031d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007f76f94c2ae5 raise (/lib64/libc.so.6+0x3dae5)\r\n #6 0x00007f76f94ab864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f76f94ab749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f76f94bb016 (/lib64/libc.so.6+0x36016)\r\n #9 0x000000000045bd42 llvm::APInt::APInt(unsigned int, unsigned long, bool) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:281:21\r\n#10 0x000000000063dcc9 mlir::Builder::getZeroAttr(mlir::Type) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Builders.cpp:282:78\r\n#11 0x0000000000793637 circt::firrtl::XorPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/FIRRTLFolds.cpp:140:50\r\n#12 0x00000000007899d8 mlir::LogicalResult mlir::Op<circt::firrtl::XorPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::OpTrait::IsCommutative, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::XorPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1699:53\r\n#13 0x00000000006cae3c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3\r\n#14 0x00000000006c45a2 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30\r\n#15 0x000000000088b90d mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#16 0x000000000088b26c mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#17 0x000000000086f7e9 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#18 0x000000000086fb14 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#19 0x000000000086fa00 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#20 0x0000000000738372 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3\r\n#21 0x0000000000959dfb mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36\r\n#22 0x000000000095a027 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15\r\n#23 0x000000000095bf3e mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:854:74\r\n#24 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13\r\n#25 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13\r\n#26 0x00007f76f94ad152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#27 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output  tmp10\r\n);\r\n  assign tmp10 = 1'h0;\r\nendmodule\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_1: SInt<0>\r\n    output tmp10: UInt<1>\r\n    tmp10 <= xor(inp_1, inp_1)", "code_snippet_02": "firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:280: llvm::APInt::APInt(unsigned int, uint64_t, bool): Assertion `BitWidth && \"bitwidth too small\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v\r\n #0 0x00000000004c16e3 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004c179a PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004bf7a0 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004c1136 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f76f9a031d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007f76f94c2ae5 raise (/lib64/libc.so.6+0x3dae5)\r\n #6 0x00007f76f94ab864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f76f94ab749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f76f94bb016 (/lib64/libc.so.6+0x36016)\r\n #9 0x000000000045bd42 llvm::APInt::APInt(unsigned int, unsigned long, bool) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:281:21\r\n#10 0x000000000063dcc9 mlir::Builder::getZeroAttr(mlir::Type) (.localalias) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Builders.cpp:282:78\r\n#11 0x0000000000793637 circt::firrtl::XorPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/FIRRTLFolds.cpp:140:50\r\n#12 0x00000000007899d8 mlir::LogicalResult mlir::Op<circt::firrtl::XorPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::NOperands<2u>::Impl, mlir::OpTrait::IsCommutative, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::XorPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1699:53\r\n#13 0x00000000006cae3c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3\r\n#14 0x00000000006c45a2 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30\r\n#15 0x000000000088b90d mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#16 0x000000000088b26c mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#17 0x000000000086f7e9 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#18 0x000000000086fb14 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#19 0x000000000086fa00 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#20 0x0000000000738372 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3\r\n#21 0x0000000000959dfb mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36\r\n#22 0x000000000095a027 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15\r\n#23 0x000000000095bf3e mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:854:74\r\n#24 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13\r\n#25 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13\r\n#26 0x00007f76f94ad152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#27 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0", "code_snippet_03": "module top_mod(\r\n  output  tmp10\r\n);\r\n  assign tmp10 = 1'h0;\r\nendmodule"}, {"number": 438, "title": "[ExportVerilog] Wires are declared after they are referenced", "created_at": "2021-01-12T19:36:56Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "In the situation where an expression cannot be inlined and appears in the IR after its use, ExportVerilog will emit the use before the declaration. Generally speaking, this will likely occur when a cycle occurs.\r\n\r\nSetting `emitInlineWireDecls` ([here](https://github.com/llvm/circt/blob/8cbe578d2363a9e97395d1b7af99d9ad3cac60bc/lib/Translation/ExportVerilog/ExportVerilog.cpp#L33)) to false mitigates the issue. Always putting the wire declarations at the beginning of the file is the simplest thing to do, but probably not what we want.\r\n\r\nShould we set `emitInlineWireDecls` to false and treat optimal decl placement as a future cleanup/enhancement?"}, {"number": 437, "title": "[FIRRTL] (bits) parameters 0,0 (core dump)", "created_at": "2021-01-12T19:26:15Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp19: UInt<1>\r\n    tmp19 <= bits(SInt<1>(-1), 0, 0)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` gives an error:\r\n\r\n```mlir\r\nfirtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:859: llvm::APInt llvm::APInt::trunc(unsigned int) const: Assertion `width < BitWidth && \"Invalid APInt Truncate request\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v\r\n #0 0x00000000004c16e3 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004c179a PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004bf7a0 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004c1136 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f927f19f1d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007f927ec5eae5 raise (/lib64/libc.so.6+0x3dae5)\r\n #6 0x00007f927ec47864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f927ec47749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f927ec57016 (/lib64/libc.so.6+0x36016)\r\n #9 0x00000000004e2e0a llvm::APInt::trunc(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:860:3\r\n#10 0x000000000079391d circt::firrtl::BitsPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/FIRRTLFolds.cpp:256:76\r\n#11 0x0000000000786255 mlir::LogicalResult mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::BitsPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1699:53\r\n#12 0x00000000006ca63e mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3\r\n#13 0x00000000006c3da4 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30\r\n#14 0x000000000088b0ab mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#15 0x000000000088aa0a mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#16 0x000000000086ef87 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#17 0x000000000086f2b2 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#18 0x000000000086f19e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#19 0x0000000000737b74 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3\r\n#20 0x0000000000959599 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36\r\n#21 0x00000000009597c5 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15\r\n#22 0x000000000095b6dc mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:854:74\r\n#23 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13\r\n#24 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13\r\n#25 0x00007f927ec49152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#26 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output  tmp19\r\n);\r\n  assign tmp19 = 1'h1;\r\nendmodule\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    output tmp19: UInt<1>\r\n    tmp19 <= bits(SInt<1>(-1), 0, 0)", "code_snippet_02": "firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:859: llvm::APInt llvm::APInt::trunc(unsigned int) const: Assertion `width < BitWidth && \"Invalid APInt Truncate request\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v\r\n #0 0x00000000004c16e3 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004c179a PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004bf7a0 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004c1136 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f927f19f1d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007f927ec5eae5 raise (/lib64/libc.so.6+0x3dae5)\r\n #6 0x00007f927ec47864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f927ec47749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f927ec57016 (/lib64/libc.so.6+0x36016)\r\n #9 0x00000000004e2e0a llvm::APInt::trunc(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:860:3\r\n#10 0x000000000079391d circt::firrtl::BitsPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/FIRRTLFolds.cpp:256:76\r\n#11 0x0000000000786255 mlir::LogicalResult mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::BitsPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1699:53\r\n#12 0x00000000006ca63e mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3\r\n#13 0x00000000006c3da4 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30\r\n#14 0x000000000088b0ab mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#15 0x000000000088aa0a mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#16 0x000000000086ef87 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#17 0x000000000086f2b2 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#18 0x000000000086f19e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#19 0x0000000000737b74 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3\r\n#20 0x0000000000959599 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36\r\n#21 0x00000000009597c5 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15\r\n#22 0x000000000095b6dc mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:854:74\r\n#23 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13\r\n#24 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13\r\n#25 0x00007f927ec49152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#26 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0", "code_snippet_03": "module top_mod(\r\n  output  tmp19\r\n);\r\n  assign tmp19 = 1'h1;\r\nendmodule"}, {"number": 436, "title": "[FIRRTL] (eq) 0-width error. LowerToRTL couldn't handle this operation", "created_at": "2021-01-12T18:56:01Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_2: UInt<0>\r\n    wire tmp19: UInt<1>\r\n    tmp19 <= eq(inp_2, inp_2)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` gives an error:\r\n\r\n```mlir\r\na_top_mod.fir:5:14: error: 'firrtl.eq' op LowerToRTL couldn't handle this operation\r\n    tmp19 <= eq(inp_2, inp_2)\r\n             ^\r\na_top_mod.fir:5:14: note: see current operation: %2 = \"firrtl.eq\"(%1, %1) : (!firrtl.uint<0>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\na_top_mod.fir:5:11: error: 'firrtl.connect' op LowerToRTL couldn't handle this operation\r\n    tmp19 <= eq(inp_2, inp_2)\r\n          ^\r\na_top_mod.fir:5:11: note: see current operation: \"firrtl.connect\"(%tmp19_0, %2) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\na_top_mod.fir:2:3: error: value has an unsupported verilog type '!firrtl.flip<uint<0>>'\r\n  module top_mod :\r\n  ^\r\na_top_mod.fir:2:3: error: value has an unsupported verilog type '!firrtl.uint<0>'\r\n  module top_mod :\r\n  ^\r\na_top_mod.fir:4:5: error: value has an unsupported verilog type '!firrtl.uint<1>'\r\n    wire tmp19: UInt<1>\r\n    ^\r\na_top_mod.fir:5:14: error: value has an unsupported verilog type '!firrtl.uint<1>'\r\n    tmp19 <= eq(inp_2, inp_2)\r\n             ^\r\na_top_mod.fir:2:3: error: 'firrtl.wire' op cannot emit this operation to Verilog\r\n  module top_mod :\r\n  ^\r\na_top_mod.fir:2:3: note: see current operation: %0 = \"firrtl.wire\"() : () -> !firrtl.flip<uint<0>>\r\na_top_mod.fir:2:3: error: 'firrtl.asPassive' op cannot emit this operation to Verilog\r\n  module top_mod :\r\n  ^\r\na_top_mod.fir:2:3: note: see current operation: %1 = \"firrtl.asPassive\"(%0) : (!firrtl.flip<uint<0>>) -> !firrtl.uint<0>\r\na_top_mod.fir:4:5: error: 'firrtl.wire' op cannot emit this operation to Verilog\r\n    wire tmp19: UInt<1>\r\n    ^\r\na_top_mod.fir:4:5: note: see current operation: %tmp19_0 = \"firrtl.wire\"() {name = \"tmp19\"} : () -> !firrtl.uint<1>\r\na_top_mod.fir:5:14: error: 'firrtl.eq' op cannot emit this operation to Verilog\r\n    tmp19 <= eq(inp_2, inp_2)\r\n             ^\r\na_top_mod.fir:5:14: note: see current operation: %2 = \"firrtl.eq\"(%1, %1) : (!firrtl.uint<0>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\na_top_mod.fir:5:11: error: 'firrtl.connect' op cannot emit this operation to Verilog\r\n    tmp19 <= eq(inp_2, inp_2)\r\n          ^\r\na_top_mod.fir:5:11: note: see current operation: \"firrtl.connect\"(%tmp19_0, %2) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n);\r\nendmodule\r\n```", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_2: UInt<0>\r\n    wire tmp19: UInt<1>\r\n    tmp19 <= eq(inp_2, inp_2)", "code_snippet_02": "a_top_mod.fir:5:14: error: 'firrtl.eq' op LowerToRTL couldn't handle this operation\r\n    tmp19 <= eq(inp_2, inp_2)\r\n             ^\r\na_top_mod.fir:5:14: note: see current operation: %2 = \"firrtl.eq\"(%1, %1) : (!firrtl.uint<0>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\na_top_mod.fir:5:11: error: 'firrtl.connect' op LowerToRTL couldn't handle this operation\r\n    tmp19 <= eq(inp_2, inp_2)\r\n          ^\r\na_top_mod.fir:5:11: note: see current operation: \"firrtl.connect\"(%tmp19_0, %2) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\na_top_mod.fir:2:3: error: value has an unsupported verilog type '!firrtl.flip<uint<0>>'\r\n  module top_mod :\r\n  ^\r\na_top_mod.fir:2:3: error: value has an unsupported verilog type '!firrtl.uint<0>'\r\n  module top_mod :\r\n  ^\r\na_top_mod.fir:4:5: error: value has an unsupported verilog type '!firrtl.uint<1>'\r\n    wire tmp19: UInt<1>\r\n    ^\r\na_top_mod.fir:5:14: error: value has an unsupported verilog type '!firrtl.uint<1>'\r\n    tmp19 <= eq(inp_2, inp_2)\r\n             ^\r\na_top_mod.fir:2:3: error: 'firrtl.wire' op cannot emit this operation to Verilog\r\n  module top_mod :\r\n  ^\r\na_top_mod.fir:2:3: note: see current operation: %0 = \"firrtl.wire\"() : () -> !firrtl.flip<uint<0>>\r\na_top_mod.fir:2:3: error: 'firrtl.asPassive' op cannot emit this operation to Verilog\r\n  module top_mod :\r\n  ^\r\na_top_mod.fir:2:3: note: see current operation: %1 = \"firrtl.asPassive\"(%0) : (!firrtl.flip<uint<0>>) -> !firrtl.uint<0>\r\na_top_mod.fir:4:5: error: 'firrtl.wire' op cannot emit this operation to Verilog\r\n    wire tmp19: UInt<1>\r\n    ^\r\na_top_mod.fir:4:5: note: see current operation: %tmp19_0 = \"firrtl.wire\"() {name = \"tmp19\"} : () -> !firrtl.uint<1>\r\na_top_mod.fir:5:14: error: 'firrtl.eq' op cannot emit this operation to Verilog\r\n    tmp19 <= eq(inp_2, inp_2)\r\n             ^\r\na_top_mod.fir:5:14: note: see current operation: %2 = \"firrtl.eq\"(%1, %1) : (!firrtl.uint<0>, !firrtl.uint<0>) -> !firrtl.uint<1>\r\na_top_mod.fir:5:11: error: 'firrtl.connect' op cannot emit this operation to Verilog\r\n    tmp19 <= eq(inp_2, inp_2)\r\n          ^\r\na_top_mod.fir:5:11: note: see current operation: \"firrtl.connect\"(%tmp19_0, %2) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()", "code_snippet_03": "module top_mod(\r\n);\r\nendmodule"}, {"number": 432, "title": "[FIRRTL] (tail) parameter 0 (core dump)", "created_at": "2021-01-12T02:25:49Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp8: UInt<10>\r\n    tmp8 <= tail(SInt<10>(130), 0)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` gives an error:\r\n\r\n```mlir\r\nfirtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:859: llvm::APInt llvm::APInt::trunc(unsigned int) const: Assertion `width < BitWidth && \"Invalid APInt Truncate request\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v\r\n #0 0x00000000004c16e3 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004c179a PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004bf7a0 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004c1136 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f901dc491d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007f901d708ae5 raise (/lib64/libc.so.6+0x3dae5)\r\n #6 0x00007f901d6f1864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f901d6f1749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f901d701016 (/lib64/libc.so.6+0x36016)\r\n #9 0x00000000004e2e0a llvm::APInt::trunc(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:860:3\r\n#10 0x0000000000809e2f circt::firrtl::BitsPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/OpFolds.cpp:232:76\r\n#11 0x0000000000785d6f mlir::LogicalResult mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::BitsPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1699:53\r\n#12 0x00000000006ca37c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3\r\n#13 0x00000000006c3ae2 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30\r\n#14 0x000000000088a72b mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#15 0x000000000088a08a mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#16 0x000000000086e607 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#17 0x000000000086e932 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#18 0x000000000086e81e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#19 0x00000000007378b2 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3\r\n#20 0x0000000000958c19 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36\r\n#21 0x0000000000958e45 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15\r\n#22 0x000000000095ad5c mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:854:74\r\n#23 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13\r\n#24 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13\r\n#25 0x00007f901d6f3152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#26 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [9:0] tmp8\r\n);\r\n  assign tmp8 = 10'h82;\r\nendmodule\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    output tmp8: UInt<10>\r\n    tmp8 <= tail(SInt<10>(130), 0)", "code_snippet_02": "firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:859: llvm::APInt llvm::APInt::trunc(unsigned int) const: Assertion `width < BitWidth && \"Invalid APInt Truncate request\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool a_top_mod.fir --lower-to-rtl --verilog -o=a_top_mod_new.v\r\n #0 0x00000000004c16e3 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:565:22\r\n #1 0x00000000004c179a PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:632:1\r\n #2 0x00000000004bf7a0 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004c1136 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:407:1\r\n #4 0x00007f901dc491d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007f901d708ae5 raise (/lib64/libc.so.6+0x3dae5)\r\n #6 0x00007f901d6f1864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007f901d6f1749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007f901d701016 (/lib64/libc.so.6+0x36016)\r\n #9 0x00000000004e2e0a llvm::APInt::trunc(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:860:3\r\n#10 0x0000000000809e2f circt::firrtl::BitsPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/OpFolds.cpp:232:76\r\n#11 0x0000000000785d6f mlir::LogicalResult mlir::Op<circt::firrtl::BitsPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::OneTypedResult<circt::firrtl::UIntType>::Impl, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::BitsPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1699:53\r\n#12 0x00000000006ca37c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:140:3\r\n#13 0x00000000006c3ae2 mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:581:30\r\n#14 0x000000000088a72b mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:198:13\r\n#15 0x000000000088a08a mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:101:13\r\n#16 0x000000000086e607 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#17 0x000000000086e932 mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#18 0x000000000086e81e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#19 0x00000000007378b2 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:34:3\r\n#20 0x0000000000958c19 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:400:36\r\n#21 0x0000000000958e45 mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:441:15\r\n#22 0x000000000095ad5c mlir::PassManager::run(mlir::Operation*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:854:74\r\n#23 0x0000000000409601 processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:141:13\r\n#24 0x0000000000409ac0 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:195:13\r\n#25 0x00007f901d6f3152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#26 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0", "code_snippet_03": "module top_mod(\r\n  output [9:0] tmp8\r\n);\r\n  assign tmp8 = 10'h82;\r\nendmodule"}, {"number": 431, "title": "[FIRRTL] (tail) 0-width result ", "created_at": "2021-01-12T01:16:23Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp9: UInt<0>\r\n    tmp9 <= tail(UInt<23>(42), 23)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` gives an error:\r\n\r\n```mlir\r\na_top_mod.fir:4:13: error: amount must be less than operand width\r\n    tmp9 <= tail(UInt<23>(42), 23)\r\n            ^\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n);\r\nendmodule\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    output tmp9: UInt<0>\r\n    tmp9 <= tail(UInt<23>(42), 23)", "code_snippet_02": "a_top_mod.fir:4:13: error: amount must be less than operand width\r\n    tmp9 <= tail(UInt<23>(42), 23)\r\n            ^", "code_snippet_03": "module top_mod(\r\n);\r\nendmodule"}, {"number": 430, "title": "[FIRRTL] (head) parameter 0 error", "created_at": "2021-01-12T00:43:20Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp27: UInt<28>\r\n    tmp27 <= head(UInt<28>(42), 0)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` gives an error:\r\n\r\n```mlir\r\na_top_mod.fir:4:14: error: operand must have integer type and amount must be >= 1\r\n    tmp27 <= head(UInt<28>(42), 0)\r\n             ^\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [27:0] tmp27\r\n);\r\n  assign tmp27 = 28'h0;\r\nendmodule\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    output tmp27: UInt<28>\r\n    tmp27 <= head(UInt<28>(42), 0)", "code_snippet_02": "a_top_mod.fir:4:14: error: operand must have integer type and amount must be >= 1\r\n    tmp27 <= head(UInt<28>(42), 0)\r\n             ^", "code_snippet_03": "module top_mod(\r\n  output [27:0] tmp27\r\n);\r\n  assign tmp27 = 28'h0;\r\nendmodule"}, {"number": 429, "title": "[FIRRTL] (div) 0-width error", "created_at": "2021-01-12T00:35:47Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_5: UInt<0>\r\n    output tmp17: UInt<0>\r\n    tmp17 <= div(inp_5, UInt<5>(5))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` gives an error:\r\n\r\n```mlir\r\na_top_mod.fir:5:11: error: LowerToRTL couldn't handle this operation\r\n    tmp17 <= div(inp_5, UInt<5>(5))\r\n          ^\r\na_top_mod.fir:5:11: note: see current operation: \"firrtl.connect\"(%2, %5) : (!firrtl.flip<uint<0>>, !firrtl.uint<0>) -> ()\r\na_top_mod.fir:5:14: error: 'rtl.extract' op result #0 must be an integer bitvector of one or more bits, but got 'i0'\r\n    tmp17 <= div(inp_5, UInt<5>(5))\r\n             ^\r\na_top_mod.fir:5:14: note: see current operation: %4 = \"rtl.extract\"(%3) {lowBit = 0 : i32} : (i5) -> i0\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n);\r\nendmodule\r\n```", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_5: UInt<0>\r\n    output tmp17: UInt<0>\r\n    tmp17 <= div(inp_5, UInt<5>(5))", "code_snippet_02": "a_top_mod.fir:5:11: error: LowerToRTL couldn't handle this operation\r\n    tmp17 <= div(inp_5, UInt<5>(5))\r\n          ^\r\na_top_mod.fir:5:11: note: see current operation: \"firrtl.connect\"(%2, %5) : (!firrtl.flip<uint<0>>, !firrtl.uint<0>) -> ()\r\na_top_mod.fir:5:14: error: 'rtl.extract' op result #0 must be an integer bitvector of one or more bits, but got 'i0'\r\n    tmp17 <= div(inp_5, UInt<5>(5))\r\n             ^\r\na_top_mod.fir:5:14: note: see current operation: %4 = \"rtl.extract\"(%3) {lowBit = 0 : i32} : (i5) -> i0", "code_snippet_03": "module top_mod(\r\n);\r\nendmodule"}, {"number": 428, "title": "[FIRRTL] (dshl) error", "created_at": "2021-01-12T00:25:06Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_1: UInt<1>\r\n    input inp_2: SInt<5>\r\n    output tmp9: SInt<3>\r\n    tmp9 <= dshl(inp_2, inp_1)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` gives an error:\r\n\r\n```mlir\r\na_top_mod.fir:6:10: error: destination width 3 is not greater than or equal to source width 6\r\n    tmp9 <= dshl(inp_2, inp_1)\r\n         ^\r\na_top_mod.fir:6:10: note: see current operation: \"firrtl.connect\"(%tmp9, %0) : (!firrtl.flip<sint<3>>, !firrtl.sint<6>) -> ()\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input        inp_1,\r\n  input  [4:0] inp_2,\r\n  output [2:0] tmp9\r\n);\r\n  wire [5:0] _GEN_0 = {{1{inp_2[4]}},inp_2};\r\n  wire [5:0] _GEN_1 = $signed(_GEN_0) << inp_1;\r\n  assign tmp9 = _GEN_1[2:0];\r\nendmodule\r\n```", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_1: UInt<1>\r\n    input inp_2: SInt<5>\r\n    output tmp9: SInt<3>\r\n    tmp9 <= dshl(inp_2, inp_1)", "code_snippet_02": "a_top_mod.fir:6:10: error: destination width 3 is not greater than or equal to source width 6\r\n    tmp9 <= dshl(inp_2, inp_1)\r\n         ^\r\na_top_mod.fir:6:10: note: see current operation: \"firrtl.connect\"(%tmp9, %0) : (!firrtl.flip<sint<3>>, !firrtl.sint<6>) -> ()", "code_snippet_03": "module top_mod(\r\n  input        inp_1,\r\n  input  [4:0] inp_2,\r\n  output [2:0] tmp9\r\n);\r\n  wire [5:0] _GEN_0 = {{1{inp_2[4]}},inp_2};\r\n  wire [5:0] _GEN_1 = $signed(_GEN_0) << inp_1;\r\n  assign tmp9 = _GEN_1[2:0];\r\nendmodule"}, {"number": 426, "title": "[FIRRTL] MLIR parser crashes on zero bit constants", "created_at": "2021-01-10T19:03:15Z", "state": "closed", "labels": "bug, FIRRTL", "body": "This in an mlir file crashes the mlir parser:\r\n```\r\n     %c0_ui0 = firrtl.constant(0 : ui0) : !firrtl.uint<0>\r\n```\r\n\r\n@seldridge are zero bit constants supported by SFC?  If so, I'll fix this to be allowed.  If not, I'll fix them to be rejected.", "code_snippet_01": "%c0_ui0 = firrtl.constant(0 : ui0) : !firrtl.uint<0>"}, {"number": 423, "title": "[FIRRTL] Relax or Promote Connect to Partial Connect Semantics", "created_at": "2021-01-09T21:55:21Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Chisel currently emits connects between a wider source and a narrower sink. The Scala FIRRTL Compiler accepts these and truncates the source (which is incorrect connect semantics, but correct partial connect semantics). This results in circuits that come out of Chisel which CIRCT won't accept.\r\n\r\nEither:\r\n\r\n1. We relax the connection verification checks \r\n2. We promote connects to partial connects if we see this during parsing\r\n\r\nExample circuit:\r\n\r\n```\r\ncircuit Foo :\r\n  module Foo :\r\n    input a: UInt<2>\r\n    output b: UInt<1>\r\n\r\n    b <= a\r\n```\r\n\r\nThe SFC produces:\r\n\r\n```verilog\r\nmodule Foo(\r\n  input  [1:0] a,\r\n  output       b\r\n);\r\n  assign b = a[0];\r\nendmodule\r\n```\r\n\r\nCIRCT gives us:\r\n\r\n```bash\r\nfirtool Foo.fir\r\n# Foo.fir:6:7: error: destination width 1 is not greater than or equal to source width 2\r\n#    b <= a\r\n#      ^\r\n# Foo.fir:6:7: note: see current operation: \"firrtl.connect\"(%b, %a) : (!firrtl.flip<uint<1>>, !firrtl.uint<2>) -> ()\r\n```", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input a: UInt<2>\r\n    output b: UInt<1>\r\n\r\n    b <= a", "code_snippet_02": "module Foo(\r\n  input  [1:0] a,\r\n  output       b\r\n);\r\n  assign b = a[0];\r\nendmodule", "code_snippet_03": "firtool Foo.fir\r\n# Foo.fir:6:7: error: destination width 1 is not greater than or equal to source width 2\r\n#    b <= a\r\n#      ^\r\n# Foo.fir:6:7: note: see current operation: \"firrtl.connect\"(%b, %a) : (!firrtl.flip<uint<1>>, !firrtl.uint<2>) -> ()"}, {"number": 419, "title": "[FIRRTL] Extend lower types with partial connect support", "created_at": "2021-01-08T16:31:35Z", "state": "closed", "labels": "bug, enhancement, FIRRTL", "body": "Add support to FIRRTL type lowering to work with partial connects `<-`. \r\n\r\nThis is both used by \"Chisel 2 compatibility mode\" and it's been discussed that Chisel should emit these instead of normal connects (`<=`) for the reason that Chisel and the Scala FIRRTL Compiler (SFC) incorrectly truncate `<=` (which is supposed to only be a feature of `<-`).\r\n\r\nCurrently, `firtool` will throw a stack trace if you have any partial connects.\r\n\r\nExample input that currently fails:\r\n\r\n```scala\r\ncircuit Foo:\r\n  module Foo:\r\n    input a: { a: UInt<1>, b: UInt<1> }\r\n    output b: { a: UInt<1> }\r\n\r\n    b <- a\r\n```\r\n\r\nWith the SFC, you get the following lowered circuit:\r\n\r\n```scala\r\ncircuit Foo :\r\n  module Foo :\r\n    input a_a : UInt<1>\r\n    input a_b : UInt<1>\r\n    output b_a : UInt<1>\r\n\r\n    b_a <= a_a\r\n```\r\n\r\nCurrently CIRCT will crash with this.", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input a: { a: UInt<1>, b: UInt<1> }\r\n    output b: { a: UInt<1> }\r\n\r\n    b <- a", "code_snippet_02": "circuit Foo :\r\n  module Foo :\r\n    input a_a : UInt<1>\r\n    input a_b : UInt<1>\r\n    output b_a : UInt<1>\r\n\r\n    b_a <= a_a"}, {"number": 418, "title": "[FIRRTL] Stack trace on multi-argument not operand", "created_at": "2021-01-08T16:21:56Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following circuit causes a stack trace because it has an invalid multi-argument `not`. The checking for `UnaryPrimOp` doesn't seem to be working like with `BinaryPrimOp`. My guess is that the default checks generated by ODS are running before the check we have for `UnaryPrimOp`'s `getResultType` (or this isn't running).\r\n\r\nMinimal circuit:\r\n```\r\ncircuit Foo:\r\n  module Foo:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    b <= not(a, a)\r\n```\r\n\r\nRunning with:\r\n```bash\r\nfirtool Foo.fir\r\n```\r\n\r\nYou get:\r\n```\r\nAssertion failed: (operands.size() == 1u && \"mismatched number of parameters\"), function build, file include/circt/Dialect/FIRRTL/FIRRTL.cpp.inc, line 8390.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: firtool Foo.fir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x000000010c57fbad llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x000000010c58015b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x000000010c57ddfb llvm::sys::RunSignalHandlers() + 123\r\n3  firtool                  0x000000010c58248d SignalHandler(int) + 205\r\n4  libsystem_platform.dylib 0x00007fff20394d7d _sigtramp + 29\r\n5  firtool                  0x000000010ce75ba0 llvm::ColorCategory + 212064\r\n6  libsystem_c.dylib        0x00007fff202a3720 abort + 120\r\n7  libsystem_c.dylib        0x00007fff202a29d6 err + 0\r\n8  firtool                  0x000000010cb0b1e2 circt::firrtl::NotPrimOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::TypeRange, mlir::ValueRange, llvm::ArrayRef<std::__1::pair<mlir::Identifier, mlir::Attribute> >) + 130\r\n9  firtool                  0x000000010c625833 circt::firrtl::NotPrimOp mlir::OpBuilder::create<circt::firrtl::NotPrimOp, circt::firrtl::FIRRTLType&, mlir::ValueRange, mlir::NamedAttrList&>(mlir::Location, circt::firrtl::FIRRTLType&, mlir::ValueRange&&, mlir::NamedAttrList&) + 499\r\n10 firtool                  0x000000010c61ce2b (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) + 11051\r\n11 firtool                  0x000000010c60f720 (anonymous namespace)::FIRStmtParser::parseExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&) + 144\r\n12 firtool                  0x000000010c60fd7e (anonymous namespace)::FIRStmtParser::parseLeadingExpStmt(mlir::Value, llvm::SmallVectorImpl<mlir::Operation*>&) + 1214\r\n13 firtool                  0x000000010c60c108 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) + 600\r\n14 firtool                  0x000000010c604be9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) + 377\r\n15 firtool                  0x000000010c5ff918 (anonymous namespace)::FIRModuleParser::parseModule(unsigned int) + 1320\r\n16 firtool                  0x000000010c5fe386 (anonymous namespace)::FIRCircuitParser::parseCircuit() + 1526\r\n17 firtool                  0x000000010c5fdbc5 circt::firrtl::importFIRRTL(llvm::SourceMgr&, mlir::MLIRContext*, circt::firrtl::FIRParserOptions) + 325\r\n18 firtool                  0x000000010c3f49a5 processBuffer(std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) + 389\r\n19 firtool                  0x000000010c3f44a1 main + 897\r\n20 libdyld.dylib            0x00007fff2036b621 start + 1\r\n21 libdyld.dylib            0x0000000000000002 start + 18446603339975707106\r\nzsh: abort      firtool Foo.fir\r\n```\r\n\r\nConversely, if you run this with the following circuit:\r\n\r\n```\r\ncircuit Foo:\r\n  module Foo:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n    output c: UInt<1>\r\n\r\n    c <= and(a, a, a)\r\n```\r\n\r\nYou get the saner:\r\n\r\n```\r\nFoo.fir:7:10: error: operation requires two operands and no constants\r\n    c <= and(a, a, a)\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    b <= not(a, a)", "code_snippet_02": "firtool Foo.fir", "code_snippet_03": "Assertion failed: (operands.size() == 1u && \"mismatched number of parameters\"), function build, file include/circt/Dialect/FIRRTL/FIRRTL.cpp.inc, line 8390.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: firtool Foo.fir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x000000010c57fbad llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x000000010c58015b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x000000010c57ddfb llvm::sys::RunSignalHandlers() + 123\r\n3  firtool                  0x000000010c58248d SignalHandler(int) + 205\r\n4  libsystem_platform.dylib 0x00007fff20394d7d _sigtramp + 29\r\n5  firtool                  0x000000010ce75ba0 llvm::ColorCategory + 212064\r\n6  libsystem_c.dylib        0x00007fff202a3720 abort + 120\r\n7  libsystem_c.dylib        0x00007fff202a29d6 err + 0\r\n8  firtool                  0x000000010cb0b1e2 circt::firrtl::NotPrimOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::TypeRange, mlir::ValueRange, llvm::ArrayRef<std::__1::pair<mlir::Identifier, mlir::Attribute> >) + 130\r\n9  firtool                  0x000000010c625833 circt::firrtl::NotPrimOp mlir::OpBuilder::create<circt::firrtl::NotPrimOp, circt::firrtl::FIRRTLType&, mlir::ValueRange, mlir::NamedAttrList&>(mlir::Location, circt::firrtl::FIRRTLType&, mlir::ValueRange&&, mlir::NamedAttrList&) + 499\r\n10 firtool                  0x000000010c61ce2b (anonymous namespace)::FIRStmtParser::parsePrimExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&) + 11051\r\n11 firtool                  0x000000010c60f720 (anonymous namespace)::FIRStmtParser::parseExp(mlir::Value&, llvm::SmallVectorImpl<mlir::Operation*>&, llvm::Twine const&) + 144\r\n12 firtool                  0x000000010c60fd7e (anonymous namespace)::FIRStmtParser::parseLeadingExpStmt(mlir::Value, llvm::SmallVectorImpl<mlir::Operation*>&) + 1214\r\n13 firtool                  0x000000010c60c108 (anonymous namespace)::FIRStmtParser::parseSimpleStmt(unsigned int) + 600\r\n14 firtool                  0x000000010c604be9 (anonymous namespace)::FIRStmtParser::parseSimpleStmtBlock(unsigned int) + 377\r\n15 firtool                  0x000000010c5ff918 (anonymous namespace)::FIRModuleParser::parseModule(unsigned int) + 1320\r\n16 firtool                  0x000000010c5fe386 (anonymous namespace)::FIRCircuitParser::parseCircuit() + 1526\r\n17 firtool                  0x000000010c5fdbc5 circt::firrtl::importFIRRTL(llvm::SourceMgr&, mlir::MLIRContext*, circt::firrtl::FIRParserOptions) + 325\r\n18 firtool                  0x000000010c3f49a5 processBuffer(std::__1::unique_ptr<llvm::MemoryBuffer, std::__1::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) + 389\r\n19 firtool                  0x000000010c3f44a1 main + 897\r\n20 libdyld.dylib            0x00007fff2036b621 start + 1\r\n21 libdyld.dylib            0x0000000000000002 start + 18446603339975707106\r\nzsh: abort      firtool Foo.fir", "code_snippet_04": "circuit Foo:\r\n  module Foo:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n    output c: UInt<1>\r\n\r\n    c <= and(a, a, a)", "code_snippet_05": "Foo.fir:7:10: error: operation requires two operands and no constants\r\n    c <= and(a, a, a)"}, {"number": 407, "title": "[ExportVerilog] Instance name collisions", "created_at": "2021-01-06T01:47:55Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "https://github.com/llvm/circt/blob/27155e4d1740dc44bd596a0a04ca961b2136d014/lib/Translation/ExportVerilog/ExportVerilog.cpp#L1494\r\n\r\nExportVerilog just spits out instance names. If you've got two instances with the same name (as I'd imagine is frequent in generated code), they will conflict in the output. Those names may also conflict with other identifiers, such as wires and ports.\r\n\r\nWe should at least error out in the case where an instanceName conflicts with another idenifier. I think we should go further and automatically rename the instance."}, {"number": 395, "title": "firrtl.node type verification", "created_at": "2021-01-04T23:27:25Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following now fails\r\n\r\n```\r\nmodule  {\r\n  firrtl.circuit \"foo\" {\r\n    firrtl.extmodule @bar(%baz: !firrtl.uint<1>)\r\n    firrtl.module @foo() {\r\n      %fetch = firrtl.instance @bar {name = \"fetch\"} : !firrtl.bundle<baz: flip<uint<1>>>\r\n      %1454 = firrtl.subfield %fetch(\"baz\") : (!firrtl.bundle<baz: flip<uint<1>>>) -> !firrtl.flip<uint<1>>\r\n      %hits_1_7 = firrtl.node %1454 {name = \"hits_1_7\"} : !firrtl.flip<uint<1>>\r\n    }\r\n  }\r\n}\r\n```\r\n", "code_snippet_01": "module  {\r\n  firrtl.circuit \"foo\" {\r\n    firrtl.extmodule @bar(%baz: !firrtl.uint<1>)\r\n    firrtl.module @foo() {\r\n      %fetch = firrtl.instance @bar {name = \"fetch\"} : !firrtl.bundle<baz: flip<uint<1>>>\r\n      %1454 = firrtl.subfield %fetch(\"baz\") : (!firrtl.bundle<baz: flip<uint<1>>>) -> !firrtl.flip<uint<1>>\r\n      %hits_1_7 = firrtl.node %1454 {name = \"hits_1_7\"} : !firrtl.flip<uint<1>>\r\n    }\r\n  }\r\n}"}, {"number": 394, "title": "[FIRRTL] (add / mux) missmatch", "created_at": "2021-01-04T21:48:42Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_3: SInt<16>\r\n    input inp_6: UInt<13>\r\n    output tmp13: SInt<14>\r\n    wire tmp11: UInt<14>\r\n    tmp11 <= add(inp_6, UInt<12>(1))\r\n    tmp13 <= mux(tail(asUInt(inp_3), 15), asSInt(tmp11), SInt<13>(1))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [15:0] inp_3,\r\n  input  [12:0] inp_6,\r\n  output [13:0] tmp13);\r\n\r\n  wire [13:0] tmp11;\t// a_top_mod.fir:6:5\r\n\r\n  assign tmp11 = {{1'd0}, inp_6} + 14'h1;\t// a_top_mod.fir:7:{11,14}\r\n  assign tmp13 = inp_3[0] ? tmp11 : 14'h1;\t// a_top_mod.fir:2:3, :8:{14,18,43}\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [15:0] inp_3,\r\n  input  [12:0] inp_6,\r\n  output [13:0] tmp13\r\n);\r\n  wire [15:0] _GEN_0 = inp_3;\r\n  assign tmp13 = _GEN_0[0] ? $signed(inp_6 + 13'h1) : $signed(14'sh1);\r\nendmodule\r\n```\r\n\r\nYosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:\r\n\r\n```\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_3: SInt<16>\r\n    input inp_6: UInt<13>\r\n    output tmp13: SInt<14>\r\n    wire tmp11: UInt<14>\r\n    tmp11 <= add(inp_6, UInt<12>(1))\r\n    tmp13 <= mux(tail(asUInt(inp_3), 15), asSInt(tmp11), SInt<13>(1))", "code_snippet_02": "module top_mod(\r\n  input  [15:0] inp_3,\r\n  input  [12:0] inp_6,\r\n  output [13:0] tmp13);\r\n\r\n  wire [13:0] tmp11;\t// a_top_mod.fir:6:5\r\n\r\n  assign tmp11 = {{1'd0}, inp_6} + 14'h1;\t// a_top_mod.fir:7:{11,14}\r\n  assign tmp13 = inp_3[0] ? tmp11 : 14'h1;\t// a_top_mod.fir:2:3, :8:{14,18,43}\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [15:0] inp_3,\r\n  input  [12:0] inp_6,\r\n  output [13:0] tmp13\r\n);\r\n  wire [15:0] _GEN_0 = inp_3;\r\n  assign tmp13 = _GEN_0[0] ? $signed(inp_6 + 13'h1) : $signed(14'sh1);\r\nendmodule", "code_snippet_04": "ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 388, "title": "[FIRRTL] Verify that FIRRTL nodes are passive", "created_at": "2021-01-02T03:23:37Z", "state": "closed", "labels": "bug, good first issue, FIRRTL", "body": "Nodes need to be passive, but the FIRRTL dialect allows them to not be. Add a verifier that asserts passivity of nodes.\r\n\r\nE.g., the following should fail, but doesn't:\r\n\r\n```\r\ncircuit Foo :\r\n  module Foo :\r\n    input a: { a: UInt<1>, flip b: UInt<1> }\r\n    output b: { a: UInt<1>, flip b: UInt<1> }\r\n\r\n    node x = a\r\n\r\n    b <= x\r\n```\r\n\r\nThe Scala FIRRTL Compiler returns:\r\n\r\n```bash\r\nfirrtl -i Foo.fir \r\n# Exception in thread \"main\" firrtl.passes.CheckTypes$NodePassiveType: : [module Foo]  Node must be a passive type.\r\n```", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input a: { a: UInt<1>, flip b: UInt<1> }\r\n    output b: { a: UInt<1>, flip b: UInt<1> }\r\n\r\n    node x = a\r\n\r\n    b <= x", "code_snippet_02": "firrtl -i Foo.fir \r\n# Exception in thread \"main\" firrtl.passes.CheckTypes$NodePassiveType: : [module Foo]  Node must be a passive type."}, {"number": 373, "title": "[FIRRTL] LowerToRTL issues with instance inputs", "created_at": "2020-12-28T18:15:47Z", "state": "closed", "labels": "bug, FIRRTL", "body": "\r\n[This patch](https://github.com/llvm/circt/commit/6752760bb93835f3e46b019c7dfb2007fd7c17a8) introduced logic into LowerToRTLModule to avoid making wires for inputs all inputs.  Unfortunately, this breaks the \"dag\" property of FIRRTL.  While this is technically ok (the output of the pass is an RTL module which allows cycles) the logic in LowerToRTL expects non-cycles, because assignments to inputs happen after the instance and can have arbitrary logic.\r\n\r\nThis breaks some larger testcases, here is a reduced testcase:\r\n\r\n```\r\n rtl.module @instance_ooo(%arg0: i2, %arg1: i2) {\r\n   %arg0c = firrtl.stdIntCast %arg0 : (i2) -> !firrtl.uint<2>\r\n   %arg1c = firrtl.stdIntCast %arg1 : (i2) -> !firrtl.uint<2>\r\n\r\n   %b = firrtl.stdIntCast %a : (!firrtl.uint<1>) -> i1\r\n   rtl.instance \"barmobile\" @bar(%b)  : (i1) -> ()\r\n   %a = firrtl.eq %arg0c, %arg1c : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>\r\n }\r\n```\r\n\r\nI plan to work on this today, but if anyone is blocked, I can back out the problematic part of the patch, just lemme know.\r\n", "code_snippet_01": "rtl.module @instance_ooo(%arg0: i2, %arg1: i2) {\r\n   %arg0c = firrtl.stdIntCast %arg0 : (i2) -> !firrtl.uint<2>\r\n   %arg1c = firrtl.stdIntCast %arg1 : (i2) -> !firrtl.uint<2>\r\n\r\n   %b = firrtl.stdIntCast %a : (!firrtl.uint<1>) -> i1\r\n   rtl.instance \"barmobile\" @bar(%b)  : (i1) -> ()\r\n   %a = firrtl.eq %arg0c, %arg1c : (!firrtl.uint<2>, !firrtl.uint<2>) -> !firrtl.uint<1>\r\n }"}, {"number": 368, "title": "[FIRRTL] (eq) with constant mismatch", "created_at": "2020-12-26T06:20:54Z", "state": "closed", "labels": "bug, FIRRTL", "body": "## 1) The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_1: UInt<15>\r\n    input inp_2: UInt<15>\r\n    output tmp9: UInt<1>\r\n    wire tmp4: UInt<1>\r\n    tmp4 <= eq(inp_2, inp_1)\r\n    tmp9 <= eq(tmp4, UInt<2>(3))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [14:0] inp_1, inp_2,\r\n  output        tmp9);\r\n\r\n  wire tmp4;\t// a_top_mod.fir:6:5\r\n\r\n  assign tmp4 = inp_2 == inp_1;\t// a_top_mod.fir:7:{10,13}\r\n  assign tmp9 = tmp4;\t// a_top_mod.fir:2:3\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [14:0] inp_1,\r\n  input  [14:0] inp_2,\r\n  output        tmp9\r\n);\r\n  wire  tmp4 = inp_2 == inp_1;\r\n  wire [1:0] _GEN_0 = {{1'd0}, tmp4};\r\n  assign tmp9 = _GEN_0 == 2'h3;\r\nendmodule\r\n```\r\n\r\nYosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:\r\n\r\n```\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n\r\n## 2) Even simpler FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp15: UInt<1>\r\n    tmp15 <= eq(UInt<1>(1), UInt<3>(7))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output tmp15);\r\n\r\n  assign tmp15 = 1'h1;\t// a_top_mod.fir:2:3, :4:17\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output  tmp15\r\n);\r\n  assign tmp15 = 1'h0;\r\nendmodule\r\n```\r\n\r\nYosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:\r\n\r\n```\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_1: UInt<15>\r\n    input inp_2: UInt<15>\r\n    output tmp9: UInt<1>\r\n    wire tmp4: UInt<1>\r\n    tmp4 <= eq(inp_2, inp_1)\r\n    tmp9 <= eq(tmp4, UInt<2>(3))", "code_snippet_02": "module top_mod(\r\n  input  [14:0] inp_1, inp_2,\r\n  output        tmp9);\r\n\r\n  wire tmp4;\t// a_top_mod.fir:6:5\r\n\r\n  assign tmp4 = inp_2 == inp_1;\t// a_top_mod.fir:7:{10,13}\r\n  assign tmp9 = tmp4;\t// a_top_mod.fir:2:3\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [14:0] inp_1,\r\n  input  [14:0] inp_2,\r\n  output        tmp9\r\n);\r\n  wire  tmp4 = inp_2 == inp_1;\r\n  wire [1:0] _GEN_0 = {{1'd0}, tmp4};\r\n  assign tmp9 = _GEN_0 == 2'h3;\r\nendmodule", "code_snippet_04": "ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.", "code_snippet_05": "circuit top_mod :\r\n  module top_mod :\r\n    output tmp15: UInt<1>\r\n    tmp15 <= eq(UInt<1>(1), UInt<3>(7))", "code_snippet_06": "module top_mod(\r\n  output tmp15);\r\n\r\n  assign tmp15 = 1'h1;\t// a_top_mod.fir:2:3, :4:17\r\nendmodule", "code_snippet_07": "module top_mod(\r\n  output  tmp15\r\n);\r\n  assign tmp15 = 1'h0;\r\nendmodule", "code_snippet_08": "ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 367, "title": "[FIRRTL] (dshr) unsign mismatch", "created_at": "2020-12-26T01:24:49Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_4: SInt<6>\r\n    input tmp7: UInt<1>\r\n    output tmp13: UInt<1>\r\n    tmp13 <= dshr(tmp7, asUInt(inp_4))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [5:0] inp_4,\r\n  input        tmp7,\r\n  output       tmp13);\r\n\r\n  assign tmp13 = tmp7 >> inp_4[0];\t// a_top_mod.fir:2:3, :6:14\r\nendmodule\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/511872/103143899-872fcd00-46d4-11eb-9ecd-c4bff7d0ba26.png)\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [5:0] inp_4,\r\n  input        tmp7,\r\n  output       tmp13\r\n);\r\n  assign tmp13 = tmp7 >> inp_4;\r\nendmodule\r\n```\r\n\r\nYosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:\r\n\r\n```\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_4: SInt<6>\r\n    input tmp7: UInt<1>\r\n    output tmp13: UInt<1>\r\n    tmp13 <= dshr(tmp7, asUInt(inp_4))", "code_snippet_02": "module top_mod(\r\n  input  [5:0] inp_4,\r\n  input        tmp7,\r\n  output       tmp13);\r\n\r\n  assign tmp13 = tmp7 >> inp_4[0];\t// a_top_mod.fir:2:3, :6:14\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [5:0] inp_4,\r\n  input        tmp7,\r\n  output       tmp13\r\n);\r\n  assign tmp13 = tmp7 >> inp_4;\r\nendmodule", "code_snippet_04": "ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 366, "title": "[FIRRTL] (dshr) signed mismatch", "created_at": "2020-12-26T01:13:45Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_7: UInt<10>\r\n    output tmp12: SInt<5>\r\n    tmp12 <= dshr(SInt<5>(6), inp_7)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [9:0] inp_7,\r\n  output [4:0] tmp12);\r\n\r\n  assign tmp12 = $signed(5'h6) >>> $signed(inp_7[4:0]);\t// a_top_mod.fir:3:3, :6:{14,19}\r\nendmodule\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/511872/103143899-872fcd00-46d4-11eb-9ecd-c4bff7d0ba26.png)\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [9:0] inp_7,\r\n  output [4:0] tmp12\r\n);\r\n  assign tmp12 = 5'sh6 >>> inp_7;\r\nendmodule\r\n```\r\n\r\nYosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:\r\n\r\n```\r\nERROR: Found 3 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_7: UInt<10>\r\n    output tmp12: SInt<5>\r\n    tmp12 <= dshr(SInt<5>(6), inp_7)", "code_snippet_02": "module top_mod(\r\n  input  [9:0] inp_7,\r\n  output [4:0] tmp12);\r\n\r\n  assign tmp12 = $signed(5'h6) >>> $signed(inp_7[4:0]);\t// a_top_mod.fir:3:3, :6:{14,19}\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [9:0] inp_7,\r\n  output [4:0] tmp12\r\n);\r\n  assign tmp12 = 5'sh6 >>> inp_7;\r\nendmodule", "code_snippet_04": "ERROR: Found 3 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 365, "title": "[FIRRTL] (rem) mismatch", "created_at": "2020-12-25T23:48:04Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp9: SInt<1>\r\n    wire tmp4: UInt<1>\r\n    tmp4 <= UInt<1>(0)\r\n    tmp9 <= rem(SInt<22>(1), asSInt(tmp4))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output tmp9);\r\n\r\n  wire tmp4;\t// top_mod.fir:4:5\r\n\r\n  assign tmp4 = 1'h0;\t// top_mod.fir:5:{10,13}\r\n  wire [21:0] _T = $signed(22'h1) % $signed({22{tmp4}});\t// top_mod.fir:6:{13,17,30}\r\n  assign tmp9 = _T[0];\t// top_mod.fir:2:3, :6:13\r\nendmodule\r\n```\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output  tmp9\r\n);\r\n  wire [21:0] _GEN_0 = 22'sh1 % 22'sh0;\r\n  assign tmp9 = _GEN_0[0];\r\nendmodule\r\n```\r\n\r\nYosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:\r\n\r\n```\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\nIs it a bug in Yosys?", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    output tmp9: SInt<1>\r\n    wire tmp4: UInt<1>\r\n    tmp4 <= UInt<1>(0)\r\n    tmp9 <= rem(SInt<22>(1), asSInt(tmp4))", "code_snippet_02": "module top_mod(\r\n  output tmp9);\r\n\r\n  wire tmp4;\t// top_mod.fir:4:5\r\n\r\n  assign tmp4 = 1'h0;\t// top_mod.fir:5:{10,13}\r\n  wire [21:0] _T = $signed(22'h1) % $signed({22{tmp4}});\t// top_mod.fir:6:{13,17,30}\r\n  assign tmp9 = _T[0];\t// top_mod.fir:2:3, :6:13\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  output  tmp9\r\n);\r\n  wire [21:0] _GEN_0 = 22'sh1 % 22'sh0;\r\n  assign tmp9 = _GEN_0[0];\r\nendmodule", "code_snippet_04": "ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 364, "title": "[FIRRTL] (neg) mismatch", "created_at": "2020-12-25T23:19:22Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp3: SInt<12>\r\n    tmp3 <= neg(UInt<11>(1175))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [11:0] tmp3);\r\n\r\n  assign tmp3 = 12'h0 - {{1'd0}, 11'h497};\t// top_mod.fir:2:3, :4:{13,17}\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [11:0] tmp3\r\n);\r\n  assign tmp3 = -$signed(11'h497);\r\nendmodule\r\n```\r\n\r\nYosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:\r\n\r\n```\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    output tmp3: SInt<12>\r\n    tmp3 <= neg(UInt<11>(1175))", "code_snippet_02": "module top_mod(\r\n  output [11:0] tmp3);\r\n\r\n  assign tmp3 = 12'h0 - {{1'd0}, 11'h497};\t// top_mod.fir:2:3, :4:{13,17}\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  output [11:0] tmp3\r\n);\r\n  assign tmp3 = -$signed(11'h497);\r\nendmodule", "code_snippet_04": "ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 363, "title": "[FIRRTL] (div) A/A mismatch", "created_at": "2020-12-25T22:58:59Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_1: UInt<14>\r\n    output tmp4: UInt<14>\r\n    tmp4 <= div(inp_1, inp_1)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [13:0] inp_1,\r\n  output [13:0] tmp4);\r\n\r\n  assign tmp4 = inp_1 / inp_1;\t// top_mod.fir:3:3, :6:13\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [13:0] inp_1,\r\n  output [13:0] tmp4\r\n);\r\n  assign tmp4 = 14'h1;\r\nendmodule\r\n```\r\n\r\nYosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:\r\n\r\n```\r\nERROR: Found 13 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_1: UInt<14>\r\n    output tmp4: UInt<14>\r\n    tmp4 <= div(inp_1, inp_1)", "code_snippet_02": "module top_mod(\r\n  input  [13:0] inp_1,\r\n  output [13:0] tmp4);\r\n\r\n  assign tmp4 = inp_1 / inp_1;\t// top_mod.fir:3:3, :6:13\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [13:0] inp_1,\r\n  output [13:0] tmp4\r\n);\r\n  assign tmp4 = 14'h1;\r\nendmodule", "code_snippet_04": "ERROR: Found 13 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 361, "title": "[FIRRTL] (div) sign extension ", "created_at": "2020-12-25T21:32:31Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Maybe related to #355 \r\n\r\nThe following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_6: UInt<7>\r\n    output tmp9: SInt<23>\r\n    tmp9 <= div(asSInt(UInt<22>(5)), SInt<4>(-3))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [6:0]  inp_6,\r\n  output [22:0] tmp9);\r\n\r\n  wire [21:0] _T = 22'h5;\t// top_mod.fir:6:24\r\n  assign tmp9 = $signed({{1{_T[21]}}, _T}) / $signed({{19'd0}, 4'hD});\t// top_mod.fir:3:3, :6:{13,38}\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [6:0]  inp_6,\r\n  output [22:0] tmp9\r\n);\r\n  assign tmp9 = 22'sh5 / -22'sh3;\r\nendmodule\r\n```\r\n\r\nYosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:\r\n\r\n```\r\nERROR: Found 23 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_6: UInt<7>\r\n    output tmp9: SInt<23>\r\n    tmp9 <= div(asSInt(UInt<22>(5)), SInt<4>(-3))", "code_snippet_02": "module top_mod(\r\n  input  [6:0]  inp_6,\r\n  output [22:0] tmp9);\r\n\r\n  wire [21:0] _T = 22'h5;\t// top_mod.fir:6:24\r\n  assign tmp9 = $signed({{1{_T[21]}}, _T}) / $signed({{19'd0}, 4'hD});\t// top_mod.fir:3:3, :6:{13,38}\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [6:0]  inp_6,\r\n  output [22:0] tmp9\r\n);\r\n  assign tmp9 = 22'sh5 / -22'sh3;\r\nendmodule", "code_snippet_04": "ERROR: Found 23 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 356, "title": "[FIRRTL] (dshr) emit verilog error", "created_at": "2020-12-24T06:57:48Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_0: UInt<14>\r\n    output tmp1: UInt<5>\r\n    tmp1 <= dshr(UInt<5>(4), inp_0)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [13:0] inp_0,\r\n  output [4:0]  tmp1\r\n);\r\n  assign tmp1 = 5'h4 >> inp_0;\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [13:0] inp_0,\r\n  output [4:0]  tmp1);\r\n\r\n  assign tmp1 = 5'h4 >>> inp_0[4:0];\t// top_mod.fir:3:3, :6:{13,18}\r\nendmodule\r\n```\r\n\r\nYosys reports formal mismatch:\r\n\r\n```\r\nERROR: Found 3 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_0: UInt<14>\r\n    output tmp1: UInt<5>\r\n    tmp1 <= dshr(UInt<5>(4), inp_0)", "code_snippet_02": "module top_mod(\r\n  input  [13:0] inp_0,\r\n  output [4:0]  tmp1\r\n);\r\n  assign tmp1 = 5'h4 >> inp_0;\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [13:0] inp_0,\r\n  output [4:0]  tmp1);\r\n\r\n  assign tmp1 = 5'h4 >>> inp_0[4:0];\t// top_mod.fir:3:3, :6:{13,18}\r\nendmodule", "code_snippet_04": "ERROR: Found 3 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 355, "title": "[FIRRTL] (div) operand extension error", "created_at": "2020-12-24T06:32:47Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_0: UInt<15>\r\n    output tmp1: UInt<8>\r\n    tmp1 <= div(UInt<8>(104), UInt<10>(306))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [14:0] inp_0,\r\n  output [7:0]  tmp1\r\n);\r\n  assign tmp1 = 10'h68 / 10'h132;\r\nendmodule\r\n```\r\n`div` result width expected to be Wnum\r\n![image](https://user-images.githubusercontent.com/511872/103143155-108bd300-46c6-11eb-9ccd-5b2e77761aa5.png)\r\n\r\n`verilator --lint-only` generates this message:\r\n\r\n```\r\n%Warning-WIDTH: top_mod.v:5:15: Operator ASSIGNW expects 8 bits on the Assign RHS, but Assign RHS's DIV generates 10 bits.\r\n                              : ... In instance top_mod\r\n    5 |   assign tmp1 = 10'h68 / 10'h132;\r\n      |               ^\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [14:0] inp_0,\r\n  output [7:0]  tmp1);\r\n\r\n  wire [9:0] _T = 10'h132;\t// top_mod.fir:5:31\r\n  assign tmp1 = 8'h68 / _T[7:0];\t// top_mod.fir:2:3, :5:{13,17}\r\nendmodule\r\n```\r\n\r\nYosys (Yosys 0.9+3755 (git sha1 442d19f6, clang 11.0.0 -fPIC -Os)) reports formal mismatch:\r\n\r\n```\r\nERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_0: UInt<15>\r\n    output tmp1: UInt<8>\r\n    tmp1 <= div(UInt<8>(104), UInt<10>(306))", "code_snippet_02": "module top_mod(\r\n  input  [14:0] inp_0,\r\n  output [7:0]  tmp1\r\n);\r\n  assign tmp1 = 10'h68 / 10'h132;\r\nendmodule", "code_snippet_03": "%Warning-WIDTH: top_mod.v:5:15: Operator ASSIGNW expects 8 bits on the Assign RHS, but Assign RHS's DIV generates 10 bits.\r\n                              : ... In instance top_mod\r\n    5 |   assign tmp1 = 10'h68 / 10'h132;\r\n      |               ^\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.", "code_snippet_04": "module top_mod(\r\n  input  [14:0] inp_0,\r\n  output [7:0]  tmp1);\r\n\r\n  wire [9:0] _T = 10'h132;\t// top_mod.fir:5:31\r\n  assign tmp1 = 8'h68 / _T[7:0];\t// top_mod.fir:2:3, :5:{13,17}\r\nendmodule", "code_snippet_05": "ERROR: Found 1 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 354, "title": "[FIRRTL]  SInt literal sign extension error", "created_at": "2020-12-24T05:45:46Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp5: SInt<19>\r\n    tmp5 <= SInt<19>(8)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [18:0] tmp5);\r\n\r\n  assign tmp5 = 19'h7FFF8;\t// top_mod.fir:3:3, :5:13\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [18:0] tmp5\r\n);\r\n  assign tmp5 = 19'sh8;\r\nendmodule\r\n```\r\n\r\nYosys reports formal mismatch:\r\n\r\n```\r\nERROR: Found 15 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    output tmp5: SInt<19>\r\n    tmp5 <= SInt<19>(8)", "code_snippet_02": "module top_mod(\r\n  output [18:0] tmp5);\r\n\r\n  assign tmp5 = 19'h7FFF8;\t// top_mod.fir:3:3, :5:13\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  output [18:0] tmp5\r\n);\r\n  assign tmp5 = 19'sh8;\r\nendmodule", "code_snippet_04": "ERROR: Found 15 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 353, "title": "[FIRRTL] (and) SInt -> UInt formal mismatch", "created_at": "2020-12-24T04:31:36Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_0: SInt<7>\r\n    input inp_7: SInt<14>\r\n    output tmp8: UInt<14>\r\n    tmp8 <= and(inp_7, inp_0)\r\n```\r\nCompiled with `firtool --lower-to-rtl` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [6:0]  inp_0,\r\n  input  [13:0] inp_7,\r\n  output [13:0] tmp8);\r\n\r\n  assign tmp8 = inp_7 & {{7'd0}, inp_0};\t// top_mod.fir:3:3, :7:13\r\nendmodule\r\n```\r\nCompiled with `firrtl-1.4.0` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [6:0]  inp_0,\r\n  input  [13:0] inp_7,\r\n  output [13:0] tmp8\r\n);\r\n  wire [13:0] _GEN_0 = {{7{inp_0[6]}},inp_0};\r\n  assign tmp8 = $signed(inp_7) & $signed(_GEN_0);\r\nendmodule\r\n```\r\n\r\nYosys reports formal missmatch:\r\n\r\n```\r\nERROR: Found 7 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n\r\nnote: Similar behavior is true for (and, or, xor) operations", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_0: SInt<7>\r\n    input inp_7: SInt<14>\r\n    output tmp8: UInt<14>\r\n    tmp8 <= and(inp_7, inp_0)", "code_snippet_02": "module top_mod(\r\n  input  [6:0]  inp_0,\r\n  input  [13:0] inp_7,\r\n  output [13:0] tmp8);\r\n\r\n  assign tmp8 = inp_7 & {{7'd0}, inp_0};\t// top_mod.fir:3:3, :7:13\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input  [6:0]  inp_0,\r\n  input  [13:0] inp_7,\r\n  output [13:0] tmp8\r\n);\r\n  wire [13:0] _GEN_0 = {{7{inp_0[6]}},inp_0};\r\n  assign tmp8 = $signed(inp_7) & $signed(_GEN_0);\r\nendmodule", "code_snippet_04": "ERROR: Found 7 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 347, "title": "[FIRRTL] Negative Signed Literal error", "created_at": "2020-12-22T01:00:18Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp12: SInt<4>\r\n    tmp12 <= SInt<4>(-4)\r\n```\r\nCompiled with `firtool --lower-to-rtl` produces this error:\r\n\r\n```python\r\ntop_mod.fir:4:22: error: expected '.' in floating point literal\r\n    tmp12 <= SInt<4>(-4)\r\n                     ^\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    output tmp12: SInt<4>\r\n    tmp12 <= SInt<4>(-4)", "code_snippet_02": "top_mod.fir:4:22: error: expected '.' in floating point literal\r\n    tmp12 <= SInt<4>(-4)\r\n                     ^"}, {"number": 331, "title": "[FIRRTL] (shr) core dump", "created_at": "2020-12-15T21:31:45Z", "state": "closed", "labels": "bug, FIRRTL", "body": "maybe related to #326 \r\n\r\nThe following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp81: SInt<1>\r\n    tmp81 <= shr(SInt<1>(1), 3)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` triggers this error:\r\n\r\n```bash\r\nfirtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:859: llvm::APInt llvm::APInt::trunc(unsigned int) const: Assertion `width < BitWidth && \"Invalid APInt Truncate request\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool --lower-to-rtl top_mod.fir --verilog -o=top_mod.v\r\n #0 0x00000000004bd25f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:563:22\r\n #1 0x00000000004bd316 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:630:1\r\n #2 0x00000000004bb332 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bccb2 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:405:1\r\n #4 0x00007efd5ce521d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007efd5c911a65 raise (/lib64/libc.so.6+0x3da65)\r\n #6 0x00007efd5c8fa864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007efd5c8fa749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007efd5c909f96 (/lib64/libc.so.6+0x35f96)\r\n #9 0x00000000004de802 llvm::APInt::trunc(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:860:3\r\n#10 0x000000000076ab02 circt::firrtl::ShrPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/OpFolds.cpp:376:61\r\n#11 0x0000000000754d13 mlir::LogicalResult mlir::Op<circt::firrtl::ShrPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::ShrPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1641:53\r\n#12 0x000000000068c45c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:138:3\r\n#13 0x00000000006860ba mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:566:30\r\n#14 0x0000000000733897 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:186:13\r\n#15 0x00000000007331de mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:89:13\r\n#16 0x0000000000716c23 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#17 0x0000000000716f4e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#18 0x0000000000716e3a mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#19 0x0000000000707e93 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:71\r\n#20 0x000000000084f635 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:368:36\r\n#21 0x000000000084f7ed mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:15\r\n#22 0x00000000008516fd mlir::PassManager::run(mlir::ModuleOp) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:808:73\r\n#23 0x000000000040952d processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:128:15\r\n#24 0x00000000004099a8 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:181:13\r\n#25 0x00007efd5c8fc152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#26 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\nAborted (core dumped)\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    output tmp81: SInt<1>\r\n    tmp81 <= shr(SInt<1>(1), 3)", "code_snippet_02": "firtool: /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:859: llvm::APInt llvm::APInt::trunc(unsigned int) const: Assertion `width < BitWidth && \"Invalid APInt Truncate request\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool --lower-to-rtl top_mod.fir --verilog -o=top_mod.v\r\n #0 0x00000000004bd25f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:563:22\r\n #1 0x00000000004bd316 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:630:1\r\n #2 0x00000000004bb332 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bccb2 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:405:1\r\n #4 0x00007efd5ce521d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007efd5c911a65 raise (/lib64/libc.so.6+0x3da65)\r\n #6 0x00007efd5c8fa864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007efd5c8fa749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007efd5c909f96 (/lib64/libc.so.6+0x35f96)\r\n #9 0x00000000004de802 llvm::APInt::trunc(unsigned int) const /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/APInt.cpp:860:3\r\n#10 0x000000000076ab02 circt::firrtl::ShrPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/OpFolds.cpp:376:61\r\n#11 0x0000000000754d13 mlir::LogicalResult mlir::Op<circt::firrtl::ShrPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::ShrPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1641:53\r\n#12 0x000000000068c45c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:138:3\r\n#13 0x00000000006860ba mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:566:30\r\n#14 0x0000000000733897 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:186:13\r\n#15 0x00000000007331de mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:89:13\r\n#16 0x0000000000716c23 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#17 0x0000000000716f4e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#18 0x0000000000716e3a mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#19 0x0000000000707e93 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:71\r\n#20 0x000000000084f635 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:368:36\r\n#21 0x000000000084f7ed mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:15\r\n#22 0x00000000008516fd mlir::PassManager::run(mlir::ModuleOp) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:808:73\r\n#23 0x000000000040952d processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:128:15\r\n#24 0x00000000004099a8 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:181:13\r\n#25 0x00007efd5c8fc152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#26 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\nAborted (core dumped)"}, {"number": 328, "title": "[FIRRTL] (mul) 0-width", "created_at": "2020-12-15T04:14:08Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Maybe related to #319\r\n\r\nThe following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_g: SInt<0>\r\n    input inp_13: SInt<383>\r\n    output tmp75: SInt<383>\r\n    tmp75 <= mul(inp_13, inp_g)\r\n```\r\nCompiled with `firtool --lower-to-rtl` produces this verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input          inp_g,\r\n  input  [382:0] inp_13,\r\n  output [382:0] tmp75);\r\n\r\n  assign tmp75 = inp_13 * {{383{inp_g[4294967295]}}, inp_g};\t// top_mod.fir:2:3, :6:14\r\nendmodule\r\n```\r\n\r\nThat has the following error:\r\n\r\n```bash\r\n%Error: top_mod.v:6:38: Illegal bit or array select; type does not have a bit range, or bad dimension: data type is 'logic'\r\n                      : ... In instance top_mod\r\n    6 |   assign tmp75 = inp_13 * {{383{inp_g[4294967295]}}, inp_g};  \r\n      |                                      ^\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_g: SInt<0>\r\n    input inp_13: SInt<383>\r\n    output tmp75: SInt<383>\r\n    tmp75 <= mul(inp_13, inp_g)", "code_snippet_02": "module top_mod(\r\n  input          inp_g,\r\n  input  [382:0] inp_13,\r\n  output [382:0] tmp75);\r\n\r\n  assign tmp75 = inp_13 * {{383{inp_g[4294967295]}}, inp_g};\t// top_mod.fir:2:3, :6:14\r\nendmodule", "code_snippet_03": "%Error: top_mod.v:6:38: Illegal bit or array select; type does not have a bit range, or bad dimension: data type is 'logic'\r\n                      : ... In instance top_mod\r\n    6 |   assign tmp75 = inp_13 * {{383{inp_g[4294967295]}}, inp_g};  \r\n      |                                      ^"}, {"number": 326, "title": "[FIRRTL] (shr) core dump", "created_at": "2020-12-15T03:57:36Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output tmp57: SInt<1>\r\n    tmp57 <= shr(SInt<7>(29), 47)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` triggers this error:\r\n\r\n```bash\r\nfirtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:971: void llvm::APInt::ashrInPlace(unsigned int): Assertion `ShiftAmt <= BitWidth && \"Invalid shift amount\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool --lower-to-rtl top_mod.fir --verilog -o=top_mod.v\r\n #0 0x00000000004bd25f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:563:22\r\n #1 0x00000000004bd316 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:630:1\r\n #2 0x00000000004bb332 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bccb2 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:405:1\r\n #4 0x00007fd442b431d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007fd442602a65 raise (/lib64/libc.so.6+0x3da65)\r\n #6 0x00007fd4425eb864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007fd4425eb749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007fd4425faf96 (/lib64/libc.so.6+0x35f96)\r\n #9 0x00000000004e868c llvm::APInt::ashrInPlace(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:972:21\r\n#10 0x000000000076f5b9 llvm::APInt::ashr(unsigned int) const /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/APInt.h:966:12\r\n#11 0x000000000076aa33 circt::firrtl::ShrPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/OpFolds.cpp:374:37\r\n#12 0x0000000000754d13 mlir::LogicalResult mlir::Op<circt::firrtl::ShrPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::ShrPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1641:53\r\n#13 0x000000000068c45c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:138:3\r\n#14 0x00000000006860ba mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:566:30\r\n#15 0x0000000000733897 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:186:13\r\n#16 0x00000000007331de mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:89:13\r\n#17 0x0000000000716c23 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#18 0x0000000000716f4e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#19 0x0000000000716e3a mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#20 0x0000000000707e93 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:71\r\n#21 0x000000000084f5b3 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:368:36\r\n#22 0x000000000084f76b mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:15\r\n#23 0x000000000085167b mlir::PassManager::run(mlir::ModuleOp) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:808:73\r\n#24 0x000000000040952d processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:128:15\r\n#25 0x00000000004099a8 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:181:13\r\n#26 0x00007fd4425ed152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#27 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\nAborted (core dumped)\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    output tmp57: SInt<1>\r\n    tmp57 <= shr(SInt<7>(29), 47)", "code_snippet_02": "firtool: /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:971: void llvm::APInt::ashrInPlace(unsigned int): Assertion `ShiftAmt <= BitWidth && \"Invalid shift amount\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool --lower-to-rtl top_mod.fir --verilog -o=top_mod.v\r\n #0 0x00000000004bd25f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:563:22\r\n #1 0x00000000004bd316 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:630:1\r\n #2 0x00000000004bb332 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bccb2 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:405:1\r\n #4 0x00007fd442b431d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007fd442602a65 raise (/lib64/libc.so.6+0x3da65)\r\n #6 0x00007fd4425eb864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007fd4425eb749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007fd4425faf96 (/lib64/libc.so.6+0x35f96)\r\n #9 0x00000000004e868c llvm::APInt::ashrInPlace(unsigned int) /home/drom/work/github/llvm/circt/llvm/llvm/include/llvm/ADT/APInt.h:972:21\r\n#10 0x000000000076f5b9 llvm::APInt::ashr(unsigned int) const /home/drom/work/github/llvm/circt/build/../llvm/llvm/include/llvm/ADT/APInt.h:966:12\r\n#11 0x000000000076aa33 circt::firrtl::ShrPrimOp::fold(llvm::ArrayRef<mlir::Attribute>) /home/drom/work/github/llvm/circt/build/../lib/Dialect/FIRRTL/OpFolds.cpp:374:37\r\n#12 0x0000000000754d13 mlir::LogicalResult mlir::Op<circt::firrtl::ShrPrimOp, mlir::OpTrait::ZeroRegion, mlir::OpTrait::OneResult, mlir::OpTrait::ZeroSuccessor, mlir::OpTrait::OneOperand, mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<circt::firrtl::ShrPrimOp>(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/build/../llvm/mlir/include/mlir/IR/OpDefinition.h:1641:53\r\n#13 0x000000000068c45c mlir::AbstractOperation::foldHook(mlir::Operation*, llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) const /home/drom/work/github/llvm/circt/llvm/mlir/include/mlir/IR/OperationSupport.h:138:3\r\n#14 0x00000000006860ba mlir::Operation::fold(llvm::ArrayRef<mlir::Attribute>, llvm::SmallVectorImpl<mlir::OpFoldResult>&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/IR/Operation.cpp:566:30\r\n#15 0x0000000000733897 mlir::OperationFolder::tryToFold(mlir::OpBuilder&, mlir::Operation*, llvm::SmallVectorImpl<mlir::Value>&, llvm::function_ref<void (mlir::Operation*)>) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:186:13\r\n#16 0x00000000007331de mlir::OperationFolder::tryToFold(mlir::Operation*, llvm::function_ref<void (mlir::Operation*)>, llvm::function_ref<void (mlir::Operation*)>, bool*) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/FoldUtils.cpp:89:13\r\n#17 0x0000000000716c23 (anonymous namespace)::GreedyPatternRewriteDriver::simplify(llvm::MutableArrayRef<mlir::Region>, int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:191:21\r\n#18 0x0000000000716f4e mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&, unsigned int) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:258:35\r\n#19 0x0000000000716e3a mlir::applyPatternsAndFoldGreedily(llvm::MutableArrayRef<mlir::Region>, mlir::FrozenRewritePatternList const&) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:238:1\r\n#20 0x0000000000707e93 (anonymous namespace)::Canonicalizer::runOnOperation() /home/drom/work/github/llvm/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:35:71\r\n#21 0x000000000084f5b3 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:368:36\r\n#22 0x000000000084f76b mlir::detail::OpToOpPassAdaptor::runPipeline(llvm::iterator_range<llvm::pointee_iterator<std::unique_ptr<mlir::Pass, std::default_delete<mlir::Pass> >*, mlir::Pass> >, mlir::Operation*, mlir::AnalysisManager, bool) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:403:15\r\n#23 0x000000000085167b mlir::PassManager::run(mlir::ModuleOp) /home/drom/work/github/llvm/circt/llvm/mlir/lib/Pass/Pass.cpp:808:73\r\n#24 0x000000000040952d processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:128:15\r\n#25 0x00000000004099a8 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:181:13\r\n#26 0x00007fd4425ed152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#27 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\nAborted (core dumped)"}, {"number": 323, "title": "[FIRRTL] firrtl.connect not catching bit truncation", "created_at": "2020-12-13T19:43:09Z", "state": "closed", "labels": "bug, FIRRTL", "body": "I think that this is malformed firrtl, because the connect is truncating from 4 to 6 bits, but it looks like the verifier doesn't reject it:\r\n\r\n```\r\n module Precedence :\r\n    input a: UInt<4>\r\n    input b: UInt<4>\r\n    input c: UInt<4>\r\n    output out1: UInt<1>\r\n    output out: UInt<4>\r\n    out <= add(a, add(b, c))\r\n```\r\n\r\n```\r\n   firrtl.module @Precedence(%a: !firrtl.uint<4>, %b: !firrtl.uint<4>, %c: !firrtl.uint<4>, %out1: !firrtl.flip<uint<1>>, %out: !firrtl.flip<uint<4>>) {\r\n      %0 = firrtl.add %b, %c : (!firrtl.uint<4>, !firrtl.uint<4>) -> !firrtl.uint<5>\r\n      %1 = firrtl.add %a, %0 : (!firrtl.uint<4>, !firrtl.uint<5>) -> !firrtl.uint<6>\r\n      firrtl.connect %out, %1 : !firrtl.flip<uint<4>>, !firrtl.uint<6>\r\n }\r\n```\r\n\r\nThe LowerToRTL pass is rejecting it, but it seems like the FIRRTL verifier should also catch this.  This would allow the firrtl parser to correct reject the input.", "code_snippet_01": "module Precedence :\r\n    input a: UInt<4>\r\n    input b: UInt<4>\r\n    input c: UInt<4>\r\n    output out1: UInt<1>\r\n    output out: UInt<4>\r\n    out <= add(a, add(b, c))", "code_snippet_02": "firrtl.module @Precedence(%a: !firrtl.uint<4>, %b: !firrtl.uint<4>, %c: !firrtl.uint<4>, %out1: !firrtl.flip<uint<1>>, %out: !firrtl.flip<uint<4>>) {\r\n      %0 = firrtl.add %b, %c : (!firrtl.uint<4>, !firrtl.uint<4>) -> !firrtl.uint<5>\r\n      %1 = firrtl.add %a, %0 : (!firrtl.uint<4>, !firrtl.uint<5>) -> !firrtl.uint<6>\r\n      firrtl.connect %out, %1 : !firrtl.flip<uint<4>>, !firrtl.uint<6>\r\n }"}, {"number": 320, "title": "[FIRRTL] literal slicing", "created_at": "2020-12-11T08:30:45Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_1: SInt<349>\r\n    output tmp6: UInt<1>\r\n    tmp6 <= eq(inp_1, asSInt(UInt<17>(72236)))\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [348:0] inp_1,\r\n  output         tmp6);\r\n\r\n  assign tmp6 = inp_1 == {{332{17'h11A2C[16]}}, 17'h11A2C};\t// top_mod.fir:3:3, :6:{13,30}\r\nendmodule\r\n```\r\nThat has the following error:\r\n\r\n```verilog\r\n%Error: top_mod.v:5:41: syntax error, unexpected '[', expecting ',' or '}'\r\n    5 |   assign tmp6 = inp_1 == {{332{17'h11A2C[16]}}, 17'h11A2C};  \r\n      |                                         ^\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_1: SInt<349>\r\n    output tmp6: UInt<1>\r\n    tmp6 <= eq(inp_1, asSInt(UInt<17>(72236)))", "code_snippet_02": "module top_mod(\r\n  input  [348:0] inp_1,\r\n  output         tmp6);\r\n\r\n  assign tmp6 = inp_1 == {{332{17'h11A2C[16]}}, 17'h11A2C};\t// top_mod.fir:3:3, :6:{13,30}\r\nendmodule", "code_snippet_03": "%Error: top_mod.v:5:41: syntax error, unexpected '[', expecting ',' or '}'\r\n    5 |   assign tmp6 = inp_1 == {{332{17'h11A2C[16]}}, 17'h11A2C};  \r\n      |                                         ^"}, {"number": 319, "title": "[FIRRTL] (cat) 0-bit width", "created_at": "2020-12-11T07:37:23Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_0: UInt<0>\r\n    input inp_1: UInt<5>\r\n    output out_0: UInt<5>\r\n    out_0 <= cat(inp_1, inp_0)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input        inp_0,\r\n  input  [4:0] inp_1,\r\n  output [4:0] out_0);\r\n\r\n  assign out_0 = {inp_1, inp_0};\t// top_mod.fir:2:3, :6:14\r\nendmodule\r\n```\r\n\r\nThat has the following error:\r\n\r\n```bash\r\n%Warning-WIDTH: top_mod.v:6:16: Operator ASSIGNW expects 5 bits on the Assign RHS, but Assign RHS's REPLICATE generates 6 bits.\r\n                              : ... In instance top_mod\r\n    6 |   assign out_0 = {inp_1, inp_0};  \r\n      |                ^\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.\r\n```\r\n\r\nExpected Verilog output is:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [4:0] inp_1,\r\n  output [4:0] out_0);\r\n\r\n  assign out_0 = inp_1;\t// top_mod.fir:2:3, :6:14\r\nendmodule\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_0: UInt<0>\r\n    input inp_1: UInt<5>\r\n    output out_0: UInt<5>\r\n    out_0 <= cat(inp_1, inp_0)", "code_snippet_02": "module top_mod(\r\n  input        inp_0,\r\n  input  [4:0] inp_1,\r\n  output [4:0] out_0);\r\n\r\n  assign out_0 = {inp_1, inp_0};\t// top_mod.fir:2:3, :6:14\r\nendmodule", "code_snippet_03": "%Warning-WIDTH: top_mod.v:6:16: Operator ASSIGNW expects 5 bits on the Assign RHS, but Assign RHS's REPLICATE generates 6 bits.\r\n                              : ... In instance top_mod\r\n    6 |   assign out_0 = {inp_1, inp_0};  \r\n      |                ^\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.", "code_snippet_04": "module top_mod(\r\n  input  [4:0] inp_1,\r\n  output [4:0] out_0);\r\n\r\n  assign out_0 = inp_1;\t// top_mod.fir:2:3, :6:14\r\nendmodule"}, {"number": 318, "title": "[FIRRTL] (rem) slicing scalar", "created_at": "2020-12-11T07:18:13Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Similar to #313 \r\n\r\nThe following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input tmp85: UInt<1>\r\n    input tmp79: UInt<1>\r\n    output tmp106: UInt<1>\r\n    tmp106 <= rem(tmp79, tmp85)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  tmp85, tmp79,\r\n  output tmp106);\r\n\r\n  wire _T = tmp79 % tmp85;\t// top_mod.fir:7:15\r\n  assign tmp106 = _T[0];\t// top_mod.fir:3:3, :7:15\r\nendmodule\r\n```\r\n\r\nThat has the following error:\r\n\r\n```bash\r\n%Error: top_mod.v:6:21: Illegal bit or array select; type does not have a bit range, or bad dimension: data type is 'logic'\r\n                      : ... In instance top_mod\r\n    6 |   assign tmp106 = _T[0];  \r\n      |                     ^\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input tmp85: UInt<1>\r\n    input tmp79: UInt<1>\r\n    output tmp106: UInt<1>\r\n    tmp106 <= rem(tmp79, tmp85)", "code_snippet_02": "module top_mod(\r\n  input  tmp85, tmp79,\r\n  output tmp106);\r\n\r\n  wire _T = tmp79 % tmp85;\t// top_mod.fir:7:15\r\n  assign tmp106 = _T[0];\t// top_mod.fir:3:3, :7:15\r\nendmodule", "code_snippet_03": "%Error: top_mod.v:6:21: Illegal bit or array select; type does not have a bit range, or bad dimension: data type is 'logic'\r\n                      : ... In instance top_mod\r\n    6 |   assign tmp106 = _T[0];  \r\n      |                     ^"}, {"number": 316, "title": "[FIRRTL] 0-wide types", "created_at": "2020-12-11T01:01:54Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_0: UInt<0>\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this crash:\r\n\r\n```bash\r\nfirtool: ../lib/EmitVerilog/EmitVerilog.cpp:258: void {anonymous}::VerilogEmitterBase::emitTypePaddedToWidth(mlir::Type, size_t, mlir::Operation*): Assertion `bitWidth != 0 && \"Shouldn't emit zero bit declarations\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool --lower-to-rtl top_mod.fir --verilog -o=top_mod.v\r\n #0 0x00000000004bd25f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:563:22\r\n #1 0x00000000004bd316 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:630:1\r\n #2 0x00000000004bb332 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bccb2 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:405:1\r\n #4 0x00007fedea7d61d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007fedea295a65 raise (/lib64/libc.so.6+0x3da65)\r\n #6 0x00007fedea27e864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007fedea27e749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007fedea28df96 (/lib64/libc.so.6+0x35f96)\r\n #9 0x00000000004f8658 (anonymous namespace)::VerilogEmitterBase::emitTypePaddedToWidth(mlir::Type, unsigned long, mlir::Operation*) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:260:3\r\n#10 0x0000000000505809 (anonymous namespace)::ModuleEmitter::emitRTLModule(circt::rtl::RTLModuleOp) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:2679:5\r\n#11 0x0000000000506014 (anonymous namespace)::CircuitEmitter::emitMLIRModule(mlir::ModuleOp) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:2837:7\r\n#12 0x00000000005061b2 circt::emitVerilog(mlir::ModuleOp, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:2850:24\r\n#13 0x000000000040962c processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:140:40\r\n#14 0x00000000004099a8 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:181:13\r\n#15 0x00007fedea280152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#16 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\nAborted (core dumped)\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_0: UInt<0>", "code_snippet_02": "firtool: ../lib/EmitVerilog/EmitVerilog.cpp:258: void {anonymous}::VerilogEmitterBase::emitTypePaddedToWidth(mlir::Type, size_t, mlir::Operation*): Assertion `bitWidth != 0 && \"Shouldn't emit zero bit declarations\"' failed.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ../../llvm/circt/build/bin/firtool --lower-to-rtl top_mod.fir --verilog -o=top_mod.v\r\n #0 0x00000000004bd25f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:563:22\r\n #1 0x00000000004bd316 PrintStackTraceSignalHandler(void*) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:630:1\r\n #2 0x00000000004bb332 llvm::sys::RunSignalHandlers() /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Signals.cpp:71:20\r\n #3 0x00000000004bccb2 SignalHandler(int) /home/drom/work/github/llvm/circt/llvm/llvm/lib/Support/Unix/Signals.inc:405:1\r\n #4 0x00007fedea7d61d0 __restore_rt (/lib64/libpthread.so.0+0x141d0)\r\n #5 0x00007fedea295a65 raise (/lib64/libc.so.6+0x3da65)\r\n #6 0x00007fedea27e864 abort (/lib64/libc.so.6+0x26864)\r\n #7 0x00007fedea27e749 _nl_load_domain.cold (/lib64/libc.so.6+0x26749)\r\n #8 0x00007fedea28df96 (/lib64/libc.so.6+0x35f96)\r\n #9 0x00000000004f8658 (anonymous namespace)::VerilogEmitterBase::emitTypePaddedToWidth(mlir::Type, unsigned long, mlir::Operation*) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:260:3\r\n#10 0x0000000000505809 (anonymous namespace)::ModuleEmitter::emitRTLModule(circt::rtl::RTLModuleOp) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:2679:5\r\n#11 0x0000000000506014 (anonymous namespace)::CircuitEmitter::emitMLIRModule(mlir::ModuleOp) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:2837:7\r\n#12 0x00000000005061b2 circt::emitVerilog(mlir::ModuleOp, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../lib/EmitVerilog/EmitVerilog.cpp:2850:24\r\n#13 0x000000000040962c processBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:140:40\r\n#14 0x00000000004099a8 main /home/drom/work/github/llvm/circt/build/../tools/firtool/firtool.cpp:181:13\r\n#15 0x00007fedea280152 __libc_start_main (/lib64/libc.so.6+0x28152)\r\n#16 0x00000000004090ee _start /home/abuild/rpmbuild/BUILD/glibc-2.32/csu/../sysdeps/x86_64/start.S:122:0\r\nAborted (core dumped)"}, {"number": 315, "title": "[FIRRTL] (add, sub) type mismatch between destination and source", "created_at": "2020-12-10T23:44:57Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_v: UInt<93>\r\n    input inp_1l: SInt<37>\r\n    output tmp118: UInt<94>\r\n    tmp118 <= sub(asSInt(inp_v), inp_1l)\r\n```\r\n\r\nShould be fine according to FIRRTL spec\r\n\r\n![image](https://user-images.githubusercontent.com/511872/101843179-80af2c00-3afe-11eb-8ded-5c398eae7d72.png)\r\n\r\nBut compiled with `firtool --lower-to-rtl` produces this error:\r\n\r\n```mlir\r\ntop_mod.fir:7:12: error: type mismatch between destination '!firrtl.uint<94>' and source '!firrtl.sint<94>'\r\n    tmp118 <= sub(asSInt(inp_v), inp_1l)\r\n```\r\n\r\nA similar problem happens with an `add` operation", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_v: UInt<93>\r\n    input inp_1l: SInt<37>\r\n    output tmp118: UInt<94>\r\n    tmp118 <= sub(asSInt(inp_v), inp_1l)", "code_snippet_02": "top_mod.fir:7:12: error: type mismatch between destination '!firrtl.uint<94>' and source '!firrtl.sint<94>'\r\n    tmp118 <= sub(asSInt(inp_v), inp_1l)"}, {"number": 314, "title": "[FIRRTL] div truncation", "created_at": "2020-12-10T23:21:19Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_2: UInt<27>\r\n    input inp_i: UInt<65>\r\n    output tmp48: UInt<27>\r\n    tmp48 <= div(inp_2, inp_i)\r\n```\r\n\r\nCompiled with `firtool --lower-to-rtl` produces this error:\r\n\r\n```mlir\r\nttop_mod.fir:6:14: error: operand should not be a truncation\r\n    tmp48 <= div(inp_2, inp_i)\r\n             ^\r\n```\r\n\r\nit also generates this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  [26:0] inp_2,\r\n  input  [64:0] inp_i,\r\n  output [26:0] tmp48);\r\n\r\n  assign tmp48 = inp_2 / inp_i;\t// top_mod.fir:2:3, :6:14\r\nendmodule\r\n```\r\n\r\nVerilator Linter is not happy about it:\r\n\r\n```bash\r\n%Warning-WIDTH: top_mod.v:6:24: Operator DIV expects 65 bits on the LHS, but LHS's VARREF 'inp_2' generates 27 bits.\r\n                              : ... In instance top_mod\r\n    6 |   assign tmp48 = inp_2 / inp_i;  \r\n      |                        ^\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.\r\n%Warning-WIDTH: top_mod.v:6:16: Operator ASSIGNW expects 27 bits on the Assign RHS, but Assign RHS's DIV generates 65 bits.\r\n                              : ... In instance top_mod\r\n    6 |   assign tmp48 = inp_2 / inp_i;  \r\n      |                ^\r\n```\r\n\r\nPart from FIRRTL spec\r\n\r\n![image](https://user-images.githubusercontent.com/511872/101842129-3b89fa80-3afc-11eb-8446-ce5af07b6dcf.png)\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_2: UInt<27>\r\n    input inp_i: UInt<65>\r\n    output tmp48: UInt<27>\r\n    tmp48 <= div(inp_2, inp_i)", "code_snippet_02": "ttop_mod.fir:6:14: error: operand should not be a truncation\r\n    tmp48 <= div(inp_2, inp_i)\r\n             ^", "code_snippet_03": "module top_mod(\r\n  input  [26:0] inp_2,\r\n  input  [64:0] inp_i,\r\n  output [26:0] tmp48);\r\n\r\n  assign tmp48 = inp_2 / inp_i;\t// top_mod.fir:2:3, :6:14\r\nendmodule", "code_snippet_04": "%Warning-WIDTH: top_mod.v:6:24: Operator DIV expects 65 bits on the LHS, but LHS's VARREF 'inp_2' generates 27 bits.\r\n                              : ... In instance top_mod\r\n    6 |   assign tmp48 = inp_2 / inp_i;  \r\n      |                        ^\r\n                ... Use \"/* verilator lint_off WIDTH */\" and lint_on around source to disable this message.\r\n%Warning-WIDTH: top_mod.v:6:16: Operator ASSIGNW expects 27 bits on the Assign RHS, but Assign RHS's DIV generates 65 bits.\r\n                              : ... In instance top_mod\r\n    6 |   assign tmp48 = inp_2 / inp_i;  \r\n      |                ^"}, {"number": 313, "title": "[FIRRTL] slicing scalars", "created_at": "2020-12-10T20:10:55Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "The following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_8: SInt<1>\r\n    output tmp9: SInt<1>\r\n    tmp9 <= shr(inp_8, 42)\r\n```\r\n\r\nCompiled with `firtool` produces this verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input  inp_8,\r\n  output tmp9);\r\n\r\n  assign tmp9 = inp_8[0];\t// top_mod.fir:6:{10,13}\r\nendmodule\r\n```\r\n\r\nThat has the following error:\r\n\r\n```bash\r\n> verilator --lint-only top_mod.v \r\n\r\n%Error: top_mod.v:57:22: Illegal bit or array select; type does not have a bit range, or bad dimension: data type is 'logic'\r\n                       : ... In instance top_mod\r\n   57 |   assign tmp9 = inp_8[0];  \r\n      |                      ^\r\n```\r\n", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_8: SInt<1>\r\n    output tmp9: SInt<1>\r\n    tmp9 <= shr(inp_8, 42)", "code_snippet_02": "module top_mod(\r\n  input  inp_8,\r\n  output tmp9);\r\n\r\n  assign tmp9 = inp_8[0];\t// top_mod.fir:6:{10,13}\r\nendmodule", "code_snippet_03": "> verilator --lint-only top_mod.v \r\n\r\n%Error: top_mod.v:57:22: Illegal bit or array select; type does not have a bit range, or bad dimension: data type is 'logic'\r\n                       : ... In instance top_mod\r\n   57 |   assign tmp9 = inp_8[0];  \r\n      |                      ^"}, {"number": 311, "title": "[FIRRTL] (or) operation with duplicate input", "created_at": "2020-12-10T05:57:06Z", "state": "closed", "labels": "bug, FIRRTL", "body": "`firtool` with the following FIRRTL program\r\n\r\n```python\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input inp_r: SInt<38>\r\n    output tmp874: UInt<38>\r\n    tmp874 <= or(inp_r, inp_r)\r\n```\r\n\r\nGenerates this error:\r\n\r\n```mlir\r\ndrom@linux-sydi:~/work/github/drom/circt-fuzzer> ../../llvm/circt/build/bin/firtool top_mod.fir\r\ntop_mod.fir:6:12: error: type mismatch between destination '!firrtl.uint<38>' and source '!firrtl.sint<38>'\r\n    tmp874 <= or(inp_r, inp_r)\r\n           ^\r\ntop_mod.fir:6:12: note: see current operation: \"firrtl.connect\"(%tmp874, %inp_r) : (!firrtl.flip<uint<38>>, !firrtl.sint<38>) -> ()\r\n```\r\n\r\nIs this expected?", "code_snippet_01": "circuit top_mod :\r\n  module top_mod :\r\n    input inp_r: SInt<38>\r\n    output tmp874: UInt<38>\r\n    tmp874 <= or(inp_r, inp_r)", "code_snippet_02": "drom@linux-sydi:~/work/github/drom/circt-fuzzer> ../../llvm/circt/build/bin/firtool top_mod.fir\r\ntop_mod.fir:6:12: error: type mismatch between destination '!firrtl.uint<38>' and source '!firrtl.sint<38>'\r\n    tmp874 <= or(inp_r, inp_r)\r\n           ^\r\ntop_mod.fir:6:12: note: see current operation: \"firrtl.connect\"(%tmp874, %inp_r) : (!firrtl.flip<uint<38>>, !firrtl.sint<38>) -> ()"}, {"number": 261, "title": "[FIRRTL] instances with flipped bundles breaks LowerTypes", "created_at": "2020-11-19T15:44:42Z", "state": "closed", "labels": "bug, FIRRTL", "body": "  firrtl.circuit \"foo\" {\r\n    firrtl.module @bar(%clock: !firrtl.clock, %reset: !firrtl.uint<1>) {\r\n    }\r\n    firrtl.module @foo(%clock: !firrtl.clock, %reset: !firrtl.uint<1>) {\r\n      %int_bus = firrtl.instance @bar {name = \"int_bus\"} : !firrtl.flip<bundle<clock: clock, reset: uint<1>>>\r\n      %0 = firrtl.subfield %int_bus(\"clock\") : (!firrtl.flip<bundle<clock: clock, reset: uint<1>>>) -> !firrtl.flip<clock>\r\n      firrtl.connect %0, %clock : !firrtl.flip<clock>, !firrtl.clock\r\n      %1 = firrtl.subfield %int_bus(\"reset\") : (!firrtl.flip<bundle<clock: clock, reset: uint<1>>>) -> !firrtl.flip<uint<1>>\r\n      firrtl.connect %1, %reset : !firrtl.flip<uint<1>>, !firrtl.uint<1>\r\n    }\r\n\r\n  }\r\n"}, {"number": 243, "title": "[FIRRTL] Inconsistent int type width", "created_at": "2020-11-13T19:57:14Z", "state": "closed", "labels": "bug, FIRRTL", "body": "In [`test/firrtl/test.mlir`,](https://github.com/llvm/circt/blob/688bd0d6f39f20367a305317ca5891dddc301c8f/test/firrtl/test.mlir#L32) there is the following firrtl dialect IR:\r\n\r\n```\r\nfirrtl.circuit \"Top\" {\r\n  firrtl.module @Top(%out: !firrtl.flip<uint>,\r\n                     %b: !firrtl.uint<32>,\r\n                     %c: !firrtl.analog<13>,\r\n                     %d: !firrtl.uint<16>) {\r\n    %3 = firrtl.add %b, %d : (!firrtl.uint<32>, !firrtl.uint<16>) -> !firrtl.uint<32>\r\n    ....\r\n  }\r\n}\r\n```\r\nThe resulting type of `%3` is given as `uint<32>` but when we look at [`getAddSubResult`](https://github.com/llvm/circt/blob/688bd0d6f39f20367a305317ca5891dddc301c8f/lib/Dialect/FIRRTL/Ops.cpp#L838) it should be `uint<33>`.\r\nThere are several inconsistent types in tests (basically related to add/sub op). Is it allowed or should we just prohibit this in the verifier? ", "code_snippet_01": "firrtl.circuit \"Top\" {\r\n  firrtl.module @Top(%out: !firrtl.flip<uint>,\r\n                     %b: !firrtl.uint<32>,\r\n                     %c: !firrtl.analog<13>,\r\n                     %d: !firrtl.uint<16>) {\r\n    %3 = firrtl.add %b, %d : (!firrtl.uint<32>, !firrtl.uint<16>) -> !firrtl.uint<32>\r\n    ....\r\n  }\r\n}"}, {"number": 240, "title": "[ESI] Cosim integration test should poll for server", "created_at": "2020-11-12T01:57:47Z", "state": "closed", "labels": "bug", "body": "Currently, it just waits for 50ms. Set up the lit test format to poll instead."}, {"number": 235, "title": "[FIRRTL] Align dhsl lowering with Scala FIRRTL Compiler", "created_at": "2020-11-11T20:31:36Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The Scala FIRRTL Compiler (SFC) does some width padding of the `dshl` operator which is not done by FIRRTL Dialect lowering, i.e., using `firtool`. Specifically, the padding for a shift is:\r\n\r\n1. Sign extend the input up to the max width of the shift\r\n2. Convert the `dshl` to a `dshlw`\r\n3. Sign extend the input up to the width of the output\r\n\r\nThe current lowering from FIRRTL dialect will, from my quick look, cause an issue when lowering `firrtl.sint` shifted into a larger value because the sign extension won't be applied.\r\n\r\nConsider the following circuit:\r\n\r\n```\r\ncircuit Foo:\r\n  module Foo:\r\n    input a_uint: UInt<2>\r\n    output b_uint: UInt<8>\r\n    input a_sint: SInt<2>\r\n    output b_sint: SInt<8>\r\n    input c: UInt<1>\r\n    b_uint <= dshl(a_uint, c)\r\n    b_sint <= dshl(a_sint, c)\r\n```\r\n\r\nThe SFC will produce, after the `firrtl.passes.PadWidths` transform (`firrtl -i Foo.fir -cll 'firrtl.passes.PadWidths$:trace' && cat Foo.v`):\r\n\r\n```\r\ncircuit Foo :\r\n  module Foo :\r\n    input a_uint : UInt<2>\r\n    output b_uint : UInt<8>\r\n    input a_sint : SInt<2>\r\n    output b_sint : SInt<8>\r\n    input c : UInt<1>\r\n\r\n    b_uint <= pad(dshlw(pad(a_uint, 3), c), 8)\r\n    b_sint <= pad(dshlw(pad(a_sint, 3), c), 8)\r\n```\r\n\r\nAnd the following Verilog:\r\n\r\n```verilog\r\nmodule Foo(\r\n  input  [1:0] a_uint,\r\n  output [7:0] b_uint,\r\n  input  [1:0] a_sint,\r\n  output [7:0] b_sint,\r\n  input        c\r\n);\r\n  wire [2:0] _GEN_0 = {{1'd0}, a_uint};\r\n  wire [2:0] _GEN_1 = _GEN_0 << c;\r\n  wire [2:0] _GEN_2 = {{1{a_sint[1]}},a_sint};\r\n  wire [2:0] _GEN_3 = $signed(_GEN_2) << c;\r\n  assign b_uint = {{5'd0}, _GEN_1};\r\n  assign b_sint = {{5{_GEN_3[2]}},_GEN_3};\r\nendmodule\r\n```\r\n\r\nUsing `firtool` we get (`firtool -verilog Foo.fir`):\r\n\r\n```verilog\r\nmodule Foo(\r\n  input  [1:0] a_uint,\r\n  output [7:0] b_uint,\r\n  input  [1:0] a_sint,\r\n  output [7:0] b_sint,\r\n  input        c);\r\n\r\n  assign b_uint = a_uint << c;\t// Foo.fir:8:{12,15}\r\n  assign b_sint = a_sint << c;\t// Foo.fir:9:{12,15}\r\nendmodule\r\n```\r\n\r\nNote that this style of padding will happen for all other primops, but `dshl` is the only one that results in an operand conversion. \r\n\r\nThis issue doesn't matter for any FIRRTL where optimizations have run (since optimizations include `firrtl.passes.PadWidths`). However, this will crop up when trying to lower SFC unoptimized Low FIRRTL.", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input a_uint: UInt<2>\r\n    output b_uint: UInt<8>\r\n    input a_sint: SInt<2>\r\n    output b_sint: SInt<8>\r\n    input c: UInt<1>\r\n    b_uint <= dshl(a_uint, c)\r\n    b_sint <= dshl(a_sint, c)", "code_snippet_02": "circuit Foo :\r\n  module Foo :\r\n    input a_uint : UInt<2>\r\n    output b_uint : UInt<8>\r\n    input a_sint : SInt<2>\r\n    output b_sint : SInt<8>\r\n    input c : UInt<1>\r\n\r\n    b_uint <= pad(dshlw(pad(a_uint, 3), c), 8)\r\n    b_sint <= pad(dshlw(pad(a_sint, 3), c), 8)", "code_snippet_03": "module Foo(\r\n  input  [1:0] a_uint,\r\n  output [7:0] b_uint,\r\n  input  [1:0] a_sint,\r\n  output [7:0] b_sint,\r\n  input        c\r\n);\r\n  wire [2:0] _GEN_0 = {{1'd0}, a_uint};\r\n  wire [2:0] _GEN_1 = _GEN_0 << c;\r\n  wire [2:0] _GEN_2 = {{1{a_sint[1]}},a_sint};\r\n  wire [2:0] _GEN_3 = $signed(_GEN_2) << c;\r\n  assign b_uint = {{5'd0}, _GEN_1};\r\n  assign b_sint = {{5{_GEN_3[2]}},_GEN_3};\r\nendmodule", "code_snippet_04": "module Foo(\r\n  input  [1:0] a_uint,\r\n  output [7:0] b_uint,\r\n  input  [1:0] a_sint,\r\n  output [7:0] b_sint,\r\n  input        c);\r\n\r\n  assign b_uint = a_uint << c;\t// Foo.fir:8:{12,15}\r\n  assign b_sint = a_sint << c;\t// Foo.fir:9:{12,15}\r\nendmodule"}, {"number": 206, "title": "[FIRRTL] LowerToRTL Unhandled op failure", "created_at": "2020-11-05T23:38:41Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Consider:\r\nmodule {\r\n  firrtl.circuit \"foo\" {\r\n    firrtl.module @bar(%io_cpu_flush: !firrtl.uint<1>) {}\r\n    firrtl.module @foo() {\r\n      %fetch = firrtl.instance @bar {name = \"fetch\"} : !firrtl.bundle<io_cpu_flush: flip<uint<1>>>\r\n      %1454 = firrtl.subfield %fetch(\"io_cpu_flush\") : (!firrtl.bundle<io_cpu_flush: flip<uint<1>>>) -> !firrtl.flip<uint<1>>\r\n      %hits_1_7 = firrtl.node %1454 {name = \"hits_1_7\"} : !firrtl.flip<uint<1>>\r\n      %1455 = firrtl.asPassive %hits_1_7 : (!firrtl.flip<uint<1>>) -> !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n\r\nFIRRTLLowering::handleUnloweredOp inserts a StdIntCast to a flipped type which fails to verify."}, {"number": 204, "title": "FIRRTL memories of depth 1 are not index correctly", "created_at": "2020-11-05T17:53:42Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Consider:\r\n```\r\n\r\ncircuit foo :\r\n\r\n  module foo :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n\r\n    mem bar : @[Decoupled.scala 218:16]\r\n      data-type => UInt<3>\r\n      depth => 1\r\n      read-latency => 0\r\n      write-latency => 1\r\n      reader => io_deq_bits_MPORT\r\n      writer => MPORT\r\n      read-under-write => undefined\r\n    \r\n    bar.io_deq_bits_MPORT.addr <= UInt<1>(\"h0\")\r\n```\r\n\r\nfirtool infers a zero-width address for the memory, but chisel is attaching 1-bit integers to it.", "code_snippet_01": "circuit foo :\r\n\r\n  module foo :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n\r\n    mem bar : @[Decoupled.scala 218:16]\r\n      data-type => UInt<3>\r\n      depth => 1\r\n      read-latency => 0\r\n      write-latency => 1\r\n      reader => io_deq_bits_MPORT\r\n      writer => MPORT\r\n      read-under-write => undefined\r\n    \r\n    bar.io_deq_bits_MPORT.addr <= UInt<1>(\"h0\")"}, {"number": 186, "title": "[All Dialects] Deprecated OpBuilder format", "created_at": "2020-10-28T03:16:01Z", "state": "closed", "labels": "bug", "body": "With #184 we get a bunch of warnings:\r\n```\r\n/home/jodemme/circt/include/circt/Dialect/SV/Statements.td:74:1: warning: Op uses a deprecated, string-based OpBuilder format; use OpBuilderDAG with '(ins <...>)' instead\r\ndef AlwaysAtPosEdgeOp : SVOp<\"alwaysat_posedge\", [HasRegionTerminator]>,\r\n```", "code_snippet_01": "/home/jodemme/circt/include/circt/Dialect/SV/Statements.td:74:1: warning: Op uses a deprecated, string-based OpBuilder format; use OpBuilderDAG with '(ins <...>)' instead\r\ndef AlwaysAtPosEdgeOp : SVOp<\"alwaysat_posedge\", [HasRegionTerminator]>,"}, {"number": 183, "title": "[FIRRTL] Parser fails on negative integer parameters", "created_at": "2020-10-26T23:55:05Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Signed integer parameters will cause the FIRRTL dialect parser to fail. \r\n\r\nConsider the following FIRRTL snippet:\r\n\r\n```\r\ncircuit Foo:\r\n  extmodule Bar:\r\n    parameter A = -1\r\n  module Foo:\r\n    inst bar of Bar\r\n```\r\n\r\nWhen run through the Scala FIRRTL compiler, you get the following Verilog:\r\n\r\n```verilog\r\nmodule Foo(\r\n);\r\n  Bar #(.A(-1)) bar (\r\n  );\r\nendmodule\r\n```\r\n\r\nWhen run through `firtool` you get:\r\n\r\n```bash\r\nfirtool Foo.fir\r\n# Foo.fir:3:19: error: expected '.' in floating point literal\r\n#    parameter A = -1\r\n#                  ^\r\n```\r\n\r\nThis also may motivate a change in the underlying data format of integer parameters. Clearly, something like `-1` needs to be set as a signed integer. However, should unsigned parameters continue to be stored as signless types, should they be unsigned, or should they be signed?", "code_snippet_01": "circuit Foo:\r\n  extmodule Bar:\r\n    parameter A = -1\r\n  module Foo:\r\n    inst bar of Bar", "code_snippet_02": "module Foo(\r\n);\r\n  Bar #(.A(-1)) bar (\r\n  );\r\nendmodule", "code_snippet_03": "firtool Foo.fir\r\n# Foo.fir:3:19: error: expected '.' in floating point literal\r\n#    parameter A = -1\r\n#                  ^"}, {"number": 181, "title": "[FIRRTL] AsAsyncResetPrimOp type check is too restrictive", "created_at": "2020-10-26T17:43:30Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The input type required by `AsAsyncResetPrimOp` is too restrictive. The FIRRTL dialect restricts this to `UInt`, `SInt`, or `Clock` types, but the Scala FIRRTL compiler [allows any FIRRTL type](https://github.com/freechipsproject/firrtl/blob/d1c0181e716c37142e233beed2efcea5c5794aa7/src/main/scala/firrtl/passes/CheckTypes.scala#L217).\r\n\r\nAs one example, the following should not error:\r\n\r\n```\r\ncircuit Foo :\r\n  module Foo :\r\n    input in : AsyncReset\r\n    output out : AsyncReset\r\n\r\n    out <= asAsyncReset(in)\r\n```\r\n\r\nCurrently, this does:\r\n\r\n```bash\r\nfirtool AsyncReset.fir \r\n# AsyncReset.fir:5:12: error: invalid input types for 'asAsyncReset': '!firrtl.asyncreset'\r\n#    out <= asAsyncReset(in)\r\n```", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input in : AsyncReset\r\n    output out : AsyncReset\r\n\r\n    out <= asAsyncReset(in)", "code_snippet_02": "firtool AsyncReset.fir \r\n# AsyncReset.fir:5:12: error: invalid input types for 'asAsyncReset': '!firrtl.asyncreset'\r\n#    out <= asAsyncReset(in)"}, {"number": 180, "title": "[FIRRTL] Parse dshlw", "created_at": "2020-10-26T17:06:34Z", "state": "closed", "labels": "bug, FIRRTL", "body": "The Scala FIRRTL compiler adds an undocumented operand, `dshlw`, in the [`PadWidths` transform](https://github.com/freechipsproject/firrtl/blob/d1c0181e716c37142e233beed2efcea5c5794aa7/src/main/scala/firrtl/passes/PadWidths.scala#L64). This will show up in emitted output if you run a low FIRRTL IR emitter with optimizations turned on, e.g.,:\r\n\r\n```bash\r\nfirrtl -i Foo.fir -X verilog -E low -E verilog\r\n```\r\n\r\nThis operand should (at least) be parsed by the FIRRTL CIRCT dialect for the same reason that we also parse `cmem` and `smem`---we should strive for interoperability with the lone extant FIRRTL compiler implementation.", "code_snippet_01": "firrtl -i Foo.fir -X verilog -E low -E verilog"}, {"number": 164, "title": "[FIRRTL] firrtl.tail needs to be able to return signed results", "created_at": "2020-10-20T15:47:05Z", "state": "closed", "labels": "bug, FIRRTL", "body": "firrtl produces tail operations on sint.  Currently the firrtl dialect requires unsigned results. "}, {"number": 163, "title": "[FIRRTL] module instances can appear before module declarations", "created_at": "2020-10-20T15:46:09Z", "state": "closed", "labels": "bug, FIRRTL", "body": "Output from firrtl can have module instances before module declarations.  firtool rejects these files."}, {"number": 139, "title": "[RTL] Fix EmitVerilog.cpp's handling of signed/unsigned rtl dialect ops like divide, rem, compare, etc", "created_at": "2020-10-12T14:33:50Z", "state": "closed", "labels": "bug, HW", "body": "RTL is currently signed-by-operation, but FIRRTL and verilog are sign-by-operand-type.  RTL to verilog emission is broken for signed operations."}, {"number": 31, "title": "linker error building from master", "created_at": "2020-07-08T03:19:45Z", "state": "closed", "labels": "bug", "body": "I am getting linker errors while building from master\r\n\r\n```\r\n/usr/bin/ld: lib/libMLIRHandshakeOps.a(HandshakeOps.cpp.o): in function `ValueRange<llvm::SmallVector<mlir::Value, 4> &, void>':\r\n/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'\r\nclang-10.0: error: linker command failed with exit code 1 (use -v to see invocation)\r\n```\r\n\r\n```\r\nldl  -ltinfo  -lpthread  -lm  ../llvm/build/lib/libLLVMDemangle.a && :\r\n/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 2> &, void>':\r\n/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'\r\n/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 5> &, void>':\r\n/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'\r\n/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 7> &, void>':\r\n/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'\r\n/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 1> &, void>':\r\n/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'\r\n/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 3> &, void>':\r\n/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'\r\nclang-10.0: error: linker command failed with exit code 1 (use -v to see invocation)\r\n```\r\n\r\nAnybody experiencing similar issues?", "code_snippet_01": "/usr/bin/ld: lib/libMLIRHandshakeOps.a(HandshakeOps.cpp.o): in function `ValueRange<llvm::SmallVector<mlir::Value, 4> &, void>':\r\n/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'\r\nclang-10.0: error: linker command failed with exit code 1 (use -v to see invocation)", "code_snippet_02": "ldl  -ltinfo  -lpthread  -lm  ../llvm/build/lib/libLLVMDemangle.a && :\r\n/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 2> &, void>':\r\n/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'\r\n/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 5> &, void>':\r\n/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'\r\n/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 7> &, void>':\r\n/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'\r\n/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 1> &, void>':\r\n/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'\r\n/usr/bin/ld: lib/libMLIRLLHDToLLVM.a(LLHDToLLVM.cpp.o): in function `ValueRange<std::array<mlir::Value, 3> &, void>':\r\n/home/drom/work/github/circt/circt/build/../llvm/mlir/include/mlir/IR/OperationSupport.h:890: undefined reference to `mlir::ValueRange::ValueRange(llvm::ArrayRef<mlir::Value>)'\r\nclang-10.0: error: linker command failed with exit code 1 (use -v to see invocation)"}, {"number": 2, "title": "\"reg\" is invalid Verilog identifier", "created_at": "2020-04-30T05:30:38Z", "state": "closed", "labels": "bug, ExportVerilog", "body": "Like many other Verilog keywords, `reg` is an invalid identifier.\r\n\r\nhttps://github.com/sifive/clattner-experimental/blob/d231ef24235ce132fd93c313771c56888161e482/test/EmitVerilog/verilog-basic.fir#L343\r\n"}]