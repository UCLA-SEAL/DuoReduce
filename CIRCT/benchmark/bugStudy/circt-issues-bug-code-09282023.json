[{"number": 6193, "code_snippet_01": "#0 0x00007ff7b9dca204 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x1fa204)\r\n #1 0x00007ff7b9dd00a1 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x2000a1)\r\n #2 0x00007ff7ba5f0107 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa20107)\r\n #3 0x00007ff7ba5f5a27 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa25a27)\r\n #4 0x00007ff7ba5f7529 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa27529)\r\n #5 0x00007ff7ba5f0616 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa20616)\r\n #6 0x00007ff7ba5f6ee2 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa26ee2)\r\n #7 0x00007ff7ba5f00f2 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa200f2)\r\n #8 0x00007ff7ba5f5a27 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa25a27)\r\n #9 0x00007ff7ba5f61fd (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa261fd)\r\n#10 0x00007ff7b9be0544 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x10544)\r\n#11 0x00007ff7b9be09ff (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x109ff)\r\n#12 0x00007ff7b9bdee3b (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xee3b)\r\n#13 0x00007ff7b9be26df (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x126df)\r\n#14 0x00007ff7ba60d560 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa3d560)\r\n#15 0x00007ffe8a4c7ac4 (C:\\Windows\\System32\\KERNEL32.DLL+0x17ac4)\r\n#16 0x00007ffe8bfda351 (C:\\Windows\\SYSTEM32\\ntdll.dll+0x5a351)", "code_snippet_02": "WARNING: Unable to resolve package source 'https://www.powershellgallery.com/api/v2'.\r\nInstall-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all\r\navailable registered module repositories.\r\n\r\nError: Process completed with exit code 1.", "code_snippet_03": "Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all\r\navailable registered module repositories.\r\n\r\nError: Process completed with exit code 1."}, {"number": 6074, "code_snippet_01": "firrtl.circuit \"ClockProbe\" {\r\n  firrtl.module @ClockProbe(in %in: !firrtl.clock, out %out: !firrtl.clock) attributes {convention = #firrtl<convention scalarized>} {\r\n    %0 = firrtl.ref.send %in : !firrtl.clock\r\n    %1 = firrtl.ref.resolve %0 : !firrtl.probe<clock>\r\n    firrtl.strictconnect %out, %1 : !firrtl.clock\r\n  }\r\n}", "code_snippet_02": "LLVM ERROR: can't create type 'circt::seq::ClockType' because storage uniquer isn't initialized: the dialect was likely not loaded, or the type wasn't added with addTypes<...>() in the Dialect::initialize() method.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/circt-opt --firrtl-lower-xmr ./clock-probe.mlir"}, {"number": 6059, "code_snippet_01": "// -----\r\n// Test that annotations keep ports alive.\r\n// CHECK-LABEL: \"AnnoAlivePort\"\r\nfirrtl.circuit \"AnnoAlivePort\" {\r\n  // CHECK: module private @AnnoPort\r\n  firrtl.module private @AnnoPort(out %dead : !firrtl.uint<5> [{class = \"circt.test\"}]) {}\r\n  firrtl.module @AnnoAlivePort() {\r\n    // CHECK: firrtl.instance\r\n    %inst_dead = firrtl.instance inst @AnnoPort(out dead : !firrtl.uint<5>)\r\n  }\r\n}", "code_snippet_02": "firrtl.circuit \"AnnoAlivePort\" {\r\n  firrtl.module private @AnnoPort() {\r\n    %0 = firrtl.wire : !firrtl.uint<5>\r\n  }\r\n  firrtl.module @AnnoAlivePort() {\r\n    firrtl.instance inst @AnnoPort()\r\n  }\r\n}"}, {"number": 6013, "code_snippet_01": "FIRRTL version 4.0.0\r\ncircuit RANDOM:\r\n  module RANDOM:\r\n    input clock: Clock\r\n    input d: UInt<1>\r\n    output q: UInt<1>\r\n\r\n    reg r: UInt<1>, clock\r\n\r\n    connect r, d\r\n    connect q, r", "code_snippet_02": "<unknown>:0: error: Referenced macro doesn't exist \"ENABLE_INITIAL_MEM_\"\r\n<unknown>:0: note: see current operation: \"sv.macro.def\"() {format_string = \"\", macroName = @ENABLE_INITIAL_MEM_, symbols = []} : () -> ()"}, {"number": 5886, "code_snippet_01": "circuit ResetEnum:\r\n  module ResetEnum:\r\n    input in : {| Some: UInt<1> |}\r\n    output out: {| Some: Reset |}\r\n    out <= in"}, {"number": 5884, "code_snippet_01": "circuit EnumConst:\r\n  module EnumConst:\r\n    input e : {| Some : const UInt<8>, None |}", "code_snippet_02": "circuit ConstEnumConst:\r\n  module ConstEnumConst:\r\n    input e : const {| Some : const UInt<8>, None |}"}, {"number": 5772, "code_snippet_01": "hw.type_scope @__hw_typedecls {\r\n  hw.typedecl @foo : i1\r\n}\r\n\r\nhw.module @Top(%arg0: !hw.typealias<@__hw_typedecls::@foo,i1>) {\r\n  %0 = comb.concat %arg0 : !hw.typealias<@__hw_typedecls::@foo,i1>\r\n}", "code_snippet_02": "circt-opt: /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ./build/bin/circt-opt foo.mlir\r\n1.      MLIR Parser: custom op parser 'hw.module'\r\n2.      MLIR Parser: custom op parser 'comb.concat'\r\n #0 0x0000000000447057 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x00000000004451e0 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x000000000044796f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007fe418fd6cf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)\r\n #4 0x00007fe417e61aff raise (/lib64/libc.so.6+0x4eaff)\r\n #5 0x00007fe417e34ea5 abort (/lib64/libc.so.6+0x21ea5)\r\n #6 0x00007fe417e34d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)\r\n #7 0x00007fe417e5a456 (/lib64/libc.so.6+0x47456)\r\n #8 0x0000000000609c3b (./build/bin/circt-opt+0x609c3b)\r\n #9 0x000000000060c749 circt::comb::ConcatOp::inferReturnTypes(mlir::MLIRContext*, std::optional<mlir::Location>, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::RegionRange, llvm::SmallVectorImpl<mlir::Type>&) /scratch/hidetou/circt/lib/Dialect/Comb/CombOps.cpp:270:21\r\n#10 0x000000000060c749 circt::comb::ConcatOp::parse(mlir::OpAsmParser&, mlir::OperationState&) /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/Comb/Comb.cpp.inc:948:22\r\n#11 0x00000000014d521f mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#12 0x00000000014d521f mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43\r\n#13 0x00000000014d521f (anonymous namespace)::CustomOpAsmParser::parseOperation(mlir::OperationState&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1491:9\r\n#14 0x00000000014d521f (anonymous namespace)::OperationParser::parseCustomOperation(llvm::ArrayRef<std::tuple<llvm::StringRef, unsigned int, llvm::SMLoc>>) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1987:19\r\n#15 0x00000000014d521f (anonymous namespace)::OperationParser::parseOperation() /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1146:10\r\n#16 0x00000000014e0ac0 mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#17 0x00000000014e0ac0 mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43\r\n#18 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlockBody(mlir::Block*) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2263:9\r\n#19 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2193:12"}, {"number": 5727, "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [\"a\", \"a\"]} {\r\n    %b = firrtl.wire interesting_name : !firrtl.uint<1>\r\n    %0 = firrtl.ref.send %b : !firrtl.uint<1>\r\n    firrtl.ref.define %a, %0 : !firrtl.probe<uint<1>>\r\n    %1 = firrtl.ref.send %b : !firrtl.uint<1>\r\n    firrtl.ref.define %a0, %1 : !firrtl.probe<uint<1>>\r\n  }\r\n}", "code_snippet_02": "# circt-opt Foo.mlir -firrtl-lower-xmr                                   \r\nfirrtl-snippets/issues/x.mlir:3:5: error: redefinition of symbol named 'ref_Foo_Foo_a'\r\n    firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [\"a\", \"a\"]} {\r\n    ^\r\nfirrtl-snippets/issues/x.mlir:3:5: note: see current operation: \"sv.macro.decl\"() {sym_name = \"ref_Foo_Foo_a\"} : () -> ()\r\nfirrtl-snippets/issues/x.mlir:3:5: note: see existing symbol definition here"}, {"number": 5721, "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo() {\r\n    %0 = firrtl.wire {name = \"a\"} : !firrtl.uint<1>\r\n    %1 = firrtl.wire {name = \"a\"} : !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_02": "FIRRTL version 3.1.0\r\ncircuit Foo :\r\n  module Foo : \r\n    wire a : UInt<1> \r\n    wire a : UInt<1>"}, {"number": 5590, "code_snippet_01": "module {\r\n  firrtl.circuit \"OMIRField\" {\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0>, out %y_b: !firrtl.uint<0>) {\r\n      %n_b = firrtl.node sym @omir_sym %x_b : !firrtl.uint<0>\r\n      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>\r\n    }\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n}", "code_snippet_02": "module {\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n  hw.module @OMIRField() {\r\n    hw.output\r\n  }\r\n}", "code_snippet_03": "omir_zw_field_issue.mlir:8:3: error: cannot get name for symbol #hw.innerNameRef<@OMIRField::@omir_sym>\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n  ^\r\nomir_zw_field_issue.mlir:8:3: note: see current operation: \"sv.verbatim\"() {format_string = \"Testing {{0}}\", symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]} : () -> ()\r\n// Generated by CIRCT 1.46.0g20230714_98d0bf5\r\nTesting <INVALID>\t// omir_zw_field_issue.mlir:8:3\r\nmodule OMIRField();\t// omir_zw_field_issue.mlir:3:5\r\nendmodule", "code_snippet_04": "module {\r\n  firrtl.circuit \"OMIRField\" {\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {\r\n      %n_b = firrtl.node %x_b : !firrtl.uint<0>\r\n      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>\r\n    }\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n}", "code_snippet_05": "omir_zw_field_issue.mlir:3:33: error: zero width port \"x_b\" is referenced by name [#hw<innerSym@omir_sym>] (e.g. in an XMR) but must be removed\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {\r\n                                ^"}, {"number": 5566, "code_snippet_01": "hw.module @unsupported(%a: !hw.inout<i42>) {\r\n  %clock = hw.constant 1 : i1\r\n  %c42 = hw.constant 42 : i42\r\n  sv.alwaysff(posedge %clock) {\r\n    sv.passign %a, %c42 : i42\r\n  }\r\n}"}, {"number": 5562, "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo() {}\r\n  firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.probe<uint<1>>) {\r\n    %0 = firrtl.ref.send %a : !firrtl.uint<1>\r\n    firrtl.ref.define %b, %0 : !firrtl.probe<uint<1>>\r\n  }\r\n}", "code_snippet_02": "Assertion failed: ((!result || !isa<FIRRTLType>(result.getType())) && \"Lowering didn't turn a FIRRTL value into a non-FIRRTL value\"), function setLowering, file LowerToHW.cpp, line 2338."}, {"number": 5483, "code_snippet_01": "module {\r\n  hw.module @EXPLODE(%0: i64, %1: i64) -> (arg1: i64, arg2: i64) {\r\n    %2 = hw.struct_create (%0, %1) : !hw.struct<arg1: i64, arg2: i64>\r\n    %arg1, %arg2 = hw.struct_explode %2 : !hw.struct<arg1: i64, arg2: i64>\r\n\r\n    hw.output %arg1, %arg2 : i64, i64\r\n  }\r\n}", "code_snippet_02": "circt-opt: circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:3295:\r\nvoid (anonymous namespace)::NameCollector::collectNames(mlir::Block &): \r\nAssertion `(!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options))\r\n && \"If 'op' is a verilog expression, the expression must be inlinable. \" \r\n \"Otherwise, it is a bug of PrepareForEmission\"' failed."}, {"number": 5462, "code_snippet_01": "circuit Loop:\r\n  module Loop:\r\n    wire w : {a: UInt<8>}\r\n    node n = w\r\n    w <= n", "code_snippet_02": "circuit Loop:\r\n  module Child:\r\n    input bundle : { a : UInt<1>, b : UInt<1> }\r\n    output p : {a : UInt<1>, b : UInt<1> }\r\n\r\n    node n = bundle\r\n\r\n    p <= n\r\n  module Loop:\r\n    input x : UInt<1>\r\n\r\n    inst c of Child\r\n    c.bundle.a <= x\r\n    c.bundle.b <= c.p.b", "code_snippet_03": "circuit Loop:\r\n  module Loop:\r\n    input in : {a: UInt<8>}\r\n    output out : {a: UInt<8>}\r\n    input c : UInt<1>\r\n\r\n    wire w : {a: UInt<8>}\r\n    node n = w\r\n    w <= mux(c, n, in)\r\n\r\n    out <= w"}, {"number": 5447}, {"number": 5355, "code_snippet_01": "$ ./build/bin/firtool perf/regress/chipyard.TestHarness.RocketSmall1Medium1Big1_BoomMedium1Large1Mega1.top.v.hi.fir -o foo.sv --lowering-options=disallowLocalVariables,disallowPackedArrays\r\nArbiters.scala:42:16: error: unsupported packed array expression\r\nArbiters.scala:42:16: note: see current operation: %57 = \"hw.array_concat\"(%3, %56) : (!hw.array<3xi1>, !hw.array<5xi1>) -> !hw.array<8xi1>"}, {"number": 5205, "code_snippet_01": "firrtl.circuit \"ProbeConstant\" {\r\n  firrtl.module @ProbeConstant(out %bore: !firrtl.probe<uint<1>>) {\r\n    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1> {name = \"internalWire\"}\r\n    %0 = firrtl.ref.send %c0_ui1 : !firrtl.uint<1>\r\n    firrtl.ref.define %bore, %0 : !firrtl.probe<uint<1>>\r\n  }\r\n}", "code_snippet_02": "circuit ProbeConstant :\r\n  module ProbeConstant :\r\n    output bore : Probe<UInt<1>>\r\n\r\n    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]", "code_snippet_03": "<stdin>:5:25: error: use of unknown declaration 'UInt'\r\n    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]"}, {"number": 5204, "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(in %clock: !firrtl.clock, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>\r\n    %0 = firrtl.wire : !firrtl.uint<1>\r\n    %r = firrtl.regreset interesting_name %clock, %c1_ui1, %0 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.strictconnect %0, %r : !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_02": "Assertion failed: (!s->text().empty() && \"empty string token\"), function operator(), file PrettyPrinter.cpp, line 91.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: circt-translate -export-firrtl Bar.mlir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  circt-translate          0x00000001079167ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  circt-translate          0x0000000107916d5b PrintStackTraceSignalHandler(void*) + 27\r\n2  circt-translate          0x0000000107914896 llvm::sys::RunSignalHandlers() + 134\r\n3  circt-translate          0x0000000107918b8f SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff81820c5ed _sigtramp + 29\r\n5  libsystem_platform.dylib 0x00007ff7b877dd20 _sigtramp + 18446744072104646480\r\n6  libsystem_c.dylib        0x00007ff818105b45 abort + 123\r\n7  libsystem_c.dylib        0x00007ff818104e5e err + 0\r\n8  circt-translate          0x0000000108746000 circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1::operator()(circt::pretty::StringToken*) const + 176\r\n9  circt-translate          0x0000000108745ee8 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::TypeSwitch<circt::pretty::Token*, void>::Case<circt::pretty::StringToken, circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 88\r\n10 circt-translate          0x0000000108744af5 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<circt::pretty::Token*, void>, circt::pretty::Token*>::Case<circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 53\r\n11 circt-translate          0x0000000108744a03 circt::pretty::PrettyPrinter::add(circt::pretty::Token) + 99\r\n12 circt-translate          0x000000010819d235 std::__1::enable_if<std::is_base_of_v<circt::pretty::Token, circt::pretty::StringToken>, void>::type circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::add<circt::pretty::StringToken, llvm::StringRef&>(llvm::StringRef&) + 101\r\n13 circt-translate          0x000000010819d1c1 circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::literal(llvm::StringRef) + 33\r\n14 circt-translate          0x000000010819c118 circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::operator<<(circt::pretty::PPExtString const&) + 56\r\n15 circt-translate          0x00000001081c2fa8 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5::operator()() const + 104\r\n16 circt-translate          0x00000001081c2f35 decltype(static_cast<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(fp)()) std::__1::__invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 21\r\n17 circt-translate          0x00000001081c2e5d std::__1::invoke_result<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>::type std::__1::invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 29\r\n18 circt-translate          0x00000001081c2d96 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(circt::pretty::PP&&, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&, circt::pretty::Token) + 102\r\n19 circt-translate          0x00000001081c2d13 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp) + 179\r\n20 circt-translate          0x00000001081c2808 auto (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16::operator()<circt::firrtl::WireOp>(circt::firrtl::WireOp) const + 40\r\n21 circt-translate          0x00000001081c278b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::WireOp, (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&>((anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&) + 107\r\n22 circt-translate          0x000000010819ea0d (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&) + 365\r\n23 circt-translate          0x000000010819e669 (anonymous namespace)::Emitter::emitModule(circt::firrtl::FModuleOp)::$_1::operator()() const + 217"}, {"number": 5202, "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    reg r: UInt<1>, clock with: (reset => (UInt<1>(1), r))\r\n\r\n    r <= a\r\n    b <= r", "code_snippet_02": "module Foo(\r\n  input  clock,\r\n         a,\r\n  output b\r\n);\r\n\r\n  reg r;\r\n  always @(posedge clock)\r\n    r <= a;\r\n  assign b = r;\r\nendmodule", "code_snippet_03": "module Foo(\r\n  input   clock,\r\n  input   a,\r\n  output  b\r\n);\r\n  assign b = 1'h0;\r\nendmodule"}, {"number": 5031}, {"number": 4921, "code_snippet_01": "module {\r\n  firrtl.circuit \"Unreachable\" {\r\n    hw.hierpath private @nla_5560 [@Unreachable::@w, @Bar2]\r\n    hw.hierpath private @nla_5561 [@Bar1::@w, @Bar3]\r\n    firrtl.module private @Bar2() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      %x = firrtl.wire sym @x {annotations = [{circt.nonlocal = @nla_5560, class = \"test0\"}]} : !firrtl.uint<8>\r\n      firrtl.instance no sym @no @Bar1()\r\n    }\r\n    firrtl.module private @Bar1() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      firrtl.instance bar3 sym @w @Bar3()\r\n    }\r\n    firrtl.module private @Bar3() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @nla_5561, class = \"test0\"}]} : !firrtl.uint<8>\r\n    }\r\n    firrtl.module @Unreachable() {\r\n      firrtl.instance no sym @no @Bar1()\r\n      firrtl.instance bar2 sym @w @Bar2()\r\n    }\r\n  }\r\n}", "code_snippet_02": "the default constructor for MutableNLA should never be used\r\nUNREACHABLE executed at /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:130!", "code_snippet_03": "* thread #1, name = 'circt-opt', stop reason = signal SIGABRT\r\n  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295\r\n    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22\r\n    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215\r\n    frame #3: 0x00005555561857bf circt-opt`llvm::llvm_unreachable_internal(msg=<unavailable>, file=<unavailable>, line=<unavailable>) at ErrorHandling.cpp:212:3\r\n    frame #4: 0x0000555556788dba circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] (anonymous namespace)::MutableNLA::MutableNLA(this=<unavailable>) at ModuleInliner.cpp:129:5\r\n    frame #5: 0x0000555556788d2e circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>* llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (this=<unavailable>, TheBucket=<unavailable>, Key=0x00007fffffff3db8)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::InsertIntoBucket<mlir::Attribute const&>(llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>*, mlir::Attribute const&) at DenseMap.h:563:37\r\n    frame #6: 0x0000555556788d20 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::FindAndConstruct(this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:339:13\r\n    frame #7: 0x0000555556788ce2 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:343:12\r\n    frame #8: 0x0000555556789f68 circt-opt`(anonymous namespace)::Inliner::setActiveHierPaths(this=0x00007fffffff4588, moduleName=StringAttr @ rbx, instInnerSym=StringAttr @ scalar) at ModuleInliner.cpp:596:11\r\n    frame #9: 0x000055555678e194 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=(Data = \"bar2_\", Length = 5), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, beb=0x00007fffffff41a0, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3f18, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1094:5\r\n    frame #10: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7\r\n    frame #11: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7\r\n    frame #12: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13\r\n    frame #13: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17\r\n    frame #14: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #15: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #16: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000330afe0, irUnits=ArrayRef<mlir::IRUnit> @ 0x000000000331dee0, args=0x0000555557bfe4f0)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #17: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfe4f0, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #18: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be0d10, op=0x0000555557bfd560, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16\r\n    frame #19: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557c00380)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36\r\n    frame #20: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18\r\n    frame #21: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10\r\n    frame #22: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14\r\n    frame #23: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5\r\n    frame #24: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20\r\n    frame #25: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #26: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #27: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003435460, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000038b4fc0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #28: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #29: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16\r\n    frame #30: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfd5c0, am=AnalysisManager @ scalar) at Pass.cpp:857:10\r\n    frame #31: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfd5c0) at Pass.cpp:837:60\r\n    frame #32: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc9000, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17\r\n    frame #33: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12\r\n    frame #34: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12\r\n    frame #35: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12\r\n    frame #36: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12\r\n    frame #37: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12\r\n    frame #38: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10\r\n    frame #39: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14\r\n    frame #40: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23\r\n    frame #41: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126\r\n    frame #42: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137\r\n    frame #43: 0x0000555556160415 circt-opt`_start + 37"}, {"number": 4896, "code_snippet_01": "module {\r\n  firrtl.circuit \"Oops\" {\r\n    firrtl.module private @Child() attributes {annotations = [{circt.nonlocal = @nla, class = \"circt.test\"}]} {\r\n    }\r\n    firrtl.module @Oops() {\r\n      firrtl.instance child @Child()\r\n    }\r\n  }\r\n}"}, {"number": 4886, "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.FullAsyncResetAnnotation\",\r\n    \"target\":\"~Top|FullAsyncWrapper>rf_reset\"\r\n  }\r\n]]\r\n  module Child :\r\n    input clock : Clock\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    reg r : UInt<8>, clock\r\n    r <= foo\r\n    bar <= r\r\n\r\n  module FullAsyncWrapper :\r\n    input clock : Clock\r\n    input rf_reset : AsyncReset\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    inst c of Child\r\n    c.clock <= clock\r\n    c.foo <= foo\r\n    bar <= c.bar\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input rf_reset : AsyncReset\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    inst wrap of FullAsyncWrapper\r\n    wrap.clock <= clock\r\n    wrap.rf_reset <= rf_reset\r\n    wrap.foo <= foo\r\n\r\n    inst child of Child\r\n    child.clock <= clock\r\n    child.foo <= foo\r\n\r\n    bar <= and(wrap.bar, child.bar)", "code_snippet_02": "test.fir:7:10: error: module 'Child' instantiated in different reset domains\r\n  module Child :\r\n         ^\r\ntest.fir:7:10: note: see current operation: \r\n\"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<8>, %arg2: !firrtl.uint<8>):\r\n  %0 = \"firrtl.reg\"(%arg0) {annotations = [], name = \"r\", nameKind = #firrtl<name_kind droppable_name>} : (!firrtl.clock) -> !firrtl.uint<8>\r\n  \"firrtl.strictconnect\"(%0, %arg1) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()\r\n  \"firrtl.strictconnect\"(%arg2, %0) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()\r\n}) {annotations = [], portAnnotations = [], portDirections = -4 : i3, portLocations = [loc(\"test.fir\":8:11), loc(\"test.fir\":9:11), loc(\"test.fir\":10:12)], portNames = [\"clock\", \"foo\", \"bar\"], portSyms = [], portTypes = [!firrtl.clock, !firrtl.uint<8>, !firrtl.uint<8>], sym_name = \"Child\", sym_visibility = \"private\"} : () -> ()\r\ntest.fir:22:5: note: instance 'wrap/c' is in reset domain rooted at 'rf_reset' of module 'FullAsyncWrapper'\r\n    inst c of Child\r\n    ^\r\ntest.fir:18:11: note: reset domain 'rf_reset' of module 'FullAsyncWrapper' declared here:\r\n    input rf_reset : AsyncReset\r\n          ^\r\ntest.fir:38:5: note: instance 'child' is in no reset domain\r\n    inst child of Child\r\n    ^"}, {"number": 4849, "code_snippet_01": "module {\r\n  sv.interface @wire {}\r\n  hw.module private @Foo() {\r\n    %module = sv.interface.instance : !sv.interface<@wire>\r\n    hw.output\r\n  }\r\n}", "code_snippet_02": "// Generated by CIRCT unknown git version\r\ninterface module_0;\r\nendinterface\r\n\r\nmodule Foo();\t// Foo.mlir:3:3\r\n  wire_0 module();\t// Foo.mlir:4:15\r\nendmodule"}, {"number": 4842, "code_snippet_01": "$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --canonicalize --lower-calyx-to-fsm", "code_snippet_02": "$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm\r\ncirct-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed", "code_snippet_03": "circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm   \r\ncirct-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ../../circt/build/bin/circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm\r\n #0 0x000055d161ee52d4 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:22\r\n #1 0x000055d161ee56a6 PrintStackTraceSignalHandler(void*) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:676:1\r\n #2 0x000055d161ee2d57 llvm::sys::RunSignalHandlers() /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Signals.cpp:104:20\r\n #3 0x000055d161ee4c32 SignalHandler(int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #4 0x00007f117de51f50 (/usr/lib/libc.so.6+0x38f50)\r\n #5 0x00007f117dea08ec (/usr/lib/libc.so.6+0x878ec)\r\n #6 0x00007f117de51ea8 raise (/usr/lib/libc.so.6+0x38ea8)\r\n #7 0x00007f117de3b53d abort (/usr/lib/libc.so.6+0x2253d)\r\n #8 0x00007f117de3b45c (/usr/lib/libc.so.6+0x2245c)\r\n #9 0x00007f117de4a9f6 (/usr/lib/libc.so.6+0x319f6)\r\n#10 0x000055d1621313f5 llvm::SmallVectorTemplateCommon<std::pair<mlir::Operation*, circt::fsm::StateOp>, void>::front() /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:304:17\r\n#11 0x000055d16212bf8b (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:196:26\r\n#12 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#13 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#14 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#15 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#16 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#17 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#18 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#19 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#20 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#21 0x000055d16212b958 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp)::'lambda'(mlir::Value, llvm::StringRef, bool, mlir::Operation*)::operator()(mlir::Value, llvm::StringRef, bool, mlir::Operation*) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:147:15\r\n#22 0x000055d16212bb0e (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:153:13\r\n#23 0x000055d16212dbe3 auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::IfOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#24 0x000055d16212dc60 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::IfOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#25 0x000055d16212b320 Case<circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#26 0x000055d16212b320 Case<circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42\r\n#27 0x000055d16212b320 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42\r\n#28 0x000055d16212b320 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#29 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#30 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#31 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#32 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#33 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#34 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#35 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#36 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#37 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#38 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#39 0x000055d16212cada (anonymous namespace)::CalyxToFSMPass::runOnOperation() /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:307:13\r\n#40 0x000055d164764cc4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:471:27\r\n#41 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15\r\n#42 0x000055d1647660e8 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:754:47\r\n#43 0x000055d164768e17 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:46:17\r\n#44 0x000055d1647681df mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:94:1\r\n#45 0x000055d164766627 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:764:13\r\n#46 0x000055d164765ab9 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:658:1\r\n#47 0x000055d164764ca5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:468:28\r\n#48 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15\r\n#49 0x000055d164766e06 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:843:40\r\n#50 0x000055d164766c66 mlir::PassManager::run(mlir::Operation*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:823:69\r\n#51 0x000055d16397c887 performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:175:13\r\n#52 0x000055d16397ccf5 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPool*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:221:26\r\n#53 0x000055d16397ce21 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:262:25\r\n#54 0x000055d16397dcd2 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:52\r\n#55 0x000055d1639bae6b llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n#56 0x000055d1639ba6ff mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:28:30\r\n#57 0x000055d16397cfd2 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:265:31\r\n#58 0x000055d16397d8cf mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:354:13\r\n#59 0x000055d161ddc13e main /home/xerpi/Desktop/Research/circt/tools/circt-opt/circt-opt.cpp:70:22\r\n#60 0x00007f117de3c790 (/usr/lib/libc.so.6+0x23790)\r\n#61 0x00007f117de3c84a __libc_start_main (/usr/lib/libc.so.6+0x2384a)\r\n#62 0x000055d161ddbec5 _start (../../circt/build/bin/circt-opt+0x119ec5)\r\nAborted (core dumped)"}, {"number": 4834, "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\": \"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"~Top|DUTModule\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top>memTap\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.MemTapAnnotation\",\r\n    \"source\":\"~Top|DUTModule>rf\",\r\n    \"sink\":[\r\n      \"~Top|Top>memTap[0]\",\r\n      \"~Top|Top>memTap[1]\",\r\n      \"~Top|Top>memTap[2]\",\r\n      \"~Top|Top>memTap[3]\",\r\n      \"~Top|Top>memTap[4]\",\r\n      \"~Top|Top>memTap[5]\",\r\n      \"~Top|Top>memTap[6]\",\r\n      \"~Top|Top>memTap[7]\"\r\n    ]\r\n  },\r\n  {\r\n    \"class\": \"firrtl.passes.InlineAnnotation\",\r\n    \"target\": \"~Top|DUTModule\"\r\n  }\r\n]]\r\n  module DUTModule :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    cmem rf : UInt<8> [8]\r\n    infer mport read = rf[io.addr], clock\r\n    io.dataOut <= read\r\n    when io.wen :\r\n      infer mport write = rf[io.addr], clock\r\n      write <= io.dataIn\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    inst dut of DUTModule\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    wire memTap : UInt<8>[8]\r\n    memTap is invalid\r\n    io.dataOut <= dut.io.dataOut\r\n    dut.io.wen <= io.wen\r\n    dut.io.dataIn <= io.dataIn\r\n    dut.io.addr <= io.addr"}, {"number": 4816}, {"number": 4780, "code_snippet_01": "circuit wut :\r\n   module wut :\r\n     output rwDataOut : UInt<8>\r\n\r\n     rwDataOut <= rwDataOut", "code_snippet_02": "firtool: /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:190: void mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith(ValueT &&) [OperandType = mlir::OpOperand, ValueT = mlir::Value &]: Assertion `(!newValue || this != OperandType::getUseList(newValue)) && \"cannot RAUW a value with itself\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool wut.fir\r\n #0 0x00000000006c71bb llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x00000000006c5450 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x00000000006c786d SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007f882063dbf0 __restore_rt (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3dbf0)\r\n #4 0x00007f882068abc7 __pthread_kill_implementation (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x8abc7)\r\n #5 0x00007f882063db46 gsignal (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3db46)\r\n #6 0x00007f88206284b5 abort (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x284b5)\r\n #7 0x00007f88206283d9 _nl_load_domain.cold.0 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x283d9)\r\n #8 0x00007f88206367b6 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x367b6)\r\n #9 0x0000000000a5476c std::enable_if<!(std::is_convertible<mlir::ValueRange&, mlir::Operation*>::value), void>::type mlir::ResultRange::replaceAllUsesWith<mlir::ValueRange&>(mlir::ValueRange&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/ValueRange.h:271:5\r\n#10 0x0000000000a52ec3 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:275:61\r\n#11 0x0000000000c31cb7 circt::sv::WireOp::canonicalize(circt::sv::WireOp, mlir::PatternRewriter&) /home/will/src/sifive/circt/lib/Dialect/SV/SVOps.cpp:1460:18\r\n#12 0x0000000000e0ccb7 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25\r\n#13 0x0000000000dd93ed (anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:229:19\r\n#14 0x0000000000dd702d (anonymous namespace)::RegionPatternRewriteDriver::simplify() && /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:458:15\r\n#15 0x0000000000dd702d mlir::applyPatternsAndFoldGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:487:47\r\n#16 0x0000000000a66148 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#17 0x0000000000a66148 mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:115:70\r\n#18 0x0000000000a66148 (anonymous namespace)::Canonicalizer::runOnOperation() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:61:9\r\n#19 0x0000000000ee9829 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11\r\n#20 0x0000000000ee9e61 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#21 0x0000000000ee9e61 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#22 0x0000000000ee9e61 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#23 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::size() const /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:919:66\r\n#24 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1045:2\r\n#25 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5\r\n#26 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18\r\n#27 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#28 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14\r\n#29 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5\r\n#30 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14\r\n#31 0x0000000000eec3a3 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#32 0x0000000000eec3a3 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#33 0x0000000000eec3a3 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#34 0x0000000000eec3a3 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:843:10\r\n#35 0x0000000000eec3a3 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:823:60\r\n#36 0x000000000061a57b mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#37 0x000000000061a57b mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#38 0x000000000061a57b processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:856:7\r\n#39 0x00000000006182bf processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:12\r\n#40 0x0000000000617f42 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:968:12\r\n#41 0x0000000000617f42 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1058:14\r\n#42 0x00000000006179f6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#43 0x00000000006179f6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#44 0x00000000006179f6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1122:8\r\n#45 0x00007f882062924e __libc_start_call_main (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x2924e)\r\n#46 0x00007f8820629309 __libc_start_main@GLIBC_2.2.5 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x29309)\r\n#47 0x0000000000617825 _start (./build/bin/firtool+0x617825)\r\nzsh: IOT instruction (core dumped)  ./build/bin/firtool wut.fir", "code_snippet_03": "// -----// IR Dump Before Canonicalizer (canonicalize) //----- //\r\nhw.module @wut() -> (rwDataOut: i8) {\r\n  %.rwDataOut.output = sv.wire : !hw.inout<i8>\r\n  %0 = sv.read_inout %.rwDataOut.output : !hw.inout<i8>\r\n  sv.assign %.rwDataOut.output, %0 : i8\r\n  hw.output %0 : i8\r\n}"}, {"number": 4771, "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    output d : { a: UInt<2>, b: Analog<1>}\r\n    input c : UInt<1>\r\n    d is invalid\r\n    when c :\r\n      inst b of Bar\r\n      attach(d.b, b.b.b[c])\r\n    else :\r\n      inst b2 of Bar\r\n      attach(d.b, b2.b.b[c])\r\n\r\n  extmodule Bar :\r\n    output b : { a : UInt<2>, b : Analog<1>[2]}", "code_snippet_02": "analog.fir:11:11: error: operand isn't an inout type\r\n      d.b <- b2.b.b[c]\r\n          ^\r\nanalog.fir:11:11: note: see current operation: \"firrtl.attach\"(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()\r\nanalog.fir:11:11: error: 'firrtl.attach' op LowerToHW couldn't handle this operation\r\n      d.b <- b2.b.b[c]\r\n          ^\r\nanalog.fir:11:11: note: see current operation: \"firrtl.attach\"(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()"}, {"number": 4770, "code_snippet_01": "hw.module.extern @parameter ()", "code_snippet_02": "verilog-error.mlir:4:1: error: name \"parameter\" is not allowed in Verilog output\r\nhw.module.extern @parameter ()\r\n^\r\nverilog-error.mlir:4:1: note: see current operation: \r\n\"hw.module.extern\"() ({\r\n}) {argLocs = [], argNames = [], comment = \"\", function_type = () -> (), parameters = [], resultLocs = [], resultNames = [], sym_name = \"parameter\"} : () -> ()\r\n// Generated by CIRCT 1.34.0g20230304_3ddf879\r\n// external module parameter"}, {"number": 4753, "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input a: UInt<8>[3]\r\n    output b: UInt<8>\r\n\r\n    b <= a[UInt<99>(300)]", "code_snippet_02": "Foo.fir:6:12: error: out of range index '300' in vector type '!firrtl.vector<uint<8>, 3>'\r\n    b <= a[UInt<99>(300)]\r\n           ^\r\nLLVM ERROR: Failed to infer result type(s).\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: firtool Foo.fir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x00000001039cf21d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x00000001039cf79b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x00000001039cd566 llvm::sys::RunSignalHandlers() + 134\r\n3  firtool                  0x00000001039d14cf SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff80f497dfd _sigtramp + 29\r\n5  firtool                  0x00000001037856e5 std::__1::__libcpp_deallocate(void*, unsigned long, unsigned long) + 85\r\n6  libsystem_c.dylib        0x00007ff80f3cdd24 abort + 123\r\n7  firtool                  0x000000010389f2d4 llvm::report_fatal_error(llvm::Twine const&, bool) + 388\r\n8  firtool                  0x000000010389f145 llvm::report_fatal_error(char const*, bool) + 53\r\n9  firtool                  0x000000010479c065 circt::firrtl::SubindexOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Value, unsigned int) + 533\r\n10 firtool                  0x0000000103ed526c circt::firrtl::SubindexOp mlir::OpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::Location, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 220\r\n11 firtool                  0x0000000103ed4fd1 circt::firrtl::SubindexOp mlir::ImplicitLocOpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 81"}, {"number": 4586, "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"target\":\"~Top|Foo\",\r\n    \"prefix\":\"A_\",\r\n    \"inclusive\":true\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"target\":\"~Top|Foo_1\",\r\n    \"prefix\":\"B_\",\r\n    \"inclusive\":true\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|Foo>in\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|Foo_1>in\"\r\n  }\r\n]]\r\n  module Foo :\r\n    input in : UInt<8>\r\n\r\n  module Foo_1 :\r\n    input in : UInt<8>\r\n\r\n  module Top :\r\n    input in : UInt<8>\r\n\r\n    inst f1 of Foo\r\n    inst f2 of Foo_1\r\n    f1.in <= in\r\n    f2.in <= in", "code_snippet_02": "module A_Foo(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule Top(\r\n  input [7:0] in);\r\n\r\n  A_Foo f1 (\r\n    .in (in)\r\n  );\r\n  A_Foo f2 (\r\n    .in (in)\r\n  );\r\nendmodule", "code_snippet_03": "module A_Foo(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule B_Foo_1(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule Top(\r\n  input [7:0] in);\r\n\r\n  A_Foo f1 (\r\n    .in (in)\r\n  );\r\n  B_Foo_1 f2 (\r\n    .in (in)\r\n  );\r\nendmodule"}, {"number": 4354, "code_snippet_01": "firrtl.circuit \"ForceNameTop\" {\r\n  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]\r\n  firrtl.hierpath private @nla_2 [@ForceNameTop::@sym_bar, @ForceNameSubmodule]\r\n  firrtl.module private @ForceNameSubmodule() attributes {annotations = [\r\n    {circt.nonlocal = @nla_1,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Foo\"},\r\n    {circt.nonlocal = @nla_2,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Foo\"}\r\n  ]} {}\r\n  firrtl.module @ForceNameTop() {\r\n    firrtl.instance Foo @ForceNameSubmodule()\r\n    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()\r\n    firrtl.instance bar sym @sym_bar @ForceNameSubmodule()\r\n  }\r\n}", "code_snippet_02": "module {\r\n  hw.module private @ForceNameSubmodule() {\r\n    hw.output\r\n  }\r\n  hw.module @ForceNameTop() {\r\n    hw.instance \"Foo\" @ForceNameSubmodule() -> ()\r\n    hw.instance \"foo\" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = \"Foo\"}\r\n    hw.instance \"bar\" sym @sym_bar @ForceNameSubmodule() -> () {hw.verilogName = \"Foo\"}\r\n    hw.output\r\n  }\r\n}", "code_snippet_03": "// Generated by CIRCT unknown git version\r\nmodule ForceNameSubmodule();\r\nendmodule\r\n\r\nmodule ForceNameTop();\r\n  ForceNameSubmodule Foo_0 ();\r\n  ForceNameSubmodule Foo ();\r\n  ForceNameSubmodule Foo_1 ();\r\nendmodule"}, {"number": 4097, "code_snippet_01": "circuit Top :\r\n  extmodule DataTap_2 :\r\n    output _2 : UInt<1>\r\n    output _1 : UInt<1>\r\n    output _0 : Clock\r\n    defname = DataTap_2\r\n\r\n  module Wrapper :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n\r\n    node _T = asUInt(reset)\r\n    node _T_1 = eq(_T, UInt<1>(\"h0\"))\r\n    when _T_1 :\r\n      node _T_2 = eq(in, UInt<1>(\"h0\"))\r\n      when _T_2 :\r\n        printf(clock, UInt<1>(\"h1\"), \"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\") : printf\r\n      assert(clock, in, UInt<1>(\"h1\"), \"\") : assert\r\n\r\n\r\n  module MyView_companion :\r\n\r\n    wire _WIRE : UInt<1>\r\n    _WIRE <= UInt<1>(\"h0\")\r\n    wire clk : Clock\r\n    wire rst : UInt<1>\r\n    wire cond : UInt<1>\r\n    inst DataTap_2 of DataTap_2\r\n    DataTap_2._0 is invalid\r\n    DataTap_2._1 is invalid\r\n    DataTap_2._2 is invalid\r\n    clk <= DataTap_2._0\r\n    rst <= DataTap_2._1\r\n    cond <= DataTap_2._2\r\n    inst wrapper of Wrapper\r\n    wrapper.clock <= clk\r\n    wrapper.reset <= rst\r\n    wrapper.in <= cond\r\n\r\n  module DUT :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n\r\n    wire w : UInt<1>\r\n    w <= in\r\n    inst MyView_companion of MyView_companion\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input in : UInt<1>\r\n\r\n    inst dut of DUT\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    dut.in <= in", "code_snippet_02": "[\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\":\"~Top|DataTap_2\",\r\n    \"keys\":[\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>clock\",\r\n        \"portName\":\"~Top|DataTap_2>_0\"\r\n      },\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>reset\",\r\n        \"portName\":\"~Top|DataTap_2>_1\"\r\n      },\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>w\",\r\n        \"portName\":\"~Top|DataTap_2>_2\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\":\"MyView\",\r\n    \"companion\":\"~Top|MyView_companion\",\r\n    \"parent\":\"~Top|DUT\",\r\n    \"view\":\"{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedBundleType\\\",\\\"defName\\\":\\\"MyInterface\\\",\\\"elements\\\":[{\\\"name\\\":\\\"ground\\\",\\\"description\\\":\\\"a ground type port\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\",\\\"ref\\\":{\\\"circuit\\\":\\\"Top\\\",\\\"module\\\":\\\"Top\\\",\\\"path\\\":[{\\\"_1\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$Instance\\\",\\\"value\\\":\\\"dut\\\"},\\\"_2\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$OfModule\\\",\\\"value\\\":\\\"DUT\\\"}}],\\\"ref\\\":\\\"w\\\",\\\"component\\\":[]},\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\\\"}}}]}\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"Top.DUT\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"gct\",\r\n    \"filename\":\"bindings.sv\"\r\n  }\r\n]", "code_snippet_03": "// Generated by CIRCT unknown git version\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\n// VCS coverage exclude_file\r\nmodule Wrapper_assert(\r\n  input in,\r\n        reset,\r\n        clock);\r\n\r\n  `ifndef SYNTHESIS\r\n    always @(posedge clock) begin\r\n      if (~reset & ~in) begin\r\n        if (`ASSERT_VERBOSE_COND_)\r\n          $error(\"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\");\r\n        if (`STOP_COND_)\r\n          $fatal;\r\n      end\r\n    end // always @(posedge)\r\n  `endif // not def SYNTHESIS\r\nendmodule\r\n\r\nmodule DUT(\r\n  input clock,\r\n        reset,\r\n        in);\r\n\r\n  wire w = in;\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    MyView_companion MyView_companion ();\r\n  */\r\nendmodule\r\n\r\nmodule Top(\r\n  input clock,\r\n        reset,\r\n        in);\r\n\r\n  DUT dut (\r\n    .clock (clock),\r\n    .reset (reset),\r\n    .in    (in)\r\n  );\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"gct/DataTap_2_impl_0.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// VCS coverage exclude_file\r\nmodule DataTap_2_impl_0(\r\n  output _2,\r\n         _1,\r\n         _0);\r\n\r\n  assign _2 = DUT.w;\r\n  assign _1 = DUT.reset;\r\n  assign _0 = DUT.clock;\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"gct/MyView_companion.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\n// VCS coverage exclude_file\r\nmodule MyView_companion();\r\n  wire _DataTap_2__2;\r\n  wire _DataTap_2__1;\r\n  wire _DataTap_2__0;\r\n  MyInterface MyView();\r\n  `ifndef SYNTHESIS\r\n    always @(posedge _DataTap_2__0) begin\r\n      if (~_DataTap_2__1 & ~_DataTap_2__2) begin\r\n        if (`ASSERT_VERBOSE_COND_)\r\n          $error(\"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\");\r\n        if (`STOP_COND_)\r\n          $fatal;\r\n      end\r\n    end // always @(posedge)\r\n  `endif // not def SYNTHESIS\r\n  assign MyView.ground = DUT.w;\r\n  DataTap_2_impl_0 DataTap_2 (\r\n    ._2 (_DataTap_2__2),\r\n    ._1 (_DataTap_2__1),\r\n    ._0 (_DataTap_2__0)\r\n  );\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    Wrapper_assert Wrapper_assert (\r\n      .in    (_DataTap_2__2),\r\n      .reset (_DataTap_2__1),\r\n      .clock (_DataTap_2__0)\r\n    );\r\n  */\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"bindings.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\nbind DUT MyView_companion MyView_companion ();\r\n\r\n// ----- 8< ----- FILE \"gct/MyInterface.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// VCS coverage exclude_file\r\ninterface MyInterface;\r\n  // a ground type port\r\n  logic ground;\r\nendinterface\r\n\r\n\r\n// ----- 8< ----- FILE \"bindfile\" ----- 8< -----\r\n\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\nbind MyView_companion Wrapper_assert Wrapper_assert (\r\n  .in    (_DataTap_2__2),\r\n  .reset (_DataTap_2__1),\r\n  .clock (_DataTap_2__0)\r\n);"}, {"number": 3810}, {"number": 3768, "code_snippet_01": "hw.type_scope @fsm_enum_typedecls {\r\n    hw.typedecl @M2_state_t : !hw.enum<A, B>\r\n    hw.typedecl @M1_state_t : !hw.enum<A, B>\r\n  }", "code_snippet_02": "typedef enum {A, B} M2_state_t;\r\ntypedef enum {A, B} M1_state_t;", "code_snippet_03": "typedef enum {M2_state_A, M2_state_B} M2_state_t;\r\ntypedef enum {M1_state_A, M1_state_B} M1_state_t;"}, {"number": 3494, "code_snippet_01": "circuit Top :\r\n  module Bar :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  module MyView_companion :\r\n\r\n    skip\r\n\r\n  module Foo :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    inst MyView_companion of MyView_companion\r\n\r\n  module Bar_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  module MyView_companion_0 :\r\n\r\n    skip\r\n\r\n  module Foo_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar_1\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    inst MyView_companion_0 of MyView_companion_0\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n\r\n    inst foo1 of Foo\r\n    foo1.clock <= clock\r\n    foo1.reset <= reset\r\n    inst foo2 of Foo_1\r\n    foo2.clock <= clock\r\n    foo2.reset <= reset", "code_snippet_02": "[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~Top|MyView_companion\",\r\n    \"parent\": \"~Top|Foo\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"w\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"Top\",\r\n              \"module\": \"Top\",\r\n              \"path\": [\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"foo1\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Foo\"\r\n                  }\r\n                },\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"bar\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Bar\"\r\n                  }\r\n                }\r\n              ],\r\n              \"ref\": \"w\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~Top|MyView_companion_0\",\r\n    \"parent\": \"~Top|Foo_1\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"w\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"Top\",\r\n              \"module\": \"Top\",\r\n              \"path\": [\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"foo2\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Foo_1\"\r\n                  }\r\n                },\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"bar\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Bar_1\"\r\n                  }\r\n                }\r\n              ],\r\n              \"ref\": \"w\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  }\r\n]", "code_snippet_03": "firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once\r\n  module Foo :\r\n         ^\r\nfirrtl/Top.fir:13:10: note: see current operation: \"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):\r\n  %0:2 = \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@bar\">, moduleName = @Bar, name = \"bar\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"]} : () -> (!firrtl.clock, !firrtl.uint<1>)\r\n  \"firrtl.strictconnect\"(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()\r\n  \"firrtl.strictconnect\"(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@MyView_companion\">, moduleName = @MyView_companion, name = \"MyView_companion\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()\r\n}) {annotations = [{circt.nonlocal = @nla_3, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 2 : i64, name = \"MyView\", type = \"parent\"}, {circt.nonlocal = @nla_4, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 0 : i64, name = \"MyView\", type = \"parent\"}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"], portSyms = [\"\", \"\"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\nfirrtl/Top.fir:49:5: note: parent is instantiated here\r\n    inst foo2 of Foo_1\r\n    ^\r\nfirrtl/Top.fir:46:5: note: parent is instantiated here\r\n    inst foo1 of Foo\r\n    ^\r\nfirrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once\r\n  module Foo :\r\n         ^\r\nfirrtl/Top.fir:13:10: note: see current operation: \"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):\r\n  %0:2 = \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@bar\">, moduleName = @Bar, name = \"bar\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"]} : () -> (!firrtl.clock, !firrtl.uint<1>)\r\n  \"firrtl.strictconnect\"(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()\r\n  \"firrtl.strictconnect\"(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@MyView_companion\">, moduleName = @MyView_companion, name = \"MyView_companion\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()\r\n}) {annotations = [{circt.nonlocal = @nla_3, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 2 : i64, name = \"MyView\", type = \"parent\"}, {circt.nonlocal = @nla_4, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 0 : i64, name = \"MyView\", type = \"parent\"}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"], portSyms = [\"\", \"\"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\nfirrtl/Top.fir:49:5: note: parent is instantiated here\r\n    inst foo2 of Foo_1\r\n    ^\r\nfirrtl/Top.fir:46:5: note: parent is instantiated here\r\n    inst foo1 of Foo\r\n    ^\r\nfirrtl/Top.fir:1:1: error: 'firrtl.circuit' op contains a 'companion' with id '2', but does not contain a GrandCentral 'parent' with the same id\r\ncircuit Top :\r\n^"}, {"number": 3454, "code_snippet_01": "hw.module private @Foo() -> (){\r\n    sv.initial {\r\n      %param_x = sv.localparam : i42 { value = 11: i42 }\r\n    }\r\n}", "code_snippet_02": "module Foo();\r\n  initial     \r\n    localparam [41:0] param_x = 42'd11; \r\n\r\nendmodule", "code_snippet_03": "initial begin \r\n    localparam [41:0] param_x = 42'd11;\r\n  end"}, {"number": 3268, "code_snippet_01": "func.func @external_mem(%mem : memref<4xi32>) {\r\n  return\r\n}\r\n\r\nfunc.func @normal_mem() {\r\n  %mem = memref.alloc() : memref<4xi32>\r\n  func.call @external_mem(%mem) : (memref<4xi32>) -> ()\r\n  return\r\n}", "code_snippet_02": "handshake.func @external_mem(%arg0: memref<4xi32>, %arg1: none, ...) -> none attributes {argNames = [\"in0\", \"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n  extmemory[ld = 0, st = 0] (%arg0 : memref<4xi32>) () {id = 0 : i32} : () -> ()\r\n  return %arg1 : none\r\n }\r\nhandshake.func @normal_mem(%arg0: none, ...) -> none attributes {argNames = [\"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n  %0:2 = fork [2] %arg0 : none\r\n  %1 = memref.alloc() : memref<4xi32>\r\n  %2 = instance @external_mem(%1, %0#0) : (memref<4xi32>, none) -> none\r\n  sink %2 : none\r\n  return %0#1 : none\r\n}"}, {"number": 3240, "code_snippet_01": "circuit Top :\r\n  module Submodule :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    wire _w : UInt<1> \r\n    _w <= in \r\n    out <= _w \r\n\r\n  module Submodule_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    wire _w : UInt<1> \r\n    _w <= in \r\n    out <= _w \r\n\r\n  module MyView_companion :\r\n\r\n    wire _WIRE : UInt<1>\r\n    _WIRE <= UInt<1>(\"h0\")\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    inst sub1 of Submodule \r\n    sub1.clock <= clock\r\n    sub1.reset <= reset\r\n    inst sub2 of Submodule_1 \r\n    sub2.clock <= clock\r\n    sub2.reset <= reset\r\n    sub1.in <= in \r\n    sub2.in <= in \r\n    node _out_T = xor(sub1.out, sub2.out) \r\n    out <= _out_T \r\n    inst MyView_companion of MyView_companion", "code_snippet_02": "[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|MyView_companion>_WIRE\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\":\"MyView\",\r\n    \"companion\":\"~Top|MyView_companion\",\r\n    \"parent\":\"~Top|Top\",\r\n    \"view\":\"{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedBundleType\\\",\\\"defName\\\":\\\"MyInterface\\\",\\\"elements\\\":[{\\\"name\\\":\\\"tap1\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\",\\\"ref\\\":{\\\"circuit\\\":\\\"Top\\\",\\\"module\\\":\\\"Top\\\",\\\"path\\\":[{\\\"_1\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$Instance\\\",\\\"value\\\":\\\"sub1\\\"},\\\"_2\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$OfModule\\\",\\\"value\\\":\\\"Submodule\\\"}}],\\\"ref\\\":\\\"_w\\\",\\\"component\\\":[]},\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\\\"}}}]}\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\":\"~Top|MyView_companion\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"builds/gct-tests/DedupOneTap/firrtl/gct\",\r\n    \"filename\":\"builds/gct-tests/DedupOneTap/firrtl/bindings.sv\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation\",\r\n    \"filename\":\"builds/gct-tests/DedupOneTap/firrtl/gct/gct.yaml\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.stage.RunFirrtlTransformAnnotation\",\r\n    \"transform\":\"sifive.enterprise.grandcentral.GrandCentralTransform\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.stage.RunFirrtlTransformAnnotation\",\r\n    \"transform\":\"sifive.enterprise.firrtl.ExtractTestCodeTransform\"\r\n  }\r\n]", "code_snippet_03": "module Submodule(\r\n  input  in,\r\n  output out);\r\n\r\n  wire _gctTap;\r\n\r\n  assign _gctTap = in;\r\n  assign out = in;\r\nendmodule\r\n\r\nmodule Submodule_1(\r\n  input  in,\r\n  output out);\r\n\r\n  assign out = in;\r\nendmodule\r\n\r\nmodule Top(\r\n  input  clock,\r\n         reset,\r\n         in,\r\n  output out);\r\n\r\n  wire _sub2_out;\r\n  wire _sub1_out;\r\n\r\n  // This interface is elsewhere emitted as a bind statement.\r\n  // MyInterface MyView();\r\n  Submodule sub1 (\r\n    .in  (in),\r\n    .out (_sub1_out)\r\n  );\r\n  Submodule_1 sub2 (\r\n    .in  (in),\r\n    .out (_sub2_out)\r\n  );\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    MyView_companion MyView_companion ();\r\n  */\r\n  assign out = _sub1_out ^ _sub2_out;\r\nendmodule"}, {"number": 3105}, {"number": 3104}, {"number": 3090}, {"number": 3033, "code_snippet_01": "circuit Bar:\r\n  module X:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    b <= not(a)\r\n  module Y:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    b <= not(a)\r\n  module Bar:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    inst y of Y\r\n    inst x of X\r\n\r\n    x.a <= a\r\n    y.a <= a\r\n    b <= xor(x.b, y.b)", "code_snippet_02": "module Y(\r\n  input  a,\r\n  output b);\r\n\r\n  assign b = ~a;\r\nendmodule\r\n\r\nmodule Bar(\r\n  input  a,\r\n  output b);\r\n\r\n  wire _x_b;\r\n  wire _y_b;\r\n\r\n  Y y (\r\n    .a (a),\r\n    .b (_y_b)\r\n  );\r\n  Y x (\r\n    .a (a),\r\n    .b (_x_b)\r\n  );\r\n  assign b = _x_b ^ _y_b;\r\nendmodule", "code_snippet_03": "module X(\r\n  input   a,\r\n  output  b\r\n);\r\n  assign b = ~a;\r\nendmodule\r\nmodule Bar(\r\n  input   a,\r\n  output  b\r\n);\r\n  wire  y_a;\r\n  wire  y_b;\r\n  wire  x_a;\r\n  wire  x_b;\r\n  X y (\r\n    .a(y_a),\r\n    .b(y_b)\r\n  );\r\n  X x (\r\n    .a(x_a),\r\n    .b(x_b)\r\n  );\r\n  assign b = x_b ^ y_b;\r\n  assign y_a = a;\r\n  assign x_a = a;\r\nendmodule"}, {"number": 2888, "code_snippet_01": "circuit Foo: %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"prefix\":\"prefix1_\",\r\n    \"inclusive\":true,\r\n    \"target\":\"~Foo|Bar\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"prefix\":\"prefix2_\",\r\n    \"inclusive\":true,\r\n    \"target\":\"~Foo|Baz\"\r\n  }\r\n]]\r\n  module Bar:\r\n  module Baz:\r\n  module Foo:\r\n    inst bar of Bar\r\n    inst baz of Baz", "code_snippet_02": "module prefix2_Bar();\r\nendmodule\r\n\r\nmodule Foo();\r\n  prefix2_Bar bar ();\r\n  prefix2_Bar baz ();\r\nendmodule", "code_snippet_03": "module prefix1_Bar();\r\nendmodule\r\n\r\nmodule prefix2_Baz();\r\nendmodule\r\n\r\nmodule Foo();\r\n  prefix1_Bar bar ();\r\n  prefix2_Baz baz ();\r\nendmodule"}, {"number": 2531, "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"Top.A.b\"\r\n  }\r\n]]\r\n  module Top :\r\n    inst a1 of A\r\n    inst a2 of A_\r\n  module A :\r\n    output x: UInt<1>\r\n    wire b: UInt<1>\r\n    b is invalid\r\n    x <= b\r\n  module A_ :\r\n    output x: UInt<1>\r\n    wire b: UInt<1>\r\n    b is invalid\r\n    x <= b", "code_snippet_02": "module  {\r\n  firrtl.circuit \"Top\"   {\r\n    firrtl.module @Top() {\r\n      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n      %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)\r\n    }\r\n    firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n      %b = firrtl.wire sym @b  : !firrtl.uint<1>\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n    firrtl.module @A_(out %x: !firrtl.uint<1>) {\r\n      %b = firrtl.wire  : !firrtl.uint<1>\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_03": "module  {\r\n  firrtl.circuit \"Top\"   {\r\n    firrtl.module @Top() {\r\n      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n      %a2_x = firrtl.instance a2  @A(out x: !firrtl.uint<1>)\r\n    }\r\n    firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      %b = firrtl.wire sym @b  : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_04": "circuit Top :\r\n  module A :\r\n    output x : UInt<1>\r\n\r\n    wire b : UInt<1> @[dont-touch.scala 33:15]\r\n    b is invalid @[dont-touch.scala 34:5]\r\n    x <= b @[dont-touch.scala 36:5]\r\n\r\n  module Top :\r\n\r\n    inst a1 of A @[dont-touch.scala 47:18]\r\n    inst a2 of A @[dont-touch.scala 48:18]", "code_snippet_05": "[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top/a1:A>b\"\r\n  }\r\n]"}, {"number": 2516, "code_snippet_01": "; seed: 6243\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock0: Clock\r\n    input raddr: UInt<10>\r\n    input waddr: UInt<10>\r\n    input wdata: UInt<20>\r\n    output tmp54: UInt<20>\r\n    mem tmp53:\r\n      data-type => UInt<20>\r\n      depth => 10\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp53.r0.clk <= clock0\r\n    tmp53.r0.en <= UInt(0)\r\n    tmp53.r0.addr <= waddr\r\n    tmp53.w0.clk <= clock0\r\n    tmp53.w0.en <= UInt(1)\r\n    tmp53.w0.addr <= raddr\r\n    tmp53.w0.data <= wdata\r\n    tmp53.w0.mask <= UInt(1)\r\n    tmp54 <= tmp53.r0.data", "code_snippet_02": "module tmp53_ext(\t// a_top_mod.fir:9:5\r\n  input  [3:0]  R0_addr,\r\n  input         R0_en, R0_clk,\r\n  input  [3:0]  W0_addr,\r\n  input         W0_en, W0_clk,\r\n  input  [19:0] W0_data,\r\n  input         W0_mask,\r\n  output [19:0] R0_data);\r\n\r\n  reg [19:0] Memory[0:9];\r\n\r\n  wire _T = W0_en & W0_mask;\r\n  always @(posedge W0_clk) begin\r\n    if (_T)\r\n      Memory[W0_addr] <= W0_data;\r\n  end // always @(posedge)\r\n  assign R0_data = R0_en ? Memory[R0_addr] : 20'bx;\t// a_top_mod.fir:9:5\r\nendmodule\r\n\r\nmodule top_mod(\t// a_top_mod.fir:3:10\r\n  input         clock0,\r\n  input  [9:0]  raddr, waddr,\r\n  input  [19:0] wdata,\r\n  output [19:0] tmp54);\r\n\r\n  tmp53_ext tmp53 (\t// a_top_mod.fir:9:5\r\n    .R0_addr (waddr[3:0]),\t// a_top_mod.fir:19:19\r\n    .R0_en   (1'h0),\t// a_top_mod.fir:18:20\r\n    .R0_clk  (clock0),\r\n    .W0_addr (raddr[3:0]),\t// a_top_mod.fir:22:19\r\n    .W0_en   (1'h1),\t// a_top_mod.fir:21:20\r\n    .W0_clk  (clock0),\r\n    .W0_data (wdata),\r\n    .W0_mask (1'h1),\t// a_top_mod.fir:21:20\r\n    .R0_data (tmp54)\r\n  );\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input         clock0,\r\n  input  [9:0]  raddr,\r\n  input  [9:0]  waddr,\r\n  input  [19:0] wdata,\r\n  output [19:0] tmp54\r\n);\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n  reg [31:0] _RAND_1;\r\n`endif // RANDOMIZE_GARBAGE_ASSIGN\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  reg [31:0] _RAND_0;\r\n`endif // RANDOMIZE_MEM_INIT\r\n  reg [19:0] tmp53 [0:9];\r\n  wire  tmp53_r0_en;\r\n  wire [3:0] tmp53_r0_addr;\r\n  wire [19:0] tmp53_r0_data;\r\n  wire [19:0] tmp53_w0_data;\r\n  wire [3:0] tmp53_w0_addr;\r\n  wire  tmp53_w0_mask;\r\n  wire  tmp53_w0_en;\r\n  assign tmp53_r0_en = 1'h0;\r\n  assign tmp53_r0_addr = waddr[3:0];\r\n  `ifndef RANDOMIZE_GARBAGE_ASSIGN\r\n  assign tmp53_r0_data = tmp53[tmp53_r0_addr];\r\n  `else\r\n  assign tmp53_r0_data = tmp53_r0_addr >= 4'ha ? _RAND_1[19:0] : tmp53[tmp53_r0_addr];\r\n  `endif // RANDOMIZE_GARBAGE_ASSIGN\r\n  assign tmp53_w0_data = wdata;\r\n  assign tmp53_w0_addr = raddr[3:0];\r\n  assign tmp53_w0_mask = 1'h1;\r\n  assign tmp53_w0_en = 1'h1;\r\n  assign tmp54 = tmp53_r0_data;\r\n  always @(posedge clock0) begin\r\n    if (tmp53_w0_en & tmp53_w0_mask) begin\r\n      tmp53[tmp53_w0_addr] <= tmp53_w0_data;\r\n    end\r\n  end\r\n// Register and memory initialization\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_INVALID_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_REG_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifndef RANDOM\r\n`define RANDOM $random\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  integer initvar;\r\n`endif\r\n`ifndef SYNTHESIS\r\n`ifdef FIRRTL_BEFORE_INITIAL\r\n`FIRRTL_BEFORE_INITIAL\r\n`endif\r\ninitial begin\r\n  `ifdef RANDOMIZE\r\n    `ifdef INIT_RANDOM\r\n      `INIT_RANDOM\r\n    `endif\r\n    `ifndef VERILATOR\r\n      `ifdef RANDOMIZE_DELAY\r\n        #`RANDOMIZE_DELAY begin end\r\n      `else\r\n        #0.002 begin end\r\n      `endif\r\n    `endif\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n  _RAND_1 = {1{`RANDOM}};\r\n`endif // RANDOMIZE_GARBAGE_ASSIGN\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  _RAND_0 = {1{`RANDOM}};\r\n  for (initvar = 0; initvar < 10; initvar = initvar+1)\r\n    tmp53[initvar] = _RAND_0[19:0];\r\n`endif // RANDOMIZE_MEM_INIT\r\n  `endif // RANDOMIZE\r\nend // initial\r\n`ifdef FIRRTL_AFTER_INITIAL\r\n`FIRRTL_AFTER_INITIAL\r\n`endif\r\n`endif // SYNTHESIS\r\nendmodule", "code_snippet_04": "ERROR: Found 20 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 2504, "code_snippet_01": "hw.module @top(%source: i1) -> (b: !hw.struct<zero: !hw.array<1xi0>, c: i1>) {\r\n    %cast = hw.bitcast %source: (i1) -> !hw.struct<zero: !hw.array<1xi0>, c: i1>\r\n    hw.output %cast : !hw.struct<zero: !hw.array<1xi0>, c: i1>\r\n }", "code_snippet_02": "module top(\t// out.mlir:2:3\r\n  input                                                            source,\r\n  output struct packed {logic [0:0]/*Zero Width*/ zero; logic c; } b);\r\n \r\n  assign b = source;\t// out.mlir:3:12, :4:5\r\nendmodule"}, {"number": 2298, "code_snippet_01": "module  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n  firrtl.circuit \"Bar\"   {\r\n    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_02": "module  {\r\n  firrtl.circuit \"Bar\"   {\r\n    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n  hw.module @Foo(%a: i1) -> (b: i1) {\r\n    hw.output %a : i1\r\n  }\r\n}"}, {"number": 2029}, {"number": 2026}, {"number": 1988, "code_snippet_01": "llhd.entity @root () -> () {\r\n  %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>\r\n\r\n  %hidden = hw.constant 0xff : i8\r\n  %base = hw.constant 0 : i8\r\n  %amnt = hw.constant 4 : i3\r\n\r\n  %resultsig = llhd.sig \"result\" %base : i8\r\n  %basesig = llhd.sig \"base\" %base : i8\r\n  %hiddensig = llhd.sig \"hidden\" %hidden : i8\r\n  %shr = llhd.shr %basesig, %hiddensig, %amnt : (!llhd.sig<i8>, !llhd.sig<i8>, i3) -> !llhd.sig<i8>\r\n  %prbshr = llhd.prb %shr : !llhd.sig<i8>\r\n  llhd.drv %resultsig, %prbshr after %time : !llhd.sig<i8>\r\n}", "code_snippet_02": "0ps 0d 0e  root/base  0x00\r\n0ps 0d 0e  root/hidden  0xff\r\n0ps 0d 0e  root/result  0x00\r\n1000ps 0d 0e  root/result  0xf0         // UB here (also seen 0x70, 0x10, etc.)\r\nFinished at 2000ps 0d 0e (3 cycles)"}, {"number": 1795, "code_snippet_01": "llhd.entity @root () -> () {\r\n    %0 = hw.constant 0 : i8\r\n    %index = hw.constant 1 : i1\r\n\r\n    %array = hw.array_create %0, %0 : i8\r\n    %get = hw.array_get %array[%index] : !hw.array<2xi8>\r\n\r\n    %getsig = llhd.sig \"get\" %get : i8  // Using %0 instead of %get works just fine; %get leads to a crash\r\n\r\n    %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>\r\n    llhd.drv %getsig, %get after %time : !llhd.sig<i8>\r\n}"}, {"number": 1771, "code_snippet_01": "circuit Bar :\r\n  module Bar :\r\n    input a: UInt<1>\r\n    output b: UInt<1024>\r\n\r\n    b <= cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))", "code_snippet_02": "# lldb firtool -- Bar.fir\r\n(lldb) target create \"firtool\"\r\nCurrent executable set to 'firtool' (x86_64).\r\n(lldb) settings set -- target.run-args  \"Bar.fir\"\r\n(lldb) run\r\nProcess 10399 launched: '/Users/schuylere/usr/bin/firtool' (x86_64)\r\nProcess 10399 stopped\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=2, address=0x7ffeef3fffff)\r\n    frame #0: 0x00000001005857e4 firtool`llvm::isAlpha(C=<unavailable>) at StringExtras.h:95\r\n   92  \tinline bool isHexDigit(char C) { return hexDigitValue(C) != ~0U; }\r\n   93  \t\r\n   94  \t/// Checks if character \\p C is a valid letter as classified by \"C\" locale.\r\n-> 95  \tinline bool isAlpha(char C) {\r\n   96  \t  return ('a' <= C && C <= 'z') || ('A' <= C && C <= 'Z');\r\n   97  \t}\r\n   98  \t\r\nTarget 0: (firtool) stopped.\r\n(lldb) frame select 1\r\nframe #1: 0x000000010024a592 firtool`circt::firrtl::FIRLexer::lexIdentifierOrKeyword(this=0x00007ffeefbfdbe8, tokStart=\"cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\"...) at FIRLexer.cpp:386:10\r\n   383 \t///\r\n   384 \tFIRToken FIRLexer::lexIdentifierOrKeyword(const char *tokStart) {\r\n   385 \t  // Match the rest of the identifier regex: [0-9a-zA-Z_$-]*\r\n-> 386 \t  while (llvm::isAlpha(*curPtr) || llvm::isDigit(*curPtr) || *curPtr == '_' ||\r\n   387 \t         *curPtr == '$' || *curPtr == '-')\r\n   388 \t    ++curPtr;\r\n   389"}, {"number": 1734}, {"number": 1289, "code_snippet_01": "; seed: 1144\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output _tmp40: UInt\r\n    wire tmp19: UInt\r\n    tmp19 <= mul(UInt(\"o20575\"), UInt<1>(0))\r\n    _tmp40 <= dshl(UInt(\"b10011010000001011101\"), tail(tmp19, 15))", "code_snippet_02": "module top_mod(\r\n  output [19:0] _tmp40);\r\n\r\n  assign _tmp40 = 20'h9A05D;\t// a_top_mod.fir:3:3, :7:20\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  output [18:0] _tmp40\r\n);\r\n  assign _tmp40 = 19'h1a05d;\r\nendmodule", "code_snippet_04": "ERROR: Can't match gold port `_tmp40_gold' to a gate port."}, {"number": 1065, "code_snippet_01": "Failed Tests (210):\r\n  CIRCT :: CAPI/ir.c\r\n  CIRCT :: Conversion/FIRRTLToHW/errors.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-errors.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-module.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/zero-width.mlir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/connect.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_inouts.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_ins.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_none.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_outs.fir\r\n  CIRCT :: Conversion/HWToLLHD/errors.mlir\r\n  CIRCT :: Conversion/HWToLLHD/structure.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/simple_addi.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_branch.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_buffer.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_cmerge.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_conditional_branch.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_constant.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_fork.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_join.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_lazy_fork.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_load.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_memory.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_merge.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_mux.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_sink.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_store.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_arithmetic.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_bitwise.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_entity.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_extract.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_insert.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_memory.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_process_persistence.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_signals.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_simple.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_value_creation.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_wait.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/errors.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-for.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-load-store.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test1.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test10.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test11.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test12.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test13.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test14.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test15.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test16.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test17.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test18.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test19.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test2.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test20.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test21.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test22.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test23.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test24.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test25.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test26.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test27.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test28.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test29.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test3.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test30.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test31.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test32.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test33.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test34.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test35.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test4.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test5.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test6.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test7.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test8.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test9.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_canonicalize.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer_errors.mlir\r\n  CIRCT :: Conversion/StandardToStaticLogic/test_pipeline.mlir\r\n  CIRCT :: Dialect/ESI/connectivity.mlir\r\n  CIRCT :: Dialect/ESI/errors.mlir\r\n  CIRCT :: Dialect/ESI/lowering.mlir\r\n  CIRCT :: Dialect/ESI/modwrap.mlir\r\n  CIRCT :: Dialect/ESI/wrapif-lowering.mlir\r\n  CIRCT :: Dialect/FIRRTL/annotations.fir\r\n  CIRCT :: Dialect/FIRRTL/blackbox-memory.mlir\r\n  CIRCT :: Dialect/FIRRTL/canonicalization.mlir\r\n  CIRCT :: Dialect/FIRRTL/check-widths-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/connect-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/connect.mlir\r\n  CIRCT :: Dialect/FIRRTL/const-prop-single-module.mlir\r\n  CIRCT :: Dialect/FIRRTL/cse.mlir\r\n  CIRCT :: Dialect/FIRRTL/errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/expand-whens-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/expand-whens.mlir\r\n  CIRCT :: Dialect/FIRRTL/imconstprop.mlir\r\n  CIRCT :: Dialect/FIRRTL/infer-widths-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/infer-widths.mlir\r\n  CIRCT :: Dialect/FIRRTL/inliner.mlir\r\n  CIRCT :: Dialect/FIRRTL/lower-types-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/lower-types.mlir\r\n  CIRCT :: Dialect/FIRRTL/parse-basic.fir\r\n  CIRCT :: Dialect/FIRRTL/parse-errors.fir\r\n  CIRCT :: Dialect/FIRRTL/parse-locations.fir\r\n  CIRCT :: Dialect/FIRRTL/test.mlir\r\n  CIRCT :: Dialect/HW/basic.mlir\r\n  CIRCT :: Dialect/HW/bitwise.mlir\r\n  CIRCT :: Dialect/HW/canonicalization.mlir\r\n  CIRCT :: Dialect/HW/errors.mlir\r\n  CIRCT :: Dialect/HW/greybox.mlir\r\n  CIRCT :: Dialect/HW/modules.mlir\r\n  CIRCT :: Dialect/HW/svEmitErrors.mlir\r\n  CIRCT :: Dialect/HW/typedecls.mlir\r\n  CIRCT :: Dialect/HW/types.mlir\r\n  CIRCT :: Dialect/Handshake/errors.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/constant.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/extract.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/memory.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/probeCSE.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/signalOps.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_entity.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_relations.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_sig.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_sig_errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/IR/array.mlir\r\n  CIRCT :: Dialect/LLHD/IR/bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/IR/connect-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/connect.mlir\r\n  CIRCT :: Dialect/LLHD/IR/const.mlir\r\n  CIRCT :: Dialect/LLHD/IR/entity.mlir\r\n  CIRCT :: Dialect/LLHD/IR/extract-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/extract.mlir\r\n  CIRCT :: Dialect/LLHD/IR/insert-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/insert.mlir\r\n  CIRCT :: Dialect/LLHD/IR/inst-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/inst.mlir\r\n  CIRCT :: Dialect/LLHD/IR/memory.mlir\r\n  CIRCT :: Dialect/LLHD/IR/proc.mlir\r\n  CIRCT :: Dialect/LLHD/IR/reg.mlir\r\n  CIRCT :: Dialect/LLHD/IR/signal-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/signal.mlir\r\n  CIRCT :: Dialect/LLHD/IR/time.mlir\r\n  CIRCT :: Dialect/LLHD/IR/tuple.mlir\r\n  CIRCT :: Dialect/LLHD/IR/wait.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_arbitrary_signal_size.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_array_boundary_check.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_bit_precision_drives.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_process.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_reg.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_shifts.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_simple.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_wait.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/earlyCodeMotion.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/memoryToBlockArgument.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/processLowering.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/processLoweringErrors.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/totalFunctionInlining.mlir\r\n  CIRCT :: Dialect/MSFT/location.mlir\r\n  CIRCT :: Dialect/MSFT/opt-errors.mlir\r\n  CIRCT :: Dialect/MSFT/translate-errors.mlir\r\n  CIRCT :: Dialect/SV/basic.mlir\r\n  CIRCT :: Dialect/SV/canonicalization.mlir\r\n  CIRCT :: Dialect/SV/errors.mlir\r\n  CIRCT :: Dialect/SV/hw-cleanup.mlir\r\n  CIRCT :: Dialect/SV/hw-generator-callout.mlir\r\n  CIRCT :: Dialect/SV/hw-legalize-names-errors.mlir\r\n  CIRCT :: Dialect/SV/hw-legalize-names.mlir\r\n  CIRCT :: Dialect/SV/hw-memsim.mlir\r\n  CIRCT :: Dialect/SV/interfaces.mlir\r\n  CIRCT :: Dialect/SV/prettify-verilog.mlir\r\n  CIRCT :: Dialect/Seq/basic.mlir\r\n  CIRCT :: ExportVerilog/hw-dialect.mlir\r\n  CIRCT :: ExportVerilog/hw-typedecls.mlir\r\n  CIRCT :: ExportVerilog/line-length.mlir\r\n  CIRCT :: ExportVerilog/load-dialect.mlir\r\n  CIRCT :: ExportVerilog/sv-alwaysff.mlir\r\n  CIRCT :: ExportVerilog/sv-dialect.mlir\r\n  CIRCT :: ExportVerilog/sv-interfaces.mlir\r\n  CIRCT :: ExportVerilog/verilog-basic.mlir\r\n  CIRCT :: ExportVerilog/verilog-errors.mlir\r\n  CIRCT :: circt-opt/trivial.mlir\r\n  CIRCT :: circt-translate/parse_int64.fir\r\n  CIRCT :: firtool/firtool.fir\r\n  CIRCT :: firtool/firtool.mlir\r\n  CIRCT :: firtool/optimizations.fir\r\n  CIRCT :: firtool/phase-ordering.fir\r\n  CIRCT :: firtool/split-verilog.mlir\r\n  CIRCT :: firtool/style.fir\r\n  CIRCT :: handshake-runner/call_bb.mlir\r\n  CIRCT :: handshake-runner/cdiv-old-std.mlir\r\n  CIRCT :: handshake-runner/cdiv-std.mlir\r\n  CIRCT :: handshake-runner/complex_bb.mlir\r\n  CIRCT :: handshake-runner/floydwarshall-std.mlir\r\n  CIRCT :: handshake-runner/histogram-std.mlir\r\n  CIRCT :: handshake-runner/loadstore.mlir\r\n  CIRCT :: handshake-runner/loop-check-1-std.mlir\r\n  CIRCT :: handshake-runner/loop-check-2-std.mlir\r\n  CIRCT :: handshake-runner/matmul-check-std.mlir\r\n  CIRCT :: handshake-runner/matmul-std.mlir\r\n  CIRCT :: handshake-runner/memory_simple_2_std.mlir\r\n  CIRCT :: handshake-runner/memory_simple_std.mlir\r\n  CIRCT :: handshake-runner/simple_loop.mlir\r\n\r\n\r\nTesting Time: 1.34s\r\n  Unsupported:   4\r\n  Passed     :   6\r\n  Failed     : 210"}, {"number": 907, "code_snippet_01": "circuit Instance:\r\n  module Sub:\r\n    output a: UInt<1>\r\n    a <= UInt<1>(0)\r\n\r\n  module Instance:\r\n    output a: {a: UInt<1>}\r\n\r\n    inst sub of Sub\r\n    a <= sub\r\n    a <- sub", "code_snippet_02": "# circt-translate --import-firrtl new/Instance.fir\r\nnew/Instance.fir:11:5: error: expected '.' in field reference\r\n    a <- sub\r\n    ^"}, {"number": 806, "code_snippet_01": "llhd.entity @adder(%clk: !llhd.sig, %res: !llhd.sig) \u2192 (%i5_output: !llhd.sig ) {\r\n%0 = llhd.const #llhd.time<0s, 0d, 1e> : !llhd.time\r\n%1 = llhd.const 16 : i32\r\nllhd.drv %i5_output, %1 after %0 : !llhd.sig\r\n}", "code_snippet_02": "Assertion failed: (idx < size()), function operator[], file \u2026/llvm/llvm/include/llvm/ADT/SmallVector.h, line 277.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0. Program arguments: \u2026/build/bin/llhd-sim addersvllhd.mlir -n 10 -r adder\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var LLVM_SYMBOLIZER_PATH to point to it):\r\n0 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca593d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca5eeb PrintStackTraceSignalHandler(void*) + 27\r\n2 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca3a6b llvm::sys::RunSignalHandlers() + 123\r\n3 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca83f8 SignalHandler(int) + 232\r\n4 libsystem_platform.dylib 0x00007fff6af445fd _sigtramp + 29\r\n5 libdyld.dylib 0x00007fff6ad4a78f dyldGlobalLockRelease() + 0\r\n6 libsystem_c.dylib 0x00007fff6ae1a808 abort + 120\r\n7 libsystem_c.dylib 0x00007fff6ae19ac6 err + 0\r\n8 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4fa48 llvm::SmallVectorTemplateCommon<circt::llhd::sim::Signal, void>::operator[](unsigned long) + 104\r\n9 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4f912 driveSignal + 178\r\n10 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011e1240f1 driveSignal + 6113425\r\n11 llhd-sim 0x000000010acda78e main + 1518\r\n12 libdyld.dylib 0x00007fff6ad4bcc9 start + 1"}, {"number": 787}]