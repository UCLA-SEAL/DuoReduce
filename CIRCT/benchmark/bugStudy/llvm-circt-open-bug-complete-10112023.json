[{"number": 6275, "title": "[ExportVerilog] Aggregate constant produces invalid assignment pattern", "created_at": "2023-10-10T18:38:20Z", "state": "open", "labels": "bug, ExportVerilog", "body": "The following snippet of MLIR creates an aggregate constant of a struct nested in an array nested in a struct:\r\n```mlir\r\nhw.module @Foo() {\r\n    %bar = sv.reg : !hw.inout<struct<mem: !hw.array<1xstruct<sink: i1>>>>\r\n    %0 = hw.aggregate_constant [[[false]]] : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>\r\n    sv.assign %bar, %0 : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>\r\n}\r\n```\r\nRunning this through `circt-opt --export-verilog` produces the following invalid Verilog:\r\n```verilog\r\nmodule Foo();\r\n  struct packed {struct packed {logic sink; }[0:0] mem; } bar;\r\n  assign bar = '{mem: {'{sink: 1'h0}}};\r\nendmodule\r\n```\r\nThe problematic part is `'{mem: {'{sink: 1'h0}}}`, which contains an assignment pattern `'{sink: 1'h0}` inside a concatenation `{...}` (without the `'`). The assignment pattern `'{...}` (with the `'`) requires an assignment-like context, which the concatenation is not.\r\n\r\nMaybe we can emit the array also as an assignment pattern `'{...}`. Or add explicit types to the assignment patterns somehow, like `struct {...} '{...}`?", "code_snippet_01": "hw.module @Foo() {\r\n    %bar = sv.reg : !hw.inout<struct<mem: !hw.array<1xstruct<sink: i1>>>>\r\n    %0 = hw.aggregate_constant [[[false]]] : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>\r\n    sv.assign %bar, %0 : !hw.struct<mem: !hw.array<1xstruct<sink: i1>>>\r\n}", "code_snippet_02": "module Foo();\r\n  struct packed {struct packed {logic sink; }[0:0] mem; } bar;\r\n  assign bar = '{mem: {'{sink: 1'h0}}};\r\nendmodule"}, {"number": 6272, "title": "[LowerToHW] Error in firtool-1.54.0 Memory Lowering w/ Clock Type", "created_at": "2023-10-09T18:21:57Z", "state": "open", "labels": "bug, FIRRTL, HW", "body": "I ran into a bug with `firtool`'s lowering of FIRRTL memories. If you have a memory that includes a `Clock` type, then `LowerToHW` creates a wire of type `(i1) -> !seq.clock` which the verifier is unhappy about.\r\n\r\nExample:\r\n\r\n```\r\ncircuit Foo:\r\n  module Foo:\r\n    input r: {addr: UInt<3>, en: UInt<1> clk: Clock, flip data: {a: Clock}}\r\n    input w: {addr: UInt<3>, en: UInt<1> clk: Clock, data: {a: Clock}, mask: {a: UInt<1>}}\r\n\r\n    mem memory:\r\n      data-type => {a: Clock}\r\n      depth => 16\r\n      reader => r\r\n      writer => w\r\n      read-latency => 1\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.r <= r\r\n    memory.w <= w\r\n```\r\n\r\nCompiling with `firtool-1.54.0 Memory.fir`:\r\n```\r\nMemory.fir:6:5: error: 'hw.wire' op requires the same type for all operands and results\r\n    mem memory:\r\n    ^\r\nMemory.fir:6:5: note: see current operation: %2 = \"hw.wire\"(%5) {name = \"memory_r_data_a\"} : (i1) -> !seq.clock\r\n```\r\n\r\nThe failing MLIR is:\r\n```mlir\r\n#loc = loc(\"Memory.fir\":3:11)\r\n#loc1 = loc(\"Memory.fir\":4:11)\r\n\"builtin.module\"() ({\r\n  \"hw.module\"() ({\r\n  ^bb0(%arg0: i3, %arg1: i1, %arg2: !seq.clock, %arg3: i3, %arg4: i1, %arg5: !seq.clock, %arg6: !seq.clock, %arg7: i1):\r\n    %0 = \"hw.constant\"() {value = false} : () -> i1\r\n    %1 = \"hw.wire\"(%7) {name = \"memory_r_addr\"} : (i4) -> i4\r\n    %2 = \"hw.wire\"(%5) {name = \"memory_r_data_a\"} : (i1) -> !seq.clock\r\n    %3 = \"hw.wire\"(%8) {name = \"memory_w_addr\"} : (i4) -> i4\r\n    %4 = \"seq.firmem\"() <{name = \"memory_a\", prefix = \"\", readLatency = 1 : i32, ruw = 0 : i32, writeLatency = 1 : i32, wuw = 1 : i32}> : () -> !seq.firmem<16 x 1>\r\n    %5 = \"seq.firmem.read_port\"(%4, %1, %arg2, %arg1) : (!seq.firmem<16 x 1>, i4, !seq.clock, i1) -> i1\r\n    %6 = \"comb.and\"(%arg4, %arg7) <{twoState}> : (i1, i1) -> i1\r\n    \"seq.firmem.write_port\"(%4, %3, %arg5, %6, %arg6) <{operandSegmentSizes = array<i32: 1, 1, 1, 1, 1, 0>}> : (!seq.firmem<16 x 1>, i4, !seq.clock, i1, !seq.clock) -> ()\r\n    %7 = \"comb.concat\"(%0, %arg0) : (i1, i3) -> i4\r\n    %8 = \"comb.concat\"(%0, %arg3) : (i1, i3) -> i4\r\n    \"hw.output\"(%2) : (!seq.clock) -> ()\r\n  }) {argLocs = [#loc, #loc, #loc, #loc1, #loc1, #loc1, #loc1, #loc1], argNames = [\"r_addr\", \"r_en\", \"r_clk\", \"w_addr\", \"w_en\", \"w_clk\", \"w_data_a\", \"w_mask_a\"], arg_attrs = [{}, {}, {}, {}, {}, {}, {}, {}], comment = \"\", function_type = (i3, i1, !seq.clock, i3, i1, !seq.clock, !seq.clock, i1) -> !seq.clock, parameters = [], res_attrs = [{}], resultLocs = [#loc], resultNames = [\"r_data_a\"], sym_name = \"Foo\"} : () -> ()\r\n}) : () -> ()\r\n```\r\n\r\nIf I compile with `firtool-1.53.0 Memory.fir -disable-all-randomization`, I get the following Verilog:\r\n```verilog\r\n// Generated by CIRCT firtool-1.53.0\r\n// VCS coverage exclude_file\r\nmodule memory_a_16x1(\r\n  input  [3:0] R0_addr,\r\n  input        R0_en,\r\n               R0_clk,\r\n  input  [3:0] W0_addr,\r\n  input        W0_en,\r\n               W0_clk,\r\n               W0_data,\r\n  output       R0_data\r\n);\r\n\r\n  reg       Memory[0:15];\r\n  reg       _R0_en_d0;\r\n  reg [3:0] _R0_addr_d0;\r\n  always @(posedge R0_clk) begin\r\n    _R0_en_d0 <= R0_en;\r\n    _R0_addr_d0 <= R0_addr;\r\n  end // always @(posedge)\r\n  always @(posedge W0_clk) begin\r\n    if (W0_en)\r\n      Memory[W0_addr] <= W0_data;\r\n  end // always @(posedge)\r\n  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 1'bx;\r\nendmodule\r\n\r\nmodule Foo(\r\n  input  [2:0] r_addr,\r\n  input        r_en,\r\n               r_clk,\r\n  input  [2:0] w_addr,\r\n  input        w_en,\r\n               w_clk,\r\n               w_data_a,\r\n               w_mask_a,\r\n  output       r_data_a\r\n);\r\n\r\n  memory_a_16x1 memory_a_ext (\r\n    .R0_addr ({1'h0, r_addr}),\r\n    .R0_en   (r_en),\r\n    .R0_clk  (r_clk),\r\n    .W0_addr ({1'h0, w_addr}),\r\n    .W0_en   (w_en & w_mask_a),\r\n    .W0_clk  (w_clk),\r\n    .W0_data (w_data_a),\r\n    .R0_data (r_data_a)\r\n  );\r\nendmodule\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input r: {addr: UInt<3>, en: UInt<1> clk: Clock, flip data: {a: Clock}}\r\n    input w: {addr: UInt<3>, en: UInt<1> clk: Clock, data: {a: Clock}, mask: {a: UInt<1>}}\r\n\r\n    mem memory:\r\n      data-type => {a: Clock}\r\n      depth => 16\r\n      reader => r\r\n      writer => w\r\n      read-latency => 1\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n\r\n    memory.r <= r\r\n    memory.w <= w", "code_snippet_02": "Memory.fir:6:5: error: 'hw.wire' op requires the same type for all operands and results\r\n    mem memory:\r\n    ^\r\nMemory.fir:6:5: note: see current operation: %2 = \"hw.wire\"(%5) {name = \"memory_r_data_a\"} : (i1) -> !seq.clock", "code_snippet_03": "#loc = loc(\"Memory.fir\":3:11)\r\n#loc1 = loc(\"Memory.fir\":4:11)\r\n\"builtin.module\"() ({\r\n  \"hw.module\"() ({\r\n  ^bb0(%arg0: i3, %arg1: i1, %arg2: !seq.clock, %arg3: i3, %arg4: i1, %arg5: !seq.clock, %arg6: !seq.clock, %arg7: i1):\r\n    %0 = \"hw.constant\"() {value = false} : () -> i1\r\n    %1 = \"hw.wire\"(%7) {name = \"memory_r_addr\"} : (i4) -> i4\r\n    %2 = \"hw.wire\"(%5) {name = \"memory_r_data_a\"} : (i1) -> !seq.clock\r\n    %3 = \"hw.wire\"(%8) {name = \"memory_w_addr\"} : (i4) -> i4\r\n    %4 = \"seq.firmem\"() <{name = \"memory_a\", prefix = \"\", readLatency = 1 : i32, ruw = 0 : i32, writeLatency = 1 : i32, wuw = 1 : i32}> : () -> !seq.firmem<16 x 1>\r\n    %5 = \"seq.firmem.read_port\"(%4, %1, %arg2, %arg1) : (!seq.firmem<16 x 1>, i4, !seq.clock, i1) -> i1\r\n    %6 = \"comb.and\"(%arg4, %arg7) <{twoState}> : (i1, i1) -> i1\r\n    \"seq.firmem.write_port\"(%4, %3, %arg5, %6, %arg6) <{operandSegmentSizes = array<i32: 1, 1, 1, 1, 1, 0>}> : (!seq.firmem<16 x 1>, i4, !seq.clock, i1, !seq.clock) -> ()\r\n    %7 = \"comb.concat\"(%0, %arg0) : (i1, i3) -> i4\r\n    %8 = \"comb.concat\"(%0, %arg3) : (i1, i3) -> i4\r\n    \"hw.output\"(%2) : (!seq.clock) -> ()\r\n  }) {argLocs = [#loc, #loc, #loc, #loc1, #loc1, #loc1, #loc1, #loc1], argNames = [\"r_addr\", \"r_en\", \"r_clk\", \"w_addr\", \"w_en\", \"w_clk\", \"w_data_a\", \"w_mask_a\"], arg_attrs = [{}, {}, {}, {}, {}, {}, {}, {}], comment = \"\", function_type = (i3, i1, !seq.clock, i3, i1, !seq.clock, !seq.clock, i1) -> !seq.clock, parameters = [], res_attrs = [{}], resultLocs = [#loc], resultNames = [\"r_data_a\"], sym_name = \"Foo\"} : () -> ()\r\n}) : () -> ()", "code_snippet_04": "// Generated by CIRCT firtool-1.53.0\r\n// VCS coverage exclude_file\r\nmodule memory_a_16x1(\r\n  input  [3:0] R0_addr,\r\n  input        R0_en,\r\n               R0_clk,\r\n  input  [3:0] W0_addr,\r\n  input        W0_en,\r\n               W0_clk,\r\n               W0_data,\r\n  output       R0_data\r\n);\r\n\r\n  reg       Memory[0:15];\r\n  reg       _R0_en_d0;\r\n  reg [3:0] _R0_addr_d0;\r\n  always @(posedge R0_clk) begin\r\n    _R0_en_d0 <= R0_en;\r\n    _R0_addr_d0 <= R0_addr;\r\n  end // always @(posedge)\r\n  always @(posedge W0_clk) begin\r\n    if (W0_en)\r\n      Memory[W0_addr] <= W0_data;\r\n  end // always @(posedge)\r\n  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 1'bx;\r\nendmodule\r\n\r\nmodule Foo(\r\n  input  [2:0] r_addr,\r\n  input        r_en,\r\n               r_clk,\r\n  input  [2:0] w_addr,\r\n  input        w_en,\r\n               w_clk,\r\n               w_data_a,\r\n               w_mask_a,\r\n  output       r_data_a\r\n);\r\n\r\n  memory_a_16x1 memory_a_ext (\r\n    .R0_addr ({1'h0, r_addr}),\r\n    .R0_en   (r_en),\r\n    .R0_clk  (r_clk),\r\n    .W0_addr ({1'h0, w_addr}),\r\n    .W0_en   (w_en & w_mask_a),\r\n    .W0_clk  (w_clk),\r\n    .W0_data (w_data_a),\r\n    .R0_data (r_data_a)\r\n  );\r\nendmodule"}, {"number": 6226, "title": "Mixed ssaName and true name fails to parse correctly", "created_at": "2023-09-29T21:51:37Z", "state": "open", "labels": "bug", "body": "See Bar3 below.\r\ncirct-opt foo.mlir --mlir-print-op-generic\r\n\r\n```\r\nhw.module @Bar0(in %0: i1) {\r\n}\r\n\r\nhw.module @Bar1(in %a: i1) {\r\n}\r\n\r\nhw.module @Bar2(in %0 \"space here\" : i1) {\r\n}\r\n\r\nhw.module @Bar3(in %b \"space here\" : i1) {\r\n}\r\n```", "code_snippet_01": "hw.module @Bar0(in %0: i1) {\r\n}\r\n\r\nhw.module @Bar1(in %a: i1) {\r\n}\r\n\r\nhw.module @Bar2(in %0 \"space here\" : i1) {\r\n}\r\n\r\nhw.module @Bar3(in %b \"space here\" : i1) {\r\n}"}, {"number": 6193, "title": "[FIRRTL][firtool] Unknown Windows Release Build Test Failures", "created_at": "2023-09-23T04:21:45Z", "state": "open", "labels": "bug, FIRRTL", "body": "There have been a number of odd test failures that have been observed on Windows release builds.\r\n\r\n## Failures\r\n\r\n### First Failure\r\n\r\nA commit, https://github.com/llvm/circt/commit/3668f6760f9c7ca814035292435f930e30320fea, enabling properties as attributes in the Seq dialect resulted in similar failures in one test. See: https://github.com/llvm/circt/actions/runs/6043611927/job/16400911216 This corrected itself on the subsequent commit, https://github.com/llvm/circt/commit/c88186e18a74fe74e2d2bdb7de2610a0334eaa7d, passed.\r\n\r\nThe failing test was:\r\n  - `Dialect/FIRRTL/SFCTests/width-spec-errors.fir`\r\n\r\nThe exit code was: 3221225477\r\n\r\n### Second Failure\r\n\r\nA commit adding two folders, https://github.com/llvm/circt/commit/68b79fc35fcc2d68abc8a0b830c0f5a303af3f04, failed intermittently. See: https://github.com/llvm/circt/actions/runs/6083208189/job/16502633046. This then passed on retry: https://github.com/llvm/circt/actions/runs/6083208189.\r\n\r\nThe failing test was:\r\n  - `Dialect/FIRRTL/SFCTests/data-taps-flip.fir`\r\n\r\nThe exit code was: 3221225477\r\n\r\nThere was no stack trace.\r\n\r\n### Third Failure\r\n\r\nCommit https://github.com/llvm/circt/commit/3b6f737c360fa19e3f16f9ea4856128f36ce9296 made a change that disabled deduplication. This caused four tests to fail repeatedly. One such run is: https://github.com/llvm/circt/actions/runs/6278904029/job/17056030822\r\n\r\nThe failing tests were:\r\n  - `Dialect/FIRRTL/SFCTests/GrandCentralInterfaces/Wire.fir`\r\n  - `Dialect/FIRRTL/SFCTests/data-taps.fir`\r\n  - `firtool/prefixMemory.fir`\r\n  - `firtool/refs-in-aggs.fir`\r\n\r\nOnly `firtool/prefixMemory.fir` was a test that was sensitive to deduplication and required modifications, in the commit, to fix.\r\n\r\nThis was \"fixed\" by adding a `-no-dedup` option to `firtool` and using it for those four tests. It is unclear if this actually \"fixed\" anything, i.e., if the issue was that not running deduplication fixed it or if this just permuted the sources enough to get `cl` to produce something that didn't crash.\r\n\r\nThe exit code was: 0xc0000005\r\n\r\nThere was a stack trace. (This isn't particularly useful as it is a release build...) Example:\r\n\r\n```\r\n #0 0x00007ff7b9dca204 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x1fa204)\r\n #1 0x00007ff7b9dd00a1 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x2000a1)\r\n #2 0x00007ff7ba5f0107 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa20107)\r\n #3 0x00007ff7ba5f5a27 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa25a27)\r\n #4 0x00007ff7ba5f7529 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa27529)\r\n #5 0x00007ff7ba5f0616 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa20616)\r\n #6 0x00007ff7ba5f6ee2 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa26ee2)\r\n #7 0x00007ff7ba5f00f2 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa200f2)\r\n #8 0x00007ff7ba5f5a27 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa25a27)\r\n #9 0x00007ff7ba5f61fd (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa261fd)\r\n#10 0x00007ff7b9be0544 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x10544)\r\n#11 0x00007ff7b9be09ff (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x109ff)\r\n#12 0x00007ff7b9bdee3b (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xee3b)\r\n#13 0x00007ff7b9be26df (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x126df)\r\n#14 0x00007ff7ba60d560 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa3d560)\r\n#15 0x00007ffe8a4c7ac4 (C:\\Windows\\System32\\KERNEL32.DLL+0x17ac4)\r\n#16 0x00007ffe8bfda351 (C:\\Windows\\SYSTEM32\\ntdll.dll+0x5a351)\r\n```\r\n\r\nJust before the third test, the windows build failed on the previous commit twice. This appeared to be due to issues running PowerShell's `Install-Package`. The two failures were:\r\n\r\n```\r\nWARNING: Unable to resolve package source 'https://www.powershellgallery.com/api/v2'.\r\nInstall-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all\r\navailable registered module repositories.\r\n\r\nError: Process completed with exit code 1.\r\n```\r\n\r\n```\r\nInstall-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all\r\navailable registered module repositories.\r\n\r\nError: Process completed with exit code 1.\r\n```\r\n\r\nThis appears unrelated, though it has high temporal locality to the third failure.\r\n\r\nFor the third failure, I tried a clean rebuild by deleting all `sccache` caches. This again failed in the same way after a 3 hour complete rebuild.\r\n\r\n## Analysis\r\n\r\n1. All tests involved `firtool` end-to-end tests. \r\n2. All tests were some kind of hard crash with exit codes 3221225477 or 0xc0000005. (This is the same number, but the latter seems to produce a stack trace and the former does not.)\r\n3. The third test would repeatedly fail. The second test was intermittent. It is unknown if the first test was intermittent or repeatable.\r\n\r\n## Ideas to try\r\n\r\n1. The Unified Build/Test/Install GitHub Action does support running a Windows build in debug mode or relwithdebinfo. This won't have caching and will be about 3 hours to run.\r\n2. More UBSan or other sanitizers. Is there a way to run these on Windows?", "code_snippet_01": "#0 0x00007ff7b9dca204 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x1fa204)\r\n #1 0x00007ff7b9dd00a1 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x2000a1)\r\n #2 0x00007ff7ba5f0107 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa20107)\r\n #3 0x00007ff7ba5f5a27 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa25a27)\r\n #4 0x00007ff7ba5f7529 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa27529)\r\n #5 0x00007ff7ba5f0616 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa20616)\r\n #6 0x00007ff7ba5f6ee2 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa26ee2)\r\n #7 0x00007ff7ba5f00f2 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa200f2)\r\n #8 0x00007ff7ba5f5a27 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa25a27)\r\n #9 0x00007ff7ba5f61fd (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa261fd)\r\n#10 0x00007ff7b9be0544 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x10544)\r\n#11 0x00007ff7b9be09ff (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x109ff)\r\n#12 0x00007ff7b9bdee3b (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xee3b)\r\n#13 0x00007ff7b9be26df (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0x126df)\r\n#14 0x00007ff7ba60d560 (d:\\a\\circt\\circt\\build\\bin\\firtool.exe+0xa3d560)\r\n#15 0x00007ffe8a4c7ac4 (C:\\Windows\\System32\\KERNEL32.DLL+0x17ac4)\r\n#16 0x00007ffe8bfda351 (C:\\Windows\\SYSTEM32\\ntdll.dll+0x5a351)", "code_snippet_02": "WARNING: Unable to resolve package source 'https://www.powershellgallery.com/api/v2'.\r\nInstall-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all\r\navailable registered module repositories.\r\n\r\nError: Process completed with exit code 1.", "code_snippet_03": "Install-Package: No match was found for the specified search criteria and module name 'VSSetup'. Try Get-PSRepository to see all\r\navailable registered module repositories.\r\n\r\nError: Process completed with exit code 1."}, {"number": 6074, "title": "[FIRRTL] Add missing dialect dependencies", "created_at": "2023-09-07T21:54:58Z", "state": "open", "labels": "bug, FIRRTL", "body": "LowerXMR and LowerToHW, at least, may lower/introduce operations from HW, SV, and Seq dialects.\r\n\r\nFix the dependentDialects to ensure this works properly (such as when invoking via `circt-opt`).\r\n\r\nCurrent failing example to demonstrate:\r\n\r\n```mlir\r\nfirrtl.circuit \"ClockProbe\" {\r\n  firrtl.module @ClockProbe(in %in: !firrtl.clock, out %out: !firrtl.clock) attributes {convention = #firrtl<convention scalarized>} {\r\n    %0 = firrtl.ref.send %in : !firrtl.clock\r\n    %1 = firrtl.ref.resolve %0 : !firrtl.probe<clock>\r\n    firrtl.strictconnect %out, %1 : !firrtl.clock\r\n  }\r\n}\r\n```\r\n\r\nWhich presently errors out when running `circt-opt --firrtl-lower-xmr`:\r\n```\r\nLLVM ERROR: can't create type 'circt::seq::ClockType' because storage uniquer isn't initialized: the dialect was likely not loaded, or the type wasn't added with addTypes<...>() in the Dialect::initialize() method.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/circt-opt --firrtl-lower-xmr ./clock-probe.mlir\r\n```", "code_snippet_01": "firrtl.circuit \"ClockProbe\" {\r\n  firrtl.module @ClockProbe(in %in: !firrtl.clock, out %out: !firrtl.clock) attributes {convention = #firrtl<convention scalarized>} {\r\n    %0 = firrtl.ref.send %in : !firrtl.clock\r\n    %1 = firrtl.ref.resolve %0 : !firrtl.probe<clock>\r\n    firrtl.strictconnect %out, %1 : !firrtl.clock\r\n  }\r\n}", "code_snippet_02": "LLVM ERROR: can't create type 'circt::seq::ClockType' because storage uniquer isn't initialized: the dialect was likely not loaded, or the type wasn't added with addTypes<...>() in the Dialect::initialize() method.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/circt-opt --firrtl-lower-xmr ./clock-probe.mlir"}, {"number": 6059, "title": "[FIRRTL][IMDCE] Annotations on ports are not preserved when moving to wires", "created_at": "2023-09-06T16:02:17Z", "state": "open", "labels": "bug, FIRRTL", "body": "Input:\r\n```mlir\r\n// -----\r\n// Test that annotations keep ports alive.\r\n// CHECK-LABEL: \"AnnoAlivePort\"\r\nfirrtl.circuit \"AnnoAlivePort\" {\r\n  // CHECK: module private @AnnoPort\r\n  firrtl.module private @AnnoPort(out %dead : !firrtl.uint<5> [{class = \"circt.test\"}]) {}\r\n  firrtl.module @AnnoAlivePort() {\r\n    // CHECK: firrtl.instance\r\n    %inst_dead = firrtl.instance inst @AnnoPort(out dead : !firrtl.uint<5>)\r\n  }\r\n}\r\n```\r\n\r\nThe port is dead at instantiation sites but alive within the module, so port is dropped and wire is created for it (maybe it's written/read locally, so on).\r\n\r\nLooks like annotations are not moved to the wire, however, here's the current output pointing IMDCE at the above:\r\n```mlir\r\nfirrtl.circuit \"AnnoAlivePort\" {\r\n  firrtl.module private @AnnoPort() {\r\n    %0 = firrtl.wire : !firrtl.uint<5>\r\n  }\r\n  firrtl.module @AnnoAlivePort() {\r\n    firrtl.instance inst @AnnoPort()\r\n  }\r\n}\r\n```\r\n\r\ncc #6046 for more discussion on annotations and IMDCE, but not directly related.", "code_snippet_01": "// -----\r\n// Test that annotations keep ports alive.\r\n// CHECK-LABEL: \"AnnoAlivePort\"\r\nfirrtl.circuit \"AnnoAlivePort\" {\r\n  // CHECK: module private @AnnoPort\r\n  firrtl.module private @AnnoPort(out %dead : !firrtl.uint<5> [{class = \"circt.test\"}]) {}\r\n  firrtl.module @AnnoAlivePort() {\r\n    // CHECK: firrtl.instance\r\n    %inst_dead = firrtl.instance inst @AnnoPort(out dead : !firrtl.uint<5>)\r\n  }\r\n}", "code_snippet_02": "firrtl.circuit \"AnnoAlivePort\" {\r\n  firrtl.module private @AnnoPort() {\r\n    %0 = firrtl.wire : !firrtl.uint<5>\r\n  }\r\n  firrtl.module @AnnoAlivePort() {\r\n    firrtl.instance inst @AnnoPort()\r\n  }\r\n}"}, {"number": 6013, "title": "[FIRRTL] Need to handle Macro Collision", "created_at": "2023-08-31T17:46:47Z", "state": "open", "labels": "bug, FIRRTL", "body": "If a FIRRTL name collides with a macro, the compiler currently crashes. `LowerToHW` and others need to disconnect the symbol creation from the name of the symbol. `sv.macro.decl` already has support for this. It is not used yet.\r\n\r\nConsider:\r\n\r\n```\r\nFIRRTL version 4.0.0\r\ncircuit RANDOM:\r\n  module RANDOM:\r\n    input clock: Clock\r\n    input d: UInt<1>\r\n    output q: UInt<1>\r\n\r\n    reg r: UInt<1>, clock\r\n\r\n    connect r, d\r\n    connect q, r\r\n```\r\n\r\nThis errors during `LowerToHW` with:\r\n\r\n```\r\n<unknown>:0: error: Referenced macro doesn't exist \"ENABLE_INITIAL_MEM_\"\r\n<unknown>:0: note: see current operation: \"sv.macro.def\"() {format_string = \"\", macroName = @ENABLE_INITIAL_MEM_, symbols = []} : () -> ()\r\n```", "code_snippet_01": "FIRRTL version 4.0.0\r\ncircuit RANDOM:\r\n  module RANDOM:\r\n    input clock: Clock\r\n    input d: UInt<1>\r\n    output q: UInt<1>\r\n\r\n    reg r: UInt<1>, clock\r\n\r\n    connect r, d\r\n    connect q, r", "code_snippet_02": "<unknown>:0: error: Referenced macro doesn't exist \"ENABLE_INITIAL_MEM_\"\r\n<unknown>:0: note: see current operation: \"sv.macro.def\"() {format_string = \"\", macroName = @ENABLE_INITIAL_MEM_, symbols = []} : () -> ()"}, {"number": 5886, "title": "[FIRRTL] Enum with uninferred reset", "created_at": "2023-08-18T16:04:53Z", "state": "open", "labels": "bug, FIRRTL, Arc", "body": "Input:\r\n```\r\ncircuit ResetEnum:\r\n  module ResetEnum:\r\n    input in : {| Some: UInt<1> |}\r\n    output out: {| Some: Reset |}\r\n    out <= in\r\n```\r\n\r\nCrashes during parsing, related: #5322 .", "code_snippet_01": "circuit ResetEnum:\r\n  module ResetEnum:\r\n    input in : {| Some: UInt<1> |}\r\n    output out: {| Some: Reset |}\r\n    out <= in"}, {"number": 5884, "title": "[FIRRTL] Can't parse const enum (and therefore can't parse enum w/const elements)", "created_at": "2023-08-18T16:00:26Z", "state": "open", "labels": "bug, FIRRTL", "body": "Enum's must be const if their elements are const, but the way we parse constructs a non-const enum (with the parsed element types) before converting it to const.\r\n\r\nConsider:\r\n\r\n```\r\ncircuit EnumConst:\r\n  module EnumConst:\r\n    input e : {| Some : const UInt<8>, None |}\r\n```\r\nWhich is invalid and should diagnose the invalid enum type.\r\n\r\nor this legal enum:\r\n\r\n```\r\ncircuit ConstEnumConst:\r\n  module ConstEnumConst:\r\n    input e : const {| Some : const UInt<8>, None |}\r\n```", "code_snippet_01": "circuit EnumConst:\r\n  module EnumConst:\r\n    input e : {| Some : const UInt<8>, None |}", "code_snippet_02": "circuit ConstEnumConst:\r\n  module ConstEnumConst:\r\n    input e : const {| Some : const UInt<8>, None |}"}, {"number": 5772, "title": "[Comb] comb.concat doesn't work with type alias", "created_at": "2023-08-03T13:32:25Z", "state": "open", "labels": "bug, Comb", "body": "```\r\nhw.type_scope @__hw_typedecls {\r\n  hw.typedecl @foo : i1\r\n}\r\n\r\nhw.module @Top(%arg0: !hw.typealias<@__hw_typedecls::@foo,i1>) {\r\n  %0 = comb.concat %arg0 : !hw.typealias<@__hw_typedecls::@foo,i1>\r\n}\r\n```\r\n\r\n```\r\ncirct-opt: /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ./build/bin/circt-opt foo.mlir\r\n1.      MLIR Parser: custom op parser 'hw.module'\r\n2.      MLIR Parser: custom op parser 'comb.concat'\r\n #0 0x0000000000447057 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x00000000004451e0 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x000000000044796f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007fe418fd6cf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)\r\n #4 0x00007fe417e61aff raise (/lib64/libc.so.6+0x4eaff)\r\n #5 0x00007fe417e34ea5 abort (/lib64/libc.so.6+0x21ea5)\r\n #6 0x00007fe417e34d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)\r\n #7 0x00007fe417e5a456 (/lib64/libc.so.6+0x47456)\r\n #8 0x0000000000609c3b (./build/bin/circt-opt+0x609c3b)\r\n #9 0x000000000060c749 circt::comb::ConcatOp::inferReturnTypes(mlir::MLIRContext*, std::optional<mlir::Location>, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::RegionRange, llvm::SmallVectorImpl<mlir::Type>&) /scratch/hidetou/circt/lib/Dialect/Comb/CombOps.cpp:270:21\r\n#10 0x000000000060c749 circt::comb::ConcatOp::parse(mlir::OpAsmParser&, mlir::OperationState&) /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/Comb/Comb.cpp.inc:948:22\r\n#11 0x00000000014d521f mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#12 0x00000000014d521f mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43\r\n#13 0x00000000014d521f (anonymous namespace)::CustomOpAsmParser::parseOperation(mlir::OperationState&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1491:9\r\n#14 0x00000000014d521f (anonymous namespace)::OperationParser::parseCustomOperation(llvm::ArrayRef<std::tuple<llvm::StringRef, unsigned int, llvm::SMLoc>>) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1987:19\r\n#15 0x00000000014d521f (anonymous namespace)::OperationParser::parseOperation() /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1146:10\r\n#16 0x00000000014e0ac0 mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#17 0x00000000014e0ac0 mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43\r\n#18 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlockBody(mlir::Block*) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2263:9\r\n#19 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2193:12\r\n```", "code_snippet_01": "hw.type_scope @__hw_typedecls {\r\n  hw.typedecl @foo : i1\r\n}\r\n\r\nhw.module @Top(%arg0: !hw.typealias<@__hw_typedecls::@foo,i1>) {\r\n  %0 = comb.concat %arg0 : !hw.typealias<@__hw_typedecls::@foo,i1>\r\n}", "code_snippet_02": "circt-opt: /scratch/hidetou/circt/llvm/llvm/include/llvm/Support/Casting.h:566: decltype(auto) llvm::cast(const From &) [To = mlir::IntegerType, From = mlir::Type]: Assertion `isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: ./build/bin/circt-opt foo.mlir\r\n1.      MLIR Parser: custom op parser 'hw.module'\r\n2.      MLIR Parser: custom op parser 'comb.concat'\r\n #0 0x0000000000447057 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x00000000004451e0 llvm::sys::RunSignalHandlers() /scratch/hidetou/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x000000000044796f SignalHandler(int) /scratch/hidetou/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #3 0x00007fe418fd6cf0 __restore_rt (/lib64/libpthread.so.0+0x12cf0)\r\n #4 0x00007fe417e61aff raise (/lib64/libc.so.6+0x4eaff)\r\n #5 0x00007fe417e34ea5 abort (/lib64/libc.so.6+0x21ea5)\r\n #6 0x00007fe417e34d79 _nl_load_domain.cold.0 (/lib64/libc.so.6+0x21d79)\r\n #7 0x00007fe417e5a456 (/lib64/libc.so.6+0x47456)\r\n #8 0x0000000000609c3b (./build/bin/circt-opt+0x609c3b)\r\n #9 0x000000000060c749 circt::comb::ConcatOp::inferReturnTypes(mlir::MLIRContext*, std::optional<mlir::Location>, mlir::ValueRange, mlir::DictionaryAttr, mlir::OpaqueProperties, mlir::RegionRange, llvm::SmallVectorImpl<mlir::Type>&) /scratch/hidetou/circt/lib/Dialect/Comb/CombOps.cpp:270:21\r\n#10 0x000000000060c749 circt::comb::ConcatOp::parse(mlir::OpAsmParser&, mlir::OperationState&) /scratch/hidetou/circt/build/tools/circt/include/circt/Dialect/Comb/Comb.cpp.inc:948:22\r\n#11 0x00000000014d521f mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#12 0x00000000014d521f mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43\r\n#13 0x00000000014d521f (anonymous namespace)::CustomOpAsmParser::parseOperation(mlir::OperationState&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1491:9\r\n#14 0x00000000014d521f (anonymous namespace)::OperationParser::parseCustomOperation(llvm::ArrayRef<std::tuple<llvm::StringRef, unsigned int, llvm::SMLoc>>) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1987:19\r\n#15 0x00000000014d521f (anonymous namespace)::OperationParser::parseOperation() /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:1146:10\r\n#16 0x00000000014e0ac0 mlir::LogicalResult::failed() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#17 0x00000000014e0ac0 mlir::ParseResult::operator bool() const /scratch/hidetou/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:126:43\r\n#18 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlockBody(mlir::Block*) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2263:9\r\n#19 0x00000000014e0ac0 (anonymous namespace)::OperationParser::parseBlock(mlir::Block*&) /scratch/hidetou/circt/llvm/mlir/lib/AsmParser/Parser.cpp:2193:12"}, {"number": 5727, "title": "[FIRRTL] Lower XMR assumes unique port names", "created_at": "2023-07-28T21:07:23Z", "state": "open", "labels": "bug, FIRRTL", "body": "FIRRTL's `LoweXMR` pass will currently produce invalid IR if it is given a module which has duplicate port names.\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [\"a\", \"a\"]} {\r\n    %b = firrtl.wire interesting_name : !firrtl.uint<1>\r\n    %0 = firrtl.ref.send %b : !firrtl.uint<1>\r\n    firrtl.ref.define %a, %0 : !firrtl.probe<uint<1>>\r\n    %1 = firrtl.ref.send %b : !firrtl.uint<1>\r\n    firrtl.ref.define %a0, %1 : !firrtl.probe<uint<1>>\r\n  }\r\n}\r\n```\r\n\r\nThis produces:\r\n\r\n```\r\n# circt-opt Foo.mlir -firrtl-lower-xmr                                   \r\nfirrtl-snippets/issues/x.mlir:3:5: error: redefinition of symbol named 'ref_Foo_Foo_a'\r\n    firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [\"a\", \"a\"]} {\r\n    ^\r\nfirrtl-snippets/issues/x.mlir:3:5: note: see current operation: \"sv.macro.decl\"() {sym_name = \"ref_Foo_Foo_a\"} : () -> ()\r\nfirrtl-snippets/issues/x.mlir:3:5: note: see existing symbol definition here\r\n```", "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [\"a\", \"a\"]} {\r\n    %b = firrtl.wire interesting_name : !firrtl.uint<1>\r\n    %0 = firrtl.ref.send %b : !firrtl.uint<1>\r\n    firrtl.ref.define %a, %0 : !firrtl.probe<uint<1>>\r\n    %1 = firrtl.ref.send %b : !firrtl.uint<1>\r\n    firrtl.ref.define %a0, %1 : !firrtl.probe<uint<1>>\r\n  }\r\n}", "code_snippet_02": "# circt-opt Foo.mlir -firrtl-lower-xmr                                   \r\nfirrtl-snippets/issues/x.mlir:3:5: error: redefinition of symbol named 'ref_Foo_Foo_a'\r\n    firrtl.module @Foo(out %a: !firrtl.probe<uint<1>>, out %a0: !firrtl.probe<uint<1>>) attributes {convention = #firrtl<convention scalarized>, portNames = [\"a\", \"a\"]} {\r\n    ^\r\nfirrtl-snippets/issues/x.mlir:3:5: note: see current operation: \"sv.macro.decl\"() {sym_name = \"ref_Foo_Foo_a\"} : () -> ()\r\nfirrtl-snippets/issues/x.mlir:3:5: note: see existing symbol definition here"}, {"number": 5721, "title": "[FIRRTL] FIRRTL Exporter needs to unique names", "created_at": "2023-07-28T17:58:04Z", "state": "open", "labels": "bug, good first issue", "body": "Currently, the FIRRTL exporter will not properly unique names during emission (like what `ExportVerilog` does). Consider the following:\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo() {\r\n    %0 = firrtl.wire {name = \"a\"} : !firrtl.uint<1>\r\n    %1 = firrtl.wire {name = \"a\"} : !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nThis produces the following illegal FIRRTL (`circt-translate -export-firrtl Foo.mlir`):\r\n```\r\nFIRRTL version 3.1.0\r\ncircuit Foo :\r\n  module Foo : \r\n    wire a : UInt<1> \r\n    wire a : UInt<1> \r\n```\r\n\r\n`wire a` is defined twice.", "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo() {\r\n    %0 = firrtl.wire {name = \"a\"} : !firrtl.uint<1>\r\n    %1 = firrtl.wire {name = \"a\"} : !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_02": "FIRRTL version 3.1.0\r\ncircuit Foo :\r\n  module Foo : \r\n    wire a : UInt<1> \r\n    wire a : UInt<1>"}, {"number": 5590, "title": "[FIRRTL][LowerToHW] Zero-width signals with inner symbol are silently deleted, breaking users", "created_at": "2023-07-14T17:16:38Z", "state": "open", "labels": "bug, FIRRTL", "body": "Consider this MLIR example:\r\n\r\n```\r\nmodule {\r\n  firrtl.circuit \"OMIRField\" {\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0>, out %y_b: !firrtl.uint<0>) {\r\n      %n_b = firrtl.node sym @omir_sym %x_b : !firrtl.uint<0>\r\n      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>\r\n    }\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n}\r\n```\r\n\r\nFeeding through LowerToHW: `circt-opt --lower-firrtl-to-hw` produces:\r\n\r\n```\r\nmodule {\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n  hw.module @OMIRField() {\r\n    hw.output\r\n  }\r\n}\r\n```\r\n\r\nAnd if run through `firtool` directly, produces:\r\n```\r\nomir_zw_field_issue.mlir:8:3: error: cannot get name for symbol #hw.innerNameRef<@OMIRField::@omir_sym>\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n  ^\r\nomir_zw_field_issue.mlir:8:3: note: see current operation: \"sv.verbatim\"() {format_string = \"Testing {{0}}\", symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]} : () -> ()\r\n// Generated by CIRCT 1.46.0g20230714_98d0bf5\r\nTesting <INVALID>\t// omir_zw_field_issue.mlir:8:3\r\nmodule OMIRField();\t// omir_zw_field_issue.mlir:3:5\r\nendmodule\r\n```\r\n\r\nThe non-failing error isn't great and should be fixed (cc #4770 for similar in adjacent code).\r\nAlso, this should be caught by the verifier in HW but that support isn't in place yet (cc #3526).\r\n\r\n---\r\n\r\nMoving the symbol to a port produces an error, modified input:\r\n\r\n```\r\nmodule {\r\n  firrtl.circuit \"OMIRField\" {\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {\r\n      %n_b = firrtl.node %x_b : !firrtl.uint<0>\r\n      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>\r\n    }\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n}\r\n```\r\n\r\nError:\r\n```\r\nomir_zw_field_issue.mlir:3:33: error: zero width port \"x_b\" is referenced by name [#hw<innerSym@omir_sym>] (e.g. in an XMR) but must be removed\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {\r\n                                ^\r\n```", "code_snippet_01": "module {\r\n  firrtl.circuit \"OMIRField\" {\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0>, out %y_b: !firrtl.uint<0>) {\r\n      %n_b = firrtl.node sym @omir_sym %x_b : !firrtl.uint<0>\r\n      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>\r\n    }\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n}", "code_snippet_02": "module {\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n  hw.module @OMIRField() {\r\n    hw.output\r\n  }\r\n}", "code_snippet_03": "omir_zw_field_issue.mlir:8:3: error: cannot get name for symbol #hw.innerNameRef<@OMIRField::@omir_sym>\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n  ^\r\nomir_zw_field_issue.mlir:8:3: note: see current operation: \"sv.verbatim\"() {format_string = \"Testing {{0}}\", symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]} : () -> ()\r\n// Generated by CIRCT 1.46.0g20230714_98d0bf5\r\nTesting <INVALID>\t// omir_zw_field_issue.mlir:8:3\r\nmodule OMIRField();\t// omir_zw_field_issue.mlir:3:5\r\nendmodule", "code_snippet_04": "module {\r\n  firrtl.circuit \"OMIRField\" {\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {\r\n      %n_b = firrtl.node %x_b : !firrtl.uint<0>\r\n      firrtl.strictconnect %y_b, %n_b : !firrtl.uint<0>\r\n    }\r\n  }\r\n  sv.verbatim \"Testing {{0}}\" {symbols = [#hw.innerNameRef<@OMIRField::@omir_sym>]}\r\n}", "code_snippet_05": "omir_zw_field_issue.mlir:3:33: error: zero width port \"x_b\" is referenced by name [#hw<innerSym@omir_sym>] (e.g. in an XMR) but must be removed\r\n    firrtl.module @OMIRField(in %x_b: !firrtl.uint<0> sym @omir_sym, out %y_b: !firrtl.uint<0>) {\r\n                                ^"}, {"number": 5566, "title": "[SV] Crash in `P/BPAssignOp` verifiers for `hw.inout` ports", "created_at": "2023-07-12T07:32:39Z", "state": "open", "labels": "bug, good first issue, Verilog/SystemVerilog", "body": "[In the SV `P/BPAssignOp` verifiers](https://github.com/llvm/circt/blob/main/lib/Dialect/SV/SVOps.cpp#L1142-L1156) it is assumed that the target argument is defined by an op (`isa` used on `getDefiningOp`). Hence, in the case of a `hw.inout` input port, the verifier crashes.\r\n\r\ni.e.:\r\n```mlir\r\nhw.module @unsupported(%a: !hw.inout<i42>) {\r\n  %clock = hw.constant 1 : i1\r\n  %c42 = hw.constant 42 : i42\r\n  sv.alwaysff(posedge %clock) {\r\n    sv.passign %a, %c42 : i42\r\n  }\r\n}\r\n```\r\n\r\n", "code_snippet_01": "hw.module @unsupported(%a: !hw.inout<i42>) {\r\n  %clock = hw.constant 1 : i1\r\n  %c42 = hw.constant 42 : i42\r\n  sv.alwaysff(posedge %clock) {\r\n    sv.passign %a, %c42 : i42\r\n  }\r\n}"}, {"number": 5562, "title": "[FIRRTL][LowerToHW] An uninstantiated module can crash LowerToHW", "created_at": "2023-07-10T23:17:06Z", "state": "open", "labels": "bug, FIRRTL", "body": "I came across the following failure. The problem occurs if a module which is not under the main module in the instance graph includes reference type ports:\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo() {}\r\n  firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.probe<uint<1>>) {\r\n    %0 = firrtl.ref.send %a : !firrtl.uint<1>\r\n    firrtl.ref.define %b, %0 : !firrtl.probe<uint<1>>\r\n  }\r\n}\r\n```\r\n\r\nThe failure trips an assert in `LowerToHW` [here](https://github.com/llvm/circt/blob/main/lib/Conversion/FIRRTLToHW/LowerToHW.cpp#L2337):\r\n\r\n```\r\nAssertion failed: ((!result || !isa<FIRRTLType>(result.getType())) && \"Lowering didn't turn a FIRRTL value into a non-FIRRTL value\"), function setLowering, file LowerToHW.cpp, line 2338.\r\n```", "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo() {}\r\n  firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.probe<uint<1>>) {\r\n    %0 = firrtl.ref.send %a : !firrtl.uint<1>\r\n    firrtl.ref.define %b, %0 : !firrtl.probe<uint<1>>\r\n  }\r\n}", "code_snippet_02": "Assertion failed: ((!result || !isa<FIRRTLType>(result.getType())) && \"Lowering didn't turn a FIRRTL value into a non-FIRRTL value\"), function setLowering, file LowerToHW.cpp, line 2338."}, {"number": 5483, "title": "[ExportVerilog] Missing `hw.struct_explode` support?", "created_at": "2023-06-26T22:23:43Z", "state": "open", "labels": "bug, HW", "body": "Running `circt-opt <file.mlir> --export-verilog` with `file.mlir` having the following content:\r\n```mlir\r\nmodule {\r\n  hw.module @EXPLODE(%0: i64, %1: i64) -> (arg1: i64, arg2: i64) {\r\n    %2 = hw.struct_create (%0, %1) : !hw.struct<arg1: i64, arg2: i64>\r\n    %arg1, %arg2 = hw.struct_explode %2 : !hw.struct<arg1: i64, arg2: i64>\r\n\r\n    hw.output %arg1, %arg2 : i64, i64\r\n  }\r\n}\r\n```\r\ntriggers the following assertion:\r\n```\r\ncirct-opt: circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:3295:\r\nvoid (anonymous namespace)::NameCollector::collectNames(mlir::Block &): \r\nAssertion `(!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options))\r\n && \"If 'op' is a verilog expression, the expression must be inlinable. \" \r\n \"Otherwise, it is a bug of PrepareForEmission\"' failed.\r\n```\r\n\r\nThis seems to be strongly related to the `hw.struct_explode` operation, because replacing it with `hw.struct_extract` ops works just fine.\r\n\r\n(Yes, I know that in this case, the canonicalizer would optimize `hw.struct_create` and `hw.struct_explode` away. But this is the smallest example that I could come up with to reproduce the bug.)", "code_snippet_01": "module {\r\n  hw.module @EXPLODE(%0: i64, %1: i64) -> (arg1: i64, arg2: i64) {\r\n    %2 = hw.struct_create (%0, %1) : !hw.struct<arg1: i64, arg2: i64>\r\n    %arg1, %arg2 = hw.struct_explode %2 : !hw.struct<arg1: i64, arg2: i64>\r\n\r\n    hw.output %arg1, %arg2 : i64, i64\r\n  }\r\n}", "code_snippet_02": "circt-opt: circt/lib/Conversion/ExportVerilog/ExportVerilog.cpp:3295:\r\nvoid (anonymous namespace)::NameCollector::collectNames(mlir::Block &): \r\nAssertion `(!isExpr || isExpressionEmittedInline(&op, moduleEmitter.state.options))\r\n && \"If 'op' is a verilog expression, the expression must be inlinable. \" \r\n \"Otherwise, it is a bug of PrepareForEmission\"' failed."}, {"number": 5462, "title": "[FIRRTL][CheckCombCycles] Missed cycles, sensitive to presence of node?", "created_at": "2023-06-22T23:52:10Z", "state": "open", "labels": "bug, FIRRTL", "body": "Input, `--preserve-aggregate=all`:\r\n\r\n```firrtl\r\ncircuit Loop:\r\n  module Loop:\r\n    wire w : {a: UInt<8>}\r\n    node n = w\r\n    w <= n\r\n```\r\n\r\nFor some reason the node is needed for this to be missed (?).\r\n\r\nThis was reduced from slightly more complicated interprocedural inputs like:\r\n\r\n```firrtl\r\ncircuit Loop:\r\n  module Child:\r\n    input bundle : { a : UInt<1>, b : UInt<1> }\r\n    output p : {a : UInt<1>, b : UInt<1> }\r\n\r\n    node n = bundle\r\n\r\n    p <= n\r\n  module Loop:\r\n    input x : UInt<1>\r\n\r\n    inst c of Child\r\n    c.bundle.a <= x\r\n    c.bundle.b <= c.p.b\r\n```\r\n\r\n----\r\n\r\nDoes not appear to be limited to cycles entirely unreachable/disconnected from the rest of the design/ports, FWIW, consider:\r\n\r\n```firrtl\r\ncircuit Loop:\r\n  module Loop:\r\n    input in : {a: UInt<8>}\r\n    output out : {a: UInt<8>}\r\n    input c : UInt<1>\r\n\r\n    wire w : {a: UInt<8>}\r\n    node n = w\r\n    w <= mux(c, n, in)\r\n\r\n    out <= w\r\n```", "code_snippet_01": "circuit Loop:\r\n  module Loop:\r\n    wire w : {a: UInt<8>}\r\n    node n = w\r\n    w <= n", "code_snippet_02": "circuit Loop:\r\n  module Child:\r\n    input bundle : { a : UInt<1>, b : UInt<1> }\r\n    output p : {a : UInt<1>, b : UInt<1> }\r\n\r\n    node n = bundle\r\n\r\n    p <= n\r\n  module Loop:\r\n    input x : UInt<1>\r\n\r\n    inst c of Child\r\n    c.bundle.a <= x\r\n    c.bundle.b <= c.p.b", "code_snippet_03": "circuit Loop:\r\n  module Loop:\r\n    input in : {a: UInt<8>}\r\n    output out : {a: UInt<8>}\r\n    input c : UInt<1>\r\n\r\n    wire w : {a: UInt<8>}\r\n    node n = w\r\n    w <= mux(c, n, in)\r\n\r\n    out <= w"}, {"number": 5447, "title": "[FIRRTL][InferWidths] Make checkCycles Iterative", "created_at": "2023-06-21T15:58:20Z", "state": "open", "labels": "bug, FIRRTL", "body": "The method `InferWidths::checkCycles` is currently recursive. If `firtool` is spawned in a thread which has an abnormally low stack size (i.e., on MacOS running Chisel tests using Scalatest), this can result in stack overflows. Fix this method to make it recursive. This is similar to https://github.com/llvm/circt/pull/5305."}, {"number": 5355, "title": "[HWLegalizeModules] Legalize array concat op", "created_at": "2023-06-10T10:18:04Z", "state": "open", "labels": "bug, HW", "body": "Support hw.array_concat in HWLegalizeModules\r\n```mlir\r\n$ ./build/bin/firtool perf/regress/chipyard.TestHarness.RocketSmall1Medium1Big1_BoomMedium1Large1Mega1.top.v.hi.fir -o foo.sv --lowering-options=disallowLocalVariables,disallowPackedArrays\r\nArbiters.scala:42:16: error: unsupported packed array expression\r\nArbiters.scala:42:16: note: see current operation: %57 = \"hw.array_concat\"(%3, %56) : (!hw.array<3xi1>, !hw.array<5xi1>) -> !hw.array<8xi1>\r\n```\r\n", "code_snippet_01": "$ ./build/bin/firtool perf/regress/chipyard.TestHarness.RocketSmall1Medium1Big1_BoomMedium1Large1Mega1.top.v.hi.fir -o foo.sv --lowering-options=disallowLocalVariables,disallowPackedArrays\r\nArbiters.scala:42:16: error: unsupported packed array expression\r\nArbiters.scala:42:16: note: see current operation: %57 = \"hw.array_concat\"(%3, %56) : (!hw.array<3xi1>, !hw.array<5xi1>) -> !hw.array<8xi1>"}, {"number": 5205, "title": "[FIRRTL] Exporter prints invalid probe of constant (, inline expressions?)", "created_at": "2023-05-16T15:34:54Z", "state": "open", "labels": "bug, FIRRTL", "body": "Cannot probe inline expressions, probe target must be a static reference to a declaration (in current spec anyway).\r\n\r\nConsider:\r\n\r\n```mlir\r\nfirrtl.circuit \"ProbeConstant\" {\r\n  firrtl.module @ProbeConstant(out %bore: !firrtl.probe<uint<1>>) {\r\n    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1> {name = \"internalWire\"}\r\n    %0 = firrtl.ref.send %c0_ui1 : !firrtl.uint<1>\r\n    firrtl.ref.define %bore, %0 : !firrtl.probe<uint<1>>\r\n  }\r\n}\r\n```\r\n\r\nWhich becomes:\r\n\r\n```firrtl\r\ncircuit ProbeConstant :\r\n  module ProbeConstant :\r\n    output bore : Probe<UInt<1>>\r\n\r\n    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]\r\n```\r\n\r\nWhich is invalid and does not parse:\r\n\r\n```\r\n<stdin>:5:25: error: use of unknown declaration 'UInt'\r\n    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]\r\n```\r\n\r\nNot sure what approach works best with Exporter, but strategies such as giving expression a name with a node (or wire if non-passive) would give something to probe.", "code_snippet_01": "firrtl.circuit \"ProbeConstant\" {\r\n  firrtl.module @ProbeConstant(out %bore: !firrtl.probe<uint<1>>) {\r\n    %c0_ui1 = firrtl.constant 0 : !firrtl.uint<1> {name = \"internalWire\"}\r\n    %0 = firrtl.ref.send %c0_ui1 : !firrtl.uint<1>\r\n    firrtl.ref.define %bore, %0 : !firrtl.probe<uint<1>>\r\n  }\r\n}", "code_snippet_02": "circuit ProbeConstant :\r\n  module ProbeConstant :\r\n    output bore : Probe<UInt<1>>\r\n\r\n    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]", "code_snippet_03": "<stdin>:5:25: error: use of unknown declaration 'UInt'\r\n    define bore = probe(UInt<1>(0)) @[export_probe_constant.mlir 5:5]"}, {"number": 5204, "title": "[FIRRTL] Register with Self Connection Crashes Exporter", "created_at": "2023-05-16T02:21:20Z", "state": "open", "labels": "bug, FIRRTL", "body": "Consider the following FIRRTL Dialect:\r\n\r\n```mlir\r\nfirrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(in %clock: !firrtl.clock, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>\r\n    %0 = firrtl.wire : !firrtl.uint<1>\r\n    %r = firrtl.regreset interesting_name %clock, %c1_ui1, %0 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.strictconnect %0, %r : !firrtl.uint<1>\r\n  }\r\n}\r\n```\r\n\r\nThis produces a nice crash in the exporter (`circt-translate -export-firrtl Bar.mlir`):\r\n\r\n```\r\nAssertion failed: (!s->text().empty() && \"empty string token\"), function operator(), file PrettyPrinter.cpp, line 91.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: circt-translate -export-firrtl Bar.mlir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  circt-translate          0x00000001079167ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  circt-translate          0x0000000107916d5b PrintStackTraceSignalHandler(void*) + 27\r\n2  circt-translate          0x0000000107914896 llvm::sys::RunSignalHandlers() + 134\r\n3  circt-translate          0x0000000107918b8f SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff81820c5ed _sigtramp + 29\r\n5  libsystem_platform.dylib 0x00007ff7b877dd20 _sigtramp + 18446744072104646480\r\n6  libsystem_c.dylib        0x00007ff818105b45 abort + 123\r\n7  libsystem_c.dylib        0x00007ff818104e5e err + 0\r\n8  circt-translate          0x0000000108746000 circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1::operator()(circt::pretty::StringToken*) const + 176\r\n9  circt-translate          0x0000000108745ee8 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::TypeSwitch<circt::pretty::Token*, void>::Case<circt::pretty::StringToken, circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 88\r\n10 circt-translate          0x0000000108744af5 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<circt::pretty::Token*, void>, circt::pretty::Token*>::Case<circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 53\r\n11 circt-translate          0x0000000108744a03 circt::pretty::PrettyPrinter::add(circt::pretty::Token) + 99\r\n12 circt-translate          0x000000010819d235 std::__1::enable_if<std::is_base_of_v<circt::pretty::Token, circt::pretty::StringToken>, void>::type circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::add<circt::pretty::StringToken, llvm::StringRef&>(llvm::StringRef&) + 101\r\n13 circt-translate          0x000000010819d1c1 circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::literal(llvm::StringRef) + 33\r\n14 circt-translate          0x000000010819c118 circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::operator<<(circt::pretty::PPExtString const&) + 56\r\n15 circt-translate          0x00000001081c2fa8 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5::operator()() const + 104\r\n16 circt-translate          0x00000001081c2f35 decltype(static_cast<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(fp)()) std::__1::__invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 21\r\n17 circt-translate          0x00000001081c2e5d std::__1::invoke_result<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>::type std::__1::invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 29\r\n18 circt-translate          0x00000001081c2d96 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(circt::pretty::PP&&, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&, circt::pretty::Token) + 102\r\n19 circt-translate          0x00000001081c2d13 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp) + 179\r\n20 circt-translate          0x00000001081c2808 auto (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16::operator()<circt::firrtl::WireOp>(circt::firrtl::WireOp) const + 40\r\n21 circt-translate          0x00000001081c278b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::WireOp, (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&>((anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&) + 107\r\n22 circt-translate          0x000000010819ea0d (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&) + 365\r\n23 circt-translate          0x000000010819e669 (anonymous namespace)::Emitter::emitModule(circt::firrtl::FModuleOp)::$_1::operator()() const + 217\r\n```", "code_snippet_01": "firrtl.circuit \"Foo\" {\r\n  firrtl.module @Foo(in %clock: !firrtl.clock, in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n    %c1_ui1 = firrtl.constant 1 : !firrtl.uint<1>\r\n    %0 = firrtl.wire : !firrtl.uint<1>\r\n    %r = firrtl.regreset interesting_name %clock, %c1_ui1, %0 : !firrtl.clock, !firrtl.uint<1>, !firrtl.uint<1>, !firrtl.uint<1>\r\n    firrtl.strictconnect %0, %r : !firrtl.uint<1>\r\n  }\r\n}", "code_snippet_02": "Assertion failed: (!s->text().empty() && \"empty string token\"), function operator(), file PrettyPrinter.cpp, line 91.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.      Program arguments: circt-translate -export-firrtl Bar.mlir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  circt-translate          0x00000001079167ed llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  circt-translate          0x0000000107916d5b PrintStackTraceSignalHandler(void*) + 27\r\n2  circt-translate          0x0000000107914896 llvm::sys::RunSignalHandlers() + 134\r\n3  circt-translate          0x0000000107918b8f SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff81820c5ed _sigtramp + 29\r\n5  libsystem_platform.dylib 0x00007ff7b877dd20 _sigtramp + 18446744072104646480\r\n6  libsystem_c.dylib        0x00007ff818105b45 abort + 123\r\n7  libsystem_c.dylib        0x00007ff818104e5e err + 0\r\n8  circt-translate          0x0000000108746000 circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1::operator()(circt::pretty::StringToken*) const + 176\r\n9  circt-translate          0x0000000108745ee8 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::TypeSwitch<circt::pretty::Token*, void>::Case<circt::pretty::StringToken, circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 88\r\n10 circt-translate          0x0000000108744af5 llvm::TypeSwitch<circt::pretty::Token*, void>& llvm::detail::TypeSwitchBase<llvm::TypeSwitch<circt::pretty::Token*, void>, circt::pretty::Token*>::Case<circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1>(circt::pretty::PrettyPrinter::add(circt::pretty::Token)::$_1&&) + 53\r\n11 circt-translate          0x0000000108744a03 circt::pretty::PrettyPrinter::add(circt::pretty::Token) + 99\r\n12 circt-translate          0x000000010819d235 std::__1::enable_if<std::is_base_of_v<circt::pretty::Token, circt::pretty::StringToken>, void>::type circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::add<circt::pretty::StringToken, llvm::StringRef&>(llvm::StringRef&) + 101\r\n13 circt-translate          0x000000010819d1c1 circt::pretty::TokenBuilder<circt::pretty::PrettyPrinter>::literal(llvm::StringRef) + 33\r\n14 circt-translate          0x000000010819c118 circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::operator<<(circt::pretty::PPExtString const&) + 56\r\n15 circt-translate          0x00000001081c2fa8 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5::operator()() const + 104\r\n16 circt-translate          0x00000001081c2f35 decltype(static_cast<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(fp)()) std::__1::__invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 21\r\n17 circt-translate          0x00000001081c2e5d std::__1::invoke_result<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>::type std::__1::invoke<(anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>((anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&) + 29\r\n18 circt-translate          0x00000001081c2d96 auto circt::pretty::TokenStream<circt::pretty::PrettyPrinter>::scopedBox<circt::pretty::PP, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5>(circt::pretty::PP&&, (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp)::$_5&&, circt::pretty::Token) + 102\r\n19 circt-translate          0x00000001081c2d13 (anonymous namespace)::Emitter::emitStatement(circt::firrtl::WireOp) + 179\r\n20 circt-translate          0x00000001081c2808 auto (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16::operator()<circt::firrtl::WireOp>(circt::firrtl::WireOp) const + 40\r\n21 circt-translate          0x00000001081c278b llvm::TypeSwitch<mlir::Operation*, void>& llvm::TypeSwitch<mlir::Operation*, void>::Case<circt::firrtl::WireOp, (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&>((anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&)::$_16&) + 107\r\n22 circt-translate          0x000000010819ea0d (anonymous namespace)::Emitter::emitStatementsInBlock(mlir::Block&) + 365\r\n23 circt-translate          0x000000010819e669 (anonymous namespace)::Emitter::emitModule(circt::firrtl::FModuleOp)::$_1::operator()() const + 217"}, {"number": 5202, "title": "[FIRRTL] Incorrect Register Parsing", "created_at": "2023-05-15T21:22:04Z", "state": "open", "labels": "bug, FIRRTL", "body": "The FIRRTL parser uses the reset initial value being the reset as a shorthand for \"this is a reset-less register\". However, it only narrowly means that if the reset signal is `UInt<1>(0)`. Consider the following:\r\n\r\n```\r\ncircuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    reg r: UInt<1>, clock with: (reset => (UInt<1>(1), r))\r\n\r\n    r <= a\r\n    b <= r\r\n```\r\n\r\nThis register never exits an indeterminate state and can be optimized to some constant. CIRCT currently thinks this is a reset-less register:\r\n\r\n```verilog\r\nmodule Foo(\r\n  input  clock,\r\n         a,\r\n  output b\r\n);\r\n\r\n  reg r;\r\n  always @(posedge clock)\r\n    r <= a;\r\n  assign b = r;\r\nendmodule\r\n```\r\n\r\nSFC will produce:\r\n```verilog\r\nmodule Foo(\r\n  input   clock,\r\n  input   a,\r\n  output  b\r\n);\r\n  assign b = 1'h0;\r\nendmodule\r\n```\r\n\r\nNote: this code is impossible to emit from Chisel due to limitations of how it works.", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    input clock: Clock\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    reg r: UInt<1>, clock with: (reset => (UInt<1>(1), r))\r\n\r\n    r <= a\r\n    b <= r", "code_snippet_02": "module Foo(\r\n  input  clock,\r\n         a,\r\n  output b\r\n);\r\n\r\n  reg r;\r\n  always @(posedge clock)\r\n    r <= a;\r\n  assign b = r;\r\nendmodule", "code_snippet_03": "module Foo(\r\n  input   clock,\r\n  input   a,\r\n  output  b\r\n);\r\n  assign b = 1'h0;\r\nendmodule"}, {"number": 5031, "title": "[scf-to-calyx] Mark `cf` operations illegal", "created_at": "2023-04-13T16:30:52Z", "state": "open", "labels": "bug, Calyx", "body": "Hi! I just posted on the #circt channel on discord about a model I had that I tried to pass to CIRCT to lower to Calyx via `-lower-scf-to-calyx`. It seems like it takes a few hours at least, and sometime just crashes my machine - which is very strange, since the model is pretty simple with mostly arithmetic operations and 163 if statements that are represented with conditional branches (they were `scf.if` statements, but converted to `cf` with [convert-scf-to-cf](https://mlir.llvm.org/docs/Passes/#-convert-scf-to-cf-convert-scf-dialect-to-controlflow-dialect-replacing-structured-control-flow-with-a-cfg). \r\n\r\nThis is the model: https://gist.github.com/asraa/93f10e86abcc3fe386eec172cb918e5c\r\n\r\nI'll be poking around the conversion code near the conditional branch handling, just in case, and if I see something suspicious I'll update this thread. https://github.com/llvm/circt/blob/4a2ae91b421c71841c69153f81fc4277fe5409ef/lib/Conversion/SCFToCalyx/SCFToCalyx.cpp#L1016\r\n\r\nThank you!\r\n\r\n@mikeurbach for CC, thank you for responding in the chat!\r\n"}, {"number": 4921, "title": "[FIRRTL][Inliner] UNREACHABLE \"the default constructor for MutableNLA should never be used\"", "created_at": "2023-04-03T14:08:13Z", "state": "open", "labels": "bug, FIRRTL", "body": "Variant of inliner crash test case in #4920 .  This crashes on 1.35.0 and 1.37.0:\r\n\r\n```firrtl\r\nmodule {\r\n  firrtl.circuit \"Unreachable\" {\r\n    hw.hierpath private @nla_5560 [@Unreachable::@w, @Bar2]\r\n    hw.hierpath private @nla_5561 [@Bar1::@w, @Bar3]\r\n    firrtl.module private @Bar2() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      %x = firrtl.wire sym @x {annotations = [{circt.nonlocal = @nla_5560, class = \"test0\"}]} : !firrtl.uint<8>\r\n      firrtl.instance no sym @no @Bar1()\r\n    }\r\n    firrtl.module private @Bar1() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      firrtl.instance bar3 sym @w @Bar3()\r\n    }\r\n    firrtl.module private @Bar3() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @nla_5561, class = \"test0\"}]} : !firrtl.uint<8>\r\n    }\r\n    firrtl.module @Unreachable() {\r\n      firrtl.instance no sym @no @Bar1()\r\n      firrtl.instance bar2 sym @w @Bar2()\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nError:\r\n\r\n```\r\nthe default constructor for MutableNLA should never be used\r\nUNREACHABLE executed at /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:130!\r\n```\r\n\r\nBacktrace:\r\n\r\n```\r\n* thread #1, name = 'circt-opt', stop reason = signal SIGABRT\r\n  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295\r\n    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22\r\n    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215\r\n    frame #3: 0x00005555561857bf circt-opt`llvm::llvm_unreachable_internal(msg=<unavailable>, file=<unavailable>, line=<unavailable>) at ErrorHandling.cpp:212:3\r\n    frame #4: 0x0000555556788dba circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] (anonymous namespace)::MutableNLA::MutableNLA(this=<unavailable>) at ModuleInliner.cpp:129:5\r\n    frame #5: 0x0000555556788d2e circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>* llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (this=<unavailable>, TheBucket=<unavailable>, Key=0x00007fffffff3db8)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::InsertIntoBucket<mlir::Attribute const&>(llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>*, mlir::Attribute const&) at DenseMap.h:563:37\r\n    frame #6: 0x0000555556788d20 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::FindAndConstruct(this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:339:13\r\n    frame #7: 0x0000555556788ce2 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:343:12\r\n    frame #8: 0x0000555556789f68 circt-opt`(anonymous namespace)::Inliner::setActiveHierPaths(this=0x00007fffffff4588, moduleName=StringAttr @ rbx, instInnerSym=StringAttr @ scalar) at ModuleInliner.cpp:596:11\r\n    frame #9: 0x000055555678e194 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=(Data = \"bar2_\", Length = 5), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, beb=0x00007fffffff41a0, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3f18, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1094:5\r\n    frame #10: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7\r\n    frame #11: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7\r\n    frame #12: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13\r\n    frame #13: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17\r\n    frame #14: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #15: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #16: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000330afe0, irUnits=ArrayRef<mlir::IRUnit> @ 0x000000000331dee0, args=0x0000555557bfe4f0)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #17: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfe4f0, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #18: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be0d10, op=0x0000555557bfd560, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16\r\n    frame #19: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557c00380)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36\r\n    frame #20: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18\r\n    frame #21: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10\r\n    frame #22: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14\r\n    frame #23: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5\r\n    frame #24: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20\r\n    frame #25: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #26: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #27: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003435460, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000038b4fc0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #28: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #29: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16\r\n    frame #30: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfd5c0, am=AnalysisManager @ scalar) at Pass.cpp:857:10\r\n    frame #31: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfd5c0) at Pass.cpp:837:60\r\n    frame #32: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc9000, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17\r\n    frame #33: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12\r\n    frame #34: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12\r\n    frame #35: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12\r\n    frame #36: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12\r\n    frame #37: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12\r\n    frame #38: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10\r\n    frame #39: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14\r\n    frame #40: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23\r\n    frame #41: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126\r\n    frame #42: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137\r\n    frame #43: 0x0000555556160415 circt-opt`_start + 37\r\n```", "code_snippet_01": "module {\r\n  firrtl.circuit \"Unreachable\" {\r\n    hw.hierpath private @nla_5560 [@Unreachable::@w, @Bar2]\r\n    hw.hierpath private @nla_5561 [@Bar1::@w, @Bar3]\r\n    firrtl.module private @Bar2() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      %x = firrtl.wire sym @x {annotations = [{circt.nonlocal = @nla_5560, class = \"test0\"}]} : !firrtl.uint<8>\r\n      firrtl.instance no sym @no @Bar1()\r\n    }\r\n    firrtl.module private @Bar1() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      firrtl.instance bar3 sym @w @Bar3()\r\n    }\r\n    firrtl.module private @Bar3() attributes {annotations = [{class = \"firrtl.passes.InlineAnnotation\"}]} {\r\n      %w = firrtl.wire sym @w {annotations = [{circt.nonlocal = @nla_5561, class = \"test0\"}]} : !firrtl.uint<8>\r\n    }\r\n    firrtl.module @Unreachable() {\r\n      firrtl.instance no sym @no @Bar1()\r\n      firrtl.instance bar2 sym @w @Bar2()\r\n    }\r\n  }\r\n}", "code_snippet_02": "the default constructor for MutableNLA should never be used\r\nUNREACHABLE executed at /home/will/src/sifive/circt/lib/Dialect/FIRRTL/Transforms/ModuleInliner.cpp:130!", "code_snippet_03": "* thread #1, name = 'circt-opt', stop reason = signal SIGABRT\r\n  * frame #0: 0x00007ffff7a8abc7 libc.so.6`__pthread_kill_implementation + 295\r\n    frame #1: 0x00007ffff7a3db46 libc.so.6`raise + 22\r\n    frame #2: 0x00007ffff7a284b5 libc.so.6`abort + 215\r\n    frame #3: 0x00005555561857bf circt-opt`llvm::llvm_unreachable_internal(msg=<unavailable>, file=<unavailable>, line=<unavailable>) at ErrorHandling.cpp:212:3\r\n    frame #4: 0x0000555556788dba circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] (anonymous namespace)::MutableNLA::MutableNLA(this=<unavailable>) at ModuleInliner.cpp:129:5\r\n    frame #5: 0x0000555556788d2e circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>* llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (this=<unavailable>, TheBucket=<unavailable>, Key=0x00007fffffff3db8)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::InsertIntoBucket<mlir::Attribute const&>(llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA>*, mlir::Attribute const&) at DenseMap.h:563:37\r\n    frame #6: 0x0000555556788d20 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](mlir::Attribute const&) [inlined] llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::FindAndConstruct(this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:339:13\r\n    frame #7: 0x0000555556788ce2 circt-opt`llvm::DenseMapBase<llvm::DenseMap<mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >, mlir::Attribute, (anonymous namespace)::MutableNLA, llvm::DenseMapInfo<mlir::Attribute, void>, llvm::detail::DenseMapPair<mlir::Attribute, (anonymous namespace)::MutableNLA> >::operator[](this=<unavailable>, Key=0x00007fffffff3db8) at DenseMap.h:343:12\r\n    frame #8: 0x0000555556789f68 circt-opt`(anonymous namespace)::Inliner::setActiveHierPaths(this=0x00007fffffff4588, moduleName=StringAttr @ rbx, instInnerSym=StringAttr @ scalar) at ModuleInliner.cpp:596:11\r\n    frame #9: 0x000055555678e194 circt-opt`(anonymous namespace)::Inliner::inlineInto(this=0x00007fffffff4588, prefix=(Data = \"bar2_\", Length = 5), b=0x00007fffffff4470, mapper=0x00007fffffff42b0, beb=0x00007fffffff41a0, edges=<unavailable>, target=FModuleOp @ 0x00007fffffff3f18, symbolRenames=<unavailable>, moduleNamespace=<unavailable>) at ModuleInliner.cpp:1094:5\r\n    frame #10: 0x0000555556786644 circt-opt`(anonymous namespace)::Inliner::run() at ModuleInliner.cpp:1206:7\r\n    frame #11: 0x0000555556785b4d circt-opt`(anonymous namespace)::Inliner::run(this=0x00007fffffff4588) at ModuleInliner.cpp:1325:7\r\n    frame #12: 0x00005555567838f2 circt-opt`(anonymous namespace)::InlinerPass::runOnOperation(this=<unavailable>) at ModuleInliner.cpp:1447:13\r\n    frame #13: 0x000055555795f79e circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff47c8)::$_7::operator()() const at Pass.cpp:482:17\r\n    frame #14: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488308168)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #15: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #16: 0x000055555795f76d circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x000000000330afe0, irUnits=ArrayRef<mlir::IRUnit> @ 0x000000000331dee0, args=0x0000555557bfe4f0)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #17: 0x000055555795f75d circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557bfe4f0, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff47a0, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #18: 0x000055555795ff41 circt-opt`mlir::detail::OpToOpPassAdaptor::runPipeline(pm=0x0000555557be0d10, op=0x0000555557bfd560, am=AnalysisManager @ 0x00007fffffff4920, verifyPasses=<unavailable>, parentInitGeneration=1, instrumentor=0x0000000000000000, parentInfo=0x00007fffffff49e0) at Pass.cpp:548:16\r\n    frame #19: 0x0000555557963336 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x00007fffffff4a10, opInfo=0x0000555557c00380)::$_15::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const at Pass.cpp:768:36\r\n    frame #20: 0x000055555796150b circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, begin=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff4a90, end=__normal_iterator<OpPMInfo *, std::vector<OpPMInfo, std::allocator<OpPMInfo> > > @ 0x00007fffffff49a0, func=0x00007fffffff4a10)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:46:18\r\n    frame #21: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) [inlined] mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&>(context=0x00007fffffff4f80, range=<unavailable>, func=0x00007fffffff4a10)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_15&) at Threading.h:92:10\r\n    frame #22: 0x00005555579612f5 circt-opt`mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:778:14\r\n    frame #23: 0x000055555795f8f4 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::runOnOperation(this=0x0000555557b8c020, verifyPasses=<unavailable>) at Pass.cpp:669:5\r\n    frame #24: 0x000055555795f8cb circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] mlir::detail::OpToOpPassAdaptor::run(this=0x00007fffffff4b78)::$_7::operator()() const at Pass.cpp:480:20\r\n    frame #25: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void llvm::function_ref<void ()>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(callable=140737488309112)::$_7>(long) at STLFunctionalExtras.h:45:12\r\n    frame #26: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] llvm::function_ref<void ()>::operator(this=<unavailable>)() const at STLFunctionalExtras.h:68:12\r\n    frame #27: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) [inlined] void mlir::MLIRContext::executeAction<mlir::PassExecutionAction, mlir::Pass&>(this=<unavailable>, actionFn=mlir::function_ref<void ()> @ 0x0000000003435460, irUnits=ArrayRef<mlir::IRUnit> @ 0x00000000038b4fc0, args=0x0000555557b8c020)>, llvm::ArrayRef<mlir::IRUnit>, mlir::Pass&) at MLIRContext.h:275:7\r\n    frame #28: 0x000055555795f8b6 circt-opt`mlir::detail::OpToOpPassAdaptor::run(pass=0x0000555557b8c020, op=<unavailable>, am=AnalysisManager @ 0x00007fffffff4b50, verifyPasses=true, parentInitGeneration=1) at Pass.cpp:476:21\r\n    frame #29: 0x00005555579622b3 circt-opt`mlir::PassManager::run(mlir::Operation*) at Pass.cpp:548:16\r\n    frame #30: 0x000055555796226a circt-opt`mlir::PassManager::run(mlir::Operation*) [inlined] mlir::PassManager::runPasses(this=0x00007fffffff4e90, op=0x0000555557bfd5c0, am=AnalysisManager @ scalar) at Pass.cpp:857:10\r\n    frame #31: 0x0000555557962251 circt-opt`mlir::PassManager::run(this=0x00007fffffff4e90, op=0x0000555557bfd5c0) at Pass.cpp:837:60\r\n    frame #32: 0x00005555570f9579 circt-opt`performActions(os=0x0000555557b57c18, sourceMgr=std::__shared_ptr<llvm::SourceMgr, __gnu_cxx::_S_atomic>::element_type @ 0x0000555557bc9000, context=0x00007fffffff4f80, config=0x00007fffffff5448) at MlirOptMain.cpp:219:17\r\n    frame #33: 0x00005555570f91f1 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at MlirOptMain.cpp:266:12\r\n    frame #34: 0x00005555570f901f circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) [inlined] mlir::MlirOptMain(this=<unavailable>, chunkBuffer=nullptr, os=<unavailable>)::$_1::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at MlirOptMain.cpp:307:12\r\n    frame #35: 0x00005555570f9011 circt-opt`mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(callable=<unavailable>, params=<unavailable>, params=0x0000555557b57c18)::$_1>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) at STLFunctionalExtras.h:45:12\r\n    frame #36: 0x000055555711a655 circt-opt`mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) [inlined] llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&)>::operator(this=0x00007fffffff51b8, params=nullptr, params=<unavailable>)(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, llvm::raw_ostream&) const at STLFunctionalExtras.h:68:12\r\n    frame #37: 0x000055555711a63d circt-opt`mlir::splitAndProcessBuffer(originalBuffer=nullptr, processChunkBuffer=mlir::ChunkBufferHandler @ 0x00007fffffff51b8, os=0x0000555557b57c18, enableSplitting=<unavailable>, insertMarkerInOutput=true)>, llvm::raw_ostream&, bool, bool) at ToolUtilities.cpp:28:12\r\n    frame #38: 0x00005555570f7871 circt-opt`mlir::MlirOptMain(outputStream=0x0000555557b57c18, buffer=nullptr, registry=0x00007fffffff55b8, config=0x00007fffffff5448) at MlirOptMain.cpp:310:10\r\n    frame #39: 0x00005555570f7f71 circt-opt`mlir::MlirOptMain(argc=<unavailable>, argv=<unavailable>, toolName=<unavailable>, registry=0x00007fffffff55b8, preloadDialectsInContext=false) at MlirOptMain.cpp:407:14\r\n    frame #40: 0x0000555556160aec circt-opt`main(argc=3, argv=0x00007fffffff5758) at circt-opt.cpp:70:23\r\n    frame #41: 0x00007ffff7a2924e libc.so.6`__libc_start_call_main + 126\r\n    frame #42: 0x00007ffff7a29309 libc.so.6`__libc_start_main@@GLIBC_2.34 + 137\r\n    frame #43: 0x0000555556160415 circt-opt`_start + 37"}, {"number": 4896, "title": "[FIRRTL] Verify annotation symbol uses!", "created_at": "2023-03-28T00:07:06Z", "state": "open", "labels": "bug, good first issue, FIRRTL", "body": "Currently there is no verification that the symbols used by annotations exist at all, nevermind any sense of being appropriate/correct.  This should be fixed.  Example:\r\n\r\n```firrtl\r\nmodule {\r\n  firrtl.circuit \"Oops\" {\r\n    firrtl.module private @Child() attributes {annotations = [{circt.nonlocal = @nla, class = \"circt.test\"}]} {\r\n    }\r\n    firrtl.module @Oops() {\r\n      firrtl.instance child @Child()\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nPresently, `circt-opt` round-trips this, and `firtool` makes it all the way to `PrefixModules` before something notices.\r\n\r\nThere may be support for Attribute symbol-use verification, so look for such as that would be ideal.  Otherwise we may need to find a way to expose the uses to the symbol verifier, there are interfaces for exposing subelement's that may be appropriate here.  A final but offhand seemingly less-than-ideal approach to consider would be SymbolUserOpInterface's `verifySymbolUses` (I suppose on all our operations that take annotations).", "code_snippet_01": "module {\r\n  firrtl.circuit \"Oops\" {\r\n    firrtl.module private @Child() attributes {annotations = [{circt.nonlocal = @nla, class = \"circt.test\"}]} {\r\n    }\r\n    firrtl.module @Oops() {\r\n      firrtl.instance child @Child()\r\n    }\r\n  }\r\n}"}, {"number": 4886, "title": "[FIRRTL] InferResets Not Duplicating Modules When Necessary", "created_at": "2023-03-24T22:32:02Z", "state": "open", "labels": "bug, FIRRTL", "body": "In the following FIRRTL, we have a module instantiated twice, once in a FullAsyncReset domain, and once not in any domain.\r\n\r\n```\r\ncircuit Top : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.FullAsyncResetAnnotation\",\r\n    \"target\":\"~Top|FullAsyncWrapper>rf_reset\"\r\n  }\r\n]]\r\n  module Child :\r\n    input clock : Clock\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    reg r : UInt<8>, clock\r\n    r <= foo\r\n    bar <= r\r\n\r\n  module FullAsyncWrapper :\r\n    input clock : Clock\r\n    input rf_reset : AsyncReset\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    inst c of Child\r\n    c.clock <= clock\r\n    c.foo <= foo\r\n    bar <= c.bar\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input rf_reset : AsyncReset\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    inst wrap of FullAsyncWrapper\r\n    wrap.clock <= clock\r\n    wrap.rf_reset <= rf_reset\r\n    wrap.foo <= foo\r\n\r\n    inst child of Child\r\n    child.clock <= clock\r\n    child.foo <= foo\r\n\r\n    bar <= and(wrap.bar, child.bar)\r\n```\r\n\r\nRun this with firtool 1.36.0 and you will get\r\n```\r\ntest.fir:7:10: error: module 'Child' instantiated in different reset domains\r\n  module Child :\r\n         ^\r\ntest.fir:7:10: note: see current operation: \r\n\"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<8>, %arg2: !firrtl.uint<8>):\r\n  %0 = \"firrtl.reg\"(%arg0) {annotations = [], name = \"r\", nameKind = #firrtl<name_kind droppable_name>} : (!firrtl.clock) -> !firrtl.uint<8>\r\n  \"firrtl.strictconnect\"(%0, %arg1) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()\r\n  \"firrtl.strictconnect\"(%arg2, %0) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()\r\n}) {annotations = [], portAnnotations = [], portDirections = -4 : i3, portLocations = [loc(\"test.fir\":8:11), loc(\"test.fir\":9:11), loc(\"test.fir\":10:12)], portNames = [\"clock\", \"foo\", \"bar\"], portSyms = [], portTypes = [!firrtl.clock, !firrtl.uint<8>, !firrtl.uint<8>], sym_name = \"Child\", sym_visibility = \"private\"} : () -> ()\r\ntest.fir:22:5: note: instance 'wrap/c' is in reset domain rooted at 'rf_reset' of module 'FullAsyncWrapper'\r\n    inst c of Child\r\n    ^\r\ntest.fir:18:11: note: reset domain 'rf_reset' of module 'FullAsyncWrapper' declared here:\r\n    input rf_reset : AsyncReset\r\n          ^\r\ntest.fir:38:5: note: instance 'child' is in no reset domain\r\n    inst child of Child\r\n    ^\r\n```\r\n\r\nThis is a very similar issue to https://github.com/llvm/circt/issues/4586", "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.FullAsyncResetAnnotation\",\r\n    \"target\":\"~Top|FullAsyncWrapper>rf_reset\"\r\n  }\r\n]]\r\n  module Child :\r\n    input clock : Clock\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    reg r : UInt<8>, clock\r\n    r <= foo\r\n    bar <= r\r\n\r\n  module FullAsyncWrapper :\r\n    input clock : Clock\r\n    input rf_reset : AsyncReset\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    inst c of Child\r\n    c.clock <= clock\r\n    c.foo <= foo\r\n    bar <= c.bar\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input rf_reset : AsyncReset\r\n    input foo : UInt<8>\r\n    output bar : UInt<8>\r\n\r\n    inst wrap of FullAsyncWrapper\r\n    wrap.clock <= clock\r\n    wrap.rf_reset <= rf_reset\r\n    wrap.foo <= foo\r\n\r\n    inst child of Child\r\n    child.clock <= clock\r\n    child.foo <= foo\r\n\r\n    bar <= and(wrap.bar, child.bar)", "code_snippet_02": "test.fir:7:10: error: module 'Child' instantiated in different reset domains\r\n  module Child :\r\n         ^\r\ntest.fir:7:10: note: see current operation: \r\n\"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<8>, %arg2: !firrtl.uint<8>):\r\n  %0 = \"firrtl.reg\"(%arg0) {annotations = [], name = \"r\", nameKind = #firrtl<name_kind droppable_name>} : (!firrtl.clock) -> !firrtl.uint<8>\r\n  \"firrtl.strictconnect\"(%0, %arg1) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()\r\n  \"firrtl.strictconnect\"(%arg2, %0) : (!firrtl.uint<8>, !firrtl.uint<8>) -> ()\r\n}) {annotations = [], portAnnotations = [], portDirections = -4 : i3, portLocations = [loc(\"test.fir\":8:11), loc(\"test.fir\":9:11), loc(\"test.fir\":10:12)], portNames = [\"clock\", \"foo\", \"bar\"], portSyms = [], portTypes = [!firrtl.clock, !firrtl.uint<8>, !firrtl.uint<8>], sym_name = \"Child\", sym_visibility = \"private\"} : () -> ()\r\ntest.fir:22:5: note: instance 'wrap/c' is in reset domain rooted at 'rf_reset' of module 'FullAsyncWrapper'\r\n    inst c of Child\r\n    ^\r\ntest.fir:18:11: note: reset domain 'rf_reset' of module 'FullAsyncWrapper' declared here:\r\n    input rf_reset : AsyncReset\r\n          ^\r\ntest.fir:38:5: note: instance 'child' is in no reset domain\r\n    inst child of Child\r\n    ^"}, {"number": 4849, "title": "[ExportVerilog][SV] sv.interface instance name not Verilog-keyword mangled", "created_at": "2023-03-17T21:27:52Z", "state": "open", "labels": "bug, ExportVerilog", "body": "The instance name of an SV interface op is not mangled if it collides with a Verilog keyword when it should be.\r\n\r\nConsider:\r\n\r\n```mlir\r\nmodule {\r\n  sv.interface @wire {}\r\n  hw.module private @Foo() {\r\n    %module = sv.interface.instance : !sv.interface<@wire>\r\n    hw.output\r\n  }\r\n}\r\n```\r\n\r\nThis is being output as the following when using `circt-opt -export-verilog Foo.mlir`:\r\n\r\n```verilog\r\n// Generated by CIRCT unknown git version\r\ninterface module_0;\r\nendinterface\r\n\r\nmodule Foo();\t// Foo.mlir:3:3\r\n  wire_0 module();\t// Foo.mlir:4:15\r\nendmodule\r\n```", "code_snippet_01": "module {\r\n  sv.interface @wire {}\r\n  hw.module private @Foo() {\r\n    %module = sv.interface.instance : !sv.interface<@wire>\r\n    hw.output\r\n  }\r\n}", "code_snippet_02": "// Generated by CIRCT unknown git version\r\ninterface module_0;\r\nendinterface\r\n\r\nmodule Foo();\t// Foo.mlir:3:3\r\n  wire_0 module();\t// Foo.mlir:4:15\r\nendmodule"}, {"number": 4842, "title": "[Lower Calyx to FSM] Pass can fail if not canonicalized before running", "created_at": "2023-03-16T16:28:01Z", "state": "open", "labels": "bug, Calyx, need triage", "body": "This works:\r\n```bash\r\n$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --canonicalize --lower-calyx-to-fsm\r\n```\r\n\r\nBut the following (without the `--canonicalize`) triggers an assertion:\r\n```bash\r\n$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm\r\ncirct-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed\r\n```\r\n\r\n`simple_arith.mlir` can be found [here](https://github.com/llvm/circt/blob/main/integration_test/Dialect/Calyx/simple_arith.mlir).\r\n\r\nBacktrace:\r\n```\r\ncirct-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm   \r\ncirct-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ../../circt/build/bin/circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm\r\n #0 0x000055d161ee52d4 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:22\r\n #1 0x000055d161ee56a6 PrintStackTraceSignalHandler(void*) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:676:1\r\n #2 0x000055d161ee2d57 llvm::sys::RunSignalHandlers() /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Signals.cpp:104:20\r\n #3 0x000055d161ee4c32 SignalHandler(int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #4 0x00007f117de51f50 (/usr/lib/libc.so.6+0x38f50)\r\n #5 0x00007f117dea08ec (/usr/lib/libc.so.6+0x878ec)\r\n #6 0x00007f117de51ea8 raise (/usr/lib/libc.so.6+0x38ea8)\r\n #7 0x00007f117de3b53d abort (/usr/lib/libc.so.6+0x2253d)\r\n #8 0x00007f117de3b45c (/usr/lib/libc.so.6+0x2245c)\r\n #9 0x00007f117de4a9f6 (/usr/lib/libc.so.6+0x319f6)\r\n#10 0x000055d1621313f5 llvm::SmallVectorTemplateCommon<std::pair<mlir::Operation*, circt::fsm::StateOp>, void>::front() /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:304:17\r\n#11 0x000055d16212bf8b (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:196:26\r\n#12 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#13 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#14 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#15 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#16 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#17 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#18 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#19 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#20 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#21 0x000055d16212b958 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp)::'lambda'(mlir::Value, llvm::StringRef, bool, mlir::Operation*)::operator()(mlir::Value, llvm::StringRef, bool, mlir::Operation*) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:147:15\r\n#22 0x000055d16212bb0e (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:153:13\r\n#23 0x000055d16212dbe3 auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::IfOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#24 0x000055d16212dc60 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::IfOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#25 0x000055d16212b320 Case<circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#26 0x000055d16212b320 Case<circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42\r\n#27 0x000055d16212b320 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42\r\n#28 0x000055d16212b320 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#29 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#30 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#31 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#32 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#33 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#34 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#35 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#36 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#37 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#38 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#39 0x000055d16212cada (anonymous namespace)::CalyxToFSMPass::runOnOperation() /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:307:13\r\n#40 0x000055d164764cc4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:471:27\r\n#41 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15\r\n#42 0x000055d1647660e8 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:754:47\r\n#43 0x000055d164768e17 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:46:17\r\n#44 0x000055d1647681df mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:94:1\r\n#45 0x000055d164766627 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:764:13\r\n#46 0x000055d164765ab9 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:658:1\r\n#47 0x000055d164764ca5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:468:28\r\n#48 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15\r\n#49 0x000055d164766e06 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:843:40\r\n#50 0x000055d164766c66 mlir::PassManager::run(mlir::Operation*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:823:69\r\n#51 0x000055d16397c887 performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:175:13\r\n#52 0x000055d16397ccf5 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPool*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:221:26\r\n#53 0x000055d16397ce21 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:262:25\r\n#54 0x000055d16397dcd2 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:52\r\n#55 0x000055d1639bae6b llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n#56 0x000055d1639ba6ff mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:28:30\r\n#57 0x000055d16397cfd2 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:265:31\r\n#58 0x000055d16397d8cf mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:354:13\r\n#59 0x000055d161ddc13e main /home/xerpi/Desktop/Research/circt/tools/circt-opt/circt-opt.cpp:70:22\r\n#60 0x00007f117de3c790 (/usr/lib/libc.so.6+0x23790)\r\n#61 0x00007f117de3c84a __libc_start_main (/usr/lib/libc.so.6+0x2384a)\r\n#62 0x000055d161ddbec5 _start (../../circt/build/bin/circt-opt+0x119ec5)\r\nAborted (core dumped)\r\n```", "code_snippet_01": "$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --canonicalize --lower-calyx-to-fsm", "code_snippet_02": "$ circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm\r\ncirct-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed", "code_snippet_03": "circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm   \r\ncirct-opt: /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:303: T& llvm::SmallVectorTemplateCommon<T, <template-parameter-1-2> >::front() [with T = std::pair<mlir::Operation*, circt::fsm::StateOp>; <template-parameter-1-2> = void; reference = std::pair<mlir::Operation*, circt::fsm::StateOp>&]: Assertion `!empty()' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ../../circt/build/bin/circt-opt simple_arith.mlir --lower-scf-to-calyx --calyx-remove-comb-groups --lower-calyx-to-fsm\r\n #0 0x000055d161ee52d4 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:22\r\n #1 0x000055d161ee56a6 PrintStackTraceSignalHandler(void*) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:676:1\r\n #2 0x000055d161ee2d57 llvm::sys::RunSignalHandlers() /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Signals.cpp:104:20\r\n #3 0x000055d161ee4c32 SignalHandler(int) /home/xerpi/Desktop/Research/circt/llvm/llvm/lib/Support/Unix/Signals.inc:413:1\r\n #4 0x00007f117de51f50 (/usr/lib/libc.so.6+0x38f50)\r\n #5 0x00007f117dea08ec (/usr/lib/libc.so.6+0x878ec)\r\n #6 0x00007f117de51ea8 raise (/usr/lib/libc.so.6+0x38ea8)\r\n #7 0x00007f117de3b53d abort (/usr/lib/libc.so.6+0x2253d)\r\n #8 0x00007f117de3b45c (/usr/lib/libc.so.6+0x2245c)\r\n #9 0x00007f117de4a9f6 (/usr/lib/libc.so.6+0x319f6)\r\n#10 0x000055d1621313f5 llvm::SmallVectorTemplateCommon<std::pair<mlir::Operation*, circt::fsm::StateOp>, void>::front() /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/SmallVector.h:304:17\r\n#11 0x000055d16212bf8b (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:196:26\r\n#12 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#13 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#14 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#15 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#16 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#17 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#18 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#19 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#20 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#21 0x000055d16212b958 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp)::'lambda'(mlir::Value, llvm::StringRef, bool, mlir::Operation*)::operator()(mlir::Value, llvm::StringRef, bool, mlir::Operation*) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:147:15\r\n#22 0x000055d16212bb0e (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::IfOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:153:13\r\n#23 0x000055d16212dbe3 auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::IfOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#24 0x000055d16212dc60 llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::IfOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#25 0x000055d16212b320 Case<circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#26 0x000055d16212b320 Case<circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)>&> /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42\r\n#27 0x000055d16212b320 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:47:42\r\n#28 0x000055d16212b320 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#29 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#30 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#31 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#32 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#33 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#34 0x000055d16212bef9 (anonymous namespace)::CompileFSMVisitor::visit(circt::fsm::StateOp, circt::calyx::SeqOp, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:188:15\r\n#35 0x000055d16212d57f auto (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)::operator()<circt::calyx::SeqOp>(auto) const /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:44:79\r\n#36 0x000055d16212d5fc llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>& llvm::TypeSwitch<mlir::Operation*, mlir::LogicalResult>::Case<circt::calyx::SeqOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&>((anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::'lambda'(auto)&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:122:28\r\n#37 0x000055d16212b2d2 Case<circt::calyx::SeqOp, circt::calyx::EnableOp, circt::calyx::IfOp, circt::calyx::WhileOp, (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp)::<lambda(auto:51)> > /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/TypeSwitch.h:46:40\r\n#38 0x000055d16212b2d2 (anonymous namespace)::CompileFSMVisitor::dispatch(circt::fsm::StateOp, mlir::Operation*, circt::fsm::StateOp) /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:43:55\r\n#39 0x000055d16212cada (anonymous namespace)::CalyxToFSMPass::runOnOperation() /home/xerpi/Desktop/Research/circt/lib/Conversion/CalyxToFSM/CalyxToFSM.cpp:307:13\r\n#40 0x000055d164764cc4 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:471:27\r\n#41 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15\r\n#42 0x000055d1647660e8 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:754:47\r\n#43 0x000055d164768e17 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>>, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:46:17\r\n#44 0x000055d1647681df mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo>>&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::'lambda'(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&)&) /home/xerpi/Desktop/Research/circt/llvm/mlir/include/mlir/IR/Threading.h:94:1\r\n#45 0x000055d164766627 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:764:13\r\n#46 0x000055d164765ab9 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:658:1\r\n#47 0x000055d164764ca5 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:468:28\r\n#48 0x000055d164764fb0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:534:15\r\n#49 0x000055d164766e06 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:843:40\r\n#50 0x000055d164766c66 mlir::PassManager::run(mlir::Operation*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Pass/Pass.cpp:823:69\r\n#51 0x000055d16397c887 performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:175:13\r\n#52 0x000055d16397ccf5 processBuffer(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::MlirOptMainConfig const&, mlir::DialectRegistry&, llvm::ThreadPool*) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:221:26\r\n#53 0x000055d16397ce21 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:262:25\r\n#54 0x000055d16397dcd2 mlir::LogicalResult llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::'lambda'(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:45:52\r\n#55 0x000055d1639bae6b llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::operator()(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) const /home/xerpi/Desktop/Research/circt/llvm/llvm/include/llvm/ADT/STLFunctionalExtras.h:68:12\r\n#56 0x000055d1639ba6ff mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<mlir::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, bool, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Support/ToolUtilities.cpp:28:30\r\n#57 0x000055d16397cfd2 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:265:31\r\n#58 0x000055d16397d8cf mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&, bool) /home/xerpi/Desktop/Research/circt/llvm/mlir/lib/Tools/mlir-opt/MlirOptMain.cpp:354:13\r\n#59 0x000055d161ddc13e main /home/xerpi/Desktop/Research/circt/tools/circt-opt/circt-opt.cpp:70:22\r\n#60 0x00007f117de3c790 (/usr/lib/libc.so.6+0x23790)\r\n#61 0x00007f117de3c84a __libc_start_main (/usr/lib/libc.so.6+0x2384a)\r\n#62 0x000055d161ddbec5 _start (../../circt/build/bin/circt-opt+0x119ec5)\r\nAborted (core dumped)"}, {"number": 4834, "title": "[FIRRTL] Inline + MarkDUT + MemTap crasher", "created_at": "2023-03-15T17:12:30Z", "state": "open", "labels": "bug, FIRRTL", "body": "Inline+MarkDUTAnnotation already don't seem compatible, but FWIW we crash in LowerToHW on this input.\r\n\r\nInput:\r\n```firrtl\r\ncircuit Top : %[[\r\n  {\r\n    \"class\": \"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"~Top|DUTModule\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top>memTap\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.MemTapAnnotation\",\r\n    \"source\":\"~Top|DUTModule>rf\",\r\n    \"sink\":[\r\n      \"~Top|Top>memTap[0]\",\r\n      \"~Top|Top>memTap[1]\",\r\n      \"~Top|Top>memTap[2]\",\r\n      \"~Top|Top>memTap[3]\",\r\n      \"~Top|Top>memTap[4]\",\r\n      \"~Top|Top>memTap[5]\",\r\n      \"~Top|Top>memTap[6]\",\r\n      \"~Top|Top>memTap[7]\"\r\n    ]\r\n  },\r\n  {\r\n    \"class\": \"firrtl.passes.InlineAnnotation\",\r\n    \"target\": \"~Top|DUTModule\"\r\n  }\r\n]]\r\n  module DUTModule :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    cmem rf : UInt<8> [8]\r\n    infer mport read = rf[io.addr], clock\r\n    io.dataOut <= read\r\n    when io.wen :\r\n      infer mport write = rf[io.addr], clock\r\n      write <= io.dataIn\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    inst dut of DUTModule\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    wire memTap : UInt<8>[8]\r\n    memTap is invalid\r\n    io.dataOut <= dut.io.dataOut\r\n    dut.io.wen <= io.wen\r\n    dut.io.dataIn <= io.dataIn\r\n    dut.io.addr <= io.addr\r\n```\r\n\r\nThis is basically our `mem-taps.fir` lit test with the Inline annotation added.\r\n\r\nWith threading disabled, see the following error: `invalid element for hw.inout type '!firrtl.ref<uint<8>>'`, FWIW.", "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\": \"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"~Top|DUTModule\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top>memTap\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.MemTapAnnotation\",\r\n    \"source\":\"~Top|DUTModule>rf\",\r\n    \"sink\":[\r\n      \"~Top|Top>memTap[0]\",\r\n      \"~Top|Top>memTap[1]\",\r\n      \"~Top|Top>memTap[2]\",\r\n      \"~Top|Top>memTap[3]\",\r\n      \"~Top|Top>memTap[4]\",\r\n      \"~Top|Top>memTap[5]\",\r\n      \"~Top|Top>memTap[6]\",\r\n      \"~Top|Top>memTap[7]\"\r\n    ]\r\n  },\r\n  {\r\n    \"class\": \"firrtl.passes.InlineAnnotation\",\r\n    \"target\": \"~Top|DUTModule\"\r\n  }\r\n]]\r\n  module DUTModule :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    cmem rf : UInt<8> [8]\r\n    infer mport read = rf[io.addr], clock\r\n    io.dataOut <= read\r\n    when io.wen :\r\n      infer mport write = rf[io.addr], clock\r\n      write <= io.dataIn\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    output io : { flip addr : UInt<3>, flip dataIn : UInt<8>, flip wen : UInt<1>, dataOut : UInt<8>}\r\n\r\n    inst dut of DUTModule\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    wire memTap : UInt<8>[8]\r\n    memTap is invalid\r\n    io.dataOut <= dut.io.dataOut\r\n    dut.io.wen <= io.wen\r\n    dut.io.dataIn <= io.dataIn\r\n    dut.io.addr <= io.addr"}, {"number": 4816, "title": "Late pipeline passes should not be doing type coercion.", "created_at": "2023-03-13T23:26:33Z", "state": "open", "labels": "bug", "body": "              Please do not do this.  The goal is to remove this logic entirely and stop duplicating it in every pass.  We should never get to this point in the pass with the register reset value being the wrong type for the register.  That should be fixed in parsing.\r\n\r\n_Originally posted by @darthscsi in https://github.com/llvm/circt/pull/4788#pullrequestreview-1338110528_\r\n            "}, {"number": 4780, "title": "[FIRRTL] Missed comb cycle, crash in canonicalizer", "created_at": "2023-03-08T02:24:27Z", "state": "open", "labels": "bug, FIRRTL", "body": "Input:\r\n\r\n```firrtl\r\ncircuit wut :\r\n   module wut :\r\n     output rwDataOut : UInt<8>\r\n\r\n     rwDataOut <= rwDataOut\r\n```\r\n\r\n<details>\r\n<summary>Crashes after making it to HW dialect:</summary>\r\n\r\n```\r\nfirtool: /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:190: void mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith(ValueT &&) [OperandType = mlir::OpOperand, ValueT = mlir::Value &]: Assertion `(!newValue || this != OperandType::getUseList(newValue)) && \"cannot RAUW a value with itself\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool wut.fir\r\n #0 0x00000000006c71bb llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x00000000006c5450 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x00000000006c786d SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007f882063dbf0 __restore_rt (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3dbf0)\r\n #4 0x00007f882068abc7 __pthread_kill_implementation (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x8abc7)\r\n #5 0x00007f882063db46 gsignal (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3db46)\r\n #6 0x00007f88206284b5 abort (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x284b5)\r\n #7 0x00007f88206283d9 _nl_load_domain.cold.0 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x283d9)\r\n #8 0x00007f88206367b6 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x367b6)\r\n #9 0x0000000000a5476c std::enable_if<!(std::is_convertible<mlir::ValueRange&, mlir::Operation*>::value), void>::type mlir::ResultRange::replaceAllUsesWith<mlir::ValueRange&>(mlir::ValueRange&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/ValueRange.h:271:5\r\n#10 0x0000000000a52ec3 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:275:61\r\n#11 0x0000000000c31cb7 circt::sv::WireOp::canonicalize(circt::sv::WireOp, mlir::PatternRewriter&) /home/will/src/sifive/circt/lib/Dialect/SV/SVOps.cpp:1460:18\r\n#12 0x0000000000e0ccb7 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25\r\n#13 0x0000000000dd93ed (anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:229:19\r\n#14 0x0000000000dd702d (anonymous namespace)::RegionPatternRewriteDriver::simplify() && /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:458:15\r\n#15 0x0000000000dd702d mlir::applyPatternsAndFoldGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:487:47\r\n#16 0x0000000000a66148 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#17 0x0000000000a66148 mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:115:70\r\n#18 0x0000000000a66148 (anonymous namespace)::Canonicalizer::runOnOperation() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:61:9\r\n#19 0x0000000000ee9829 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11\r\n#20 0x0000000000ee9e61 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#21 0x0000000000ee9e61 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#22 0x0000000000ee9e61 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#23 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::size() const /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:919:66\r\n#24 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1045:2\r\n#25 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5\r\n#26 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18\r\n#27 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#28 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14\r\n#29 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5\r\n#30 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14\r\n#31 0x0000000000eec3a3 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#32 0x0000000000eec3a3 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#33 0x0000000000eec3a3 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#34 0x0000000000eec3a3 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:843:10\r\n#35 0x0000000000eec3a3 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:823:60\r\n#36 0x000000000061a57b mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#37 0x000000000061a57b mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#38 0x000000000061a57b processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:856:7\r\n#39 0x00000000006182bf processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:12\r\n#40 0x0000000000617f42 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:968:12\r\n#41 0x0000000000617f42 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1058:14\r\n#42 0x00000000006179f6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#43 0x00000000006179f6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#44 0x00000000006179f6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1122:8\r\n#45 0x00007f882062924e __libc_start_call_main (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x2924e)\r\n#46 0x00007f8820629309 __libc_start_main@GLIBC_2.2.5 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x29309)\r\n#47 0x0000000000617825 _start (./build/bin/firtool+0x617825)\r\nzsh: IOT instruction (core dumped)  ./build/bin/firtool wut.fir\r\n```\r\n\r\n</details>\r\n\r\nDumping the IR shows this before the crash:\r\n\r\n```\r\n// -----// IR Dump Before Canonicalizer (canonicalize) //----- //\r\nhw.module @wut() -> (rwDataOut: i8) {\r\n  %.rwDataOut.output = sv.wire : !hw.inout<i8>\r\n  %0 = sv.read_inout %.rwDataOut.output : !hw.inout<i8>\r\n  sv.assign %.rwDataOut.output, %0 : i8\r\n  hw.output %0 : i8\r\n}\r\n```", "code_snippet_01": "circuit wut :\r\n   module wut :\r\n     output rwDataOut : UInt<8>\r\n\r\n     rwDataOut <= rwDataOut", "code_snippet_02": "firtool: /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/UseDefLists.h:190: void mlir::IRObjectWithUseList<mlir::OpOperand>::replaceAllUsesWith(ValueT &&) [OperandType = mlir::OpOperand, ValueT = mlir::Value &]: Assertion `(!newValue || this != OperandType::getUseList(newValue)) && \"cannot RAUW a value with itself\"' failed.\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: ./build/bin/firtool wut.fir\r\n #0 0x00000000006c71bb llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:602:13\r\n #1 0x00000000006c5450 llvm::sys::RunSignalHandlers() /home/will/src/sifive/circt/llvm/llvm/lib/Support/Signals.cpp:105:18\r\n #2 0x00000000006c786d SignalHandler(int) /home/will/src/sifive/circt/llvm/llvm/lib/Support/Unix/Signals.inc:0:3\r\n #3 0x00007f882063dbf0 __restore_rt (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3dbf0)\r\n #4 0x00007f882068abc7 __pthread_kill_implementation (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x8abc7)\r\n #5 0x00007f882063db46 gsignal (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x3db46)\r\n #6 0x00007f88206284b5 abort (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x284b5)\r\n #7 0x00007f88206283d9 _nl_load_domain.cold.0 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x283d9)\r\n #8 0x00007f88206367b6 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x367b6)\r\n #9 0x0000000000a5476c std::enable_if<!(std::is_convertible<mlir::ValueRange&, mlir::Operation*>::value), void>::type mlir::ResultRange::replaceAllUsesWith<mlir::ValueRange&>(mlir::ValueRange&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/ValueRange.h:271:5\r\n#10 0x0000000000a52ec3 mlir::RewriterBase::replaceOp(mlir::Operation*, mlir::ValueRange) /home/will/src/sifive/circt/llvm/mlir/lib/IR/PatternMatch.cpp:275:61\r\n#11 0x0000000000c31cb7 circt::sv::WireOp::canonicalize(circt::sv::WireOp, mlir::PatternRewriter&) /home/will/src/sifive/circt/lib/Dialect/SV/SVOps.cpp:1460:18\r\n#12 0x0000000000e0ccb7 mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<mlir::LogicalResult (mlir::Pattern const&)>) /home/will/src/sifive/circt/llvm/mlir/lib/Rewrite/PatternApplicator.cpp:200:25\r\n#13 0x0000000000dd93ed (anonymous namespace)::GreedyPatternRewriteDriver::processWorklist() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:229:19\r\n#14 0x0000000000dd702d (anonymous namespace)::RegionPatternRewriteDriver::simplify() && /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:458:15\r\n#15 0x0000000000dd702d mlir::applyPatternsAndFoldGreedily(mlir::Region&, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp:487:47\r\n#16 0x0000000000a66148 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#17 0x0000000000a66148 mlir::applyPatternsAndFoldGreedily(mlir::Operation*, mlir::FrozenRewritePatternSet const&, mlir::GreedyRewriteConfig) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Transforms/GreedyPatternRewriteDriver.h:115:70\r\n#18 0x0000000000a66148 (anonymous namespace)::Canonicalizer::runOnOperation() /home/will/src/sifive/circt/llvm/mlir/lib/Transforms/Canonicalizer.cpp:61:9\r\n#19 0x0000000000ee9829 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:11\r\n#20 0x0000000000ee9e61 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#21 0x0000000000ee9e61 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#22 0x0000000000ee9e61 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#23 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::size() const /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:919:66\r\n#24 0x0000000000eeb518 std::vector<std::atomic<bool>, std::allocator<std::atomic<bool> > >::operator[](unsigned long) /nix/store/z1yw9cw97bcdfmxz5wk7j1bycw42r1mw-gcc-11.3.0/include/c++/11.3.0/bits/stl_vector.h:1045:2\r\n#25 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14::operator()(mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo&) const /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:759:5\r\n#26 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<__gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, __gnu_cxx::__normal_iterator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> > >, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:46:18\r\n#27 0x0000000000eeb518 mlir::LogicalResult mlir::failableParallelForEach<std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&>(mlir::MLIRContext*, std::vector<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo, std::allocator<mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::OpPMInfo> >&, mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool)::$_14&) /home/will/src/sifive/circt/llvm/mlir/include/mlir/IR/Threading.h:92:10\r\n#28 0x0000000000eeb518 mlir::detail::OpToOpPassAdaptor::runOnOperationAsyncImpl(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:764:14\r\n#29 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::runOnOperation(bool) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:0:5\r\n#30 0x0000000000ee9865 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:468:14\r\n#31 0x0000000000eec3a3 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#32 0x0000000000eec3a3 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#33 0x0000000000eec3a3 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:534:9\r\n#34 0x0000000000eec3a3 mlir::PassManager::runPasses(mlir::Operation*, mlir::AnalysisManager) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:843:10\r\n#35 0x0000000000eec3a3 mlir::PassManager::run(mlir::Operation*) /home/will/src/sifive/circt/llvm/mlir/lib/Pass/Pass.cpp:823:60\r\n#36 0x000000000061a57b mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#37 0x000000000061a57b mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#38 0x000000000061a57b processBuffer(mlir::MLIRContext&, mlir::TimingScope&, llvm::SourceMgr&, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:856:7\r\n#39 0x00000000006182bf processInputSplit(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:952:12\r\n#40 0x0000000000617f42 processInput(mlir::MLIRContext&, mlir::TimingScope&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer> >, std::optional<std::unique_ptr<llvm::ToolOutputFile, std::default_delete<llvm::ToolOutputFile> > >&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:968:12\r\n#41 0x0000000000617f42 executeFirtool(mlir::MLIRContext&) /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1058:14\r\n#42 0x00000000006179f6 mlir::LogicalResult::failed() const /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:44:33\r\n#43 0x00000000006179f6 mlir::failed(mlir::LogicalResult) /home/will/src/sifive/circt/llvm/mlir/include/mlir/Support/LogicalResult.h:72:58\r\n#44 0x00000000006179f6 main /home/will/src/sifive/circt/tools/firtool/firtool.cpp:1122:8\r\n#45 0x00007f882062924e __libc_start_call_main (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x2924e)\r\n#46 0x00007f8820629309 __libc_start_main@GLIBC_2.2.5 (/nix/store/yzjgl0h6a3qh1mby405428f16xww37h0-glibc-2.35-224/lib/libc.so.6+0x29309)\r\n#47 0x0000000000617825 _start (./build/bin/firtool+0x617825)\r\nzsh: IOT instruction (core dumped)  ./build/bin/firtool wut.fir", "code_snippet_03": "// -----// IR Dump Before Canonicalizer (canonicalize) //----- //\r\nhw.module @wut() -> (rwDataOut: i8) {\r\n  %.rwDataOut.output = sv.wire : !hw.inout<i8>\r\n  %0 = sv.read_inout %.rwDataOut.output : !hw.inout<i8>\r\n  sv.assign %.rwDataOut.output, %0 : i8\r\n  hw.output %0 : i8\r\n}"}, {"number": 4771, "title": "[FIRRTL] attach of analog under when (+ subaccess)?", "created_at": "2023-03-06T14:58:23Z", "state": "open", "labels": "bug, FIRRTL", "body": "Generally, this may be more of a FIRRTL-spec consideration, but the following is accepted and only is rejected late in the pipeline:\r\n\r\n```firrtl\r\ncircuit Foo :\r\n  module Foo :\r\n    output d : { a: UInt<2>, b: Analog<1>}\r\n    input c : UInt<1>\r\n    d is invalid\r\n    when c :\r\n      inst b of Bar\r\n      attach(d.b, b.b.b[c])\r\n    else :\r\n      inst b2 of Bar\r\n      attach(d.b, b2.b.b[c])\r\n\r\n  extmodule Bar :\r\n    output b : { a : UInt<2>, b : Analog<1>[2]}\r\n ```\r\n \r\n Output:\r\n \r\n ```\r\nanalog.fir:11:11: error: operand isn't an inout type\r\n      d.b <- b2.b.b[c]\r\n          ^\r\nanalog.fir:11:11: note: see current operation: \"firrtl.attach\"(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()\r\nanalog.fir:11:11: error: 'firrtl.attach' op LowerToHW couldn't handle this operation\r\n      d.b <- b2.b.b[c]\r\n          ^\r\nanalog.fir:11:11: note: see current operation: \"firrtl.attach\"(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> () \r\n ```\r\n \r\n*Does conditional attach make sense?* (is it unconditional even under `when`?)\r\n", "code_snippet_01": "circuit Foo :\r\n  module Foo :\r\n    output d : { a: UInt<2>, b: Analog<1>}\r\n    input c : UInt<1>\r\n    d is invalid\r\n    when c :\r\n      inst b of Bar\r\n      attach(d.b, b.b.b[c])\r\n    else :\r\n      inst b2 of Bar\r\n      attach(d.b, b2.b.b[c])\r\n\r\n  extmodule Bar :\r\n    output b : { a : UInt<2>, b : Analog<1>[2]}", "code_snippet_02": "analog.fir:11:11: error: operand isn't an inout type\r\n      d.b <- b2.b.b[c]\r\n          ^\r\nanalog.fir:11:11: note: see current operation: \"firrtl.attach\"(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()\r\nanalog.fir:11:11: error: 'firrtl.attach' op LowerToHW couldn't handle this operation\r\n      d.b <- b2.b.b[c]\r\n          ^\r\nanalog.fir:11:11: note: see current operation: \"firrtl.attach\"(%1, %19, %11) : (!firrtl.analog<1>, !firrtl.analog<1>, !firrtl.analog<1>) -> ()"}, {"number": 4770, "title": "[ExportVerilog] \"$name is not allowed in Verilog output\" error does not fail pass", "created_at": "2023-03-06T14:37:28Z", "state": "open", "labels": "bug, ExportVerilog", "body": "Encountered crafting test over here: https://github.com/llvm/circt/pull/4589#discussion_r1126488967 .\r\n\r\nIs currently reachable + executed as part of the `verilog-errors.mlir` test case:\r\n\r\n```mlir\r\nhw.module.extern @parameter ()\r\n```\r\n\r\n=>\r\n\r\n```\r\nverilog-error.mlir:4:1: error: name \"parameter\" is not allowed in Verilog output\r\nhw.module.extern @parameter ()\r\n^\r\nverilog-error.mlir:4:1: note: see current operation: \r\n\"hw.module.extern\"() ({\r\n}) {argLocs = [], argNames = [], comment = \"\", function_type = () -> (), parameters = [], resultLocs = [], resultNames = [], sym_name = \"parameter\"} : () -> ()\r\n// Generated by CIRCT 1.34.0g20230304_3ddf879\r\n// external module parameter\r\n```\r\n\r\nAs an aside, getting our error tests to check that pass/execution is not successful would be great, cc #4553 .", "code_snippet_01": "hw.module.extern @parameter ()", "code_snippet_02": "verilog-error.mlir:4:1: error: name \"parameter\" is not allowed in Verilog output\r\nhw.module.extern @parameter ()\r\n^\r\nverilog-error.mlir:4:1: note: see current operation: \r\n\"hw.module.extern\"() ({\r\n}) {argLocs = [], argNames = [], comment = \"\", function_type = () -> (), parameters = [], resultLocs = [], resultNames = [], sym_name = \"parameter\"} : () -> ()\r\n// Generated by CIRCT 1.34.0g20230304_3ddf879\r\n// external module parameter"}, {"number": 4753, "title": "[FIRRTL] Crash with out-of-bounds Index", "created_at": "2023-03-02T16:55:07Z", "state": "open", "labels": "bug, FIRRTL", "body": "I noticed that the following is crashing:\r\n\r\n```\r\ncircuit Foo:\r\n  module Foo:\r\n    input a: UInt<8>[3]\r\n    output b: UInt<8>\r\n\r\n    b <= a[UInt<99>(300)]\r\n```\r\n\r\nThis throws an error (doesn't exit) and then crashes (`firtool Foo.fir`):\r\n\r\n```\r\nFoo.fir:6:12: error: out of range index '300' in vector type '!firrtl.vector<uint<8>, 3>'\r\n    b <= a[UInt<99>(300)]\r\n           ^\r\nLLVM ERROR: Failed to infer result type(s).\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: firtool Foo.fir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x00000001039cf21d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x00000001039cf79b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x00000001039cd566 llvm::sys::RunSignalHandlers() + 134\r\n3  firtool                  0x00000001039d14cf SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff80f497dfd _sigtramp + 29\r\n5  firtool                  0x00000001037856e5 std::__1::__libcpp_deallocate(void*, unsigned long, unsigned long) + 85\r\n6  libsystem_c.dylib        0x00007ff80f3cdd24 abort + 123\r\n7  firtool                  0x000000010389f2d4 llvm::report_fatal_error(llvm::Twine const&, bool) + 388\r\n8  firtool                  0x000000010389f145 llvm::report_fatal_error(char const*, bool) + 53\r\n9  firtool                  0x000000010479c065 circt::firrtl::SubindexOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Value, unsigned int) + 533\r\n10 firtool                  0x0000000103ed526c circt::firrtl::SubindexOp mlir::OpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::Location, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 220\r\n11 firtool                  0x0000000103ed4fd1 circt::firrtl::SubindexOp mlir::ImplicitLocOpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 81\r\n```", "code_snippet_01": "circuit Foo:\r\n  module Foo:\r\n    input a: UInt<8>[3]\r\n    output b: UInt<8>\r\n\r\n    b <= a[UInt<99>(300)]", "code_snippet_02": "Foo.fir:6:12: error: out of range index '300' in vector type '!firrtl.vector<uint<8>, 3>'\r\n    b <= a[UInt<99>(300)]\r\n           ^\r\nLLVM ERROR: Failed to infer result type(s).\r\nPLEASE submit a bug report to https://github.com/llvm/circt and include the crash backtrace.\r\nStack dump:\r\n0.\tProgram arguments: firtool Foo.fir\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var `LLVM_SYMBOLIZER_PATH` to point to it):\r\n0  firtool                  0x00000001039cf21d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1  firtool                  0x00000001039cf79b PrintStackTraceSignalHandler(void*) + 27\r\n2  firtool                  0x00000001039cd566 llvm::sys::RunSignalHandlers() + 134\r\n3  firtool                  0x00000001039d14cf SignalHandler(int) + 223\r\n4  libsystem_platform.dylib 0x00007ff80f497dfd _sigtramp + 29\r\n5  firtool                  0x00000001037856e5 std::__1::__libcpp_deallocate(void*, unsigned long, unsigned long) + 85\r\n6  libsystem_c.dylib        0x00007ff80f3cdd24 abort + 123\r\n7  firtool                  0x000000010389f2d4 llvm::report_fatal_error(llvm::Twine const&, bool) + 388\r\n8  firtool                  0x000000010389f145 llvm::report_fatal_error(char const*, bool) + 53\r\n9  firtool                  0x000000010479c065 circt::firrtl::SubindexOp::build(mlir::OpBuilder&, mlir::OperationState&, mlir::Value, unsigned int) + 533\r\n10 firtool                  0x0000000103ed526c circt::firrtl::SubindexOp mlir::OpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::Location, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 220\r\n11 firtool                  0x0000000103ed4fd1 circt::firrtl::SubindexOp mlir::ImplicitLocOpBuilder::create<circt::firrtl::SubindexOp, mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>, long long>(mlir::detail::TypedValue<circt::firrtl::FIRRTLBaseType>&&, long long&&) + 81"}, {"number": 4586, "title": "[FIRRTL] PrefixModules Not Duplicating Modules When Necessary", "created_at": "2023-01-25T01:29:48Z", "state": "open", "labels": "bug, FIRRTL", "body": "I hit a situation where `PrefixModules` should be duplicating modules, but it is not.\r\n\r\nConsider the following:\r\n\r\n```\r\ncircuit Top : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"target\":\"~Top|Foo\",\r\n    \"prefix\":\"A_\",\r\n    \"inclusive\":true\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"target\":\"~Top|Foo_1\",\r\n    \"prefix\":\"B_\",\r\n    \"inclusive\":true\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|Foo>in\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|Foo_1>in\"\r\n  }\r\n]]\r\n  module Foo :\r\n    input in : UInt<8>\r\n\r\n  module Foo_1 :\r\n    input in : UInt<8>\r\n\r\n  module Top :\r\n    input in : UInt<8>\r\n\r\n    inst f1 of Foo\r\n    inst f2 of Foo_1\r\n    f1.in <= in\r\n    f2.in <= in\r\n```\r\n\r\nIf I run this with `firtool -dedup`, I get the following Verilog:\r\n\r\n```verilog\r\nmodule A_Foo(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule Top(\r\n  input [7:0] in);\r\n\r\n  A_Foo f1 (\r\n    .in (in)\r\n  );\r\n  A_Foo f2 (\r\n    .in (in)\r\n  );\r\nendmodule\r\n```\r\n\r\nIf I run without dedup, I get two modules (expectedly):\r\n\r\n```verilog\r\nmodule A_Foo(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule B_Foo_1(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule Top(\r\n  input [7:0] in);\r\n\r\n  A_Foo f1 (\r\n    .in (in)\r\n  );\r\n  B_Foo_1 f2 (\r\n    .in (in)\r\n  );\r\nendmodule\r\n```\r\n\r\nBasically, I'm expecting to see both an `A_` and `B_` prefix in the output and I only get an `A_` prefix.", "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"target\":\"~Top|Foo\",\r\n    \"prefix\":\"A_\",\r\n    \"inclusive\":true\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"target\":\"~Top|Foo_1\",\r\n    \"prefix\":\"B_\",\r\n    \"inclusive\":true\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|Foo>in\"\r\n  },\r\n  {\r\n    \"class\": \"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\": \"~Top|Foo_1>in\"\r\n  }\r\n]]\r\n  module Foo :\r\n    input in : UInt<8>\r\n\r\n  module Foo_1 :\r\n    input in : UInt<8>\r\n\r\n  module Top :\r\n    input in : UInt<8>\r\n\r\n    inst f1 of Foo\r\n    inst f2 of Foo_1\r\n    f1.in <= in\r\n    f2.in <= in", "code_snippet_02": "module A_Foo(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule Top(\r\n  input [7:0] in);\r\n\r\n  A_Foo f1 (\r\n    .in (in)\r\n  );\r\n  A_Foo f2 (\r\n    .in (in)\r\n  );\r\nendmodule", "code_snippet_03": "module A_Foo(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule B_Foo_1(\r\n  input [7:0] in);\r\n\r\nendmodule\r\n\r\nmodule Top(\r\n  input [7:0] in);\r\n\r\n  A_Foo f1 (\r\n    .in (in)\r\n  );\r\n  B_Foo_1 f2 (\r\n    .in (in)\r\n  );\r\nendmodule"}, {"number": 4354, "title": "[LowerToHW] An Error Should Be Generated if ForceNameAnnotation Would Not Be Unique", "created_at": "2022-11-23T03:08:03Z", "state": "open", "labels": "bug, good first issue, FIRRTL", "body": "Currently, two `ForceNameAnnotation`s can set an instance within the same module to the same name. The later one will eventually lose when it is uniqued by `PrepareForEmission`/`ExporVerilog`. This should instead be an error:\r\n\r\nConsider the following which is trying to set all instances inside `ForceNameTop` to be called `Foo`:\r\n\r\n```mlir\r\nfirrtl.circuit \"ForceNameTop\" {\r\n  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]\r\n  firrtl.hierpath private @nla_2 [@ForceNameTop::@sym_bar, @ForceNameSubmodule]\r\n  firrtl.module private @ForceNameSubmodule() attributes {annotations = [\r\n    {circt.nonlocal = @nla_1,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Foo\"},\r\n    {circt.nonlocal = @nla_2,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Foo\"}\r\n  ]} {}\r\n  firrtl.module @ForceNameTop() {\r\n    firrtl.instance Foo @ForceNameSubmodule()\r\n    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()\r\n    firrtl.instance bar sym @sym_bar @ForceNameSubmodule()\r\n  }\r\n}\r\n```\r\n\r\nAfter `LowerToHW` this has two instances with the same `verilogName`:\r\n\r\n```mlir\r\nmodule {\r\n  hw.module private @ForceNameSubmodule() {\r\n    hw.output\r\n  }\r\n  hw.module @ForceNameTop() {\r\n    hw.instance \"Foo\" @ForceNameSubmodule() -> ()\r\n    hw.instance \"foo\" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = \"Foo\"}\r\n    hw.instance \"bar\" sym @sym_bar @ForceNameSubmodule() -> () {hw.verilogName = \"Foo\"}\r\n    hw.output\r\n  }\r\n}\r\n```\r\n\r\nThis is fine and will generate sane Verilog below. However, this may be surprising to a user. Verilog is:\r\n\r\n```verilog\r\n// Generated by CIRCT unknown git version\r\nmodule ForceNameSubmodule();\r\nendmodule\r\n\r\nmodule ForceNameTop();\r\n  ForceNameSubmodule Foo_0 ();\r\n  ForceNameSubmodule Foo ();\r\n  ForceNameSubmodule Foo_1 ();\r\nendmodule\r\n```", "code_snippet_01": "firrtl.circuit \"ForceNameTop\" {\r\n  firrtl.hierpath private @nla_1 [@ForceNameTop::@sym_foo, @ForceNameSubmodule]\r\n  firrtl.hierpath private @nla_2 [@ForceNameTop::@sym_bar, @ForceNameSubmodule]\r\n  firrtl.module private @ForceNameSubmodule() attributes {annotations = [\r\n    {circt.nonlocal = @nla_1,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Foo\"},\r\n    {circt.nonlocal = @nla_2,\r\n     class = \"chisel3.util.experimental.ForceNameAnnotation\", name = \"Foo\"}\r\n  ]} {}\r\n  firrtl.module @ForceNameTop() {\r\n    firrtl.instance Foo @ForceNameSubmodule()\r\n    firrtl.instance foo sym @sym_foo @ForceNameSubmodule()\r\n    firrtl.instance bar sym @sym_bar @ForceNameSubmodule()\r\n  }\r\n}", "code_snippet_02": "module {\r\n  hw.module private @ForceNameSubmodule() {\r\n    hw.output\r\n  }\r\n  hw.module @ForceNameTop() {\r\n    hw.instance \"Foo\" @ForceNameSubmodule() -> ()\r\n    hw.instance \"foo\" sym @sym_foo @ForceNameSubmodule() -> () {hw.verilogName = \"Foo\"}\r\n    hw.instance \"bar\" sym @sym_bar @ForceNameSubmodule() -> () {hw.verilogName = \"Foo\"}\r\n    hw.output\r\n  }\r\n}", "code_snippet_03": "// Generated by CIRCT unknown git version\r\nmodule ForceNameSubmodule();\r\nendmodule\r\n\r\nmodule ForceNameTop();\r\n  ForceNameSubmodule Foo_0 ();\r\n  ForceNameSubmodule Foo ();\r\n  ForceNameSubmodule Foo_1 ();\r\nendmodule"}, {"number": 4097, "title": "[FIRRTL][SV] Grand Central w/ Extract Test Code Can Create Bind-under-bind", "created_at": "2022-10-13T21:36:28Z", "state": "open", "labels": "bug, FIRRTL", "body": "Nested binds are pedantically illegal SystemVerilog even though some tools support them. I have a situation where the combination of instantiating a module inside a Grand Central View that has assertions can result in extraction which produces a bind-under-bind.\r\n\r\nConsider the following FIRRTL text and annotation file:\r\n\r\n```\r\ncircuit Top :\r\n  extmodule DataTap_2 :\r\n    output _2 : UInt<1>\r\n    output _1 : UInt<1>\r\n    output _0 : Clock\r\n    defname = DataTap_2\r\n\r\n  module Wrapper :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n\r\n    node _T = asUInt(reset)\r\n    node _T_1 = eq(_T, UInt<1>(\"h0\"))\r\n    when _T_1 :\r\n      node _T_2 = eq(in, UInt<1>(\"h0\"))\r\n      when _T_2 :\r\n        printf(clock, UInt<1>(\"h1\"), \"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\") : printf\r\n      assert(clock, in, UInt<1>(\"h1\"), \"\") : assert\r\n\r\n\r\n  module MyView_companion :\r\n\r\n    wire _WIRE : UInt<1>\r\n    _WIRE <= UInt<1>(\"h0\")\r\n    wire clk : Clock\r\n    wire rst : UInt<1>\r\n    wire cond : UInt<1>\r\n    inst DataTap_2 of DataTap_2\r\n    DataTap_2._0 is invalid\r\n    DataTap_2._1 is invalid\r\n    DataTap_2._2 is invalid\r\n    clk <= DataTap_2._0\r\n    rst <= DataTap_2._1\r\n    cond <= DataTap_2._2\r\n    inst wrapper of Wrapper\r\n    wrapper.clock <= clk\r\n    wrapper.reset <= rst\r\n    wrapper.in <= cond\r\n\r\n  module DUT :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n\r\n    wire w : UInt<1>\r\n    w <= in\r\n    inst MyView_companion of MyView_companion\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input in : UInt<1>\r\n\r\n    inst dut of DUT\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    dut.in <= in\r\n```\r\n\r\n```json\r\n[\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\":\"~Top|DataTap_2\",\r\n    \"keys\":[\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>clock\",\r\n        \"portName\":\"~Top|DataTap_2>_0\"\r\n      },\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>reset\",\r\n        \"portName\":\"~Top|DataTap_2>_1\"\r\n      },\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>w\",\r\n        \"portName\":\"~Top|DataTap_2>_2\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\":\"MyView\",\r\n    \"companion\":\"~Top|MyView_companion\",\r\n    \"parent\":\"~Top|DUT\",\r\n    \"view\":\"{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedBundleType\\\",\\\"defName\\\":\\\"MyInterface\\\",\\\"elements\\\":[{\\\"name\\\":\\\"ground\\\",\\\"description\\\":\\\"a ground type port\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\",\\\"ref\\\":{\\\"circuit\\\":\\\"Top\\\",\\\"module\\\":\\\"Top\\\",\\\"path\\\":[{\\\"_1\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$Instance\\\",\\\"value\\\":\\\"dut\\\"},\\\"_2\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$OfModule\\\",\\\"value\\\":\\\"DUT\\\"}}],\\\"ref\\\":\\\"w\\\",\\\"component\\\":[]},\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\\\"}}}]}\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"Top.DUT\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"gct\",\r\n    \"filename\":\"bindings.sv\"\r\n  }\r\n]\r\n```\r\n\r\nCompiling this with `firtool Top.fir -annotation-file Top.anno.json -extract-test-code` produces the illegal:\r\n\r\n```\r\n// Generated by CIRCT unknown git version\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\n// VCS coverage exclude_file\r\nmodule Wrapper_assert(\r\n  input in,\r\n        reset,\r\n        clock);\r\n\r\n  `ifndef SYNTHESIS\r\n    always @(posedge clock) begin\r\n      if (~reset & ~in) begin\r\n        if (`ASSERT_VERBOSE_COND_)\r\n          $error(\"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\");\r\n        if (`STOP_COND_)\r\n          $fatal;\r\n      end\r\n    end // always @(posedge)\r\n  `endif // not def SYNTHESIS\r\nendmodule\r\n\r\nmodule DUT(\r\n  input clock,\r\n        reset,\r\n        in);\r\n\r\n  wire w = in;\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    MyView_companion MyView_companion ();\r\n  */\r\nendmodule\r\n\r\nmodule Top(\r\n  input clock,\r\n        reset,\r\n        in);\r\n\r\n  DUT dut (\r\n    .clock (clock),\r\n    .reset (reset),\r\n    .in    (in)\r\n  );\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"gct/DataTap_2_impl_0.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// VCS coverage exclude_file\r\nmodule DataTap_2_impl_0(\r\n  output _2,\r\n         _1,\r\n         _0);\r\n\r\n  assign _2 = DUT.w;\r\n  assign _1 = DUT.reset;\r\n  assign _0 = DUT.clock;\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"gct/MyView_companion.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\n// VCS coverage exclude_file\r\nmodule MyView_companion();\r\n  wire _DataTap_2__2;\r\n  wire _DataTap_2__1;\r\n  wire _DataTap_2__0;\r\n  MyInterface MyView();\r\n  `ifndef SYNTHESIS\r\n    always @(posedge _DataTap_2__0) begin\r\n      if (~_DataTap_2__1 & ~_DataTap_2__2) begin\r\n        if (`ASSERT_VERBOSE_COND_)\r\n          $error(\"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\");\r\n        if (`STOP_COND_)\r\n          $fatal;\r\n      end\r\n    end // always @(posedge)\r\n  `endif // not def SYNTHESIS\r\n  assign MyView.ground = DUT.w;\r\n  DataTap_2_impl_0 DataTap_2 (\r\n    ._2 (_DataTap_2__2),\r\n    ._1 (_DataTap_2__1),\r\n    ._0 (_DataTap_2__0)\r\n  );\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    Wrapper_assert Wrapper_assert (\r\n      .in    (_DataTap_2__2),\r\n      .reset (_DataTap_2__1),\r\n      .clock (_DataTap_2__0)\r\n    );\r\n  */\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"bindings.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\nbind DUT MyView_companion MyView_companion ();\r\n\r\n// ----- 8< ----- FILE \"gct/MyInterface.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// VCS coverage exclude_file\r\ninterface MyInterface;\r\n  // a ground type port\r\n  logic ground;\r\nendinterface\r\n\r\n\r\n// ----- 8< ----- FILE \"bindfile\" ----- 8< -----\r\n\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\nbind MyView_companion Wrapper_assert Wrapper_assert (\r\n  .in    (_DataTap_2__2),\r\n  .reset (_DataTap_2__1),\r\n  .clock (_DataTap_2__0)\r\n);\r\n```\r\n\r\nNotice that `MyView_companion` is bound into `DUT` and `Wrapper_assert` is bound into `MyView_companion`. Verilator happily accepts this, so I don't have a nice script to lint that this doesn't happen.", "code_snippet_01": "circuit Top :\r\n  extmodule DataTap_2 :\r\n    output _2 : UInt<1>\r\n    output _1 : UInt<1>\r\n    output _0 : Clock\r\n    defname = DataTap_2\r\n\r\n  module Wrapper :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n\r\n    node _T = asUInt(reset)\r\n    node _T_1 = eq(_T, UInt<1>(\"h0\"))\r\n    when _T_1 :\r\n      node _T_2 = eq(in, UInt<1>(\"h0\"))\r\n      when _T_2 :\r\n        printf(clock, UInt<1>(\"h1\"), \"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\") : printf\r\n      assert(clock, in, UInt<1>(\"h1\"), \"\") : assert\r\n\r\n\r\n  module MyView_companion :\r\n\r\n    wire _WIRE : UInt<1>\r\n    _WIRE <= UInt<1>(\"h0\")\r\n    wire clk : Clock\r\n    wire rst : UInt<1>\r\n    wire cond : UInt<1>\r\n    inst DataTap_2 of DataTap_2\r\n    DataTap_2._0 is invalid\r\n    DataTap_2._1 is invalid\r\n    DataTap_2._2 is invalid\r\n    clk <= DataTap_2._0\r\n    rst <= DataTap_2._1\r\n    cond <= DataTap_2._2\r\n    inst wrapper of Wrapper\r\n    wrapper.clock <= clk\r\n    wrapper.reset <= rst\r\n    wrapper.in <= cond\r\n\r\n  module DUT :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n\r\n    wire w : UInt<1>\r\n    w <= in\r\n    inst MyView_companion of MyView_companion\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input in : UInt<1>\r\n\r\n    inst dut of DUT\r\n    dut.clock <= clock\r\n    dut.reset <= reset\r\n    dut.in <= in", "code_snippet_02": "[\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.DataTapsAnnotation\",\r\n    \"blackBox\":\"~Top|DataTap_2\",\r\n    \"keys\":[\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>clock\",\r\n        \"portName\":\"~Top|DataTap_2>_0\"\r\n      },\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>reset\",\r\n        \"portName\":\"~Top|DataTap_2>_1\"\r\n      },\r\n      {\r\n        \"class\":\"sifive.enterprise.grandcentral.ReferenceDataTapKey\",\r\n        \"source\":\"~Top|Top/dut:DUT>w\",\r\n        \"portName\":\"~Top|DataTap_2>_2\"\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\":\"MyView\",\r\n    \"companion\":\"~Top|MyView_companion\",\r\n    \"parent\":\"~Top|DUT\",\r\n    \"view\":\"{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedBundleType\\\",\\\"defName\\\":\\\"MyInterface\\\",\\\"elements\\\":[{\\\"name\\\":\\\"ground\\\",\\\"description\\\":\\\"a ground type port\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\",\\\"ref\\\":{\\\"circuit\\\":\\\"Top\\\",\\\"module\\\":\\\"Top\\\",\\\"path\\\":[{\\\"_1\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$Instance\\\",\\\"value\\\":\\\"dut\\\"},\\\"_2\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$OfModule\\\",\\\"value\\\":\\\"DUT\\\"}}],\\\"ref\\\":\\\"w\\\",\\\"component\\\":[]},\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\\\"}}}]}\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.MarkDUTAnnotation\",\r\n    \"target\":\"Top.DUT\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"gct\",\r\n    \"filename\":\"bindings.sv\"\r\n  }\r\n]", "code_snippet_03": "// Generated by CIRCT unknown git version\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\n// VCS coverage exclude_file\r\nmodule Wrapper_assert(\r\n  input in,\r\n        reset,\r\n        clock);\r\n\r\n  `ifndef SYNTHESIS\r\n    always @(posedge clock) begin\r\n      if (~reset & ~in) begin\r\n        if (`ASSERT_VERBOSE_COND_)\r\n          $error(\"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\");\r\n        if (`STOP_COND_)\r\n          $fatal;\r\n      end\r\n    end // always @(posedge)\r\n  `endif // not def SYNTHESIS\r\nendmodule\r\n\r\nmodule DUT(\r\n  input clock,\r\n        reset,\r\n        in);\r\n\r\n  wire w = in;\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    MyView_companion MyView_companion ();\r\n  */\r\nendmodule\r\n\r\nmodule Top(\r\n  input clock,\r\n        reset,\r\n        in);\r\n\r\n  DUT dut (\r\n    .clock (clock),\r\n    .reset (reset),\r\n    .in    (in)\r\n  );\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"gct/DataTap_2_impl_0.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// VCS coverage exclude_file\r\nmodule DataTap_2_impl_0(\r\n  output _2,\r\n         _1,\r\n         _0);\r\n\r\n  assign _2 = DUT.w;\r\n  assign _1 = DUT.reset;\r\n  assign _0 = DUT.clock;\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"gct/MyView_companion.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\n// VCS coverage exclude_file\r\nmodule MyView_companion();\r\n  wire _DataTap_2__2;\r\n  wire _DataTap_2__1;\r\n  wire _DataTap_2__0;\r\n  MyInterface MyView();\r\n  `ifndef SYNTHESIS\r\n    always @(posedge _DataTap_2__0) begin\r\n      if (~_DataTap_2__1 & ~_DataTap_2__2) begin\r\n        if (`ASSERT_VERBOSE_COND_)\r\n          $error(\"Assertion failed: hello\\n    at AssertInView.scala:24 assert(in, \\\"hello\\\")\\n\");\r\n        if (`STOP_COND_)\r\n          $fatal;\r\n      end\r\n    end // always @(posedge)\r\n  `endif // not def SYNTHESIS\r\n  assign MyView.ground = DUT.w;\r\n  DataTap_2_impl_0 DataTap_2 (\r\n    ._2 (_DataTap_2__2),\r\n    ._1 (_DataTap_2__1),\r\n    ._0 (_DataTap_2__0)\r\n  );\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    Wrapper_assert Wrapper_assert (\r\n      .in    (_DataTap_2__2),\r\n      .reset (_DataTap_2__1),\r\n      .clock (_DataTap_2__0)\r\n    );\r\n  */\r\nendmodule\r\n\r\n\r\n// ----- 8< ----- FILE \"bindings.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\nbind DUT MyView_companion MyView_companion ();\r\n\r\n// ----- 8< ----- FILE \"gct/MyInterface.sv\" ----- 8< -----\r\n\r\n// Generated by CIRCT unknown git version\r\n// VCS coverage exclude_file\r\ninterface MyInterface;\r\n  // a ground type port\r\n  logic ground;\r\nendinterface\r\n\r\n\r\n// ----- 8< ----- FILE \"bindfile\" ----- 8< -----\r\n\r\n// Standard header to adapt well known macros to our needs.\r\n\r\n// Users can define 'ASSERT_VERBOSE_COND' to add an extra gate to assert error printing.\r\n`ifdef ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ (`ASSERT_VERBOSE_COND)\r\n`else  // ASSERT_VERBOSE_COND\r\n  `define ASSERT_VERBOSE_COND_ 1\r\n`endif // ASSERT_VERBOSE_COND\r\n\r\n// Users can define 'STOP_COND' to add an extra gate to stop conditions.\r\n`ifdef STOP_COND\r\n  `define STOP_COND_ (`STOP_COND)\r\n`else  // STOP_COND\r\n  `define STOP_COND_ 1\r\n`endif // STOP_COND\r\n\r\nbind MyView_companion Wrapper_assert Wrapper_assert (\r\n  .in    (_DataTap_2__2),\r\n  .reset (_DataTap_2__1),\r\n  .clock (_DataTap_2__0)\r\n);"}, {"number": 3810, "title": "[SystemC] SCModuleOp::getPortsOfDirection(direction) only returns first occurence", "created_at": "2022-09-02T14:36:30Z", "state": "open", "labels": "bug, SystemC", "body": "Above mentioned member function seems to only return the first port of the given direction for some reason.\r\nThere is no regression test with more than one output port, thus at least one should be added.\r\nObserved in the `hw.output` lowering in HWToSystemC at 9384dccab8692086c21a4166c5e5181623695d91"}, {"number": 3768, "title": "[HW] Enum aliasing in SV output", "created_at": "2022-08-24T09:25:15Z", "state": "open", "labels": "bug, HW", "body": "Currently, different enums with identical field names:\r\n```mlir\r\n  hw.type_scope @fsm_enum_typedecls {\r\n    hw.typedecl @M2_state_t : !hw.enum<A, B>\r\n    hw.typedecl @M1_state_t : !hw.enum<A, B>\r\n  }\r\n```\r\n\r\nWill export as:\r\n```sv\r\ntypedef enum {A, B} M2_state_t;\r\ntypedef enum {A, B} M1_state_t;\r\n```\r\nwherein enum values alias.\r\n\r\nEnum values should be emitted with additional pre/suffixing of the enum type name to avoid this, e.g.:\r\n```sv\r\ntypedef enum {M2_state_A, M2_state_B} M2_state_t;\r\ntypedef enum {M1_state_A, M1_state_B} M1_state_t;\r\n```", "code_snippet_01": "hw.type_scope @fsm_enum_typedecls {\r\n    hw.typedecl @M2_state_t : !hw.enum<A, B>\r\n    hw.typedecl @M1_state_t : !hw.enum<A, B>\r\n  }", "code_snippet_02": "typedef enum {A, B} M2_state_t;\r\ntypedef enum {A, B} M1_state_t;", "code_snippet_03": "typedef enum {M2_state_A, M2_state_B} M2_state_t;\r\ntypedef enum {M1_state_A, M1_state_B} M1_state_t;"}, {"number": 3494, "title": "[FIRRTL] GCT Views and Dedup", "created_at": "2022-07-08T23:19:29Z", "state": "open", "labels": "bug, FIRRTL", "body": "Grand Central (GCT) Views do not currently work when combined with FIRRTL's deduplication pass. Consider the following circuit and annotation file. `Top` instantiates `Foo` and `Foo_1`. Each of those, respectively, instantiate `Bar` and `Bar_1`. Each `Foo*` has a view of something inside each `Bar*`:\r\n\r\n```scala\r\ncircuit Top :\r\n  module Bar :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  module MyView_companion :\r\n\r\n    skip\r\n\r\n  module Foo :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    inst MyView_companion of MyView_companion\r\n\r\n  module Bar_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  module MyView_companion_0 :\r\n\r\n    skip\r\n\r\n  module Foo_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar_1\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    inst MyView_companion_0 of MyView_companion_0\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n\r\n    inst foo1 of Foo\r\n    foo1.clock <= clock\r\n    foo1.reset <= reset\r\n    inst foo2 of Foo_1\r\n    foo2.clock <= clock\r\n    foo2.reset <= reset\r\n```\r\n\r\n```json\r\n[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~Top|MyView_companion\",\r\n    \"parent\": \"~Top|Foo\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"w\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"Top\",\r\n              \"module\": \"Top\",\r\n              \"path\": [\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"foo1\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Foo\"\r\n                  }\r\n                },\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"bar\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Bar\"\r\n                  }\r\n                }\r\n              ],\r\n              \"ref\": \"w\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~Top|MyView_companion_0\",\r\n    \"parent\": \"~Top|Foo_1\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"w\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"Top\",\r\n              \"module\": \"Top\",\r\n              \"path\": [\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"foo2\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Foo_1\"\r\n                  }\r\n                },\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"bar\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Bar_1\"\r\n                  }\r\n                }\r\n              ],\r\n              \"ref\": \"w\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  }\r\n]\r\n```\r\n\r\nIf you run this with `firtool Foo.fir -annotation-file Foo.anno.json -dedup -firrtl-grand-central` you get an expected error. The GCT Views pass is asserting that the `NoDedupAnnotation` behavior exists:\r\n\r\n```\r\nfirrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once\r\n  module Foo :\r\n         ^\r\nfirrtl/Top.fir:13:10: note: see current operation: \"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):\r\n  %0:2 = \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@bar\">, moduleName = @Bar, name = \"bar\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"]} : () -> (!firrtl.clock, !firrtl.uint<1>)\r\n  \"firrtl.strictconnect\"(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()\r\n  \"firrtl.strictconnect\"(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@MyView_companion\">, moduleName = @MyView_companion, name = \"MyView_companion\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()\r\n}) {annotations = [{circt.nonlocal = @nla_3, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 2 : i64, name = \"MyView\", type = \"parent\"}, {circt.nonlocal = @nla_4, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 0 : i64, name = \"MyView\", type = \"parent\"}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"], portSyms = [\"\", \"\"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\nfirrtl/Top.fir:49:5: note: parent is instantiated here\r\n    inst foo2 of Foo_1\r\n    ^\r\nfirrtl/Top.fir:46:5: note: parent is instantiated here\r\n    inst foo1 of Foo\r\n    ^\r\nfirrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once\r\n  module Foo :\r\n         ^\r\nfirrtl/Top.fir:13:10: note: see current operation: \"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):\r\n  %0:2 = \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@bar\">, moduleName = @Bar, name = \"bar\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"]} : () -> (!firrtl.clock, !firrtl.uint<1>)\r\n  \"firrtl.strictconnect\"(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()\r\n  \"firrtl.strictconnect\"(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@MyView_companion\">, moduleName = @MyView_companion, name = \"MyView_companion\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()\r\n}) {annotations = [{circt.nonlocal = @nla_3, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 2 : i64, name = \"MyView\", type = \"parent\"}, {circt.nonlocal = @nla_4, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 0 : i64, name = \"MyView\", type = \"parent\"}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"], portSyms = [\"\", \"\"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\nfirrtl/Top.fir:49:5: note: parent is instantiated here\r\n    inst foo2 of Foo_1\r\n    ^\r\nfirrtl/Top.fir:46:5: note: parent is instantiated here\r\n    inst foo1 of Foo\r\n    ^\r\nfirrtl/Top.fir:1:1: error: 'firrtl.circuit' op contains a 'companion' with id '2', but does not contain a GrandCentral 'parent' with the same id\r\ncircuit Top :\r\n^\r\n```\r\n\r\nIf you run this without dedup (or with a `NoDedupAnnotation`) everything expectedly works. The fundamental problem is that GCT Views are encoding an XMR using annotations. After Dedup runs, it rightly keeps both of these annotations around. However, now you have a multiply instantiated parent module that is supposed to describe _two_ XMRs. However, these XMRs \"deduplicate\" to a single XMR.\r\n\r\nThere are multiple approaches to fix this:\r\n\r\n1. Modify the GCT Views pass to recognize this pattern and generate a \"minimal\" XMR that combines all the deduplicated XMRs.\r\n2. Special case certain annotations in dedup to also deduplicate.\r\n3. Change `LowerAnnotations` to represent XMRs as \"fake ports\" in the design rooted at the lowest-common ancestor necessary to make the connection. Then dedup works correctly.\r\n\r\n(1) is janky, but expedient. (2) is extremely janky. (3) is the only reasonable solution here.", "code_snippet_01": "circuit Top :\r\n  module Bar :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  module MyView_companion :\r\n\r\n    skip\r\n\r\n  module Foo :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    inst MyView_companion of MyView_companion\r\n\r\n  module Bar_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    wire w : UInt<1>\r\n    w <= UInt<1>(\"h0\")\r\n\r\n  module MyView_companion_0 :\r\n\r\n    skip\r\n\r\n  module Foo_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n\r\n    inst bar of Bar_1\r\n    bar.clock <= clock\r\n    bar.reset <= reset\r\n    inst MyView_companion_0 of MyView_companion_0\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n\r\n    inst foo1 of Foo\r\n    foo1.clock <= clock\r\n    foo1.reset <= reset\r\n    inst foo2 of Foo_1\r\n    foo2.clock <= clock\r\n    foo2.reset <= reset", "code_snippet_02": "[\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~Top|MyView_companion\",\r\n    \"parent\": \"~Top|Foo\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"w\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"Top\",\r\n              \"module\": \"Top\",\r\n              \"path\": [\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"foo1\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Foo\"\r\n                  }\r\n                },\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"bar\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Bar\"\r\n                  }\r\n                }\r\n              ],\r\n              \"ref\": \"w\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  },\r\n  {\r\n    \"class\": \"sifive.enterprise.grandcentral.ViewAnnotation\",\r\n    \"name\": \"MyView\",\r\n    \"companion\": \"~Top|MyView_companion_0\",\r\n    \"parent\": \"~Top|Foo_1\",\r\n    \"view\": {\r\n      \"class\": \"sifive.enterprise.grandcentral.AugmentedBundleType\",\r\n      \"defName\": \"MyInterface\",\r\n      \"elements\": [\r\n        {\r\n          \"name\": \"w\",\r\n          \"tpe\": {\r\n            \"class\": \"sifive.enterprise.grandcentral.AugmentedGroundType\",\r\n            \"ref\": {\r\n              \"circuit\": \"Top\",\r\n              \"module\": \"Top\",\r\n              \"path\": [\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"foo2\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Foo_1\"\r\n                  }\r\n                },\r\n                {\r\n                  \"_1\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$Instance\",\r\n                    \"value\": \"bar\"\r\n                  },\r\n                  \"_2\": {\r\n                    \"class\": \"firrtl.annotations.TargetToken$OfModule\",\r\n                    \"value\": \"Bar_1\"\r\n                  }\r\n                }\r\n              ],\r\n              \"ref\": \"w\",\r\n              \"component\": []\r\n            },\r\n            \"tpe\": {\r\n              \"class\": \"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\"\r\n            }\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  }\r\n]", "code_snippet_03": "firrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once\r\n  module Foo :\r\n         ^\r\nfirrtl/Top.fir:13:10: note: see current operation: \"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):\r\n  %0:2 = \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@bar\">, moduleName = @Bar, name = \"bar\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"]} : () -> (!firrtl.clock, !firrtl.uint<1>)\r\n  \"firrtl.strictconnect\"(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()\r\n  \"firrtl.strictconnect\"(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@MyView_companion\">, moduleName = @MyView_companion, name = \"MyView_companion\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()\r\n}) {annotations = [{circt.nonlocal = @nla_3, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 2 : i64, name = \"MyView\", type = \"parent\"}, {circt.nonlocal = @nla_4, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 0 : i64, name = \"MyView\", type = \"parent\"}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"], portSyms = [\"\", \"\"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\nfirrtl/Top.fir:49:5: note: parent is instantiated here\r\n    inst foo2 of Foo_1\r\n    ^\r\nfirrtl/Top.fir:46:5: note: parent is instantiated here\r\n    inst foo1 of Foo\r\n    ^\r\nfirrtl/Top.fir:13:10: error: 'firrtl.module' op is marked as a GrandCentral 'parent', but it is instantiated more than once\r\n  module Foo :\r\n         ^\r\nfirrtl/Top.fir:13:10: note: see current operation: \"firrtl.module\"() ({\r\n^bb0(%arg0: !firrtl.clock, %arg1: !firrtl.uint<1>):\r\n  %0:2 = \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@bar\">, moduleName = @Bar, name = \"bar\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"]} : () -> (!firrtl.clock, !firrtl.uint<1>)\r\n  \"firrtl.strictconnect\"(%0#0, %arg0) : (!firrtl.clock, !firrtl.clock) -> ()\r\n  \"firrtl.strictconnect\"(%0#1, %arg1) : (!firrtl.uint<1>, !firrtl.uint<1>) -> ()\r\n  \"firrtl.instance\"() {annotations = [], inner_sym = #firrtl<\"innerSym@MyView_companion\">, moduleName = @MyView_companion, name = \"MyView_companion\", nameKind = #firrtl<\"name_kind droppable_name\">, portAnnotations = [], portDirections = 0 : i0, portNames = []} : () -> ()\r\n}) {annotations = [{circt.nonlocal = @nla_3, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 2 : i64, name = \"MyView\", type = \"parent\"}, {circt.nonlocal = @nla_4, class = \"sifive.enterprise.grandcentral.ViewAnnotation.parent\", id = 0 : i64, name = \"MyView\", type = \"parent\"}], portAnnotations = [[], []], portDirections = 0 : i2, portNames = [\"clock\", \"reset\"], portSyms = [\"\", \"\"], portTypes = [!firrtl.clock, !firrtl.uint<1>], sym_name = \"Foo\", sym_visibility = \"private\"} : () -> ()\r\nfirrtl/Top.fir:49:5: note: parent is instantiated here\r\n    inst foo2 of Foo_1\r\n    ^\r\nfirrtl/Top.fir:46:5: note: parent is instantiated here\r\n    inst foo1 of Foo\r\n    ^\r\nfirrtl/Top.fir:1:1: error: 'firrtl.circuit' op contains a 'companion' with id '2', but does not contain a GrandCentral 'parent' with the same id\r\ncircuit Top :\r\n^"}, {"number": 3454, "title": "[ExportVerilog] Initial statement needs begin/end for single declaration", "created_at": "2022-06-30T11:00:07Z", "state": "open", "labels": "bug, ExportVerilog", "body": "Input:\r\n```mlir\r\nhw.module private @Foo() -> (){\r\n    sv.initial {\r\n      %param_x = sv.localparam : i42 { value = 11: i42 }\r\n    }\r\n}\r\n```\r\n`$ circt-opt -export-verilog` produces:\r\n```verilog\r\nmodule Foo();\r\n  initial     \r\n    localparam [41:0] param_x = 42'd11; \r\n\r\nendmodule\r\n```\r\n\r\nAt least Verilator and Yosys produce a syntax error. When I added \"begin\" and \"end\" around initial statement, it parses.  \r\n```verilog\r\n  initial begin \r\n    localparam [41:0] param_x = 42'd11;\r\n  end\r\n```", "code_snippet_01": "hw.module private @Foo() -> (){\r\n    sv.initial {\r\n      %param_x = sv.localparam : i42 { value = 11: i42 }\r\n    }\r\n}", "code_snippet_02": "module Foo();\r\n  initial     \r\n    localparam [41:0] param_x = 42'd11; \r\n\r\nendmodule", "code_snippet_03": "initial begin \r\n    localparam [41:0] param_x = 42'd11;\r\n  end"}, {"number": 3268, "title": "[StandardToHandshake] Passing `memref` to a function will still use `memref.alloc` ", "created_at": "2022-06-03T11:12:50Z", "state": "open", "labels": "bug, Handshake", "body": "Passing the following code to `--lower-std-to-handshake` produces a weird output.\r\n\r\n```mlir\r\nfunc.func @external_mem(%mem : memref<4xi32>) {\r\n  return\r\n}\r\n\r\nfunc.func @normal_mem() {\r\n  %mem = memref.alloc() : memref<4xi32>\r\n  func.call @external_mem(%mem) : (memref<4xi32>) -> ()\r\n  return\r\n}\r\n```\r\n\r\nOutput:\r\n\r\n```mlir\r\nhandshake.func @external_mem(%arg0: memref<4xi32>, %arg1: none, ...) -> none attributes {argNames = [\"in0\", \"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n  extmemory[ld = 0, st = 0] (%arg0 : memref<4xi32>) () {id = 0 : i32} : () -> ()\r\n  return %arg1 : none\r\n }\r\nhandshake.func @normal_mem(%arg0: none, ...) -> none attributes {argNames = [\"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n  %0:2 = fork [2] %arg0 : none\r\n  %1 = memref.alloc() : memref<4xi32>\r\n  %2 = instance @external_mem(%1, %0#0) : (memref<4xi32>, none) -> none\r\n  sink %2 : none\r\n  return %0#1 : none\r\n}\r\n```\r\n\r\nAs you can see, a `memref.alloc()` remains, which is not expected and thus breaks further transformations. \r\n\r\nI would expect that a correct lowering would construct a `MemoryOp` in the `@normal_mem` function. How this exactly interacts with the external memory op is not clear to me, as this will cause cross function dependencies depending on the amount of memory operations in `@external_mem`.", "code_snippet_01": "func.func @external_mem(%mem : memref<4xi32>) {\r\n  return\r\n}\r\n\r\nfunc.func @normal_mem() {\r\n  %mem = memref.alloc() : memref<4xi32>\r\n  func.call @external_mem(%mem) : (memref<4xi32>) -> ()\r\n  return\r\n}", "code_snippet_02": "handshake.func @external_mem(%arg0: memref<4xi32>, %arg1: none, ...) -> none attributes {argNames = [\"in0\", \"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n  extmemory[ld = 0, st = 0] (%arg0 : memref<4xi32>) () {id = 0 : i32} : () -> ()\r\n  return %arg1 : none\r\n }\r\nhandshake.func @normal_mem(%arg0: none, ...) -> none attributes {argNames = [\"inCtrl\"], resNames = [\"outCtrl\"]} {\r\n  %0:2 = fork [2] %arg0 : none\r\n  %1 = memref.alloc() : memref<4xi32>\r\n  %2 = instance @external_mem(%1, %0#0) : (memref<4xi32>, none) -> none\r\n  sink %2 : none\r\n  return %0#1 : none\r\n}"}, {"number": 3240, "title": "[FIRRTL] Grand Central Views/Taps Should Not Block Deduplication", "created_at": "2022-05-29T05:27:10Z", "state": "open", "labels": "bug, FIRRTL", "body": "The dead wire taps added to GCT Views and Data Taps are causing problems with deduplication. Specifically, the dead wire taps can block deduplication because they are IR operations. A GCT view or tap should not block deduplication.\r\n\r\n## Example\r\n\r\nConsider the following circuit.  In this, there are two submodules and _only one_ is tapped via a Grand Central View on wire `_w`:\r\n\r\n```scala\r\ncircuit Top :\r\n  module Submodule :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    wire _w : UInt<1> \r\n    _w <= in \r\n    out <= _w \r\n\r\n  module Submodule_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    wire _w : UInt<1> \r\n    _w <= in \r\n    out <= _w \r\n\r\n  module MyView_companion :\r\n\r\n    wire _WIRE : UInt<1>\r\n    _WIRE <= UInt<1>(\"h0\")\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    inst sub1 of Submodule \r\n    sub1.clock <= clock\r\n    sub1.reset <= reset\r\n    inst sub2 of Submodule_1 \r\n    sub2.clock <= clock\r\n    sub2.reset <= reset\r\n    sub1.in <= in \r\n    sub2.in <= in \r\n    node _out_T = xor(sub1.out, sub2.out) \r\n    out <= _out_T \r\n    inst MyView_companion of MyView_companion \r\n```\r\n\r\nThe corresponding annotation file is:\r\n```json\r\n[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|MyView_companion>_WIRE\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\":\"MyView\",\r\n    \"companion\":\"~Top|MyView_companion\",\r\n    \"parent\":\"~Top|Top\",\r\n    \"view\":\"{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedBundleType\\\",\\\"defName\\\":\\\"MyInterface\\\",\\\"elements\\\":[{\\\"name\\\":\\\"tap1\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\",\\\"ref\\\":{\\\"circuit\\\":\\\"Top\\\",\\\"module\\\":\\\"Top\\\",\\\"path\\\":[{\\\"_1\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$Instance\\\",\\\"value\\\":\\\"sub1\\\"},\\\"_2\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$OfModule\\\",\\\"value\\\":\\\"Submodule\\\"}}],\\\"ref\\\":\\\"_w\\\",\\\"component\\\":[]},\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\\\"}}}]}\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\":\"~Top|MyView_companion\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"builds/gct-tests/DedupOneTap/firrtl/gct\",\r\n    \"filename\":\"builds/gct-tests/DedupOneTap/firrtl/bindings.sv\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation\",\r\n    \"filename\":\"builds/gct-tests/DedupOneTap/firrtl/gct/gct.yaml\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.stage.RunFirrtlTransformAnnotation\",\r\n    \"transform\":\"sifive.enterprise.grandcentral.GrandCentralTransform\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.stage.RunFirrtlTransformAnnotation\",\r\n    \"transform\":\"sifive.enterprise.firrtl.ExtractTestCodeTransform\"\r\n  }\r\n]\r\n```\r\n\r\nWhen compiled, this currently produces two copies of the submodule due to the `_gctTap` which causes them to differ.\r\n\r\nThe output Verilog currently is:\r\n\r\n```verilog\r\nmodule Submodule(\r\n  input  in,\r\n  output out);\r\n\r\n  wire _gctTap;\r\n\r\n  assign _gctTap = in;\r\n  assign out = in;\r\nendmodule\r\n\r\nmodule Submodule_1(\r\n  input  in,\r\n  output out);\r\n\r\n  assign out = in;\r\nendmodule\r\n\r\nmodule Top(\r\n  input  clock,\r\n         reset,\r\n         in,\r\n  output out);\r\n\r\n  wire _sub2_out;\r\n  wire _sub1_out;\r\n\r\n  // This interface is elsewhere emitted as a bind statement.\r\n  // MyInterface MyView();\r\n  Submodule sub1 (\r\n    .in  (in),\r\n    .out (_sub1_out)\r\n  );\r\n  Submodule_1 sub2 (\r\n    .in  (in),\r\n    .out (_sub2_out)\r\n  );\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    MyView_companion MyView_companion ();\r\n  */\r\n  assign out = _sub1_out ^ _sub2_out;\r\nendmodule\r\n```", "code_snippet_01": "circuit Top :\r\n  module Submodule :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    wire _w : UInt<1> \r\n    _w <= in \r\n    out <= _w \r\n\r\n  module Submodule_1 :\r\n    input clock : Clock\r\n    input reset : Reset\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    wire _w : UInt<1> \r\n    _w <= in \r\n    out <= _w \r\n\r\n  module MyView_companion :\r\n\r\n    wire _WIRE : UInt<1>\r\n    _WIRE <= UInt<1>(\"h0\")\r\n\r\n  module Top :\r\n    input clock : Clock\r\n    input reset : UInt<1>\r\n    input in : UInt<1>\r\n    output out : UInt<1>\r\n\r\n    inst sub1 of Submodule \r\n    sub1.clock <= clock\r\n    sub1.reset <= reset\r\n    inst sub2 of Submodule_1 \r\n    sub2.clock <= clock\r\n    sub2.reset <= reset\r\n    sub1.in <= in \r\n    sub2.in <= in \r\n    node _out_T = xor(sub1.out, sub2.out) \r\n    out <= _out_T \r\n    inst MyView_companion of MyView_companion", "code_snippet_02": "[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|MyView_companion>_WIRE\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralView$SerializedViewAnnotation\",\r\n    \"name\":\"MyView\",\r\n    \"companion\":\"~Top|MyView_companion\",\r\n    \"parent\":\"~Top|Top\",\r\n    \"view\":\"{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedBundleType\\\",\\\"defName\\\":\\\"MyInterface\\\",\\\"elements\\\":[{\\\"name\\\":\\\"tap1\\\",\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.AugmentedGroundType\\\",\\\"ref\\\":{\\\"circuit\\\":\\\"Top\\\",\\\"module\\\":\\\"Top\\\",\\\"path\\\":[{\\\"_1\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$Instance\\\",\\\"value\\\":\\\"sub1\\\"},\\\"_2\\\":{\\\"class\\\":\\\"firrtl.annotations.TargetToken$OfModule\\\",\\\"value\\\":\\\"Submodule\\\"}}],\\\"ref\\\":\\\"_w\\\",\\\"component\\\":[]},\\\"tpe\\\":{\\\"class\\\":\\\"sifive.enterprise.grandcentral.GrandCentralView$UnknownGroundType$\\\"}}}]}\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.transforms.NoDedupAnnotation\",\r\n    \"target\":\"~Top|MyView_companion\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.ExtractGrandCentralAnnotation\",\r\n    \"directory\":\"builds/gct-tests/DedupOneTap/firrtl/gct\",\r\n    \"filename\":\"builds/gct-tests/DedupOneTap/firrtl/bindings.sv\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.grandcentral.GrandCentralHierarchyFileAnnotation\",\r\n    \"filename\":\"builds/gct-tests/DedupOneTap/firrtl/gct/gct.yaml\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.stage.RunFirrtlTransformAnnotation\",\r\n    \"transform\":\"sifive.enterprise.grandcentral.GrandCentralTransform\"\r\n  },\r\n  {\r\n    \"class\":\"firrtl.stage.RunFirrtlTransformAnnotation\",\r\n    \"transform\":\"sifive.enterprise.firrtl.ExtractTestCodeTransform\"\r\n  }\r\n]", "code_snippet_03": "module Submodule(\r\n  input  in,\r\n  output out);\r\n\r\n  wire _gctTap;\r\n\r\n  assign _gctTap = in;\r\n  assign out = in;\r\nendmodule\r\n\r\nmodule Submodule_1(\r\n  input  in,\r\n  output out);\r\n\r\n  assign out = in;\r\nendmodule\r\n\r\nmodule Top(\r\n  input  clock,\r\n         reset,\r\n         in,\r\n  output out);\r\n\r\n  wire _sub2_out;\r\n  wire _sub1_out;\r\n\r\n  // This interface is elsewhere emitted as a bind statement.\r\n  // MyInterface MyView();\r\n  Submodule sub1 (\r\n    .in  (in),\r\n    .out (_sub1_out)\r\n  );\r\n  Submodule_1 sub2 (\r\n    .in  (in),\r\n    .out (_sub2_out)\r\n  );\r\n  /* This instance is elsewhere emitted as a bind statement.\r\n    MyView_companion MyView_companion ();\r\n  */\r\n  assign out = _sub1_out ^ _sub2_out;\r\nendmodule"}, {"number": 3105, "title": "[FIRRTL] ExtractInstances wrapper module name is not prefixed", "created_at": "2022-05-11T14:49:40Z", "state": "open", "labels": "bug, FIRRTL", "body": "The optional wrapper modules that `ExtractInstances` can generate (e.g. through the `group` field in `ExtractSeqMemsFileAnnotation`) do not get prefixed by `PrefixModules`. See `test/Dialect/FIRRTL/SFCTests/ExtractSeqMems/Compose.fir` for an example.\r\n\r\nDoing the prefixing is not that simple, since ideally we would want prefixing to run before extraction. But extraction creates `sv.verbatim` ops with symbol references to modules which prefixing will invalidate. Alternatively one could go the route of GrandCentral views which also runs after prefixing, but where prefixing updates the annotations relevant for GCT views to contain the prefix. This is challenging for extraction though, since instances to be extracted are not all explicitly annotated, and whether or not a prefix has to be added to the wrapper module also depends on whether the location of the wrapper module is inside the area of effect of a prefix annotation.\r\n\r\nIdeally we would make `PrefixInstances` update symbols appropriately (#3104) and make `sv.verbatim` robust under hierarchy modification. That would disentangle the ordering requirements of the passes and we could run extraction before prefixing."}, {"number": 3104, "title": "[FIRRTL] PrefixModules does not update symbols in sv.verbatim ops", "created_at": "2022-05-11T14:42:23Z", "state": "open", "labels": "bug, FIRRTL", "body": "The `PrefixModules` pass does not update uses of the old module symbol names to the renamed version. Occurs if a pass runs before prefixing that already generates verbatim nodes refering to modules through symbol placeholders (as we commonly do in metadata emission).\r\n\r\nGetting this right might actually be harder than it looks at first glance, especially if modules have to be duplicated to account for instance-specific prefixing."}, {"number": 3090, "title": "[FIRRTL] ExtractInstances duplicates NLAs without assigning new names", "created_at": "2022-05-10T14:52:23Z", "state": "open", "labels": "bug, FIRRTL", "body": "The following caveat is a problem: https://github.com/llvm/circt/blob/a9bdc67cf5bd9493b402c1ee18dca1f6c9766e28/lib/Dialect/FIRRTL/Transforms/ExtractInstances.cpp#L601-L620\r\n\r\nIn a nutshell: There are cases where `ExtractInstances` has to create multiple copies of an NLA during extraction, and currently it does not pick new names for those NLAs. Doing so is a bit cumbersome since the pass has to visit all instances along the NLA path and insert trackers for the newly-created NLAs there as well.\r\n\r\nThe case where this happens requires:\r\n- An instance to be extracted that is nested somewhere within a multiply-instantiated module\r\n- An NLA on that instance that is rooted at the multiply-instantiated module"}, {"number": 3033, "title": "[FIRRTL] Dedup Should Work in Circuit Order", "created_at": "2022-05-03T22:37:08Z", "state": "open", "labels": "bug, FIRRTL", "body": "CIRCT deviates from the SFC because it is doing deduplication based on the instantiation order).  Instead, deduplication should use circuit order (declaration order).\r\n\r\nConsider the following:\r\n\r\n```scala\r\ncircuit Bar:\r\n  module X:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    b <= not(a)\r\n  module Y:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    b <= not(a)\r\n  module Bar:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    inst y of Y\r\n    inst x of X\r\n\r\n    x.a <= a\r\n    y.a <= a\r\n    b <= xor(x.b, y.b)\r\n```\r\n\r\nThis circuit, `Bar`, instantiates two modules that will deduplicate, `X` and `Y`. Module `Y` is instantiated before module `X`. However, `Y` should deduplicate into `X` because `X` is declared first.\r\n\r\nCurrently CIRCT produces (`firtool Bar.fir -dedup -strip-debug-info`):\r\n\r\n```verilog\r\nmodule Y(\r\n  input  a,\r\n  output b);\r\n\r\n  assign b = ~a;\r\nendmodule\r\n\r\nmodule Bar(\r\n  input  a,\r\n  output b);\r\n\r\n  wire _x_b;\r\n  wire _y_b;\r\n\r\n  Y y (\r\n    .a (a),\r\n    .b (_y_b)\r\n  );\r\n  Y x (\r\n    .a (a),\r\n    .b (_x_b)\r\n  );\r\n  assign b = _x_b ^ _y_b;\r\nendmodule\r\n```\r\n\r\nSFC produces (`firrtl -i Bar.fir`):\r\n\r\n```verilog\r\nmodule X(\r\n  input   a,\r\n  output  b\r\n);\r\n  assign b = ~a;\r\nendmodule\r\nmodule Bar(\r\n  input   a,\r\n  output  b\r\n);\r\n  wire  y_a;\r\n  wire  y_b;\r\n  wire  x_a;\r\n  wire  x_b;\r\n  X y (\r\n    .a(y_a),\r\n    .b(y_b)\r\n  );\r\n  X x (\r\n    .a(x_a),\r\n    .b(x_b)\r\n  );\r\n  assign b = x_b ^ y_b;\r\n  assign y_a = a;\r\n  assign x_a = a;\r\nendmodule\r\n```", "code_snippet_01": "circuit Bar:\r\n  module X:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    b <= not(a)\r\n  module Y:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    b <= not(a)\r\n  module Bar:\r\n    input a: UInt<1>\r\n    output b: UInt<1>\r\n\r\n    inst y of Y\r\n    inst x of X\r\n\r\n    x.a <= a\r\n    y.a <= a\r\n    b <= xor(x.b, y.b)", "code_snippet_02": "module Y(\r\n  input  a,\r\n  output b);\r\n\r\n  assign b = ~a;\r\nendmodule\r\n\r\nmodule Bar(\r\n  input  a,\r\n  output b);\r\n\r\n  wire _x_b;\r\n  wire _y_b;\r\n\r\n  Y y (\r\n    .a (a),\r\n    .b (_y_b)\r\n  );\r\n  Y x (\r\n    .a (a),\r\n    .b (_x_b)\r\n  );\r\n  assign b = _x_b ^ _y_b;\r\nendmodule", "code_snippet_03": "module X(\r\n  input   a,\r\n  output  b\r\n);\r\n  assign b = ~a;\r\nendmodule\r\nmodule Bar(\r\n  input   a,\r\n  output  b\r\n);\r\n  wire  y_a;\r\n  wire  y_b;\r\n  wire  x_a;\r\n  wire  x_b;\r\n  X y (\r\n    .a(y_a),\r\n    .b(y_b)\r\n  );\r\n  X x (\r\n    .a(x_a),\r\n    .b(x_b)\r\n  );\r\n  assign b = x_b ^ y_b;\r\n  assign y_a = a;\r\n  assign x_a = a;\r\nendmodule"}, {"number": 2888, "title": "[FIRRTL] Don't Dedup Modules with Different NestedPrefixModulesAnnotation", "created_at": "2022-04-13T04:49:07Z", "state": "open", "labels": "bug", "body": "`NestedPrefixModulesAnnotation` with different prefixes should not deduplicate. This can be interpreted one of two ways, either of which should have the same effect:\r\n\r\n1. `NestedPrefixModulesAnnotation` should block deduplication.\r\n2. The `PrefixModules` pass should duplicate modules which have different prefixes.\r\n\r\nSiFive's extensions to the SFC are implementing this using strategy (2).\r\n\r\nAn end-to-end test case that should work is the following:\r\n\r\n```scala\r\ncircuit Foo: %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"prefix\":\"prefix1_\",\r\n    \"inclusive\":true,\r\n    \"target\":\"~Foo|Bar\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"prefix\":\"prefix2_\",\r\n    \"inclusive\":true,\r\n    \"target\":\"~Foo|Baz\"\r\n  }\r\n]]\r\n  module Bar:\r\n  module Baz:\r\n  module Foo:\r\n    inst bar of Bar\r\n    inst baz of Baz\r\n```\r\n\r\nCurrently, this produces (`firtool -dedup -strip-debug-info`):\r\n\r\n```verilog\r\nmodule prefix2_Bar();\r\nendmodule\r\n\r\nmodule Foo();\r\n  prefix2_Bar bar ();\r\n  prefix2_Bar baz ();\r\nendmodule\r\n```\r\n\r\nThis should produce:\r\n```verilog\r\nmodule prefix1_Bar();\r\nendmodule\r\n\r\nmodule prefix2_Baz();\r\nendmodule\r\n\r\nmodule Foo();\r\n  prefix1_Bar bar ();\r\n  prefix2_Baz baz ();\r\nendmodule\r\n```\r\n\r\nThere may also be an interaction here with memories where memories should not deduplicate if they have different prefixes.  This may be a little funky because it has interactions with the memory generator schema which may not respect prefixing.", "code_snippet_01": "circuit Foo: %[[\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"prefix\":\"prefix1_\",\r\n    \"inclusive\":true,\r\n    \"target\":\"~Foo|Bar\"\r\n  },\r\n  {\r\n    \"class\":\"sifive.enterprise.firrtl.NestedPrefixModulesAnnotation\",\r\n    \"prefix\":\"prefix2_\",\r\n    \"inclusive\":true,\r\n    \"target\":\"~Foo|Baz\"\r\n  }\r\n]]\r\n  module Bar:\r\n  module Baz:\r\n  module Foo:\r\n    inst bar of Bar\r\n    inst baz of Baz", "code_snippet_02": "module prefix2_Bar();\r\nendmodule\r\n\r\nmodule Foo();\r\n  prefix2_Bar bar ();\r\n  prefix2_Bar baz ();\r\nendmodule", "code_snippet_03": "module prefix1_Bar();\r\nendmodule\r\n\r\nmodule prefix2_Baz();\r\nendmodule\r\n\r\nmodule Foo();\r\n  prefix1_Bar bar ();\r\n  prefix2_Baz baz ();\r\nendmodule"}, {"number": 2531, "title": "[FIRRTL] DontTouchAnnotation as Symbol and Deduplication", "created_at": "2022-01-27T21:03:37Z", "state": "open", "labels": "bug, FIRRTL", "body": "The modeling of `DontTouchAnnotation` as a symbol destroys some information that may be necessary for an SFC-exact implementation of deduplication.\r\n\r\nConsider the following circuit. Modules `A` and `A_` are structurally equivalent and should deduplicate. `A` has a `DontTouchAnnotation` on a wire inside it. This is not supposed to block deduplication.\r\n\r\n```scala\r\ncircuit Top : %[[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"Top.A.b\"\r\n  }\r\n]]\r\n  module Top :\r\n    inst a1 of A\r\n    inst a2 of A_\r\n  module A :\r\n    output x: UInt<1>\r\n    wire b: UInt<1>\r\n    b is invalid\r\n    x <= b\r\n  module A_ :\r\n    output x: UInt<1>\r\n    wire b: UInt<1>\r\n    b is invalid\r\n    x <= b\r\n```\r\n\r\nWhen we parse this in, this specific annotations becomes a symbol `@b`:\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Top\"   {\r\n    firrtl.module @Top() {\r\n      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n      %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)\r\n    }\r\n    firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n      %b = firrtl.wire sym @b  : !firrtl.uint<1>\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n    firrtl.module @A_(out %x: !firrtl.uint<1>) {\r\n      %b = firrtl.wire  : !firrtl.uint<1>\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nAfter deduplication, the circuit looks like with `@b` applied to the deduplicated wire. The effect of the annotation now applies to both wires:\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Top\"   {\r\n    firrtl.module @Top() {\r\n      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n      %a2_x = firrtl.instance a2  @A(out x: !firrtl.uint<1>)\r\n    }\r\n    firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      %b = firrtl.wire sym @b  : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nIn contrast, the SFC produces a non-local annotation targeting the original instance's wire:\r\n```scala\r\ncircuit Top :\r\n  module A :\r\n    output x : UInt<1>\r\n\r\n    wire b : UInt<1> @[dont-touch.scala 33:15]\r\n    b is invalid @[dont-touch.scala 34:5]\r\n    x <= b @[dont-touch.scala 36:5]\r\n\r\n  module Top :\r\n\r\n    inst a1 of A @[dont-touch.scala 47:18]\r\n    inst a2 of A @[dont-touch.scala 48:18]\r\n```\r\n```json\r\n[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top/a1:A>b\"\r\n  }\r\n]\r\n```\r\n\r\nI don't have an opinion or evidence that this is problematic, yet. This is just reporting an SFC deviation.", "code_snippet_01": "circuit Top : %[[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"Top.A.b\"\r\n  }\r\n]]\r\n  module Top :\r\n    inst a1 of A\r\n    inst a2 of A_\r\n  module A :\r\n    output x: UInt<1>\r\n    wire b: UInt<1>\r\n    b is invalid\r\n    x <= b\r\n  module A_ :\r\n    output x: UInt<1>\r\n    wire b: UInt<1>\r\n    b is invalid\r\n    x <= b", "code_snippet_02": "module  {\r\n  firrtl.circuit \"Top\"   {\r\n    firrtl.module @Top() {\r\n      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n      %a2_x = firrtl.instance a2  @A_(out x: !firrtl.uint<1>)\r\n    }\r\n    firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n      %b = firrtl.wire sym @b  : !firrtl.uint<1>\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n    firrtl.module @A_(out %x: !firrtl.uint<1>) {\r\n      %b = firrtl.wire  : !firrtl.uint<1>\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_03": "module  {\r\n  firrtl.circuit \"Top\"   {\r\n    firrtl.module @Top() {\r\n      %a1_x = firrtl.instance a1  @A(out x: !firrtl.uint<1>)\r\n      %a2_x = firrtl.instance a2  @A(out x: !firrtl.uint<1>)\r\n    }\r\n    firrtl.module @A(out %x: !firrtl.uint<1>) {\r\n      %invalid_ui1 = firrtl.invalidvalue : !firrtl.uint<1>\r\n      %b = firrtl.wire sym @b  : !firrtl.uint<1>\r\n      firrtl.connect %b, %invalid_ui1 {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>\r\n      firrtl.connect %x, %b {annotations = []} : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_04": "circuit Top :\r\n  module A :\r\n    output x : UInt<1>\r\n\r\n    wire b : UInt<1> @[dont-touch.scala 33:15]\r\n    b is invalid @[dont-touch.scala 34:5]\r\n    x <= b @[dont-touch.scala 36:5]\r\n\r\n  module Top :\r\n\r\n    inst a1 of A @[dont-touch.scala 47:18]\r\n    inst a2 of A @[dont-touch.scala 48:18]", "code_snippet_05": "[\r\n  {\r\n    \"class\":\"firrtl.transforms.DontTouchAnnotation\",\r\n    \"target\":\"~Top|Top/a1:A>b\"\r\n  }\r\n]"}, {"number": 2516, "title": "[FIRRTL] (mem) mismatch", "created_at": "2022-01-25T05:27:32Z", "state": "open", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\n```python\r\n; seed: 6243\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock0: Clock\r\n    input raddr: UInt<10>\r\n    input waddr: UInt<10>\r\n    input wdata: UInt<20>\r\n    output tmp54: UInt<20>\r\n    mem tmp53:\r\n      data-type => UInt<20>\r\n      depth => 10\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp53.r0.clk <= clock0\r\n    tmp53.r0.en <= UInt(0)\r\n    tmp53.r0.addr <= waddr\r\n    tmp53.w0.clk <= clock0\r\n    tmp53.w0.en <= UInt(1)\r\n    tmp53.w0.addr <= raddr\r\n    tmp53.w0.data <= wdata\r\n    tmp53.w0.mask <= UInt(1)\r\n    tmp54 <= tmp53.r0.data\r\n```\r\n\r\nCompiled with firtool --lower-to-hw --infer-widths --imconstprop --lowering-options=disallowPackedArrays,emittedLineLength=8192 --mlir-timing --verilog -o=$VFILE2 produces this Verilog:\r\n\r\n```verilog\r\nmodule tmp53_ext(\t// a_top_mod.fir:9:5\r\n  input  [3:0]  R0_addr,\r\n  input         R0_en, R0_clk,\r\n  input  [3:0]  W0_addr,\r\n  input         W0_en, W0_clk,\r\n  input  [19:0] W0_data,\r\n  input         W0_mask,\r\n  output [19:0] R0_data);\r\n\r\n  reg [19:0] Memory[0:9];\r\n\r\n  wire _T = W0_en & W0_mask;\r\n  always @(posedge W0_clk) begin\r\n    if (_T)\r\n      Memory[W0_addr] <= W0_data;\r\n  end // always @(posedge)\r\n  assign R0_data = R0_en ? Memory[R0_addr] : 20'bx;\t// a_top_mod.fir:9:5\r\nendmodule\r\n\r\nmodule top_mod(\t// a_top_mod.fir:3:10\r\n  input         clock0,\r\n  input  [9:0]  raddr, waddr,\r\n  input  [19:0] wdata,\r\n  output [19:0] tmp54);\r\n\r\n  tmp53_ext tmp53 (\t// a_top_mod.fir:9:5\r\n    .R0_addr (waddr[3:0]),\t// a_top_mod.fir:19:19\r\n    .R0_en   (1'h0),\t// a_top_mod.fir:18:20\r\n    .R0_clk  (clock0),\r\n    .W0_addr (raddr[3:0]),\t// a_top_mod.fir:22:19\r\n    .W0_en   (1'h1),\t// a_top_mod.fir:21:20\r\n    .W0_clk  (clock0),\r\n    .W0_data (wdata),\r\n    .W0_mask (1'h1),\t// a_top_mod.fir:21:20\r\n    .R0_data (tmp54)\r\n  );\r\nendmodule\r\n```\r\n\r\nCompiled with firrtl-1.5-SNAPSHOT produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  input         clock0,\r\n  input  [9:0]  raddr,\r\n  input  [9:0]  waddr,\r\n  input  [19:0] wdata,\r\n  output [19:0] tmp54\r\n);\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n  reg [31:0] _RAND_1;\r\n`endif // RANDOMIZE_GARBAGE_ASSIGN\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  reg [31:0] _RAND_0;\r\n`endif // RANDOMIZE_MEM_INIT\r\n  reg [19:0] tmp53 [0:9];\r\n  wire  tmp53_r0_en;\r\n  wire [3:0] tmp53_r0_addr;\r\n  wire [19:0] tmp53_r0_data;\r\n  wire [19:0] tmp53_w0_data;\r\n  wire [3:0] tmp53_w0_addr;\r\n  wire  tmp53_w0_mask;\r\n  wire  tmp53_w0_en;\r\n  assign tmp53_r0_en = 1'h0;\r\n  assign tmp53_r0_addr = waddr[3:0];\r\n  `ifndef RANDOMIZE_GARBAGE_ASSIGN\r\n  assign tmp53_r0_data = tmp53[tmp53_r0_addr];\r\n  `else\r\n  assign tmp53_r0_data = tmp53_r0_addr >= 4'ha ? _RAND_1[19:0] : tmp53[tmp53_r0_addr];\r\n  `endif // RANDOMIZE_GARBAGE_ASSIGN\r\n  assign tmp53_w0_data = wdata;\r\n  assign tmp53_w0_addr = raddr[3:0];\r\n  assign tmp53_w0_mask = 1'h1;\r\n  assign tmp53_w0_en = 1'h1;\r\n  assign tmp54 = tmp53_r0_data;\r\n  always @(posedge clock0) begin\r\n    if (tmp53_w0_en & tmp53_w0_mask) begin\r\n      tmp53[tmp53_w0_addr] <= tmp53_w0_data;\r\n    end\r\n  end\r\n// Register and memory initialization\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_INVALID_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_REG_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifndef RANDOM\r\n`define RANDOM $random\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  integer initvar;\r\n`endif\r\n`ifndef SYNTHESIS\r\n`ifdef FIRRTL_BEFORE_INITIAL\r\n`FIRRTL_BEFORE_INITIAL\r\n`endif\r\ninitial begin\r\n  `ifdef RANDOMIZE\r\n    `ifdef INIT_RANDOM\r\n      `INIT_RANDOM\r\n    `endif\r\n    `ifndef VERILATOR\r\n      `ifdef RANDOMIZE_DELAY\r\n        #`RANDOMIZE_DELAY begin end\r\n      `else\r\n        #0.002 begin end\r\n      `endif\r\n    `endif\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n  _RAND_1 = {1{`RANDOM}};\r\n`endif // RANDOMIZE_GARBAGE_ASSIGN\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  _RAND_0 = {1{`RANDOM}};\r\n  for (initvar = 0; initvar < 10; initvar = initvar+1)\r\n    tmp53[initvar] = _RAND_0[19:0];\r\n`endif // RANDOMIZE_MEM_INIT\r\n  `endif // RANDOMIZE\r\nend // initial\r\n`ifdef FIRRTL_AFTER_INITIAL\r\n`FIRRTL_AFTER_INITIAL\r\n`endif\r\n`endif // SYNTHESIS\r\nendmodule\r\n```\r\n`Yosys 0.13+15 (git sha1 bc027b2ca, clang 13.0.0 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nERROR: Found 20 unproven $equiv cells in 'equiv_status -assert'.\r\n```\r\n", "code_snippet_01": "; seed: 6243\r\ncircuit top_mod :\r\n  module top_mod :\r\n    input clock0: Clock\r\n    input raddr: UInt<10>\r\n    input waddr: UInt<10>\r\n    input wdata: UInt<20>\r\n    output tmp54: UInt<20>\r\n    mem tmp53:\r\n      data-type => UInt<20>\r\n      depth => 10\r\n      read-latency => 0\r\n      write-latency => 1\r\n      read-under-write => undefined\r\n      reader => r0\r\n      writer => w0\r\n    tmp53.r0.clk <= clock0\r\n    tmp53.r0.en <= UInt(0)\r\n    tmp53.r0.addr <= waddr\r\n    tmp53.w0.clk <= clock0\r\n    tmp53.w0.en <= UInt(1)\r\n    tmp53.w0.addr <= raddr\r\n    tmp53.w0.data <= wdata\r\n    tmp53.w0.mask <= UInt(1)\r\n    tmp54 <= tmp53.r0.data", "code_snippet_02": "module tmp53_ext(\t// a_top_mod.fir:9:5\r\n  input  [3:0]  R0_addr,\r\n  input         R0_en, R0_clk,\r\n  input  [3:0]  W0_addr,\r\n  input         W0_en, W0_clk,\r\n  input  [19:0] W0_data,\r\n  input         W0_mask,\r\n  output [19:0] R0_data);\r\n\r\n  reg [19:0] Memory[0:9];\r\n\r\n  wire _T = W0_en & W0_mask;\r\n  always @(posedge W0_clk) begin\r\n    if (_T)\r\n      Memory[W0_addr] <= W0_data;\r\n  end // always @(posedge)\r\n  assign R0_data = R0_en ? Memory[R0_addr] : 20'bx;\t// a_top_mod.fir:9:5\r\nendmodule\r\n\r\nmodule top_mod(\t// a_top_mod.fir:3:10\r\n  input         clock0,\r\n  input  [9:0]  raddr, waddr,\r\n  input  [19:0] wdata,\r\n  output [19:0] tmp54);\r\n\r\n  tmp53_ext tmp53 (\t// a_top_mod.fir:9:5\r\n    .R0_addr (waddr[3:0]),\t// a_top_mod.fir:19:19\r\n    .R0_en   (1'h0),\t// a_top_mod.fir:18:20\r\n    .R0_clk  (clock0),\r\n    .W0_addr (raddr[3:0]),\t// a_top_mod.fir:22:19\r\n    .W0_en   (1'h1),\t// a_top_mod.fir:21:20\r\n    .W0_clk  (clock0),\r\n    .W0_data (wdata),\r\n    .W0_mask (1'h1),\t// a_top_mod.fir:21:20\r\n    .R0_data (tmp54)\r\n  );\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  input         clock0,\r\n  input  [9:0]  raddr,\r\n  input  [9:0]  waddr,\r\n  input  [19:0] wdata,\r\n  output [19:0] tmp54\r\n);\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n  reg [31:0] _RAND_1;\r\n`endif // RANDOMIZE_GARBAGE_ASSIGN\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  reg [31:0] _RAND_0;\r\n`endif // RANDOMIZE_MEM_INIT\r\n  reg [19:0] tmp53 [0:9];\r\n  wire  tmp53_r0_en;\r\n  wire [3:0] tmp53_r0_addr;\r\n  wire [19:0] tmp53_r0_data;\r\n  wire [19:0] tmp53_w0_data;\r\n  wire [3:0] tmp53_w0_addr;\r\n  wire  tmp53_w0_mask;\r\n  wire  tmp53_w0_en;\r\n  assign tmp53_r0_en = 1'h0;\r\n  assign tmp53_r0_addr = waddr[3:0];\r\n  `ifndef RANDOMIZE_GARBAGE_ASSIGN\r\n  assign tmp53_r0_data = tmp53[tmp53_r0_addr];\r\n  `else\r\n  assign tmp53_r0_data = tmp53_r0_addr >= 4'ha ? _RAND_1[19:0] : tmp53[tmp53_r0_addr];\r\n  `endif // RANDOMIZE_GARBAGE_ASSIGN\r\n  assign tmp53_w0_data = wdata;\r\n  assign tmp53_w0_addr = raddr[3:0];\r\n  assign tmp53_w0_mask = 1'h1;\r\n  assign tmp53_w0_en = 1'h1;\r\n  assign tmp54 = tmp53_r0_data;\r\n  always @(posedge clock0) begin\r\n    if (tmp53_w0_en & tmp53_w0_mask) begin\r\n      tmp53[tmp53_w0_addr] <= tmp53_w0_data;\r\n    end\r\n  end\r\n// Register and memory initialization\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_INVALID_ASSIGN\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_REG_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n`define RANDOMIZE\r\n`endif\r\n`ifndef RANDOM\r\n`define RANDOM $random\r\n`endif\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  integer initvar;\r\n`endif\r\n`ifndef SYNTHESIS\r\n`ifdef FIRRTL_BEFORE_INITIAL\r\n`FIRRTL_BEFORE_INITIAL\r\n`endif\r\ninitial begin\r\n  `ifdef RANDOMIZE\r\n    `ifdef INIT_RANDOM\r\n      `INIT_RANDOM\r\n    `endif\r\n    `ifndef VERILATOR\r\n      `ifdef RANDOMIZE_DELAY\r\n        #`RANDOMIZE_DELAY begin end\r\n      `else\r\n        #0.002 begin end\r\n      `endif\r\n    `endif\r\n`ifdef RANDOMIZE_GARBAGE_ASSIGN\r\n  _RAND_1 = {1{`RANDOM}};\r\n`endif // RANDOMIZE_GARBAGE_ASSIGN\r\n`ifdef RANDOMIZE_MEM_INIT\r\n  _RAND_0 = {1{`RANDOM}};\r\n  for (initvar = 0; initvar < 10; initvar = initvar+1)\r\n    tmp53[initvar] = _RAND_0[19:0];\r\n`endif // RANDOMIZE_MEM_INIT\r\n  `endif // RANDOMIZE\r\nend // initial\r\n`ifdef FIRRTL_AFTER_INITIAL\r\n`FIRRTL_AFTER_INITIAL\r\n`endif\r\n`endif // SYNTHESIS\r\nendmodule", "code_snippet_04": "ERROR: Found 20 unproven $equiv cells in 'equiv_status -assert'."}, {"number": 2504, "title": "[ExportVerilog] Incorrect verilog output for bitcast + zero width aggregate types", "created_at": "2022-01-23T22:10:34Z", "state": "open", "labels": "bug, ExportVerilog", "body": "We are emitting zero bit width array/struct as one bit element. This is problem when we use bitcast for them.\r\n\r\n```mlir\r\nhw.module @top(%source: i1) -> (b: !hw.struct<zero: !hw.array<1xi0>, c: i1>) {\r\n    %cast = hw.bitcast %source: (i1) -> !hw.struct<zero: !hw.array<1xi0>, c: i1>\r\n    hw.output %cast : !hw.struct<zero: !hw.array<1xi0>, c: i1>\r\n }\r\n```\r\n\r\n```sv\r\nmodule top(\t// out.mlir:2:3\r\n  input                                                            source,\r\n  output struct packed {logic [0:0]/*Zero Width*/ zero; logic c; } b);\r\n \r\n  assign b = source;\t// out.mlir:3:12, :4:5\r\nendmodule\r\n```\r\n", "code_snippet_01": "hw.module @top(%source: i1) -> (b: !hw.struct<zero: !hw.array<1xi0>, c: i1>) {\r\n    %cast = hw.bitcast %source: (i1) -> !hw.struct<zero: !hw.array<1xi0>, c: i1>\r\n    hw.output %cast : !hw.struct<zero: !hw.array<1xi0>, c: i1>\r\n }", "code_snippet_02": "module top(\t// out.mlir:2:3\r\n  input                                                            source,\r\n  output struct packed {logic [0:0]/*Zero Width*/ zero; logic c; } b);\r\n \r\n  assign b = source;\t// out.mlir:3:12, :4:5\r\nendmodule"}, {"number": 2298, "title": "[LowerToHW] Define Behavior for Multiple Circuits", "created_at": "2021-12-06T19:11:08Z", "state": "open", "labels": "bug, FIRRTL, HW", "body": "Currently, if you compile multiple FIRRTL circuits, only one of them gets lowered. We need to define a behavior here for how this should work and what the resulting HW representation is. Consider the following:\r\n\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n  firrtl.circuit \"Bar\"   {\r\n    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThis produces, after `LowerToHW`:\r\n```mlir\r\nmodule  {\r\n  firrtl.circuit \"Bar\"   {\r\n    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n  hw.module @Foo(%a: i1) -> (b: i1) {\r\n    hw.output %a : i1\r\n  }\r\n}\r\n```\r\n\r\nIf allowed to continue after this, eventually `ExportVerilog` will print an error because it doesn't know how to handle a `firrtl.circuit`.\r\n\r\nI can think of two behaviors here:\r\n\r\n1. This should produce a flat list of modules.\r\n2. (Likely what we need) This should lower each to two lists of modules in a `hw.namespace`-guarded region.", "code_snippet_01": "module  {\r\n  firrtl.circuit \"Foo\"   {\r\n    firrtl.module @Foo(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n  firrtl.circuit \"Bar\"   {\r\n    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n}", "code_snippet_02": "module  {\r\n  firrtl.circuit \"Bar\"   {\r\n    firrtl.module @Bar(in %a: !firrtl.uint<1>, out %b: !firrtl.uint<1>) {\r\n      firrtl.connect %b, %a : !firrtl.uint<1>, !firrtl.uint<1>\r\n    }\r\n  }\r\n  hw.module @Foo(%a: i1) -> (b: i1) {\r\n    hw.output %a : i1\r\n  }\r\n}"}, {"number": 2029, "title": "[FIRRTL] RemoveCHIRRTL Should Lower Unused Memories (or at least repsect DontTouch)", "created_at": "2021-10-22T17:54:24Z", "state": "open", "labels": "bug, FIRRTL", "body": "If you have an unused behavior memory in FIRRTL, the SFC will lower this to a memory that has no ports. This is a candidate for later DCE, but won't be DCE'd if there is a don't touch annotation. \r\n\r\nIn CIRCT, we are deleting behavioral memories which have no users, i.e., DCE'ing unused memories during RemoveCHIRRTL,  and not respecting a dont touch annotation that may exist.\r\n\r\nI expect that this has no effect on \"sane\" designs and is consequently a low priority bug. For more info, I hit this when writing some test cases for Grand Central where I didn't want to hook up my memories. \ud83d\ude05 "}, {"number": 2026, "title": "[FIRRTL] BlackBoxMemory Pass Needs to Handle All Annotations", "created_at": "2021-10-22T04:43:51Z", "state": "open", "labels": "bug, FIRRTL", "body": "The `BlackBoxMemory` pass was updated to copy annotations from memories onto the blackboxed instance in f239be4cd23bb21a1a19854f5bdc325ddf953ec1. However, port annotations are currently being dropped.\r\n\r\nUpdate this pass to copy over port annotations with the following strategy:\r\n- An annotation on a memory port should be applied to all flattened ports associated with the original port\r\n- An annotation on a specific field of a memory port should be copied to its respective flattened new port\r\n\r\nAdditionally, it may make more sense to copy annotations onto the external module as opposed to onto the instance (which is how f239be4cd23bb21a1a19854f5bdc325ddf953ec1) does it. One or the other should be entirely equivalent (from the perspective of preserving the information, though copying onto the module may be better)."}, {"number": 1988, "title": "[Simulator] UB when using llhd.shr on signal", "created_at": "2021-10-13T10:26:15Z", "state": "open", "labels": "bug, LLHD, Simulator", "body": "The following code leads to UB in the output trace, although, the semantics are clearly defined. This is because of a bug in the `ShrOpConversion` pattern in the `LLHDToLLVM` pass, where there is a slice extract performed only on the `%basesig` value instead of a concatenation of hidden and base.\r\n\r\n```mlir\r\nllhd.entity @root () -> () {\r\n  %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>\r\n\r\n  %hidden = hw.constant 0xff : i8\r\n  %base = hw.constant 0 : i8\r\n  %amnt = hw.constant 4 : i3\r\n\r\n  %resultsig = llhd.sig \"result\" %base : i8\r\n  %basesig = llhd.sig \"base\" %base : i8\r\n  %hiddensig = llhd.sig \"hidden\" %hidden : i8\r\n  %shr = llhd.shr %basesig, %hiddensig, %amnt : (!llhd.sig<i8>, !llhd.sig<i8>, i3) -> !llhd.sig<i8>\r\n  %prbshr = llhd.prb %shr : !llhd.sig<i8>\r\n  llhd.drv %resultsig, %prbshr after %time : !llhd.sig<i8>\r\n}\r\n```\r\n\r\nExpected output:\r\n```\r\n0ps 0d 0e  root/base  0x00\r\n0ps 0d 0e  root/hidden  0xff\r\n0ps 0d 0e  root/result  0x00\r\n1000ps 0d 0e  root/result  0xf0         // UB here (also seen 0x70, 0x10, etc.)\r\nFinished at 2000ps 0d 0e (3 cycles)\r\n```", "code_snippet_01": "llhd.entity @root () -> () {\r\n  %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>\r\n\r\n  %hidden = hw.constant 0xff : i8\r\n  %base = hw.constant 0 : i8\r\n  %amnt = hw.constant 4 : i3\r\n\r\n  %resultsig = llhd.sig \"result\" %base : i8\r\n  %basesig = llhd.sig \"base\" %base : i8\r\n  %hiddensig = llhd.sig \"hidden\" %hidden : i8\r\n  %shr = llhd.shr %basesig, %hiddensig, %amnt : (!llhd.sig<i8>, !llhd.sig<i8>, i3) -> !llhd.sig<i8>\r\n  %prbshr = llhd.prb %shr : !llhd.sig<i8>\r\n  llhd.drv %resultsig, %prbshr after %time : !llhd.sig<i8>\r\n}", "code_snippet_02": "0ps 0d 0e  root/base  0x00\r\n0ps 0d 0e  root/hidden  0xff\r\n0ps 0d 0e  root/result  0x00\r\n1000ps 0d 0e  root/result  0xf0         // UB here (also seen 0x70, 0x10, etc.)\r\nFinished at 2000ps 0d 0e (3 cycles)"}, {"number": 1795, "title": "[Simulator] Crash when initializing `llhd.sig` with non-constant value", "created_at": "2021-09-15T12:19:24Z", "state": "open", "labels": "bug, LLHD", "body": "When trying to simulate a module such as the following, the simulator crashes without a meaningful error message or assertion (just telling you that a value not defined in this region is used or the reconcile conversion cast pass complaining that some op was already replaced). This is because in `LLHDToLLVM.cpp` the operations creating `%get` are recursively cloned into a init function created indirectly by the simulation engine, but it only considers `hw.array_create`, `hw.struct_create`, and operations without operands (stop condition of recursion).\r\n\r\nIt would be ideal to support any operation not just these three, or at least throw a meaningful error message for the user in `recursiveCloneInit`.\r\nAlso, wouldn't it be better to clone these operations in a separate function and let the LLVM inliner decide whether to inline it or not (because the operation chain might be a lot bigger than just a constant op, leading to a lot of duplicated code)?\r\n\r\n```mlir\r\nllhd.entity @root () -> () {\r\n    %0 = hw.constant 0 : i8\r\n    %index = hw.constant 1 : i1\r\n\r\n    %array = hw.array_create %0, %0 : i8\r\n    %get = hw.array_get %array[%index] : !hw.array<2xi8>\r\n\r\n    %getsig = llhd.sig \"get\" %get : i8  // Using %0 instead of %get works just fine; %get leads to a crash\r\n\r\n    %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>\r\n    llhd.drv %getsig, %get after %time : !llhd.sig<i8>\r\n}\r\n```", "code_snippet_01": "llhd.entity @root () -> () {\r\n    %0 = hw.constant 0 : i8\r\n    %index = hw.constant 1 : i1\r\n\r\n    %array = hw.array_create %0, %0 : i8\r\n    %get = hw.array_get %array[%index] : !hw.array<2xi8>\r\n\r\n    %getsig = llhd.sig \"get\" %get : i8  // Using %0 instead of %get works just fine; %get leads to a crash\r\n\r\n    %time = llhd.constant_time #llhd.time<1ns, 0d, 0e>\r\n    llhd.drv %getsig, %get after %time : !llhd.sig<i8>\r\n}"}, {"number": 1771, "title": "[FIRRTL] Lexing Issues With Deeply Nested Expressions?", "created_at": "2021-09-10T23:09:58Z", "state": "open", "labels": "bug, FIRRTL", "body": "Circuits with long lines and/or deeply nested expressions seem to crash the lexer.\r\n\r\nHere's a failing circuit (this is a 1024-deep concatenation):\r\n\r\n```scala\r\ncircuit Bar :\r\n  module Bar :\r\n    input a: UInt<1>\r\n    output b: UInt<1024>\r\n\r\n    b <= cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\r\n```\r\n\r\nThis is erroring out with an `EXC_BAD_ACCESS` occurring in the lexer:\r\n\r\n```\r\n# lldb firtool -- Bar.fir\r\n(lldb) target create \"firtool\"\r\nCurrent executable set to 'firtool' (x86_64).\r\n(lldb) settings set -- target.run-args  \"Bar.fir\"\r\n(lldb) run\r\nProcess 10399 launched: '/Users/schuylere/usr/bin/firtool' (x86_64)\r\nProcess 10399 stopped\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=2, address=0x7ffeef3fffff)\r\n    frame #0: 0x00000001005857e4 firtool`llvm::isAlpha(C=<unavailable>) at StringExtras.h:95\r\n   92  \tinline bool isHexDigit(char C) { return hexDigitValue(C) != ~0U; }\r\n   93  \t\r\n   94  \t/// Checks if character \\p C is a valid letter as classified by \"C\" locale.\r\n-> 95  \tinline bool isAlpha(char C) {\r\n   96  \t  return ('a' <= C && C <= 'z') || ('A' <= C && C <= 'Z');\r\n   97  \t}\r\n   98  \t\r\nTarget 0: (firtool) stopped.\r\n(lldb) frame select 1\r\nframe #1: 0x000000010024a592 firtool`circt::firrtl::FIRLexer::lexIdentifierOrKeyword(this=0x00007ffeefbfdbe8, tokStart=\"cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\"...) at FIRLexer.cpp:386:10\r\n   383 \t///\r\n   384 \tFIRToken FIRLexer::lexIdentifierOrKeyword(const char *tokStart) {\r\n   385 \t  // Match the rest of the identifier regex: [0-9a-zA-Z_$-]*\r\n-> 386 \t  while (llvm::isAlpha(*curPtr) || llvm::isDigit(*curPtr) || *curPtr == '_' ||\r\n   387 \t         *curPtr == '$' || *curPtr == '-')\r\n   388 \t    ++curPtr;\r\n   389\r\n```", "code_snippet_01": "circuit Bar :\r\n  module Bar :\r\n    input a: UInt<1>\r\n    output b: UInt<1024>\r\n\r\n    b <= cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))", "code_snippet_02": "# lldb firtool -- Bar.fir\r\n(lldb) target create \"firtool\"\r\nCurrent executable set to 'firtool' (x86_64).\r\n(lldb) settings set -- target.run-args  \"Bar.fir\"\r\n(lldb) run\r\nProcess 10399 launched: '/Users/schuylere/usr/bin/firtool' (x86_64)\r\nProcess 10399 stopped\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=2, address=0x7ffeef3fffff)\r\n    frame #0: 0x00000001005857e4 firtool`llvm::isAlpha(C=<unavailable>) at StringExtras.h:95\r\n   92  \tinline bool isHexDigit(char C) { return hexDigitValue(C) != ~0U; }\r\n   93  \t\r\n   94  \t/// Checks if character \\p C is a valid letter as classified by \"C\" locale.\r\n-> 95  \tinline bool isAlpha(char C) {\r\n   96  \t  return ('a' <= C && C <= 'z') || ('A' <= C && C <= 'Z');\r\n   97  \t}\r\n   98  \t\r\nTarget 0: (firtool) stopped.\r\n(lldb) frame select 1\r\nframe #1: 0x000000010024a592 firtool`circt::firrtl::FIRLexer::lexIdentifierOrKeyword(this=0x00007ffeefbfdbe8, tokStart=\"cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, cat(a, a)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\"...) at FIRLexer.cpp:386:10\r\n   383 \t///\r\n   384 \tFIRToken FIRLexer::lexIdentifierOrKeyword(const char *tokStart) {\r\n   385 \t  // Match the rest of the identifier regex: [0-9a-zA-Z_$-]*\r\n-> 386 \t  while (llvm::isAlpha(*curPtr) || llvm::isDigit(*curPtr) || *curPtr == '_' ||\r\n   387 \t         *curPtr == '$' || *curPtr == '-')\r\n   388 \t    ++curPtr;\r\n   389"}, {"number": 1734, "title": "[FIRRTL] Add non-local annotation support to GCT Data Taps", "created_at": "2021-09-06T15:13:33Z", "state": "open", "labels": "bug, FIRRTL", "body": "The Grand Central Data/Mem Taps pass currently only works with annotations that refer to entire modules. With the non-local annotations having been merged recently, it should now be expanded to also properly support those. We've seen a few cases internally where this is necessary."}, {"number": 1289, "title": "[FIRRTL] (dshl, tail, mul) width inference mismatch", "created_at": "2021-06-16T16:43:39Z", "state": "open", "labels": "bug, FIRRTL", "body": "The following FIRRTL program\r\n\r\nProduces different width for the output port `_tmp40`\r\n\r\n```python\r\n; seed: 1144\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output _tmp40: UInt\r\n    wire tmp19: UInt\r\n    tmp19 <= mul(UInt(\"o20575\"), UInt<1>(0))\r\n    _tmp40 <= dshl(UInt(\"b10011010000001011101\"), tail(tmp19, 15))\r\n```\r\n\r\nCompiled with `firtool` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [19:0] _tmp40);\r\n\r\n  assign _tmp40 = 20'h9A05D;\t// a_top_mod.fir:3:3, :7:20\r\nendmodule\r\n```\r\n\r\nCompiled with `firrtl-1.5-SNAPSHOT` produces this Verilog:\r\n\r\n```verilog\r\nmodule top_mod(\r\n  output [18:0] _tmp40\r\n);\r\n  assign _tmp40 = 19'h1a05d;\r\nendmodule\r\n```\r\n\r\n`Yosys 0.9+3911 (git sha1 4b31223e, clang 11.0.1 -fPIC -Os)` reports formal mismatch:\r\n\r\n```\r\nERROR: Can't match gold port `_tmp40_gold' to a gate port.\r\n```", "code_snippet_01": "; seed: 1144\r\ncircuit top_mod :\r\n  module top_mod :\r\n    output _tmp40: UInt\r\n    wire tmp19: UInt\r\n    tmp19 <= mul(UInt(\"o20575\"), UInt<1>(0))\r\n    _tmp40 <= dshl(UInt(\"b10011010000001011101\"), tail(tmp19, 15))", "code_snippet_02": "module top_mod(\r\n  output [19:0] _tmp40);\r\n\r\n  assign _tmp40 = 20'h9A05D;\t// a_top_mod.fir:3:3, :7:20\r\nendmodule", "code_snippet_03": "module top_mod(\r\n  output [18:0] _tmp40\r\n);\r\n  assign _tmp40 = 19'h1a05d;\r\nendmodule", "code_snippet_04": "ERROR: Can't match gold port `_tmp40_gold' to a gate port."}, {"number": 1065, "title": "[CI] Most tests fail on Ubuntu 18.04", "created_at": "2021-05-17T17:43:44Z", "state": "open", "labels": "bug", "body": "I have a Docker-based repro: https://github.com/llvm/circt/blob/crashes-1804/utils/run-docker-1804.sh. Just run `./utils/run-docker-1804.sh`. This is running the LLVM build in the release config w/ asserts enabled and CIRCT in debug. I've attached a log of the crashes: [test_fails.log](https://github.com/llvm/circt/files/6495753/test_fails.log).\r\n\r\n\r\n```\r\nFailed Tests (210):\r\n  CIRCT :: CAPI/ir.c\r\n  CIRCT :: Conversion/FIRRTLToHW/errors.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-errors.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-module.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/zero-width.mlir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/connect.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_inouts.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_ins.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_none.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_outs.fir\r\n  CIRCT :: Conversion/HWToLLHD/errors.mlir\r\n  CIRCT :: Conversion/HWToLLHD/structure.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/simple_addi.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_branch.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_buffer.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_cmerge.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_conditional_branch.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_constant.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_fork.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_join.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_lazy_fork.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_load.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_memory.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_merge.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_mux.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_sink.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_store.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_arithmetic.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_bitwise.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_entity.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_extract.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_insert.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_memory.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_process_persistence.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_signals.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_simple.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_value_creation.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_wait.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/errors.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-for.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-load-store.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test1.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test10.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test11.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test12.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test13.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test14.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test15.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test16.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test17.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test18.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test19.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test2.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test20.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test21.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test22.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test23.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test24.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test25.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test26.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test27.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test28.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test29.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test3.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test30.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test31.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test32.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test33.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test34.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test35.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test4.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test5.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test6.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test7.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test8.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test9.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_canonicalize.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer_errors.mlir\r\n  CIRCT :: Conversion/StandardToStaticLogic/test_pipeline.mlir\r\n  CIRCT :: Dialect/ESI/connectivity.mlir\r\n  CIRCT :: Dialect/ESI/errors.mlir\r\n  CIRCT :: Dialect/ESI/lowering.mlir\r\n  CIRCT :: Dialect/ESI/modwrap.mlir\r\n  CIRCT :: Dialect/ESI/wrapif-lowering.mlir\r\n  CIRCT :: Dialect/FIRRTL/annotations.fir\r\n  CIRCT :: Dialect/FIRRTL/blackbox-memory.mlir\r\n  CIRCT :: Dialect/FIRRTL/canonicalization.mlir\r\n  CIRCT :: Dialect/FIRRTL/check-widths-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/connect-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/connect.mlir\r\n  CIRCT :: Dialect/FIRRTL/const-prop-single-module.mlir\r\n  CIRCT :: Dialect/FIRRTL/cse.mlir\r\n  CIRCT :: Dialect/FIRRTL/errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/expand-whens-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/expand-whens.mlir\r\n  CIRCT :: Dialect/FIRRTL/imconstprop.mlir\r\n  CIRCT :: Dialect/FIRRTL/infer-widths-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/infer-widths.mlir\r\n  CIRCT :: Dialect/FIRRTL/inliner.mlir\r\n  CIRCT :: Dialect/FIRRTL/lower-types-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/lower-types.mlir\r\n  CIRCT :: Dialect/FIRRTL/parse-basic.fir\r\n  CIRCT :: Dialect/FIRRTL/parse-errors.fir\r\n  CIRCT :: Dialect/FIRRTL/parse-locations.fir\r\n  CIRCT :: Dialect/FIRRTL/test.mlir\r\n  CIRCT :: Dialect/HW/basic.mlir\r\n  CIRCT :: Dialect/HW/bitwise.mlir\r\n  CIRCT :: Dialect/HW/canonicalization.mlir\r\n  CIRCT :: Dialect/HW/errors.mlir\r\n  CIRCT :: Dialect/HW/greybox.mlir\r\n  CIRCT :: Dialect/HW/modules.mlir\r\n  CIRCT :: Dialect/HW/svEmitErrors.mlir\r\n  CIRCT :: Dialect/HW/typedecls.mlir\r\n  CIRCT :: Dialect/HW/types.mlir\r\n  CIRCT :: Dialect/Handshake/errors.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/constant.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/extract.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/memory.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/probeCSE.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/signalOps.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_entity.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_relations.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_sig.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_sig_errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/IR/array.mlir\r\n  CIRCT :: Dialect/LLHD/IR/bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/IR/connect-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/connect.mlir\r\n  CIRCT :: Dialect/LLHD/IR/const.mlir\r\n  CIRCT :: Dialect/LLHD/IR/entity.mlir\r\n  CIRCT :: Dialect/LLHD/IR/extract-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/extract.mlir\r\n  CIRCT :: Dialect/LLHD/IR/insert-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/insert.mlir\r\n  CIRCT :: Dialect/LLHD/IR/inst-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/inst.mlir\r\n  CIRCT :: Dialect/LLHD/IR/memory.mlir\r\n  CIRCT :: Dialect/LLHD/IR/proc.mlir\r\n  CIRCT :: Dialect/LLHD/IR/reg.mlir\r\n  CIRCT :: Dialect/LLHD/IR/signal-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/signal.mlir\r\n  CIRCT :: Dialect/LLHD/IR/time.mlir\r\n  CIRCT :: Dialect/LLHD/IR/tuple.mlir\r\n  CIRCT :: Dialect/LLHD/IR/wait.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_arbitrary_signal_size.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_array_boundary_check.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_bit_precision_drives.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_process.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_reg.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_shifts.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_simple.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_wait.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/earlyCodeMotion.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/memoryToBlockArgument.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/processLowering.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/processLoweringErrors.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/totalFunctionInlining.mlir\r\n  CIRCT :: Dialect/MSFT/location.mlir\r\n  CIRCT :: Dialect/MSFT/opt-errors.mlir\r\n  CIRCT :: Dialect/MSFT/translate-errors.mlir\r\n  CIRCT :: Dialect/SV/basic.mlir\r\n  CIRCT :: Dialect/SV/canonicalization.mlir\r\n  CIRCT :: Dialect/SV/errors.mlir\r\n  CIRCT :: Dialect/SV/hw-cleanup.mlir\r\n  CIRCT :: Dialect/SV/hw-generator-callout.mlir\r\n  CIRCT :: Dialect/SV/hw-legalize-names-errors.mlir\r\n  CIRCT :: Dialect/SV/hw-legalize-names.mlir\r\n  CIRCT :: Dialect/SV/hw-memsim.mlir\r\n  CIRCT :: Dialect/SV/interfaces.mlir\r\n  CIRCT :: Dialect/SV/prettify-verilog.mlir\r\n  CIRCT :: Dialect/Seq/basic.mlir\r\n  CIRCT :: ExportVerilog/hw-dialect.mlir\r\n  CIRCT :: ExportVerilog/hw-typedecls.mlir\r\n  CIRCT :: ExportVerilog/line-length.mlir\r\n  CIRCT :: ExportVerilog/load-dialect.mlir\r\n  CIRCT :: ExportVerilog/sv-alwaysff.mlir\r\n  CIRCT :: ExportVerilog/sv-dialect.mlir\r\n  CIRCT :: ExportVerilog/sv-interfaces.mlir\r\n  CIRCT :: ExportVerilog/verilog-basic.mlir\r\n  CIRCT :: ExportVerilog/verilog-errors.mlir\r\n  CIRCT :: circt-opt/trivial.mlir\r\n  CIRCT :: circt-translate/parse_int64.fir\r\n  CIRCT :: firtool/firtool.fir\r\n  CIRCT :: firtool/firtool.mlir\r\n  CIRCT :: firtool/optimizations.fir\r\n  CIRCT :: firtool/phase-ordering.fir\r\n  CIRCT :: firtool/split-verilog.mlir\r\n  CIRCT :: firtool/style.fir\r\n  CIRCT :: handshake-runner/call_bb.mlir\r\n  CIRCT :: handshake-runner/cdiv-old-std.mlir\r\n  CIRCT :: handshake-runner/cdiv-std.mlir\r\n  CIRCT :: handshake-runner/complex_bb.mlir\r\n  CIRCT :: handshake-runner/floydwarshall-std.mlir\r\n  CIRCT :: handshake-runner/histogram-std.mlir\r\n  CIRCT :: handshake-runner/loadstore.mlir\r\n  CIRCT :: handshake-runner/loop-check-1-std.mlir\r\n  CIRCT :: handshake-runner/loop-check-2-std.mlir\r\n  CIRCT :: handshake-runner/matmul-check-std.mlir\r\n  CIRCT :: handshake-runner/matmul-std.mlir\r\n  CIRCT :: handshake-runner/memory_simple_2_std.mlir\r\n  CIRCT :: handshake-runner/memory_simple_std.mlir\r\n  CIRCT :: handshake-runner/simple_loop.mlir\r\n\r\n\r\nTesting Time: 1.34s\r\n  Unsupported:   4\r\n  Passed     :   6\r\n  Failed     : 210\r\n```", "code_snippet_01": "Failed Tests (210):\r\n  CIRCT :: CAPI/ir.c\r\n  CIRCT :: Conversion/FIRRTLToHW/errors.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-errors.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw-module.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/lower-to-hw.mlir\r\n  CIRCT :: Conversion/FIRRTLToHW/zero-width.mlir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/connect.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_inouts.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_ins.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_none.fir\r\n  CIRCT :: Conversion/FIRRTLToLLHD/empty_outs.fir\r\n  CIRCT :: Conversion/HWToLLHD/errors.mlir\r\n  CIRCT :: Conversion/HWToLLHD/structure.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/simple_addi.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_branch.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_buffer.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_cmerge.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_conditional_branch.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_constant.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_fork.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_join.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_lazy_fork.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_load.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_memory.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_merge.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_mux.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_sink.mlir\r\n  CIRCT :: Conversion/HandshakeToFIRRTL/test_store.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_arithmetic.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_bitwise.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_entity.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_extract.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_insert.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_memory.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_process_persistence.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_signals.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_simple.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_value_creation.mlir\r\n  CIRCT :: Conversion/LLHDToLLVM/convert_wait.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/errors.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-for.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/Affine/test-affine-load-store.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test1.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test10.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test11.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test12.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test13.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test14.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test15.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test16.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test17.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test18.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test19.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test2.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test20.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test21.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test22.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test23.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test24.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test25.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test26.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test27.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test28.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test29.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test3.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test30.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test31.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test32.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test33.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test34.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test35.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test4.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test5.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test6.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test7.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test8.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test9.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_canonicalize.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer.mlir\r\n  CIRCT :: Conversion/StandardToHandshake/test_insert_buffer_errors.mlir\r\n  CIRCT :: Conversion/StandardToStaticLogic/test_pipeline.mlir\r\n  CIRCT :: Dialect/ESI/connectivity.mlir\r\n  CIRCT :: Dialect/ESI/errors.mlir\r\n  CIRCT :: Dialect/ESI/lowering.mlir\r\n  CIRCT :: Dialect/ESI/modwrap.mlir\r\n  CIRCT :: Dialect/ESI/wrapif-lowering.mlir\r\n  CIRCT :: Dialect/FIRRTL/annotations.fir\r\n  CIRCT :: Dialect/FIRRTL/blackbox-memory.mlir\r\n  CIRCT :: Dialect/FIRRTL/canonicalization.mlir\r\n  CIRCT :: Dialect/FIRRTL/check-widths-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/connect-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/connect.mlir\r\n  CIRCT :: Dialect/FIRRTL/const-prop-single-module.mlir\r\n  CIRCT :: Dialect/FIRRTL/cse.mlir\r\n  CIRCT :: Dialect/FIRRTL/errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/expand-whens-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/expand-whens.mlir\r\n  CIRCT :: Dialect/FIRRTL/imconstprop.mlir\r\n  CIRCT :: Dialect/FIRRTL/infer-widths-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/infer-widths.mlir\r\n  CIRCT :: Dialect/FIRRTL/inliner.mlir\r\n  CIRCT :: Dialect/FIRRTL/lower-types-errors.mlir\r\n  CIRCT :: Dialect/FIRRTL/lower-types.mlir\r\n  CIRCT :: Dialect/FIRRTL/parse-basic.fir\r\n  CIRCT :: Dialect/FIRRTL/parse-errors.fir\r\n  CIRCT :: Dialect/FIRRTL/parse-locations.fir\r\n  CIRCT :: Dialect/FIRRTL/test.mlir\r\n  CIRCT :: Dialect/HW/basic.mlir\r\n  CIRCT :: Dialect/HW/bitwise.mlir\r\n  CIRCT :: Dialect/HW/canonicalization.mlir\r\n  CIRCT :: Dialect/HW/errors.mlir\r\n  CIRCT :: Dialect/HW/greybox.mlir\r\n  CIRCT :: Dialect/HW/modules.mlir\r\n  CIRCT :: Dialect/HW/svEmitErrors.mlir\r\n  CIRCT :: Dialect/HW/typedecls.mlir\r\n  CIRCT :: Dialect/HW/types.mlir\r\n  CIRCT :: Dialect/Handshake/errors.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/constant.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/extract.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/memory.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/probeCSE.mlir\r\n  CIRCT :: Dialect/LLHD/Canonicalization/signalOps.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_entity.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_relations.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_sig.mlir\r\n  CIRCT :: Dialect/LLHD/Export/verilog_sig_errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/arithmetic.mlir\r\n  CIRCT :: Dialect/LLHD/IR/array.mlir\r\n  CIRCT :: Dialect/LLHD/IR/bitwise.mlir\r\n  CIRCT :: Dialect/LLHD/IR/connect-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/connect.mlir\r\n  CIRCT :: Dialect/LLHD/IR/const.mlir\r\n  CIRCT :: Dialect/LLHD/IR/entity.mlir\r\n  CIRCT :: Dialect/LLHD/IR/extract-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/extract.mlir\r\n  CIRCT :: Dialect/LLHD/IR/insert-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/insert.mlir\r\n  CIRCT :: Dialect/LLHD/IR/inst-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/inst.mlir\r\n  CIRCT :: Dialect/LLHD/IR/memory.mlir\r\n  CIRCT :: Dialect/LLHD/IR/proc.mlir\r\n  CIRCT :: Dialect/LLHD/IR/reg.mlir\r\n  CIRCT :: Dialect/LLHD/IR/signal-errors.mlir\r\n  CIRCT :: Dialect/LLHD/IR/signal.mlir\r\n  CIRCT :: Dialect/LLHD/IR/time.mlir\r\n  CIRCT :: Dialect/LLHD/IR/tuple.mlir\r\n  CIRCT :: Dialect/LLHD/IR/wait.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_arbitrary_signal_size.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_array_boundary_check.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_bit_precision_drives.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_formats.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_process.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_reg.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_shifts.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_simple.mlir\r\n  CIRCT :: Dialect/LLHD/Simulator/sim_wait.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/earlyCodeMotion.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/memoryToBlockArgument.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/processLowering.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/processLoweringErrors.mlir\r\n  CIRCT :: Dialect/LLHD/Transforms/totalFunctionInlining.mlir\r\n  CIRCT :: Dialect/MSFT/location.mlir\r\n  CIRCT :: Dialect/MSFT/opt-errors.mlir\r\n  CIRCT :: Dialect/MSFT/translate-errors.mlir\r\n  CIRCT :: Dialect/SV/basic.mlir\r\n  CIRCT :: Dialect/SV/canonicalization.mlir\r\n  CIRCT :: Dialect/SV/errors.mlir\r\n  CIRCT :: Dialect/SV/hw-cleanup.mlir\r\n  CIRCT :: Dialect/SV/hw-generator-callout.mlir\r\n  CIRCT :: Dialect/SV/hw-legalize-names-errors.mlir\r\n  CIRCT :: Dialect/SV/hw-legalize-names.mlir\r\n  CIRCT :: Dialect/SV/hw-memsim.mlir\r\n  CIRCT :: Dialect/SV/interfaces.mlir\r\n  CIRCT :: Dialect/SV/prettify-verilog.mlir\r\n  CIRCT :: Dialect/Seq/basic.mlir\r\n  CIRCT :: ExportVerilog/hw-dialect.mlir\r\n  CIRCT :: ExportVerilog/hw-typedecls.mlir\r\n  CIRCT :: ExportVerilog/line-length.mlir\r\n  CIRCT :: ExportVerilog/load-dialect.mlir\r\n  CIRCT :: ExportVerilog/sv-alwaysff.mlir\r\n  CIRCT :: ExportVerilog/sv-dialect.mlir\r\n  CIRCT :: ExportVerilog/sv-interfaces.mlir\r\n  CIRCT :: ExportVerilog/verilog-basic.mlir\r\n  CIRCT :: ExportVerilog/verilog-errors.mlir\r\n  CIRCT :: circt-opt/trivial.mlir\r\n  CIRCT :: circt-translate/parse_int64.fir\r\n  CIRCT :: firtool/firtool.fir\r\n  CIRCT :: firtool/firtool.mlir\r\n  CIRCT :: firtool/optimizations.fir\r\n  CIRCT :: firtool/phase-ordering.fir\r\n  CIRCT :: firtool/split-verilog.mlir\r\n  CIRCT :: firtool/style.fir\r\n  CIRCT :: handshake-runner/call_bb.mlir\r\n  CIRCT :: handshake-runner/cdiv-old-std.mlir\r\n  CIRCT :: handshake-runner/cdiv-std.mlir\r\n  CIRCT :: handshake-runner/complex_bb.mlir\r\n  CIRCT :: handshake-runner/floydwarshall-std.mlir\r\n  CIRCT :: handshake-runner/histogram-std.mlir\r\n  CIRCT :: handshake-runner/loadstore.mlir\r\n  CIRCT :: handshake-runner/loop-check-1-std.mlir\r\n  CIRCT :: handshake-runner/loop-check-2-std.mlir\r\n  CIRCT :: handshake-runner/matmul-check-std.mlir\r\n  CIRCT :: handshake-runner/matmul-std.mlir\r\n  CIRCT :: handshake-runner/memory_simple_2_std.mlir\r\n  CIRCT :: handshake-runner/memory_simple_std.mlir\r\n  CIRCT :: handshake-runner/simple_loop.mlir\r\n\r\n\r\nTesting Time: 1.34s\r\n  Unsupported:   4\r\n  Passed     :   6\r\n  Failed     : 210"}, {"number": 907, "title": "Parsing Instance Connects Broken", "created_at": "2021-04-09T15:45:51Z", "state": "open", "labels": "bug, FIRRTL", "body": "Connections involving instances fail to parse, but work in the Scala FIRRTL Compiler.\r\n\r\nThe following currently fails:\r\n```scala\r\ncircuit Instance:\r\n  module Sub:\r\n    output a: UInt<1>\r\n    a <= UInt<1>(0)\r\n\r\n  module Instance:\r\n    output a: {a: UInt<1>}\r\n\r\n    inst sub of Sub\r\n    a <= sub\r\n    a <- sub\r\n```\r\n\r\nThe error is: \r\n\r\n```\r\n# circt-translate --import-firrtl new/Instance.fir\r\nnew/Instance.fir:11:5: error: expected '.' in field reference\r\n    a <- sub\r\n    ^\r\n```\r\n\r\nGlancing at the parser, it looks like it expects `sub` to be in the value table, but it isn't. [There is special logic to handle `sub is invalid`](https://github.com/llvm/circt/blob/main/lib/Dialect/FIRRTL/Import/FIRParser.cpp#L1187), but that needs to be extended to handle connections to submodules. If this isn't a `sub is invalid` situation, then the parser expects to see a subfield.", "code_snippet_01": "circuit Instance:\r\n  module Sub:\r\n    output a: UInt<1>\r\n    a <= UInt<1>(0)\r\n\r\n  module Instance:\r\n    output a: {a: UInt<1>}\r\n\r\n    inst sub of Sub\r\n    a <= sub\r\n    a <- sub", "code_snippet_02": "# circt-translate --import-firrtl new/Instance.fir\r\nnew/Instance.fir:11:5: error: expected '.' in field reference\r\n    a <- sub\r\n    ^"}, {"number": 806, "title": "[LLHD] llhd-sim unable to simulate generated llhd dialect ", "created_at": "2021-03-22T22:30:35Z", "state": "open", "labels": "bug, LLHD", "body": "To simulate below llhd:\r\n\r\n```\r\nllhd.entity @adder(%clk: !llhd.sig, %res: !llhd.sig) \u2192 (%i5_output: !llhd.sig ) {\r\n%0 = llhd.const #llhd.time<0s, 0d, 1e> : !llhd.time\r\n%1 = llhd.const 16 : i32\r\nllhd.drv %i5_output, %1 after %0 : !llhd.sig\r\n}\r\n```\r\n\r\nshows this error:\r\n\r\n```\r\nAssertion failed: (idx < size()), function operator[], file \u2026/llvm/llvm/include/llvm/ADT/SmallVector.h, line 277.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0. Program arguments: \u2026/build/bin/llhd-sim addersvllhd.mlir -n 10 -r adder\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var LLVM_SYMBOLIZER_PATH to point to it):\r\n0 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca593d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca5eeb PrintStackTraceSignalHandler(void*) + 27\r\n2 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca3a6b llvm::sys::RunSignalHandlers() + 123\r\n3 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca83f8 SignalHandler(int) + 232\r\n4 libsystem_platform.dylib 0x00007fff6af445fd _sigtramp + 29\r\n5 libdyld.dylib 0x00007fff6ad4a78f dyldGlobalLockRelease() + 0\r\n6 libsystem_c.dylib 0x00007fff6ae1a808 abort + 120\r\n7 libsystem_c.dylib 0x00007fff6ae19ac6 err + 0\r\n8 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4fa48 llvm::SmallVectorTemplateCommon<circt::llhd::sim::Signal, void>::operator[](unsigned long) + 104\r\n9 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4f912 driveSignal + 178\r\n10 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011e1240f1 driveSignal + 6113425\r\n11 llhd-sim 0x000000010acda78e main + 1518\r\n12 libdyld.dylib 0x00007fff6ad4bcc9 start + 1\r\n```\r\n\r\nMy command to llhd-sim is -n 10 -r adder and I think the expect behaviour should be a constant signal at the output (signal i5_output being constantly at value 16). I was able to trace the code till line 235 of engine.cpp \r\n\r\n(ps: this is not the full code for my sv; I have reduced it to the simplest form to see if I can get an output. Originally my code just aborted when the reaches the adder.adder entity in state.)", "code_snippet_01": "llhd.entity @adder(%clk: !llhd.sig, %res: !llhd.sig) \u2192 (%i5_output: !llhd.sig ) {\r\n%0 = llhd.const #llhd.time<0s, 0d, 1e> : !llhd.time\r\n%1 = llhd.const 16 : i32\r\nllhd.drv %i5_output, %1 after %0 : !llhd.sig\r\n}", "code_snippet_02": "Assertion failed: (idx < size()), function operator[], file \u2026/llvm/llvm/include/llvm/ADT/SmallVector.h, line 277.\r\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.\r\nStack dump:\r\n0. Program arguments: \u2026/build/bin/llhd-sim addersvllhd.mlir -n 10 -r adder\r\nStack dump without symbol names (ensure you have llvm-symbolizer in your PATH or set the environment var LLVM_SYMBOLIZER_PATH to point to it):\r\n0 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca593d llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) + 61\r\n1 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca5eeb PrintStackTraceSignalHandler(void*) + 27\r\n2 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca3a6b llvm::sys::RunSignalHandlers() + 123\r\n3 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011dca83f8 SignalHandler(int) + 232\r\n4 libsystem_platform.dylib 0x00007fff6af445fd _sigtramp + 29\r\n5 libdyld.dylib 0x00007fff6ad4a78f dyldGlobalLockRelease() + 0\r\n6 libsystem_c.dylib 0x00007fff6ae1a808 abort + 120\r\n7 libsystem_c.dylib 0x00007fff6ae19ac6 err + 0\r\n8 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4fa48 llvm::SmallVectorTemplateCommon<circt::llhd::sim::Signal, void>::operator[](unsigned long) + 104\r\n9 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011db4f912 driveSignal + 178\r\n10 libcirct-llhd-signals-runtime-wrappers.dylib 0x000000011e1240f1 driveSignal + 6113425\r\n11 llhd-sim 0x000000010acda78e main + 1518\r\n12 libdyld.dylib 0x00007fff6ad4bcc9 start + 1"}, {"number": 787, "title": "[FIRRTL] FIRRTL to RTL Memory Lowering Needs to Handle All Read Under Write Behaviors", "created_at": "2021-03-18T22:30:18Z", "state": "open", "labels": "bug, FIRRTL", "body": "Add support for the \"old\" read-under-write FIRRTL memory behavior. Currently, this is incorrectly emitted as \"new\".\r\n\r\nThe FIRRTL spec defines three read-under-write behaviors for memories. A read-under-write behavior is what happens if you try to read and write the same address on the same cycle These three behaviors are:\r\n\r\n1. New (return the value in the memory when the read was made)\r\n2. Old (return the value when the read was requested)\r\n3. Undefined (technically anything, but the Scala FIRRTL Compiler treats this as \"compiler's choice\" and chooses \"New\")\r\n\r\nNote that this only matters for read latencies > 0. These can be treated as equivalent if the ~read latency == 1~ read latency == 0."}]